<?xml version="1.0" encoding="windows-1251"?>
<FictionBook xmlns="http://www.gribuser.ru/xml/fictionbook/2.0" xmlns:l="http://www.w3.org/1999/xlink">
 <stylesheet type="text/css">
                     section section section title { page-break-before: auto }
  section section section section section title { font-style: italic; font-size: 95% }
  image + p { page-break-before: avoid; margin-bottom: 1em; }
  p &gt; code { font-size: 89% }
 </stylesheet>
 <description>
  <title-info>
   <genre>comp_programming</genre>
   <genre>comp_osnet</genre>
   <author>
    <first-name>Арнольд</first-name>
    <last-name>Роббинс</last-name>
   </author>
   <book-title>Linux программирование в примерах</book-title>
   <annotation>
    <p>В книге рассмотрены вопросы, связанные с программированием под Linux: файловый ввод/вывод, метаданные файлов, основы управления памятью, процессы и сигналы, пользователи и группы, вопросы интернационализации и локализации, сортировка, поиск и многие другие. Много внимания уделено средствам отладки, доступным под GNU Linux. Все темы иллюстрируются примерами кода, взятого из V7 UNIX и GNU. Эта книга может быть полезна любому, кто интересуется программированием под Linux.</p>
   </annotation>
   <date>2005</date>
   <coverpage>
    <image l:href="#img_0.jpeg"/></coverpage>
   <lang>ru</lang>
   <src-lang>en</src-lang>
   <translator>
    <first-name>Р.</first-name>
    <middle-name>Г.</middle-name>
    <last-name>Галеев</last-name>
   </translator>
  </title-info>
  <src-title-info>
   <genre>comp_programming</genre>
   <genre>comp_osnet</genre>
   <author>
    <first-name>Arnold</first-name>
    <last-name>Robbins</last-name>
   </author>
   <book-title>Unix Programming By Example</book-title>
   <date>2004</date>
   <lang>en</lang>
  </src-title-info>
  <document-info>
   <author>
    <nickname>honorato bonafe</nickname>
   </author>
   <program-used>OOoFBTools-2.5 (ExportToFB21), FictionBook Editor Release 2.6.6</program-used>
   <date value="2013-08-15">15.08.2013</date>
   <id>OOoFBTools-2013-6-22-11-59-38-1367</id>
   <version>1.0</version>
   <history>
    <p>1.0 djvu-&gt;fb2</p>
   </history>
  </document-info>
  <publish-info>
   <book-name>Linux: Программирование в примерах</book-name>
   <publisher>Кудиц-Образ</publisher>
   <city>Москва</city>
   <year>2005</year>
   <isbn>5-9579-0059-1</isbn>
  </publish-info>
 </description>
 <body>
  <title>
   <p>Linux</p>
   <p>программирование в примерах</p>
  </title>
  <section>
   <title>
    <p>Предисловие</p>
   </title>
   <p>Одним из лучших способов научиться программированию является чтение хорошо написанных программ. Данная книга обучает фундаментальному API системных вызовов Linux — тех, которые образуют ядро любой значительной программы — представляя код из программных изделий, которые вы используете каждый день.</p>
   <p>Рассматривая конкретные программы, вы не только видите, как использовать Linux API, но можете также исследовать реальные проблемы (производительности, переносимости, устойчивости), которые возникают при написании программного обеспечения.</p>
   <p>Хотя книга называется <emphasis>Программирование под Linux на примерах</emphasis>, все, что мы рассматриваем, относится также к современным системам Unix, если не отмечено противное. Обычно мы используем термин «Linux» для обозначения ядра Linux, a «GNU/Linux» для обозначения всей системы (ядра, библиотек, инструментов). Часто также мы говорим «Linux», когда имеем в виду и Linux, GNU/Linux и Unix; если что-то является специфичным для той или иной системы, мы отмечаем это явным образом.</p>
   <subtitle>Аудитория</subtitle>
   <p>Данная книга предназначена для лиц, разбирающихся в программировании и знакомых с основами С, по крайней мере на уровне книги Кернигана и Ричи <emphasis>Программирование на языке С</emphasis>. (Программисты Java, желающие прочесть эту книгу, должны разбираться в указателях С, поскольку С активно их использует.) В примерах используются как версия Стандартного С 1990 года, так и Оригинальный С.</p>
   <p>В частности, вам следует быть знакомыми со всеми операторами С, структурами управления потоком исполнения, использованием объявлений переменных и указателей, функциями работы со строками, использованием <code>exit()</code> и набором функций <code>&lt;stdio.h&gt;</code> для файлового ввода/вывода.</p>
   <p>Вы должны понимать базовые концепции <emphasis>стандартного ввода</emphasis>, <emphasis>стандартного вывода</emphasis> и <emphasis>стандартной ошибки</emphasis>, а также знать тот факт, что все программы на С получают массив символьных строк, представляющих вызываемые опции и аргументы. Вы должны также быть знакомы с основными инструментами командной строки, такими, как <code>cd</code>, <code>cp</code>, <code>date</code>, <code>ln</code>, <code>ls</code>, <code>man</code> (и <code>info</code>, если он у вас имеется), <code>rmdir</code> и <code>rm</code>, с использованием длинных и коротких опций командной строки, переменных окружения и перенаправления ввода/вывода, включая каналы.</p>
   <p>Мы предполагаем, что вы хотите писать программы, которые работают не только под GNU/Linux, но и на множестве различных систем Unix. С этой целью мы помечаем каждый интерфейс с точки зрения его доступности (лишь для систем GLIBC или определен в POSIX и т.д.), а в тексте приведены также советы по переносимости.</p>
   <p>Программирование, которое здесь приводится, может быть на более низком уровне, чем вы обычно использовали; это нормально. Системные вызовы являются основными строительными блоками для операций более высокого уровня и поэтому они низкоуровневые по своей природе. Это, в свою очередь, определяет использование нами С: функции API были спроектированы для использования из С, и код, связывающий их с языками более высокого уровня, такими как C++ и Java, неизбежно будет на более низком уровне и вероятнее всего, написанным на С. «Низкий уровень» не означает «плохой», это просто значит «более стимулирующий».</p>
   <subtitle>Что вы изучите</subtitle>
   <p>Данная книга фокусируется на базовых API, образующих ядро программирования под Linux:</p>
   <p>• Управление памятью</p>
   <p>• Файловый ввод/вывод</p>
   <p>• Метаданные файлов</p>
   <p>• Процессы и сигналы</p>
   <p>• Пользователи и группы</p>
   <p>• Поддержка программирования (сортировка, анализ аргументов и т.д.)</p>
   <p>• Интернационализация</p>
   <p>• Отладка</p>
   <p>Мы намеренно сохранили список тем коротким. Мы считаем, что попытка научить а одной книге «всему, что можно узнать», пугает. Большинство читателей предпочитают книжки поменьше, более сфокусированные, и лучшие книги по Unix написаны таким способом</p>
   <p>Поэтому вместо одного гигантского тома мы планируем несколько книг: одну по межпроцессному взаимодействию (IPC) и сетям, другую по разработке программного обеспечения и переносимости кода. Мы также положили глаз а направлении дополнительных томов в серии <emphasis>Программирование под Linux на примерах</emphasis>, которые будут раскрывать такие темы, как многопоточное программирование и программирование графических интерфейсов пользователя (GUI).</p>
   <p>Рассматриваемые нами API включают как системные вызовы, так и библиотечные функции. Действительно, на уровне С оба вида выступают в виде простых вызовов функций. <emphasis>Системный вызов</emphasis> является непосредственным запросом системной службы, такой, как чтение или запись файла или создание процесса. <emphasis>Библиотечная функция</emphasis>, с другой стороны, работает на уровне пользователя, возможно, никогда не запрашивая какие-либо сервисы у операционной системы. Системные вызовы документированы в разделе 2 справочного руководства (которое можно просмотреть с помощью команды man), а библиотечные функции документированы в разделе 3.</p>
   <p>Нашей целью является научить вас использовать Linux API на примерах: в частности, посредством использования, где это возможно, как оригинальных исходных кодов Unix, так и инструментов GNU. К сожалению, самодостаточных примеров не так много, как должно было бы быть. Поэтому мы также написали большое число небольших демонстрационных программ. Был сделан акцент на принципах программирования: особенно на таких аспектах программирования для GNU, как «никаких произвольных ограничений», которые превращают инструменты GNU в незаурядные программы.</p>
   <p>Выбор для изучения повседневных программ намеренный. Если вы уже использовали GNU/Linux в течение какого-либо периода времени, вы уже понимаете, что делают такие программы, как <code>ls</code> и <code>cp</code>; после этого просто погрузиться прямо в то, как работают программы, не тратя много времени на изучение того, что они делают.</p>
   <p>Иногда мы представляем как высокоуровневый, так и низкоуровневый способы выполнения задачи. Обычно стандарт интерфейса более высокого уровня реализуется посредством более низкоуровневого интерфейса или конструкции. Мы надеемся, что такой взгляд на то, что происходит «под капотом», поможет вам понять, как это работает; для всего кода, который вы пишете сами, нужно всегда использовать более высокоуровневый, стандартный интерфейс.</p>
   <p>Таким же образом иногда мы представляем функции, которые предоставляют определенные возможности, а затем рекомендуем (по указанной причине) избегать этих функций! Главной причиной такого подхода является то, что вы получаете возможность узнавать эти функции при встрече и понимать код с их использованием. Всеобъемлющее знание темы требует понимания не только того, что вы можете сделать, но и того, что должны или не должны делать.</p>
   <p>Наконец, каждая глава завершается упражнениями. Некоторые из них требуют модификации или написания кода. Другие больше относятся к категориям «Мысленных экспериментов» или «как вы думаете, почему…». Мы рекомендуем выполнить их все — они помогут закрепить понимание материала.</p>
   <subtitle>Небольшой — значит красивый: программы Unix</subtitle>
   <cite>
    <p>Закон Хоара: «Внутри каждой большой программы есть старающаяся пробиться маленькая программа»</p>
    <text-author>- C.A.R. Hoare -</text-author>
   </cite>
   <p>Вначале мы планировали обучать Linux API, используя код инструментов GNU. Однако, современные версии даже простых программ командной строки (подобно <code>mv</code> и <code>cp</code>) большие и многофункциональные. Это особенно верно в отношении GNU вариантов стандартных утилит, которые допускают длинные и короткие опции, делают все, требуемое POSIX и часто имеют также дополнительные, внешне не связанные опции (подобно выделению вывода).</p>
   <p>Поэтому возник разумный вопрос: «Как мы можем в этом большом и запутывающем лесу сконцентрироваться на одном или двух важных деревьях?» Другими словами, если мы представим современные полнофункциональные программы, будет ли возможно увидеть лежащую в основе работу программы?</p>
   <p>Вот когда <emphasis>закон Хоара</emphasis><a l:href="#n1" type="note">[1]</a> вдохновил нас на рассмотрение в качестве примера кода оригинальных программ Unix. Оригинальные утилиты V7 Unix маленькие и простые, что упрощает наблюдение происходящего и понимание использования системных вызовов (V7 был выпущен около 1979 г.; это общий предок всех современных систем Unix, включая системы GNU/Linux и BSD.)</p>
   <p>В течение многих лет исходный код Unix был защищен авторскими правами и лицензионными соглашениями коммерческой тайны, что затрудняло его использование для обучения и делало невозможным опубликование. Это до сих пор верно в отношении исходного кода всех коммерческих систем Unix. Однако в 2002 г. Caldera (в настоящее время работающая под именем SCO) сделала оригинальный код Unix (вплоть до V7 и 32V Unix) доступным на условиях лицензии в стиле Open Source (см. приложение В «Лицензия Caldera для старой Unix»). Это дает нам возможность включить в эту книгу код из ранних систем Unix.</p>
   <subtitle>Стандарты</subtitle>
   <p>По всей книге мы ссылаемся на несколько различных официальных стандартов. Стандарт является документом, описывающим, как что-либо работает. Официальные стандарты существуют для многих вещей, например, форма, размещение и назначение отверстий в электрической розетке на вашей стене определяется официальным стандартом, так что все сетевые шнуры в вашей стране работают со всеми розетками.</p>
   <p>Таким же образом официальные стандарты для вычислительных систем определяют, как они должны работать; это дает возможность пользователям и разработчикам знать, чего ожидать от своего программного обеспечения, и дает им возможность жаловаться своему поставщику, когда программное обеспечение не работает.</p>
   <p>Здесь интерес для нас представляют:</p>
   <p>1. <emphasis>ISO/IEC International Standard 9899 Programming Languages — С (Международный стандарт ISO/IEC 9899. Языки программирования - С), 1990</emphasis>. Первый официальный стандарт для языка программирования С.</p>
   <p>2. <emphasis>ISO/IEC International Standard 9899. Programming Languages — С, Second edition, 1999 (Международный стандарт ISO/IEC 9899. Языки программирования С, второе издание)</emphasis>. Второй (текущий) официальный стандарт для языка программирования C.</p>
   <p>3. <emphasis>ISO/IEC International Standard 14882. Programming Languages — С++, 1998 (Международный стандарт ISO/IEC 14882. Языки программирования - С++)</emphasis>. Первый официальный стандарт для языка программирования С++.</p>
   <p>4. <emphasis>ISO/IEC International Standard 14882. Programming Languages — С++, 2003 (Международный стандарт 14882. Языки программирования — С++)</emphasis>. Второй (текущий) официальный стандарт для языка программирования С++.</p>
   <p>5. <emphasis>IEEE Standard 1003 1-2001 Standard for Information Technology — Portable Operating System Interface (POSIX®) (Стандарт IEEE 1003.1-2001. Стандарт информационных технологий — переносимый интерфейс операционной системы)</emphasis>. Текущая версия стандарта POSIX; описывает поведение, ожидаемое от Unix и Unix-подобных систем. Данное издание освещает как системные вызовы, так и библиотечные интерфейсы с точки зрения программиста C/C++, и интерфейс оболочки и инструментов с точки зрения пользователя. Он состоит из нескольких томов:</p>
   <p> • <emphasis>Базовые определения (Base Definitions)</emphasis>. Определения терминов, средств и заголовочных файлов.</p>
   <p> • <emphasis>Базовые определения — Обоснование (Base Definitions — Rationale)</emphasis>. Объяснения и обоснования выбора средств как включенных, так и невключенных в стандарт.</p>
   <p> • <emphasis>Системные интерфейсы (System Interfaces)</emphasis>. Системные вызовы и библиотечные функции. POSIX называет обе разновидности просто «функции».</p>
   <p> • <emphasis>Оболочка и инструменты (Shell and Utilities)</emphasis>. Язык оболочки и доступные для интерактивного использования и использования сценариями оболочки инструменты.</p>
   <p>Хотя стандарты языков не являются захватывающим чтением, можно рассмотреть покупку экземпляра стандарта С, он дает окончательное определение языка. Книги можно приобрести в ANSI<a l:href="#n2" type="note">[2]</a> и в ISO<a l:href="#n3" type="note">[3]</a>. (PDF-версия стандарта С вполне доступна.)</p>
   <p>Стандарт POSIX можно заказать в The Open Group<a l:href="#n4" type="note">[4]</a>. Исследуя в каталоге их изданий элементы, перечисленные а «Спецификациях CAE» («CAE Specifications»), вы можете найти отдельные страницы для каждой части стандарта (озаглавленные с «C031» по «C034»). Каждая такая страница предоставляет свободный доступ к HTML версии определенного тома</p>
   <p>Стандарт POSIX предназначен для реализации как Unix и Unix-подобных систем, так и не-Unix систем. Таким образом, базовые возможности, которые он предоставляет, составляют лишь часть возможностей, которые есть на системах Unix. Однако, стандарт POSIX определяет также <emphasis>расширения</emphasis> — дополнительные возможности, например, для многопоточности или поддержки реального времени. Для нас важнее всего расширение <emphasis>X/Open System Interface</emphasis> (XSI), описывающее возможности исторических систем Unix.</p>
   <p>По всей книге мы помечаем каждый API в отношении его доступности: ISO С, POSIX, XSI, только GLIBC или как нестандартный, но широко доступный.</p>
   <subtitle>Возможности и мощь: программы GNU</subtitle>
   <p>Ограничив себя лишь оригинальным кодом Unix, можно было бы получить интересную историческую книгу, но она была бы не очень полезна в XXI веке. Современные программы не имеют тех же ограничений (памяти, мощности процессора, дискового пространства и скорости), которые были у ранних систем Unix. Более того, они должны работать в многоязычном мире — ASCII и американского английского недостаточно.</p>
   <p>Что еще важнее, одной из главных свобод, выдвинутых явным образом Фондом бесплатных программ (Free Software Foundation) и проектом GNU<a l:href="#n5" type="note">[5]</a>, является «свобода обучения». Программы GNU предназначены для обеспечения большого собрания хорошо написанных программ, которые программисты среднего уровня могут использовать а качестве источника для своего обучения.</p>
   <p>Используя программы GNU, мы преследуем две цели: показать вам хорошо написанный современный код, на котором вы будете учиться писать хорошие программы, а также использовать API.</p>
   <p>Мы считаем, что программное обеспечение GNU лучше, поскольку оно свободно (в смысле «свободы», а не «бесплатного пива»)<a l:href="#n6" type="note">[6]</a>. Но признается также, что программное обеспечение GNU часто также <emphasis>технически</emphasis> лучше соответствующих двойников в Unix, и мы уделили место в разделе 1.4 «Почему программы GNU лучше», чтобы это объяснить</p>
   <p>Часть примеров кода GNU происходит из <code>gawk</code> (GNU <code>awk</code>). Главной причиной этого является то, что это программа, с которой мы очень знакомы, поэтому было просто отобрать оттуда примеры. У нас нет относительно нее других притязаний.</p>
   <subtitle>Обзор глав</subtitle>
   <p>Вождение автомобиля целостный процесс, включающий множество одновременных задач. Во многих отношениях программирование по Linux похоже на это, требуя понимания многих аспектов API, таких, как файловый ввод/вывод, метаданные файлов, каталоги, хранение сведений о времени и т.д.</p>
   <p>В первой части книги рассматривается достаточное количество этих отдельных элементов, чтобы дать возможность изучить первую значительную программу, V7 ls. Затем мы завершим наше обсуждение файлов и пользователей, рассмотрев иерархии файлов и принципы работы файловых систем и их использование.</p>
   <p><emphasis>Глава 1, «Введение»,</emphasis></p>
   <p>описывает модели файлов и процессов Unix и Linux, рассматривает отличия оригинального С от стандартного С 1990 г., а также предоставляет обзор принципов, которые делают программы GNU в целом лучшими по сравнению со стандартными программами Unix.</p>
   <p><emphasis>Глава 2, «Аргументы, опции и переменные окружения»,</emphasis></p>
   <p>описывает, как С программа получает доступ к аргументам и опциям командной строки и обрабатывает их, а также объясняет, как работать с переменными окружения.</p>
   <p><emphasis>Глава 3, «Управление памятью на уровне пользователя»,</emphasis></p>
   <p>предоставляет обзор различных видов используемой памяти, доступной работающему процессу. Управление памятью на уровне пользователя является основным для каждого нетривиального приложения, поэтому важно понять это с самого начала.</p>
   <p><emphasis>Глава 4, «Файлы и файловый ввод/вывод»,</emphasis></p>
   <p>обсуждает базовый файловый ввод/вывод, показывая, как создавать и использовать файлы. Понимание этого важно для всего последующего материала.</p>
   <p><emphasis>Глава 5, «Каталоги и служебные данные файлов»,</emphasis></p>
   <p>описывает, как работают каталоги, прямые и символические ссылки. Затем описываются служебные данные файлов, такие, как владелец, права доступа и т.д., а также освещается работа с каталогами</p>
   <p><emphasis>Глава 6, «Общие библиотечные интерфейсы — часть 1»,</emphasis></p>
   <p>рассматривает первый набор интерфейсов общего программирования, которые будут нам нужны для эффективного использования служебных данных файлов.</p>
   <p><emphasis>Глава 7, «Соединяя все вместе:</emphasis> <code><emphasis>ls</emphasis></code><emphasis>»,</emphasis></p>
   <p>связывает воедино все рассмотренное до сих пор, рассматривая программу V7 <code>ls</code>.</p>
   <p><emphasis>Глава 8, «Файловые системы и обходы каталогов»,</emphasis></p>
   <p>описывает, как монтируются и демонтируются файловые системы и как программа может получить сведения о том, что смонтировано в системе. В главе описывается также, как программа может легко «обойти» всю иерархию файлов, предпринимая а отношении каждого встреченного объекта необходимые действия.</p>
   <p>Вторая часть книги имеет дело с созданием и управлением процессами, межпроцессным взаимодействием посредством каналов и сигнала, ID пользователей и групп и дополнительными интерфейсами общего программирования. Далее в книге сначала описываются интернационализация с использованием GNU <code>gettext</code>, а затем несколько расширенных API.</p>
   <p><emphasis>Глава 9, «Управление процессами и каналы»,</emphasis></p>
   <p>рассматривает создание процесса, исполнение программы, межпроцессное взаимодействие (IPC) с использованием каналов и управление дескрипторами файлов, включая неблокирующий ввод/вывод.</p>
   <p><emphasis>Глава 10, «Сигналы»,</emphasis></p>
   <p>обсуждает сигналы, упрощенную форму межпроцессного взаимодействия. Сигналы играют также важную роль а управлении родительским процессом порожденных процессов.</p>
   <p><emphasis>Глава 11, «Права доступа и ID пользователей и групп»,</emphasis></p>
   <p>рассматривает, как идентифицируются процессы и файлы, как работает проверка прав доступа и как работают механизмы <code>setuid</code> и <code>setgid</code>.</p>
   <p><emphasis>Глава 12, «Общие библиотечные интерфейсы — часть 2»,</emphasis></p>
   <p>рассматривает оставшуюся часть общих API; многие из них более специализированы, чем первый общий набор API.</p>
   <p><emphasis>Глава 13, «Интернационализация и локализация»,</emphasis></p>
   <p>объясняет, как почти без усилий обеспечить работу ваших программ на нескольких языках.</p>
   <p><emphasis>Глава 14, «Расширенные интерфейсы»,</emphasis></p>
   <p>описывает несколько расширенных версий интерфейсов, освещенных в предыдущих главах, а также более подробно освещает блокировку файлов.</p>
   <p>Мы завершаем книгу главой об отладке, поскольку (почти) никто не может сделать все правильно с первого раза, и рекомендуем финальный проект для закрепления ваших знаний по рассмотренным в данной книге API.</p>
   <p><emphasis>Глава 15, «Отладка»,</emphasis></p>
   <p>описывает основы отладчика GDB, передает как можно больше нашего опыта в этой области и рассматривает несколько полезных инструментов для осуществления различных видов отладки.</p>
   <p><emphasis>Глава 16, «Проект, связывающий все воедино»,</emphasis></p>
   <p>представляет значительный проект по программированию, который использует почти все, рассмотренное в книге.</p>
   <p>Несколько приложений освещают представляющие интерес темы, включая лицензии для использованного в данной книге исходного коде.</p>
   <p><emphasis>Приложение А, «Научитесь программированию за десять лет»,</emphasis></p>
   <p>ссылается на знаменитое высказывание: «Москва не сразу строилась»<a l:href="#n7" type="note">[7]</a>. Также и квалификация в Linux/Unix и понимание этих систем приходит лишь со временем и практикой. С этой целью мы включили это эссе Петера Норвига, которое мы горячо рекомендуем.</p>
   <p><emphasis>Приложение В, «Лицензия Caldera для старой Unix»,</emphasis></p>
   <p>охватывает исходный код Unix, использованный в данной книге.</p>
   <p><emphasis>Приложение С, «Общедоступная лицензия GNU»,</emphasis></p>
   <p>охватывает исходный код GNU, использованный в данной книге.</p>
   <subtitle>Соглашения об обозначениях</subtitle>
   <p>Как и в любой книге на компьютерную тему, для передачи информации мы используем определенные соглашения об обозначениях. <emphasis>Определения</emphasis> или первое использование термина выделяется курсивом, как слово «Определения» в начале этого предложения. Курсив используется также для <emphasis>выделения</emphasis>, для цитирования других работ и комментариев в примерах. Переменные элементы, такие, как аргументы или имена файлов, выглядят <strong>таким образом</strong>. Иногда мы используем жирный шрифт, когда нужно <strong>усилить</strong> мысль.</p>
   <p>Вещи, находящиеся на компьютере, обозначаются моноширинными шрифтом, как в случае имен файлов (<code>foo.c</code>) и названий команд (<code>ls</code>, <code>grep</code>). Короткие фрагменты, которые вы вводите, дополнительно заключаются в одинарные кавычки: '<code>ls -l *.с</code>'</p>
   <p><code>$</code> и <code>&gt;</code> являются первичным и вторичным приглашениями оболочки Борна и используются при отображении интерактивных примеров. Ввод пользователя выделяется другим шрифтом от обычного вывода компьютера в примерах. Примеры выглядят следующим образом:</p>
   <p><code>$ <strong>ls -1</strong> /* Просмотр файлов. Опция - цифра 1, а не буква l */</code></p>
   <p><code>foo</code></p>
   <p><code>bar</code></p>
   <p><code>baz</code></p>
   <p>Мы предпочитаем оболочку Борна и ее варианты (ksh93, Bash) по сравнению с оболочкой С; соответственно на всех наших примерах показана лишь оболочка Борна. Знайте, что правила применения кавычек и переноса на следующую строку в оболочке С другие; если вы используете ее, то на свой страх и риск!<a l:href="#n8" type="note">[8]</a></p>
   <p>При ссылках на функции в программах мы добавляем к имени функции пустую пару скобок: <code>printf()</code>, <code>strcpy()</code>. При ссылке на справочную страницу (доступную по команде man), мы следуем стандартному соглашению Unix по написанию имени команды или функции курсивом, а раздела — в скобках после имени обычным шрифтом: <emphasis>awk</emphasis>(1), <emphasis>printf</emphasis>(3)<a l:href="#n9" type="note">[9]</a>.</p>
   <subtitle>Где получить исходные коды Unix и GNU</subtitle>
   <p>Вы можете захотеть получить копни программ, которые мы использовали в данной книге, для своих собственных экспериментов и просмотра. Весь исходный код доступен через Интернет, а ваш дистрибутив GNU/Linux содержит исходный код для инструментов GNU.</p>
   <subtitle>Код Unix</subtitle>
   <p>Архивы различных «древних» версий Unix поддерживаются Обществом наследства UNIX (The UNIX Heritage Society — TUHS), <code>http://www.tuhs.org</code>.</p>
   <p>Наибольший интерес представляет возможность просматривать архив старых исходных кодов Unix через веб. Начните с <code>http://minnie.tuhs.org/UnixTree/</code>. Все примеры кода в данной книге из седьмого издания исследовательской системы UNIX, известной также как «V7».</p>
   <p>Сайт TUHS физически расположен в Австралии, хотя имеются зеркала архива по всему миру — см. <code>http://www.tuhs.org/archive_sites.html</code>. Эта страница также указывает, что архив доступен для зеркала через <code>rsync</code>. (Если у вас нет <code>rsync</code>, см. <code>http://rsync.samba.org/</code>: это стандартная утилита на системах GNU/Linux.)</p>
   <p>Чтобы скопировать весь архив, потребуется примерно 2-3 гигабайта дискового пространства. Для копирования архива создайте пустой каталог, а в нем выполните следующие команды:</p>
   <p><code>mkdir Applications 4BSD PDP-11 PDP-11/Trees VAX Other</code></p>
   <p><code>rsync -avz minnie.tuhs.org::UA_Root .</code></p>
   <p><code>rsync -avz minnie.tuhs.org::UA_Applications Applications</code></p>
   <p><code>rsync -avz minnie.tuhs.org::UA_4BSD 4BSD</code></p>
   <p><code>rsync -avz minnie.tuhs.org::UA_PDP11 PDP-11</code></p>
   <p><code>rsync -avz minnie.tuhs.org::UA_PDP11_Trees PDP-11/Trees</code></p>
   <p><code>rsync -avz minnie.tuhs.org::UA_VAX VAX</code></p>
   <p><code>rsync -avz minnie.tuhs.org::UA_Other Other</code></p>
   <p>Вы можете пропустить копирование каталога <code>Trees</code>, который содержит извлечения из нескольких версий Unix и занимает на диске около 700 мегабайт.</p>
   <p>В рассылке TUHS можно также поинтересоваться, нет ли поблизости от вас кого-нибудь, кто мог бы предоставить вам архив на CD-ROM, чтобы избежать пересылки по Интернету такого большого количества данных.</p>
   <p>Группа в Southern Storm Software, Pty. Ltd. в Австралии «модернизировала» часть кода уровня пользователя V7, так что его можно откомпилировать и запустить на современных системах, особенно на GNU/Linux. Этот код можно загрузить с их веб-сайта<a l:href="#n10" type="note">[10]</a>.</p>
   <p>Интересно отметить, что код V7 не содержит в себе каких-либо уведомлений об авторских правах или разрешениях. Авторы писали код главным образом для себя и своего исследования, оставив проблемы разрешений отделу корпоративного лицензирования AT&amp;T.</p>
   <subtitle>Код GNU</subtitle>
   <p>Если вы используете GNU/Linux, ваш дистрибутив поступит с исходным кодом, предположительно в формате, используемом для упаковки (файлы RPM Red Hat, файлы DEB Debian, файлы <code>.tar.gz</code> Slackware и т.д.) Многие примеры в книге взяты из GNU Coreutils, версия 5.0. Найдите соответствующий CD-ROM для своего дистрибутива GNU/Linux и используйте для извлечения кода соответствующий инструмент. Или следуйте для получения кода инструкциям в следующих нескольких абзацах.</p>
   <p>Если вы предпочитаете самостоятельно получать файлы из ftp-сайта GNU, вы найдете его по адресу: <code>ftp://ftp.gnu.org/gnu/coreutils/coreutils-5.0.tar.gz</code>.</p>
   <p>Для получения файла можно использовать утилиту <code>wget</code>:</p>
   <p><code>$ <strong>wget ftp://ftp.gnu.org/ena/coreutils/coreuitils-5.0.tar.gz</strong></code></p>
   <p><code>/* Получить дистрибутив */</code></p>
   <p><code>/* ... здесь при получении файла куча вывода ... */</code></p>
   <p>В качестве альтернативы можно использовать для получения файла старый добрый <code>ftp</code>:</p>
   <p><code>$ <strong>ftp ftp.gnu.org</strong> /* Подключиться к ftp-сайту GNU */</code></p>
   <p><code>Connected to ftp.gnu.org (199.232.41.7).</code></p>
   <p><code>220 GNU FTP server ready.</code></p>
   <p><code>Name (ftp.gnu.org:arnold): <strong>anonymous</strong> /* Использовать анонимный ftp */</code></p>
   <p><code>331 Please specify the password.</code></p>
   <p><code>Password: /* Пароль на экране не отображается */</code></p>
   <p><code>230-If you have any problems with the GNU software or its downloading,</code></p>
   <p><code>230-please refer your questions to &lt;gnu@gnu.org&gt;.</code></p>
   <p><code>... /* Куча вывода опущена */</code></p>
   <p><code>230 Login successful. Have fun.</code></p>
   <p><code>Remote system type is UNIX.</code></p>
   <p><code>Using binary mode to transfer files.</code></p>
   <p><code>ftp&gt; <strong>cd /gnu/coreutils</strong> /* Перейти в каталог Coreutils */</code></p>
   <p><code>250 Directory successfully changed.</code></p>
   <p><code>ftp&gt; <strong>bin</strong></code></p>
   <p><code>200 Switching to Binary mode.</code></p>
   <p><code>ftp&gt; <strong>hash</strong> /* Выводить символы # по мере закачки */</code></p>
   <p><code>Hash mark printing on (1024 bytes/hash mark).</code></p>
   <p><code>ftp&gt; <strong>get coreutils-5.0.tar.gz</strong> /* Retrieve file */</code></p>
   <p><code>local: coreutils-5.0.tar.gz</code></p>
   <p><code>remote: coreutils-5.0.tar.gz</code></p>
   <p><code>227 Entering Passive Mode (199,232,41,7,86,107)</code></p>
   <p><code>150 Opening BINARY mode data connection for coreutils-5.0.tar.gz (6020616 bytes)</code></p>
   <p><code>######################################################################</code></p>
   <p><code>######################################################################</code></p>
   <p><code>...</code></p>
   <p><code>226 File send OK.</code></p>
   <p><code>6020616 bytes received in 2.03e+03 secs (2.9 Kbytes/sec)</code></p>
   <p><code>ftp&gt; <strong>quit</strong> /* Закончить работу */</code></p>
   <p><code>221 Goodbye.</code></p>
   <p>Получив файл, извлеките его следующим образом:</p>
   <p><code>$ <strong>gzip -dc &lt; coreutils-5.0.tar.gz | tar -xvpf -</strong> /* Извлечь файлы */</code></p>
   <p><code>/* ... при извлечении файла куча вывода ... */</code></p>
   <p>Системы, использующие GNU tar, могут использовать следующее заклинание:</p>
   <p><code>$ <strong>tar -xvpzf coreutils-5.0.tar.gz</strong> /* Извлечь файлы */</code></p>
   <p><code>/* ... при извлечении файла куча вывода ... */</code></p>
   <p>В соответствии с общедоступной лицензией GNU, вот сведения об авторских правах для всех GNU программ, процитированных в данной книге. Все программы являются «свободным программным обеспечением; вы можете распространять их и/или модифицировать на условиях общедоступной лицензии GNU в изданном Фондом бесплатных программ виде; либо версии 2 лицензии, либо (по вашему выбору) любой последующей версии». Текст общедоступной лицензии GNU см. в приложении С «Общедоступная лицензия GNU».</p>
   <table>
    <tr align="left">
     <th align="left" valign="top">Файл Coreutils 5.0</th>
     <th align="left" valign="top">Даты авторского права</th>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>lib/safe-read.с</code></td>
     <td align="left" valign="top">© 1993-1994, 1998, 2002</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>lib/safe-write.c</code></td>
     <td align="left" valign="top">© 2002</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>lib/utime.c</code></td>
     <td align="left" valign="top">© 1998, 2001-2002</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>lib/xreadlink.с</code></td>
     <td align="left" valign="top">© 2001</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>src/du.c</code></td>
     <td align="left" valign="top">© 1988-1991, 1995-2003</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>src/env.с</code></td>
     <td align="left" valign="top">© 1986, 1991-2003</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>src/install.с</code></td>
     <td align="left" valign="top">© 1989-1991, 1995-2002</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>src/link.c</code></td>
     <td align="left" valign="top">© 2001-2002</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>src/ls.с</code></td>
     <td align="left" valign="top">© 1985, 1988, 1990, 1991, 1995-2003</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>src/pathchk.c</code></td>
     <td align="left" valign="top">© 1991-2003</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>src/sort.с</code></td>
     <td align="left" valign="top">© 1988, 1991-2002</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>src/sys2.h</code></td>
     <td align="left" valign="top">© 1997-2003</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>src/wc.с</code></td>
     <td align="left" valign="top">© 1985, 1991, 1995-2002</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файл Gawk 3.0.6</td>
     <td align="left" valign="top">Даты авторского права</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>eval.с</code></td>
     <td align="left" valign="top">© 1986, 1988, 1989, 1991-2000</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файл Gawk 3.1.3</td>
     <td align="left" valign="top">Даты авторского права</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>awk.h</code></td>
     <td align="left" valign="top">© 1986, 1988, 1989, 1991-2003</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>builtin.с</code></td>
     <td align="left" valign="top">© 1986, 1988, 1989, 1991-2003</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>eval.с</code></td>
     <td align="left" valign="top">© 1986, 1988, 1989, 1991-2003</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>io.c</code></td>
     <td align="left" valign="top">© 1986, 1988, 1989, 1991-2003</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>main.с</code></td>
     <td align="left" valign="top">© 1986, 1988, 1989, 1991-2003</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>posix/gawkmisc.с</code></td>
     <td align="left" valign="top">© 1986, 1988, 1989, 1991-1998, 2001-2003</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файл Gawk 3.1.4</td>
     <td align="left" valign="top">Даты авторского права</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>builtin.c</code></td>
     <td align="left" valign="top">© 1986, 1988, 1989, 1991-2004</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файл GLIBC 23.2</td>
     <td align="left" valign="top">Даты авторского права</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>locale/locale.h</code></td>
     <td align="left" valign="top">© 1991, 1992, 1995-2002</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>posix/unistd.h</code></td>
     <td align="left" valign="top">© 1991-2003</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>time/sys/time.h</code></td>
     <td align="left" valign="top">© 1991-1994, 1996-2003</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файл Make 3.80</td>
     <td align="left" valign="top">Даты авторского права</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top"><code>read.с</code></td>
     <td align="left" valign="top">© 1988-1997, 2002</td>
    </tr>
   </table>
   <subtitle>Где получить примеры программ, использованные в данной книге</subtitle>
   <p>Примеры программ, использованные в данной книге, можно найти по адресу: <code>http://authors.phptr.com/robbins</code>.</p>
   <subtitle>Об обложке</subtitle>
   <cite>
    <p>«Это оружие Джедая …, элегантное оружие для более цивилизованной эпохи. На протяжении тысяч поколений Рыцари Джедай были защитниками мира и справедливости в Старой Республике. От мрачных времен, до Империи».</p>
    <text-author>- Оби-Ван Кеноби -</text-author>
   </cite>
   <p>Возможно, вы удивляетесь, почему мы поместили на обложке легкую саблю и использовали ее во внутреннем оформлении книги. Что она представляет и какое она имеет отношение к программированию под Linux?</p>
   <p>В руках Рыцаря Джедай легкая сабля является и мощным оружием, и предметом красоты. Ее использование демонстрирует мощь, знание, контроль над Силой и напряженное обучение для владеющего им Джедая.</p>
   <p>Элегантность легкой сабли отражает элегантность оригинального дизайна Unix API. Там также обдуманное, точное использование API и программных инструментов и принципов проектирования GNU привело к сегодняшним мощным, гибким, развитым системам GNU/Linux. Эта система демонстрирует знание и понимание программистов, создавших все их компоненты.</p>
   <p>И конечно, легкие сабли — это просто круто!</p>
   <subtitle>Благодарности</subtitle>
   <p>Написание книги требует большого количества работы, а чтобы сделать это хорошо, нужна помощь от многих людей. Д-р Brian W. Kernighan, д-р Doug McIlroy, Peter Memishian и Peter van der Linden сделали рецензию первоначального предложения. David J. Agans, Fred Fish, Don Marti, Jim Meyering, Peter Norvig и Julian Seward достали разрешения на воспроизведение различных элементов, процитированных по всей книге. Спасибо Geoff Collyer, Ulrich Drepper, Yosef Gold, д-ру C.A.R. (Tony) Hoare, д-ру Manny Lehman, Jim Meyering, д-ру Dennis M. Ritchie, Julian Seward, Henry Spencer и д-ру Wladyslaw M. Turski за предоставление множества полезной общей информации. Спасибо также другим членам группы GNITS. Karl Berry, Akim DeMaille, Ulrich Drepper, Greg McGary, Jim Meyering, Francois Pinard и Tom Tromey, которые предоставили полезную обратную связь относительно хорошей практики программирования. Karl Berry, Alper Ersoy и д-р Nelson H.F. Beebe предоставили ценную техническую помощь по Texinfo и DocBook/XML.</p>
   <p>Хорошие технические обзоры не только гарантируют, что автор использует правильные факты, они также гарантируют, что он тщательно обдумывает свое представление. Д-р Nelson H.F. Beebe, Geoff Collyer, Russ Cox, Ulrich Drepper, Randy Lechlitner, д-р Brian W. Kernighan, Peter Memishian, Jim Meyering, Chet Ramey и Louis Taber работали в качестве технических рецензентов для всей книги. Д-р Michael Brennan предоставил полезные комментарии для главы 15. Их рецензии принесли пользу как содержанию, так и многим примерам программ. Настоящим я благодарю их всех. Как обычно говорят в таких случаях большинство авторов, «все оставшиеся ошибки мои».</p>
   <p>Я особенно хотел бы поблагодарить Mark Taub из Pearson Education за инициирование этого проекта, за его энтузиазм для этой серии и за его помощь и советы по мере прохождения книги через различные ее стадии. Anthony Gemmellaro сделал феноменальную работу по реализации моей идеи для обложки, а внутренний дизайн Gail Cocker великолепен. Faye Gemmellaro сделал процесс производства вместо рутины приятным. Dmitry Kirsanov и Alina Kirsanova сделали рисунки, макеты страниц и предметный указатель; работать с ними было одно удовольствие.</p>
   <p>Наконец, моя глубочайшая благодарность жене Мириам за ее поддержку и ободрение во время написания книги.</p>
   <cite>
    <text-author>Арнольд Роббинс</text-author>
    <text-author>Nof Ayalon</text-author>
    <text-author>ИЗРАИЛЬ</text-author>
   </cite>
  </section>
  <section>
   <title>
    <p>Часть 1</p>
    <p>Файлы и пользователи</p>
   </title>
   <section>
    <title>
     <p>Глава 1</p>
     <p>Введение</p>
    </title>
    <section>
     <p>Если есть одна фраза, резюмирующая важнейшие понятия GNU/Linux (а следовательно, и Unix), это «файлы и процессы». В данной главе мы рассмотрим модели файлов и процессов в Linux. Их важно понять, потому что почти все системные вызовы имеют отношение к изменению какого-либо атрибута или части состояния файла или процесса.</p>
     <p>Далее, поскольку мы будем изучать код в обеих стилях, мы кратко рассмотрим главные различия между стандартным С 1990 г. и первоначальным С. Наконец, мы довольно подробно обсудим то, что делает GNU-программы «лучше» — принципы программирования, использование которых в коде мы увидим.</p>
     <p>В данной главе содержится ряд умышленных упрощений. Детали в подробностях будут освещены по мере продвижения по книге. Если вы уже являетесь специалистом в Linux, пожалуйста, простите нас</p>
    </section>
    <section>
     <title>
      <p>1.1. Модель файловой системы Linux/Unix</p>
     </title>
     <section>
      <p>Одной из движущих целей первоначального проекта Unix была простота. Простые понятия легко изучать и использовать. Когда понятия переведены в простые API, легко проектировать, писать и отлаживать простые программы. Вдобавок, простой код часто занимает меньше места и он более эффективен, чем более усложненные проекты.</p>
      <p>Поиск простоты направлялся двумя факторами. С технической точки зрения, первоначальные мини-компьютеры PDP-11, на которых разрабатывалась Unix, имели маленькое адресное пространство: 64 килобайта на меньших системах, 64 Кб кода и 64 Кб данных на больших. Эти ограничения относились не только к обычным программам (так называемому коду <emphasis>уровня пользователя</emphasis>), но и к самой операционной системе (коду <emphasis>уровня ядра</emphasis>). Поэтому не только «Маленький — значит красивый» в эстетическом смысле, но «Маленький — значит красивый», потому что не было другого выбора!</p>
      <p>Вторым фактором была отрицательная реакция на современные коммерческие операционные системы, которые были без надобности усложнены, со сложными командными языками, множеством разновидностей файлового ввода-вывода и слабой общностью или гармонией. (Стив Джонсон однажды заметил: «Использование TSO подобно пинанию мертвого кита на побережье». TSO — это как раз одна из только что описанных бестолковых систем с разделением времени «для мэйнфреймов.)</p>
     </section>
     <section>
      <title>
       <p>1.1.1. Файлы и права доступа</p>
      </title>
      <p>Файловая модель Unix проста, как фраза: файл — это линейный поток байтов. Точка. Операционная система не накладывает на файлы никаких предопределенных структур, ни фиксированных или переменных размеров записей, ни индексированных файлов, ничего. Интерпретация содержимого файла целиком оставлена приложению. (Это не совсем верно, как мы вскоре увидим, но для начала достаточно близко к истине.)</p>
      <p>Если у вас есть файл, вы можете сделать с данными в файле три вещи: прочитать, записать или исполнить их.</p>
      <p>Unix разрабатывался для мини-компьютеров с разделением времени; это предполагает наличие с самого начала многопользовательского окружения. Раз есть множество пользователей, должно быть возможным указание прав доступа к файлам: возможно, пользователь <code>jane</code> является начальником пользователя <code>fred</code>, и <code>jane</code> не хочет, чтобы <code>fred</code> прочел последние результаты аттестации.</p>
      <p>В целях создания прав доступа пользователи подразделяются на три различные категории: <emphasis>владелец</emphasis> файла; <emphasis>группа</emphasis> пользователей, связанная с данным файлом (вскоре будет пояснено); и <emphasis>остальные пользователи</emphasis>. Для каждой из этих категорий <emphasis>каждый</emphasis> файл имеет отдельные, связанные с этим файлом, биты прав доступа, разрешающие чтение, запись и исполнение. Эти разрешения отображаются в первом поле вывода команды '<code>ls -l</code>':</p>
      <p><code>$ <strong>ls -l progex.texi</strong></code></p>
      <p><code>-rw-r--r-- 1 arnold devel 5614 Feb 24 18:02 progex.texi</code></p>
      <p>Здесь arnold и devel являются соответственно владельцем и группой файла <code>progex.texi</code>, a <code>-rw-r--r--</code> является строкой типа файла и прав доступа. Для обычного файла первым символом будет дефис, для каталогов - <code>d</code>, а для других видов файлов - небольшой набор других символов, которые пока не имеют значения. Каждая последующая тройка символов представляют права на чтение, запись и исполнение для владельца, группы и «остальных» соответственно.</p>
      <p>В данном примере файл <code>progex.texi</code> может читать и записывать владелец файла, а группа и остальные пользователи могут только читать. Дефисы означают отсутствие разрешений, поэтому этот файл никто не может исполнить, а группа и остальные пользователи не могут в него записывать.</p>
      <p>Владелец и группа файла хранятся в виде числовых значений, известных как идентификатор пользователя (user ID — UID) и идентификатор группы (group ID — GID); стандартные библиотечные функции, которые мы рассмотрим далее в книге, позволяют напечатать эти значения в виде читаемых имен.</p>
      <p>Владелец файла может изменить разрешения, используя команду <code>chmod</code> (change mode — изменить режим). (Права доступа к файлу, по существу, иногда называют «режимом файла».) Группу файла можно изменить с помощью команд <code>chgrp</code> (change group — изменить группу) и <code>chown</code> (change owner — сменить владельца)<a l:href="#n11" type="note">[11]</a>.</p>
      <p>Групповые права доступа были нацелены на поддержку совместной работы: хотя определенным файлом может владеть один член группы или подразделения, возможно, каждый член группы должен иметь возможность изменять его. (Рассмотрите совместный маркетинговый доклад или данные исследования.)</p>
      <p>Когда система проверяет доступ к файлу (обычно при открытии файла), если UID процесса совпадает с UID файла, используются права доступа владельца файла. Если эти права доступа запрещают операцию (скажем, попытка записи в файл с доступом <code>-r--rw-rw-</code>), операция завершается неудачей; Unix и Linux не продолжают проверку прав доступа для группы и других пользователей<a l:href="#n12" type="note">[12]</a>. Это верно также, если UID различаются, но совпадают GID; если права доступа группы запрещают операцию, она завершается неудачей.</p>
      <p>Unix и Linux поддерживают понятие <emphasis>суперпользователя (superuser)</emphasis>: это пользователь с особыми привилегиями. Этот пользователь известен как root и имеет UID, равный 0. root позволено делать все; никаких проверок, все двери открыты, все ящики отперты.<a l:href="#n13" type="note">[13]</a> (Это может иметь важные последствия для безопасности, которых мы будем касаться по всей книге, но не будем освещать исчерпывающе.) Поэтому, даже если файл имеет режим <code>----------</code>, <code>root</code> все равно может читать файл и записывать в него. (Исключением является то, что файл нельзя исполнить. Но поскольку <code>root</code> может добавить право на исполнение, это ограничение ничего не предотвращает.)</p>
      <p>Модель прав доступа владелец/группа/другие, чтение/запись/исполнение проста, тем не менее достаточно гибка, чтобы охватывать большинство ситуаций. Существуют другие, более мощные, но и более сложные модели, реализованные на других системах, но ни одна из них не стандартизирована достаточно хорошо и не реализована достаточно широко, чтобы заслуживать обсуждения в общем руководстве, подобном этому.</p>
     </section>
     <section>
      <title>
       <p>1.1.2. Каталоги и имена файлов</p>
      </title>
      <p>Раз у вас есть файл, нужно где-то его хранить. В этом назначение <emphasis>каталога</emphasis> (известного в системах Windows или Apple Macintosh под названием «папка»). Каталог является особой разновидностью файла, связывающего имена файлов с метаданными, известными как <emphasis>узлы</emphasis> (inodes). Каталоги являются особыми, поскольку их может обновлять лишь операционная система путем описанных в главе 4, «Файлы и файловый ввод-вывод», системных вызовов. Они особые также потому, что операционная система предписывает формат элементов каталога.</p>
      <p>Имена файлов могут содержать любой 8-битный байт, за исключением символа '<code>/</code>' (прямой косой черты) и ASCII символа NUL, все биты которого содержат 0. Ранние Unix- системы ограничивали имена 14 байтами; современные системы допускают отдельные имена файлов вплоть до 255 байтов.</p>
      <p>Узел содержит всю информацию о файле, за исключением его имени: тип, владелец, группа, права допуска, размер, времена изменения и доступа. Он хранит также размещение на диске блоков, содержащих данные файла. Все это данные <emphasis>о</emphasis> файле, а не данные самого файла, отсюда термин <emphasis>метаданные</emphasis>.</p>
      <p>Права доступа к каталогам по сравнению с правами доступа к файлам имеют несколько другой смысл. Разрешение на чтение означает возможность поиска в каталоге, т.е. его просмотр с целью определить, какие файлы в нем содержатся. Разрешение на запись дает возможность создавать и <emphasis>удалять</emphasis> файлы в каталоге. Разрешение на исполнение означает возможность прохода через каталог при открытии или ином доступе к содержащемуся файлу или подкаталогу.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Если у вас есть разрешение на запись в каталог, вы можете удалять файлы из этого каталога, даже если они не принадлежат вам! При интерактивной работе команда rm отмечает это, запрашивая в таком случае подтверждение</p>
       <p>Каталог <code>/tmp</code> имеет разрешение на запись для каждого, но ваши файлы в <code>/tmp</code> находятся вполне в безопасности, поскольку <code>/tmp</code> обычно имеет установленный так называемый «липкий» (sticky) бит:</p>
       <p><code>$ <strong>ls -ld /trap</strong></code></p>
       <p><code>drwxrwxrwt 11 root root 4096 May 15 17:11 /tmp</code></p>
       <p>Обратите внимание, что t находится в последней позиции первого поля. В большинстве каталогов в этом месте стоит x. При установленном «липком» бите ваши файлы можете удалять лишь вы, как владелец файла, или <code>root</code>. (Более детально это обсуждается в разделе 11.2 5, «Каталоги и липкий бит».)</p>
      </cite>
     </section>
     <section>
      <title>
       <p>1.1.3. Исполняемые файлы</p>
      </title>
      <p>Помните, мы говорили, что операционная система на накладывает структуру на файлы? Мы уже видели, что это было невинной ложью относительно каталогов. Это же относится к двоичным исполняемым файлам. Чтобы запустить программу, ядро должно знать, какая часть файла представляет инструкции (код), а какая — данные. Это ведет к понятию формата <emphasis>объектного файла</emphasis>, которое определяет, как эти данные располагаются внутри файла на диске.</p>
      <p>Хотя ядро запустит лишь файлы, имеющие соответствующий формат, создание таких файлов задача утилит режима пользователя. Компилятор с языка программирования (такого как Ada, Fortran, С или С++) создает объектные файлы, а затем компоновщик или загрузчик (обычно с именем <code>ld</code>) связывает объектные файлы с библиотечными функциями для окончательного создания исполняемого файла. Обратите внимание, что даже если все нужные биты в файле размешены в нужных местах, ядро не запустит его, если не установлен соответствующий бит, разрешающий исполнение (или хотя бы один исполняющий бит для <code>root</code>).</p>
      <p>Поскольку компилятор, ассемблер и загрузчик являются инструментами режима пользователя, изменить со временем по мере необходимости форматы объектных файлов (сравнительно) просто; надо только «научить» ядро новому формату, и он может быть использован. Часть ядра, загружающая исполняемые файлы, относительно невелика, и это не является невозможной задачей. Поэтому форматы файлов Unix развиваются с течением времени. Первоначальный формат был известен как a.out (Assembler OUTput — вывод сборщика). Следующий формат, до сих пор использующийся в некоторых коммерческих системах, известен как COFF (Common Object File Format — общий формат объектных файлов), а современный, наиболее широко использующийся формат — ELF (Extensible Linking Format — открытый формат компоновки). Современные системы GNU/Linux используют ELF.</p>
      <p>Ядро распознает, что исполняемый файл содержит двоичный объектный код, проверяя первые несколько байтов файла на предмет совпадения со специальными <emphasis>магическими числами</emphasis>. Это последовательности двух или четырех байтов, которые ядро распознает в качестве специальных. Для обратной совместимости современные Unix-системы распознают несколько форматов. Файлы ELF начинаются с четырех символов «<code>\177ELF</code>».</p>
      <p>Помимо двоичных исполняемых файлов, ядро поддерживает также исполняемые <emphasis>сценарии (скрипты)</emphasis>. Такой файл также начинается с магического числа: в этом случае, это два обычных символа <code># !</code> . Сценарий является программой, исполняемой интерпретатором, таким, как командный процессор, awk, Perl, Python или Tcl. Строка, начинающаяся с <code>#!</code>, предоставляет полный путь к интерпретатору и один необязательный аргумент:</p>
      <p><code>#! /bin/awk -f</code></p>
      <p><code>BEGIN {print "hello, world"}</code></p>
      <p>Предположим, указанное содержимое располагается в файле <code>hello.awk</code> и этот файл исполняемый. Когда вы набираете '<code>hello.awk</code>', ядро запускает программу, как если бы вы напечатали '<code>/bin/awk -f hello.awk</code>'. Любые дополнительные аргументы командной строки также передаются программе. В этом случае, <code>awk</code> запускает программу и отображает общеизвестное сообщение <code>hello, world</code>.</p>
      <p>Механизм с использованием <code>#!</code> является элегантным способом скрыть различие между двоичными исполняемыми файлами и сценариями. Если <code>hello.awk</code> переименовать просто в <code>hello</code>, пользователь, набирающий '<code>hello</code>', не сможет сказать (и, конечно, не должен знать), что <code>hello</code> не является двоичной исполняемой программой.</p>
     </section>
     <section>
      <title>
       <p>1.1.4. Устройства</p>
      </title>
      <p>Одним из самых замечательных новшеств Unix было объединение файлового ввода- вывода и ввода-вывода от устройств.<a l:href="#n14" type="note">[14]</a> Устройства выглядят в файловой системе как файлы, для доступа к ним используются обычные права доступа, а для их открытия, чтения, записи и закрытия используются те же самые системные вызовы ввода-вывода. Вся «магия», заставляющая устройства выглядеть подобно файлам, скрыта в ядре. Это просто другой аспект движущего принципа простоты в действии, мы можем выразить это как <emphasis>никаких частных случаев для кода пользователя</emphasis>.</p>
      <p>В повседневной практике, в частности, на уровне оболочки, часто появляются два устройства: <code>/dev/null</code> и <code>/dev/tty</code>.</p>
      <p><code>/dev/null</code> является «битоприемником». Все данные, посылаемые <code>/dev/null</code>, уничтожаются операционной системой, а все попытки прочесть отсюда немедленно возвращают конец файла (EOF).</p>
      <p><code>/dev/tty</code> является текущим управляющим терминалом процесса — тем, который он слушает, когда пользователь набирает символ прерывания (обычно CTRL-C) или выполняет управление заданием (CTRL-Z).</p>
      <p>Системы GNU/Linux и многие современные системы Unix предоставляют устройства <code>/dev/stdin</code>, <code>/dev/stdout</code> и <code>/dev/stderr</code>, которые дают возможность указать открытые файлы, которые каждый процесс наследует при своем запуске.</p>
      <p>Другие устройства представляют реальное оборудование, такое, как ленточные и дисковые приводы, приводы CD-ROM и последовательные порты. Имеются также программные устройства, такие, как псевдотерминалы, которые используются для сетевых входов в систему и систем управления окнами, <code>/dev/console</code> представляет системную консоль, особое аппаратное устройство мини-компьютеров. В современных компьютерах <code>/dev/console</code> представлен экраном и клавиатурой, но это может быть также и последовательный порт</p>
      <p>К сожалению, соглашения по именованию устройств не стандартизированы, и каждая операционная система использует для лент, дисков и т.п. собственные имена. (К счастью, это не представляет проблемы для того, что мы рассматриваем в данной книге.) Устройства имеют в выводе '<code>ls -l</code>' в качестве первого символа <code>b</code> или <code>с</code>.</p>
      <p><code>$ <strong>ls -l /dev/tty /dev/hda</strong></code></p>
      <p><code>brw-rw-rw- 1 root disk 3, 0 Aug 31 02:31 /dev/hda</code></p>
      <p><code>crw-rw-rw- 1 root root 5, 0 Feb 26 08:44 /dev/tty</code></p>
      <p>Начальная '<code>b</code>' представляет блочные устройства, а '<code>c</code>' представляет символьные устройства. Файлы устройств обсуждаются далее в разделе 5.4, «Получение информации о файлах».</p>
     </section>
    </section>
    <section>
     <title>
      <p>1.2. Модель процессов Linux/Unix</p>
     </title>
     <section>
      <p>Процесс является работающей программой.<a l:href="#n15" type="note">[15]</a> Процесс имеет следующие атрибуты:</p>
      <p>уникальный идентификатор процесса (PID);</p>
      <p>• родительский процесс (с соответствующим идентификатором, PPID);</p>
      <p>• идентификаторы прав доступа (UID, GID, набор групп и т.д.);</p>
      <p>• отдельное от всех других процессов адресное пространство;</p>
      <p>• программа, работающая в этом адресном пространстве;</p>
      <p>• текущий рабочий каталог ('<code>.</code>');</p>
      <p>• текущий корневой каталог (<code>/</code>; его изменение является продвинутой темой);</p>
      <p>• набор открытых файлов, каталогов, или и того, и другого;</p>
      <p>• маска запретов доступа, использующаяся при создании новых файлов;</p>
      <p>• набор строк, представляющих окружение<a l:href="#n16" type="note">[16]</a>;</p>
      <p>• приоритеты распределения времени процессора (продвинутая тема);</p>
      <p>• установки для размещения сигналов (signal disposition) (продвинутая тема); управляющий терминал (тоже продвинутая тема).</p>
      <p>Когда функция <code>main()</code> начинает исполнение, все эти вещи уже помещены в работающей программе на свои места. Для запроса и изменения каждого из этих вышеназванных элементов доступны системные вызовы; их освещение является целью данной книги.</p>
      <p>Новые процессы всегда создаются существующими процессами. Существующий процесс называется <emphasis>родительским</emphasis>, а новый процесс — <emphasis>порожденным</emphasis>. При загрузке ядро вручную создает первый, изначальный процесс, который запускает программу <code>/sbin/init</code>; идентификатор этого процесса равен 1, он осуществляет несколько административных функций. Все остальные процессы являются потомками <code>init</code>. (Родительским процессом <code>init</code> является ядро, часто обозначаемое в списках как процесс с ID 0.)</p>
      <p>Отношение порожденный-родительский является отношением один к одному; у каждого процесса есть только один родитель, поэтому легко выяснить PID родителя. Отношение родительский-порожденный является отношением один ко многим; каждый данный процесс может создать потенциально неограниченное число порожденных. Поэтому для процесса нет простого способа выяснить все PID своих потомков. (Во всяком случае, на практике это не требуется.) Родительский процесс можно настроить так, чтобы он получал уведомление при завершении порожденного процесса, он может также явным образом ожидать наступления такого события.</p>
      <p>Адресное пространство (память) каждого процесса отделена от адресного пространства всех остальных процессов. Если два процесса не договорились явным образом разделять память, один процесс не может повлиять на адресное пространство другого. Это важно; это обеспечивает базовый уровень безопасности и надежности системы. (В целях эффективности, система разделяет исполняемый код одной программы с правом доступа только для чтения между всеми процессами, запустившими эту программу. Это прозрачно для пользователя и запущенной программы.)</p>
      <p>Текущий рабочий каталог — это каталог, относительно которого отсчитываются относительные пути файлов (те, которые не начинаются с '<code>/</code>'). Это каталог, в котором вы находитесь, когда набираете команду оболочки '<code>cd <emphasis>someplace</emphasis></code>'.</p>
      <p>По соглашению, все программы запускаются с тремя уже открытыми файлами: стандартным вводом, стандартным выводом и стандартной ошибкой. Это места, откуда принимается ввод, куда направляется вывод и куда направляются сообщения об ошибках соответственно. На протяжении этой книги мы увидим, как они назначаются. Родительский процесс может открыть дополнительные файлы и сделать их доступными для порожденных процессов; порожденный процесс должен каким-то образом узнать, что они есть, либо посредством какого-либо соглашения, либо через аргументы командной строки или переменную окружения.</p>
      <p><emphasis>Окружение</emphasis> представляет собой набор строк, каждая в виде '<code>имя=значение</code>'. Для запроса и установки значений переменных окружения имеются специальные функции, а порожденные процессы наследуют окружение своих родителей. Типичными переменными окружения оболочки являются PATH и НОМЕ. Многие программы для управления своим поведением полагаются на наличие и значения определенных переменных окружения.</p>
      <p>Важно понять, что один процесс в течение своего существования может исполнить множество программ. <emphasis>Все</emphasis> устанавливаемые системой атрибуты (текущий каталог, открытые файлы, PID и т.д.) остаются теми же самыми, если только они не изменены явным образом. Отделение «запуска нового процесса» от «выбора программы для запуска» является ключевым нововведением Unix. Это упрощает многие операции. Другие операционные системы, которые объединяют эти две операции, являются менее общими и их сложнее использовать.</p>
     </section>
     <section>
      <title>
       <p>1.2.1. Каналы: сцепление процессов</p>
      </title>
      <p>Без сомнения, вам приходилось использовать конструкцию ('<code>|</code>') оболочки для соединения двух или более запущенных программ. Канал действует подобно файлу: один процесс записывает в него, используя обычную операцию записи, а другой процесс считывает из него с помощью операции чтения. Процессы (обычно) не знают, что их ввод/вывод является каналом, а не обычным файлом.</p>
      <p>Как ядро скрывает «магию» для устройств, заставляя их действовать подобно файлам, точно так же оно проделывает эту работу для каналов, принимая меры по задержке записи в канал при его наполнении и задержке чтения, когда нет ожидающих чтения данных.</p>
      <p>Таким образом, принцип файлового ввода/вывода применительно к каналам служит ключевым механизмом для связывания запушенных программ; не требуется никаких временных файлов. Опять-таки общность и простота работы: никаких особых случаев для кода пользователя.</p>
     </section>
    </section>
    <section>
     <title>
      <p>1.3. Стандартный С против оригинального С</p>
     </title>
     <p>В течение многих лет определение С де-факто можно было найти в первом издании книги Брайана Кернигана и Денниса Ричи «Язык программирования С» (Brian Kernighan &amp; Dennis Ritchie, <emphasis>The С Programming Language</emphasis>). Эта книга описала С, как он существовал для Unix и на системах, на которые его перенесли разработчики лаборатории Bell Labs. На протяжении данной книги мы называем его как «оригинальный С», хотя обычным является также название «С Кернигана и Ричи» («K&amp;R С»), по именам двух авторов книги. (Деннис Ричи разработал и реализовал С.)</p>
     <p>Стандарт ISO С 1990 г.<a l:href="#n17" type="note">[17]</a> формализовал определения языка, включая функции библиотеки С (такие, как <code>printf()</code> и <code>fopen()</code>). Комитет по стандартам С проделал замечательную работу по стандартизации существующей практики и избежал введения новых возможностей, с одним значительным исключением (и несколькими незначительными). Наиболее заметным изменением языка было использование прототипов функций, заимствованных от С++.</p>
     <p>Стандартные языки программирования С, C++ и Java используют прототипы функций для объявлений и определений функций. Прототип описывает не только возвращаемое значение функции, но также и число и тип ее аргументов. С прототипами компилятор может выполнить проверку типов в точке вызова функции:</p>
     <p><emphasis>Объявление</emphasis></p>
     <p><code>extern int myfunc(struct my_struct *a,</code></p>
     <p><code> struct my_struct *b, double c, int d);</code></p>
     <p><emphasis>Определение</emphasis></p>
     <p><code>int myfunc(struct my_struct *a,</code></p>
     <p><code> struct my_struct *b, double c, int d) {</code></p>
     <p><code> ...</code></p>
     <p><code>}</code></p>
     <p><code>...</code></p>
     <p><code>struct my_struct s, t;</code></p>
     <p><code>int j;</code></p>
     <p><code>...</code></p>
     <p><code>/* Вызов функции, где-то в другом месте: */</code></p>
     <p><code>j = my_func(&amp;s, &amp;t, 3.1415, 42);</code></p>
     <p>Это правильный вызов функции. Но рассмотрите ошибочный вызов:</p>
     <p><code>j = my_func(-1, -2, 0);</code></p>
     <p><code>/* Ошибочные число и типы аргументов */</code></p>
     <p>Компилятор может сразу же определить этот вызов как неверный. Однако, в оригинальном С функции объявляются без указания списка аргументов:</p>
     <p><code>extern int myfunc();</code></p>
     <p><code>/* Возвращает int, аргументы неизвестны */</code></p>
     <p>Более того, определения функций перечисляют имена параметров в заголовке функции, затем объявляют параметры перед телом функции. Параметры типа int объявлять не нужно, и если функция возвращает int, его тоже не нужно объявлять:</p>
     <p><code>myfunc(a, b, с, d); /* Возвращаемый тип int*/</code></p>
     <p><code>struct my_struct *а, *b;</code></p>
     <p><code>double с;</code></p>
     <p><code>/* Обратите внимание, нет объявления параметра d*/</code></p>
     <p><code>{</code></p>
     <p><code> ...</code></p>
     <p><code>}</code></p>
     <p>Рассмотрите снова тот же ошибочный вызов функции: '<code>j = my_func(-1, -2 , 0);</code>'. В оригинальном С у компилятора нет возможности узнать, что вы (ошибочно, полагаем) передали <code>my_func()</code> ошибочные аргументы. Подобные ошибочные вызовы обычно приводят к трудно устранимым проблемам времени исполнения (таким, как ошибки сегментации, из-за чего программа завершается), и для работы с такими вещами была создана программа Unix <code>lint</code>.</p>
     <p>Поэтому, хотя прототипы функции и были радикальным отходом от существующей практики, дополнительную проверку типов посчитали слишком важной, чтобы обходиться без нее, и после небольшого сопротивления она была добавлена в язык.</p>
     <p>Для С стандарта 1990 г. код, написанный в оригинальном стиле, является действительным как для объявлений, так и для определений. Это дает возможность продолжать компилировать миллионы строк существующего кода с помощью компилятора, удовлетворяющего стандарту. Новый код, очевидно, должен быть написан с прототипами из-за улучшенных возможностей проверки ошибок времени компилирования.</p>
     <p>Стандарт С 1999 г.<a l:href="#n18" type="note">[18]</a> продолжает допускать объявления и определения в оригинальном стиле. Однако, правило «неявного <code>int</code>» было убрано; функции должны иметь возвращаемый тип, а все параметры должны быть объявлены.</p>
     <p>Более того, когда программа вызывала функцию, которая не была формально объявлена, оригинальный С создал бы для функции неявное объявление с возвращаемым типом <code>int</code>. С стандарта 1999 г. делал то же самое, дополнительно отметив, что у него не было информации о параметрах. С стандарта 1999 г. не предоставляет больше возможности «автоматического объявления».</p>
     <p>Другими заметными дополнениями в стандарте С являются ключевое слово <code>const</code>, также из С++, и ключевое слово <code>volatile</code>, которое придумал комитет. Для кода, который вы увидите в этой книге, наиболее важной вещью является понимание различных синтаксисов объявлений и определений функций.</p>
     <p>Для кода V7, использующего определения в оригинальном стиле, мы добавили комментарии, показывающие эквивалентный прототип. В остальных случаях мы оставили код как есть, предпочитая показать его точно таким, каким он был первоначально написан, и как бы вы его увидели, если бы сами загрузили код.</p>
     <p>Хотя стандарт С 1999 г. добавляет некоторые дополнительные ключевые слова и возможности, отсутствующие в версии 1990 г., мы решили придерживаться диалекта 1990 г, поскольку компиляторы C99 не являются пока типичными. Практически, это не имеет значения: код C89 должен компилироваться и запускаться без изменений при использовании компилятора C99, а новые возможности C99 не затрагивают наше обсуждение или использование фундаментальных API Linux/Unix.</p>
    </section>
    <section>
     <title>
      <p>1.4. Почему программы GNU лучше</p>
     </title>
     <section>
      <p>Что делает программу GNU программой GNU?<a l:href="#n19" type="note">[19]</a> Что делает программное обеспечение GNU «лучше» по сравнению с другим (платным или бесплатным) программным обеспечением? Наиболее очевидной разницей является общедоступная лицензия (General Public License — GPL), которая описывает условия распространения для программного обеспечения GNU. Но это обычно не причина, чтобы вы могли услышать, как люди говорят: «Дайте GNU-версию <code>xyz</code>, она намного лучше». Программное обеспечение GNU в общем более устойчиво, имеет лучшую производительность, чем в стандартных версиях Unix. В данном разделе мы рассмотрим некоторые причины этого явления, а также рассмотрим документ, описывающий принципы проектирования программного обеспечения GNU.</p>
      <p>«Стандарты кодирования GNU» (<emphasis>GNU Coding Standards</emphasis>) описывают создание программного обеспечения для проекта GNU. Они охватывает ряд тем. Вы можете найти <emphasis>GNU Coding Standards</emphasis> по адресу <code>http://www.gnu.org/prep/standards.html</code>. Смотрите в онлайн-версии ссылки на исходные файлы в других форматах.</p>
      <p>В данном разделе мы описываем лишь те части <emphasis>GNU Coding Standards</emphasis>, которые относятся к проектированию и реализации программ.</p>
     </section>
     <section>
      <title>
       <p>1.4.1. Проектирование программ</p>
      </title>
      <p>Глава 3 <emphasis>GNU Coding Standards</emphasis> содержит общие советы относительно проектирования программ. Четырьмя главными проблемами являются совместимость (со стандартами и с Unix), язык, использование нестандартных возможностей других программ (одним словом, «ничего»), и смысл «переносимости».</p>
      <p>Важной целью является совместимость со стандартом С и POSIX, а также, в меньшей степени, с Berkley Unix. Но она не преобладает. Общей идеей является предоставление всех необходимых возможностей через аргументы командной строки для предоставления точного режима ISO или POSIX.</p>
      <p>Предпочтительным языком для написания программного обеспечения GNU является С, поскольку это наиболее доступный язык. В мире Unix стандарт С теперь обычен, но если для вас не представляет труда поддержка оригинального С, вы должны сделать это. Хотя стандарты кодирования отдают предпочтение С перед С++, C++ теперь тоже вполне обычен. Примером широко используемого пакета GNU, написанного на С++, является <code>groff</code> (GNU <code>troff</code>). Наш опыт говорит, что с GCC, поддерживающим С++, установка <code>groff</code> не представляет сложности.</p>
      <p>Стандарты утверждают, что переносимость является чем-то вроде отвлекающего маневра. Утилиты GNU ясно нацелены на работу с ядром GNU и с библиотекой GNU С<a l:href="#n20" type="note">[20]</a>. Но поскольку ядро еще не завершено, и пользователи используют инструменты GNU на не-GNU системах, переносимость желательна, но не является первостепенной задачей. Стандарт рекомендует для достижения переносимости между различными системами Unix использовать Autoconf.</p>
     </section>
     <section>
      <title>
       <p>1.4.2. Поведение программы</p>
      </title>
      <p>Глава 4 <emphasis>GNU Coding Standards</emphasis> предоставляет общие советы относительно поведения программы. Ниже мы вернемся к одному из ее разделов для более подробного рассмотрения. Глава фокусируется на строении программы, форматировании сообщений об ошибках, написании библиотек (делая их рентабельными) и стандартах для интерфейса командной строки.</p>
      <p>Форматирование сообщений об ошибках важно, поскольку несколько инструментов, особенно Emacs, используют сообщения об ошибках, чтобы помочь вам попасть в то место в исходном файле или файле данных, где произошла ошибка.</p>
      <p>Утилиты GNU должны использовать для обработки командной строки функцию <code>getopt_long()</code>. Эта функция предусматривает разбор аргументов командной строки как для опций в стиле традиционного Unix ('<code>gawk -F:...</code>'), так и для длинных опций в стиле GNU ('<code>gawk --field-separator=:...</code>'). Все программы должны предусматривать опции <code>--help</code> и <code>--version</code>, а когда в одной программе используется длинное имя, оно таким же образом должно использоваться и в другой программе GNU. Для этой цели есть довольно полный список длинных опций, используемых современными GNU-программами.</p>
      <p>В качестве простого, но очевидного примера, <code>--verbose</code> пишется точно таким же способом во всех GNU-программах. Сравните это с <code>-v</code>, <code>-V</code>, <code>-d</code> и т.д. во многих других программах Unix. Большая часть главы 2, «Аргументы, опции и окружение», с. 23, посвящена механике разбора аргументов и опций.</p>
     </section>
     <section>
      <title>
       <p>1.4.3. Программирование на С</p>
      </title>
      <p>Наиболее привлекательной частью <emphasis>GNU Coding Standards</emphasis> является глава 5, которая описывает написание кода на С, освещая такие темы, как форматирование кода, правильное использование комментариев, чистое использование С, именование ваших функций и переменных, а также объявление или не объявление стандартных системных функций, которые вы хотите использовать.</p>
      <p>Форматирование кода является религиозной проблемой; у многих людей разные стили, которые они предпочитают. Лично нам не нравится стиль FSF, и если вы взглянете на <code>gawk</code>, который мы поддерживаем, вы увидите, что он форматирован в стандартном стиле K&amp;R (стиль расположения кода, использованный в обоих изданиях книги Кернигана и Ричи). Но это единственное отклонение в <code>gawk</code> от этой части стандартов кодирования.</p>
      <p>Тем не менее, хотя нам и не нравится стиль FSF<a l:href="#n21" type="note">[21]</a>, мы чувствуем, что при модификации некоторых других программ, придерживание уже использованного стиля кода является исключительно важным. Последовательность в стиле кода более важна, чем сам стиль, который вы выбираете. <emphasis>GNU Coding Standards</emphasis> дает такой же совет. (Иногда невозможно обнаружить последовательный стиль кода, в этом случае программа, возможно, испорчена использованием <code>indent</code> от GNU или <code>cb</code> от Unix.)</p>
      <p>Что мы сочли важным в главе о написании кода на С, это то, что эти советы хороши для <emphasis>любого</emphasis> кода на С, а не только когда вы работаете над программой GNU. Поэтому, если вы просто учите С или даже если вы уже работали некоторое время на С (или С++), мы рекомендуем вам эту главу, поскольку она заключает в себе многолетний опыт.</p>
     </section>
     <section>
      <title>
       <p>1.4.4. Вещи, которые делают программы GNU лучше</p>
      </title>
      <p>Теперь мы рассмотрим раздел, озаглавленный «<emphasis>Написание надежных программ</emphasis>», в главе 4 «<emphasis>Поведение программ для всех программ</emphasis>». Этот раздел описывает принципы проектирования программного обеспечения, которые делают программы GNU лучше их двойников в Unix Мы процитируем выбранные части главы, с несколькими примерами случаев, в которых эти принципы окупились.</p>
      <cite>
       <p>Избегайте произвольных ограничений длины или числа любой структуры данных, включая имена файлов, строки, файлы и символы, выделяя все структуры данных динамически. В большинстве инструментов Unix «длинные строки молча срезаются». Это неприемлемо в инструменте GNU.</p>
      </cite>
      <p>Это правило, возможно, единственное наиболее важное в проектировании программного обеспечения GNU — <emphasis>никаких произвольных ограничений</emphasis>. Все инструменты GNU должны быть способны обрабатывать произвольные объемы данных.</p>
      <p>Хотя это требование, возможно, усложняет работу программиста, оно облегчает жизнь пользователю. С одной стороны, у нас есть пользователь <code>gawk</code>, регулярно запускающий программу <code>awk</code> для более чем 650 000 файлов (нет, это не опечатка) для сбора статистики, <code>gawk</code> заняла бы более 192 мегабайтов пространства данных, и программа работала бы в течение 7 часов. Он не смог бы запустить эту программу, используя другую реализацию <code>awk</code>.<a l:href="#n22" type="note">[22]</a></p>
      <cite>
       <p>Утилиты, читающие файлы, не должны удалять символы NUL или любые другие неотображаемые символы, включая символы с кодами больше 0177. Единственными здравыми исключениями были бы утилиты, специально предназначенные для связывания с определенными типами терминалов или принтеров, которые не могут обработать эти символы.</p>
      </cite>
      <p>Также хорошо известно, что Emacs может редактировать любые произвольные файлы, включая файлы, содержащие двоичные данные!</p>
      <cite>
       <p>По возможности, программы должны обрабатывать должным образом последовательности байтов, представляющих многобайтные символы, используя такие кодировки, как UTF-8 и другие.<a l:href="#n23" type="note">[23]</a> Каждый системный вызов проверяйте на предмет возвращенной ошибки, если вы не хотите игнорировать ошибки. Включите текст системной ошибки (от <code>perror</code> или эквивалентной функции) в каждое сообщение об ошибке, возникшей при неудачном системном вызове, также, как и имя файла, если он есть, и имя утилиты. Простого «невозможно открыть foo.с» или «ошибка запуска» недостаточно.</p>
      </cite>
      <p>Проверка каждого системного вызова создает устойчивость. Это еще один случай, когда жизнь программиста труднее, а пользователя легче. Подробно описанное сообщение об ошибке значительно упрощает нахождение и разрешение проблем<a l:href="#n24" type="note">[24]</a>.</p>
      <p>Наконец, мы цитируем главу 1 <emphasis>GNU Coding Standards</emphasis>, которая обсуждает, как написать вашу программу способом, отличным от того, каким написаны программы Unix.</p>
      <cite>
       <p>Например, утилиты Unix обычно оптимизированы для минимизации использования памяти, если вы взамен хотите получить скорость, ваша программа будет сильно отличаться. Вы можете хранить весь входной файл в ядре и сканировать его там. вместо использования stdio. Используйте недавно открытый более изящный алгоритм вместо алгоритма Unix-программы. Исключите использование временных файлов. Делайте это в один проход вместо двух (мы сделали это на ассемблере) Или, напротив, сделайте упор на простоте вместо скорости. Для некоторых приложений скорость сегодняшних компьютеров делает адекватными более простые алгоритмы.</p>
       <p>Или выберите обобщение. Например, программы Unix часто содержат статичные таблицы или строки фиксированного размера, которые создают произвольные ограничения, используйте вместо этого динамическое выделение памяти. Убедитесь, что ваша программа обрабатывает во входных файлах символы NUL и другие курьезные символы. Добавьте язык программирования для расширяемости и напишите часть программы на этом языке.</p>
       <p>Или выделите части программы в независимо используемые библиотеки. Или используйте простой сборщик мусора вместо точного отслеживания, когда освобождать память, или используйте новую возможность GNU, такую как obstacks.</p>
      </cite>
      <p>Великолепным примером того, какое отличие можно сделать в алгоритме, является GNU <code>diff</code>. Одним из первых ранних воплощений нашей системы было AT&amp;T 3B1, система с процессором МС68010, огромными двумя мегабайтами памяти и 80 мегабайтами на диске. Мы проделали (и делаем) кучу исправлений в руководстве для <code>gawk</code>, файле длиной почти 28 000 строк (хотя в то время он был лишь в диапазоне 10 000 строк). Обычно мы частенько использовали '<code>diff -с</code>', чтобы посмотреть на сделанные нами изменения. На этой медленной системе переключение на GNU <code>diff</code> показало ошеломительную разницу во времени появления контекста <code>diff</code>. Разница почти всецело благодаря лучшему алгоритму, который использует GNU <code>diff</code>.</p>
      <p>В последнем параграфе упоминается идея структурирования программы как независимо используемой библиотеки, с оболочкой командной строки или другим окружающим се интерфейсом. Примером этого является GDB, отладчик GNU, который реализован в виде инструмента с интерфейсом командной строки поверх отладочной библиотеки. (Разделение основных возможностей GDB от интерфейса командной строки является продолжающимся проектом). Эта реализация дает возможность создать поверх отладочных функциональных возможностей графический интерфейс отладчика.</p>
     </section>
     <section>
      <title>
       <p>1.4.5. Заключительные соображения по поводу «GNU Coding Standards»</p>
      </title>
      <p><emphasis>GNU Coding Standards</emphasis> является стоящим для прочтения документом, если вы хотите разрабатывать новое программное обеспечение GNU, обмениваться существующими программами GNU или просто научиться программировать лучше. Принципы и методики, которые она поддерживает — вот что делает программное обеспечение GNU предпочитаемым выбором в сообществе Unix.</p>
     </section>
    </section>
    <section>
     <title>
      <p>1.5. Пересмотренная переносимость</p>
     </title>
     <p>Переносимость является чем-то вроде Святого Грааля; всегда недостающим впоследствии, но не всегда достижимым и определенно нелегким. Есть несколько аспектов написания переносимого кода. <emphasis>GNU Coding Standards</emphasis> обсуждает многие из них. Но есть и другие стороны. При разработке принимайте переносимость во внимание как на высоком, так и на низком уровнях. Мы рекомендуем следующие правила:</p>
     <p><emphasis>Соответствуйте стандартам</emphasis></p>
     <p>Хотя это может потребовать напряжения, знакомство с формальными стандартами языка, который вы используете, окупается. В частности, обратите внимание на стандарты ISO 1990 и 1999 гг. для С и стандарт 2003 г. для С++, поскольку большинство программ Linux создано на одном из этих двух языков.</p>
     <p>В промышленности также широко поддерживается стандарт POSIX для интерфейса библиотечных и системных вызовов, хотя он и большой. Написание в соответствии с POSIX значительно повышает шансы успешного переноса вашего кода и на другие системы, помимо GNU/Linux. Этот стандарт вполне читабелен; он концентрирует в себе десятилетия опыта и хорошей практики.</p>
     <p><emphasis>Выбирайте для работы лучший интерфейс</emphasis></p>
     <p>Если стандартный интерфейс выполняет нужную вам работу, используйте его в своем коде. Для обнаружения недоступного интерфейса используйте Autoconf, и добавьте его замещающую версию для ограниченной системы. (Например, на некоторых более старых системах отсутствует функция <code>memmove()</code>, которую довольно легко запрограммировать самому или вставить из библиотеки GLIBC).</p>
     <p><emphasis>Изолируйте проблемы переносимости за новыми интерфейсами</emphasis></p>
     <p>Иногда вам может потребоваться выполнить специфичные для операционной системы задачи, которые можно исполнить на одних системах, но нельзя на других. (Например, на некоторых системах каждая программа должна сама раскрывать групповые символы в командной строке, вместо выполнения этой работы командным процессором.) Создайте новый интерфейс, который ничего не делает в системах, которым он не нужен, но проделывает необходимую коррекцию для систем, которые в этом нуждаются.</p>
     <p><emphasis>Используйте для конфигурирования Autoconf</emphasis></p>
     <p>По возможности избегайте <code>#ifdef</code>. Если это невозможно, скройте его в низкоуровневом библиотечном коде. Для проверки тестов, которые должны исполняться с помощью <code>#ifdef</code>, используйте Autoconf.</p>
    </section>
    <section>
     <title>
      <p>1.6. Рекомендуемая литература</p>
     </title>
     <p>1. <emphasis>The С Programming Language</emphasis>, 2nd edition, by Brian W. Kernighan and Dennis M. Ritchie Prentice-Hall, Englewood Cliffs, New Jersey, USA, 1989. ISBN: 0-13-110370-9<a l:href="#n25" type="note">[25]</a>.</p>
     <p>Это «библия» С, охватывающая версию стандарта С 1990 г. Это довольно сжатая книга, с большим количеством информации, помещенной в поразительно небольшое число страниц. Вам может потребоваться прочитать ее более одного раза; это стоит затраченных усилий.</p>
     <p>2. <emphasis>С, A Reference Manual</emphasis>. 5th edition, by Samuel P. Harbison III and Guy L. Steele, Ji. Prentice-Hall, Upper Saddle River, New Jersey, USA, 2002. ISBN: 0-13-089592-X.</p>
     <p>Это тоже классическая книга. Она охватывает оригинальный С, а также стандарты 1990 и 1999 гг. Поскольку она современна, она служит ценным дополнением к первой книге. Она охватывает многие важные темы, такие, как интернациональные типы и библиотечные функции, которых нет в книге Кернигана и Ричи.</p>
     <p>3. <emphasis>Notes on Programming in С</emphasis>, by Rob Pike, February 21,1989 Доступна через множество веб-сайтов. Возможно, чаще всего упоминаемым местом является <code>http://www.lysator.liu.se/c/pikestyle.html</code>. (Многие другие полезные статьи доступны там же на один уровень выше: <code>http://www.lysator.liu.se/с/</code>.) Роб Пайк много лет работал в исследовательском центре Bell Labs, где были созданы С и Unix, и проводил там изыскания. Его замечания концентрируют многолетний опыт в «философию ясности в программировании», это стоит прочтения.</p>
     <p>4. Различные ссылки на <code>http://www.chris-lott.org/resources/cstyle/</code>. Этот сайт включает заметки Роба Пайка и несколько статей Генри Спенсера (Henry Spencer). Особенно высокое положение занимает «Рекомендуемый стиль С и стандарты программирования» (<emphasis>Recommended С Style and Coding Standards</emphasis>), первоначально написанный на сайте Bell Labs Indian Hill.</p>
    </section>
    <section>
     <title>
      <p>1.7. Резюме</p>
     </title>
     <p>• «Файлы и процессы» суммируют мировоззрение Linux/Unix. Трактовка файлов как потоков байтов, а устройств как файлов, и использование стандартных ввода, вывода и ошибки упрощают построение программ и унифицируют модель доступа к данным. Модель прав доступа проста, но гибка, и приложима как к файлам, так и каталогам.</p>
     <p>• Процессы являются работающими программами, у которых есть связанные с ними идентификаторы пользователя и группы для проверки прав доступа, а также другие атрибуты, такие, как открытые файлы и текущий рабочий каталог.</p>
     <p>• Наиболее заметным различием между стандартным С и оригинальным С является использование прототипов функций для более строгой проверки типов. Хороший программист на С должен быть способен прочесть код, написанный в оригинальном стиле, поскольку его используют многие существующие программы. Новый код должен быть написан с использованием прототипов.</p>
     <p>• <emphasis>GNU Coding Standards</emphasis> описывает написание программ GNU. Она предусматривает многочисленные ценные методики и руководящие принципы для создания надежного, практичного программного обеспечения. Принцип «никаких произвольных ограничений» является, возможно, единственным наиболее важным из них. Этот документ является обязательным для прочтения серьезными программистами.</p>
     <p>• Переносимость программ является сложной проблемой. Руководящие указания и инструментарий помогают, но в конечном счете нужен также и опыт.</p>
    </section>
    <section>
     <title>
      <p>Упражнения</p>
     </title>
     <p>1. Прочтите и прокомментируйте статью Ричарда М. Столмена «Проект GNU» (Richard M. Stallman, «The GNU Project»)<a l:href="#n26" type="note">[26]</a>, первоначально написанную в августе 1998 г.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 2</p>
     <p>Аргументы, опции и переменные окружения</p>
    </title>
    <section>
     <p>Первой задачей любой программы обычно является интерпретация опций и аргументов командной строки. Данная глава рассматривает, как программы С (и С++) получают аргументы своей командной строки, описывает стандартные процедуры для разбора опций и бросает взгляд на переменные окружения.</p>
    </section>
    <section>
     <title>
      <p>2.1. Соглашения по опциям и аргументам</p>
     </title>
     <section>
      <p>У слова <emphasis>аргументы</emphasis> есть два значения. Более техническим определением является «все 'слова' в командной строке». Например:</p>
      <p><code>$ <strong>ls main.с opts.с process.с</strong></code></p>
      <p>Здесь пользователь напечатал четыре «слова». Все четыре слова сделаны доступными программе в качестве ее аргументов<a l:href="#n27" type="note">[27]</a>.</p>
      <p>Второе определение более неформальное: аргументами являются все слова командной строки, <emphasis>за исключением</emphasis> имени команды. По умолчанию, оболочки Unix отделяют аргументы друг от друга <emphasis>разделителями</emphasis> (пробелами или символами TAB). Кавычки позволяют включать в аргументы разделитель:</p>
      <p><code>$ <strong>echo here are lots of spaces</strong></code></p>
      <p><code>here are lots of spaces /* Оболочка «съедает» пробелы */</code></p>
      <p><code>$ <strong>echo "here are lots of spaces"</strong></code></p>
      <p><code>here are lots of spaces /* Пробелы остались */</code></p>
      <p>Кавычки прозрачны для запущенной программы; <code>echo</code> никогда не видит символов двойной кавычки. (В оболочке двойные и одинарные кавычки различаются; обсуждение этих правил выходит за рамки данной книги, которая фокусируется на программировании на С.)</p>
      <p>Аргументы можно подразделить далее на <emphasis>опции</emphasis> и <emphasis>операнды</emphasis>. В предыдущих двух примерах все аргументы были операндами: файлы для <code>ls</code> и простой текст для <code>echo</code>.</p>
      <p>Опции являются специальными аргументами, которые каждая программа интерпретирует. Опции изменяют поведение программы или предоставляют программе информацию. По старому соглашению, которого (почти) всегда придерживаются, опции начинаются с черточки (т.е. дефиса, значка минус), и состоят из единственной буквы. <emphasis>Аргументы опции</emphasis> являются информацией, необходимой для опции, в отличие от обычных аргументов-операндов. Например, опция <code>-f</code> программы <code>fgrep</code> означает «использовать содержимое следующего файла в качестве списка строк для поиска». См. рис 2.1.</p>
      <image l:href="#img_1.png"/>
      <p><strong>Рис. 2.1</strong>. Компоненты командной строки</p>
      <p>Таким образом, <code>patfile</code> является не файлом данных для поиска, а предназначен для использования <code>fgrep</code> в определении списка строк, которые нужно искать.</p>
     </section>
     <section>
      <title>
       <p>2.1.1. Соглашения POSIX</p>
      </title>
      <p>Стандарт POSIX описывает ряд соглашений, которых придерживаются удовлетворяющие стандарту программы. Никто от вас не требует, чтобы ваши программы удовлетворяли этим стандартам, но это хорошая мысль сделать так: пользователи Linux и Unix по всему миру понимают и используют эти соглашения, и если вы не будете им следовать, ваши пользователи будут несчастны. (Или у вас вообще не будет пользователей!) Более того, функции, которые мы обсуждаем далее в этой главе, освобождают вас от бремени ручной реализации этих соглашений для каждой программы, которую вы пишете. Вот эти правила, перефразированные из стандарта:</p>
      <p>1. В имени программы должно быть не менее двух и не более девяти символов.</p>
      <p>2. Имена программ должны содержать лишь строчные символы и цифры.</p>
      <p>3. Имя опции должно быть простым буквенно-цифровым символом. Опции с множеством цифр не должны допускаться. Для производителей, реализующих утилиты POSIX, опция <code>-W</code> зарезервирована для специфичных для производителя опций.</p>
      <p>4. Все опции должны начинаться с символа '<code>-</code>'.</p>
      <p>5. Для опций, не требующих аргументов, должно быть возможно объединение нескольких опций после единственного символа '<code>-</code>'. (Например, '<code>foo -a -b -c</code>' и '<code>foo -abc</code>' должны интерпретироваться одинаково.)</p>
      <p>6. Когда опции все же требуется аргумент, он должен быть отделен от опции пробелом (например, '<code>fgrep -f patfile</code>').</p>
      <p>Однако, стандарт допускает историческую практику, при которой иногда опция и ее операнд могут находиться в одной строке: '<code>fgrep -fpatfile</code>'. На практике функции <code>getopt()</code> и <code>getopt_long()</code> интерпретируют '<code>-fpatfile</code>' как '<code>-f patfile</code>', а не как '<code>-f -p -a -t ...</code>'.</p>
      <p>7. Аргументы опций не должны быть необязательными.</p>
      <p>Это означает, что если в документации программы указано, что опции требуется аргумент, этот аргумент должен присутствовать всегда, иначе программа потерпит неудачу GNU <code>getopt()</code> все же предусматривает необязательные аргументы опций, поскольку иногда они полезны</p>
      <p>8. Если опция принимает аргумент, который может иметь несколько значений, программа должна получать этот аргумент в виде одной строки со значениями, разделенными запятыми или разделителем.</p>
      <p>Например, предположим, что гипотетической программе <code>myprog</code> требуется список пользователей для опции <code>-u</code>. Далее она может быть вызвана одним из двух способов:</p>
      <p><code>myprog -u "arnold,joe,jane" /* Разделение запятыми */</code></p>
      <p><code>myprog -u "arnold joe jane" /* Разделение пробелами */</code></p>
      <p>В таком случае вы должны самостоятельно отделить и обработать каждое значение (т.е. здесь нет стандартной процедуры), но ручная реализация обычно проста.</p>
      <p>9. Опции должны находиться в командной строке первыми, перед операндами. Версии <code>getopt()</code> Unix проводят в жизнь это соглашение. GNU <code>getopt()</code> по умолчанию этого не делает, хотя вы можете настроить его на это.</p>
      <p>10. Специальный аргумент '<code>--</code>' указывает на окончание всех опций. Все последующие аргументы командной строки рассматриваются как операнды, даже если они начинаются с черточки.</p>
      <p>11. Порядок, в котором приведены опции, не должен играть роли. Однако, для взаимно исключающих опций, когда одна опция перекрывает установки другой, тогда (так сказать) последняя побеждает. Если опция, имеющая аргумент, повторяется, программа должна обработать аргументы по порядку. Например, '<code>myprog -u arnold -u jane</code>' то же самое, что и '<code>myprog -u "arnold, jane"</code>'. (Вам придется осуществить это самостоятельно; <code>getopt()</code> вам не поможет.)</p>
      <p>12. Нормально, когда порядок аргументов имеет для программы значение. Каждая программа должна документировать такие вещи.</p>
      <p>13. Программы, читающие или записывающие именованные файлы, должны трактовать единственный аргумент '<code>-</code>' как означающий стандартный ввод или стандартный вывод, в зависимости от того, что подходит программе.</p>
      <p>Отметим, что многие стандартные программы не следуют всем указанным соглашениям. Главной причиной является историческая совместимость; многие такие программы предшествовали систематизации этих соглашений.</p>
     </section>
     <section>
      <title>
       <p>2.1.2. Длинные опции GNU</p>
      </title>
      <p>Как мы видели в разделе 1.4.2 «Поведение программ», программам GNU рекомендуется использовать длинные опции в форме <code>--help</code>, <code>--verbose</code> и т.д. Такие опции, поскольку они начинаются с '<code>--</code>', не конфликтуют с соглашениями POSIX. Их также легче запомнить, и они предоставляют возможность последовательности среди всех утилит GNU. (Например, <code>--help</code> является везде одним и тем же, в отличие от <code>-h</code> для «help», <code>-i</code> для «information» и т.д.) Длинные опции GNU имеют свои собственные соглашения, реализованные в функции <code>getopt_long()</code>:</p>
      <p>1. У программ, реализующих инструменты POSIX, каждая короткая опция (один символ) должна иметь также свой вариант в виде длинной опции.</p>
      <p>2. Дополнительные специфические для GNU опции не нуждаются в соответствующей короткой опции, но мы рекомендуем это сделать.</p>
      <p>3. Длинную опцию можно сократить до кратчайшей строки, которая остается уникальной. Например, если есть две опции <code>--verbose</code> и <code>--verbatim</code>, самыми короткими сокращениями будут <code>--verbo</code> и <code>--verba</code>.</p>
      <p>4. Аргументы опции отделяются от длинных опций либо разделителем, либо символом <code>=</code>. Например, <code>--sourcefile=/some/file</code> или <code>--sourcefile /some/file</code>.</p>
      <p>5. Опции и аргументы могут быть заинтересованы в операндах командной строки, <code>getopt_long()</code> переставляет аргументы таким образом, что сначала обрабатываются все опции, а затем все операнды доступны последовательно. (Такое поведение можно запретить.)</p>
      <p>6. Аргументы опций могут быть необязательными. Для таких опций считается, что аргумент присутствует, если он находится в одной строке с опцией. Это работает лишь для коротких опций. Например, если -х такая опция и дана строка '<code>foo -хYANKEES -y</code>', аргументом <code>-х</code> является '<code>YANKEES</code>'. Для '<code>foo -х -y</code>' у <code>-х</code> нет аргументов.</p>
      <p>7. Программы могут разрешить длинным опциям начинаться с одной черточки (Это типично для многих программ X Window.)</p>
      <p>Многое из этого станет яснее, когда позже в этой главе мы рассмотрим <code>getopt_long()</code>.</p>
      <p><emphasis>GNU Coding Standards</emphasis> уделяет значительное место перечислению всех длинных и коротких опций, используемых программами GNU. Если вы пишете программу, использующую длинные опции, посмотрите, нет ли уже использующихся имен опций, которые имело бы смысл использовать и вам.</p>
     </section>
    </section>
    <section>
     <title>
      <p>2.2. Базовая обработка командной строки</p>
     </title>
     <section>
      <p>Программа на С получает доступ к своим аргументам командной строки через параметры <code>argc</code> и <code>argv</code>. Параметр <code>argc</code> является целым, указывающим число имеющихся аргументов, включая имя команды. Есть два обычных способа определения <code>main()</code>, отличающихся способом объявления <code>argc</code>:</p>
      <p><code>int main(int argc, char *argv[])  int main(int argc, char **argv)</code></p>
      <p><code>{                                 {</code></p>
      <p><code>...                                ...</code></p>
      <p><code>}                                 }</code></p>
      <p>Практически между двумя этими объявлениями нет разницы, хотя первое концептуально более понятно: <code>argc</code> является массивом указателей на символы. А второе определение технически более корректно, это то, что мы используем. На рис. 2.2 изображена эта ситуация.</p>
      <image l:href="#img_2.png"/>
      <p><strong>Рис. 2.2</strong>. Память для <code>argc</code></p>
      <p>По соглашению, <code>argv[0]</code> является именем программы. (Детали см. в разделе 9.1.4.3. «Имена программ и <code>argv[0]</code>».) Последующие элементы являются аргументами командной строки. Последним элементом массива <code>argv</code> является указатель <code>NULL</code>.</p>
      <p><code>argc</code> указывает, сколько имеется аргументов; поскольку в С индексы отсчитываются с нуля, выражение '<code>argv[argc] == NULL</code>' всегда верно. Из-за этого, особенно в коде для Unix, вы увидите различные способы проверки окончания списка аргументов, такие, как цикл с проверкой, что счетчик превысил <code>argc</code>, или '<code>argv[i] == 0</code>', или '<code>*argv != NULL</code>' и т.д. Они все эквивалентны.</p>
     </section>
     <section>
      <title>
       <p>2.2.1. Программа <code>echo</code> V7</p>
      </title>
      <p>Возможно, простейшим примером обработки командной строки является программа V7 <code>echo,</code> печатающая свои аргументы в стандартный вывод, разделяя их пробелами и завершая символом конца строки. Если первым аргументом является <code>-n</code>, завершающий символ новой строки опускается. (Это используется для приглашений из сценариев оболочки.) Вот код<a l:href="#n28" type="note">[28]</a>:</p>
      <p><code>1  #include &lt;stdio.h&gt;</code></p>
      <p><code>2</code></p>
      <p><code>3  main(argc, argv) /*int main(int argc, char **argv)*/</code></p>
      <p><code>4  int argc;</code></p>
      <p><code>5  char *argv[];</code></p>
      <p><code>6  {</code></p>
      <p><code>7   register int i, nflg;</code></p>
      <p><code>8</code> </p>
      <p><code>9   nflg = 0;</code></p>
      <p><code>10  if (argc &gt; 1 &amp;&amp; argv[1][0] == &amp;&amp; argv[1][1] == 'n') {</code></p>
      <p><code>11   nflg++;</code></p>
      <p><code>12   argc--;</code></p>
      <p><code>13   argv++;</code></p>
      <p><code>14  }</code></p>
      <p><code>15  for (i=1; i&lt;argc; i++) {</code></p>
      <p><code>16   fputs(argv[i], stdout);</code></p>
      <p><code>17   if (i &lt; argc-1)</code></p>
      <p><code>18   putchar(' ');</code></p>
      <p><code>19  }</code></p>
      <p><code>20  if (nflg == 0)</code></p>
      <p><code>21   putchar('\n');</code></p>
      <p><code>22  exit(0);</code></p>
      <p><code>23 }</code></p>
      <p>Всего 23 строки! Здесь есть два интересных момента. Во-первых, уменьшение <code>argc</code> и одновременное увеличение <code>argv</code> (строки 12 и 13) являются обычным способом пропуска начальных аргументов. Во-вторых, проверка наличия <code>-n</code> (строка 10) является упрощением. <code>-no-newline-at-the-end</code> также работает. (Откомпилируйте и проверьте это!)</p>
      <p>Ручной разбор опций обычен для кода V7, поскольку функция <code>getopt()</code> не была еще придумана.</p>
      <p>Наконец, здесь и в других местах по всей книге, мы видим использование ключевого слова register. Одно время это ключевое слово давало компилятору подсказку, что данная переменная должна по возможности размещаться в регистре процессора. Теперь это ключевое слово устарело; современные компиляторы все основывают размещение переменных в регистрах на анализе исходного кода, игнорируя ключевое слово <code>register</code>. Мы решили оставить использующий это слово код, как есть, но вы должны знать, что оно больше не имеет реального применения.<a l:href="#n29" type="note">[29]</a></p>
     </section>
    </section>
    <section>
     <title>
      <p>2.3. Разбор опций: <code>getopt()</code> и <code>getopt_long()</code></p>
     </title>
     <section>
      <p>Примерно в 1980-х группа поддержки Unix для System III в AT&amp;T заметила, что каждая программа Unix использовала для разбора аргументов свои собственные методики. Чтобы облегчить работу пользователей и программистов, они разработали большинство из перечисленных ранее соглашений. (Хотя изложение в System III справки для <emphasis>intro</emphasis>(1) значительно менее формально, чем в стандарте POSIX.)</p>
      <p>Группа поддержки Unix разработала также функцию <code>getopt()</code>, вместе с несколькими внешними переменными, чтобы упростить написание кода, придерживающегося стандартных соглашений. Функция GNU <code>getopt_long()</code> предоставляет совместимую с <code>getopt()</code> версию, а также упрощает разбор длинных опций в описанной ранее форме.</p>
     </section>
     <section>
      <title>
       <p>2.3.1. Опции с одним символом</p>
      </title>
      <p>Функция <code>getopt()</code> объявлена следующим образом:</p>
      <p><code>#include &lt;unistd.h&gt; /*POSIX*/</code></p>
      <empty-line/>
      <p><code>int getopt(int argc, char *const argv[], const char *optstring);</code></p>
      <p><code>extern char *optarg;</code></p>
      <p><code>extern int optind, opterr, optopt;</code></p>
      <p>Аргументы <code>argc</code> и <code>argv</code> обычно передаются непосредственно от <code>main()</code>. <code>optstring</code> является строкой символов опций. Если за какой-либо буквой в строке следует двоеточие, эта опция ожидает наличия аргумента.</p>
      <p>Для использования <code>getopt()</code> вызывайте ее повторно из цикла <code>while</code> до тех пор, пока она не вернет <code>-1</code>. Каждый раз, обнаружив действительный символ опции, функция возвращает этот символ. Если опция принимает аргумент, указатель на него помещается в переменную <code>optarg</code>. Рассмотрим программу, принимающую опцию <code>-а</code> без аргумента и опцию <code>-b</code> с аргументом:</p>
      <p><code>int ос; /* символ опции */</code></p>
      <p><code>char *b_opt_arg;</code></p>
      <p><code>while ((ос = getopt(argc, argv, "ab:")) != -1) {</code></p>
      <p><code> switch (oc) {</code></p>
      <p><code> case 'a':</code></p>
      <p><code>  /* обработка -а, установить соответствующий флаг */</code></p>
      <p><code>  break;</code></p>
      <p><code> case 'b':</code></p>
      <p><code>  /* обработка -b, получить значение аргумента из optarg */</code></p>
      <p><code>  b_opt_arg = optarg;</code></p>
      <p><code>  break;</code></p>
      <p><code> case ':':</code></p>
      <p><code>  ... /* обработка ошибок, см. текст */</code></p>
      <p><code> case '?':</code></p>
      <p><code> default:</code></p>
      <p><code>  ... /* обработка ошибок, см. текст */</code></p>
      <p><code> }</code></p>
      <p><code>}</code></p>
      <p>В ходе работы <code>getopt()</code> устанавливает несколько переменных, контролирующих обработку ошибок:</p>
      <p><code>char *optarg</code></p>
      <p>Аргумент для опции, если она принимает аргумент.</p>
      <p><code>int optind</code></p>
      <p>Текущий индекс в <code>argv</code>. Когда цикл <code>loop</code> завершается, оставшиеся операнды находятся с <code>argv[optind]</code> по <code>argv[argc-1]</code>. (Помните, что '<code>argv [argc] ==NULL</code>'.)</p>
      <p><code>int opterr</code></p>
      <p>Когда эта переменная не равна нулю (значение по умолчанию), <code>getopt()</code> печатает свои собственные сообщения для недействительных опций или отсутствующих аргументов опций.</p>
      <p><code>int optopt</code></p>
      <p>Когда находится недействительный символ опции, <code>getopt()</code> возвращает либо '<code>?</code>', либо '<code>:</code>' (см ниже), a <code>optopt</code> содержит обнаруженный недействительный символ.</p>
      <p>Люди есть люди, программы неизбежно будут иногда вызываться неправильно либо с недействительной опцией, либо с отсутствующим аргументом опции. Обычно в таких случаях <code>getopt()</code> выводит свои собственные сообщения и возвращает символ '<code>?</code>'. Однако, вы можете изменить такое поведение двумя способами.</p>
      <p>Во-первых, записав 0 в <code>opterr</code> перед вызовом <code>getopt()</code>, можно заставить <code>getopt()</code> не предпринимать при обнаружении проблем никаких действий.</p>
      <p>Во-вторых, если <emphasis>первый</emphasis> символ в <code>optstring</code> является двоеточием, <code>getopt()</code> не предпринимает никаких действий и возвращает другой символ в зависимости от ошибки следующим образом:</p>
      <p><emphasis>Неверная опция</emphasis></p>
      <p><code>getopt()</code> возвращает '<code>?</code>', a <code>optopt</code> содержит неверный символ опции (Это обычное поведение).</p>
      <p><emphasis>Отсутствует аргумент опции</emphasis></p>
      <p><code>getopt()</code> возвращает '<code>:</code>'. Если первый символ <code>optstring</code> не является двоеточием, <code>getopt()</code> возвращает '<code>?</code>', делая этот случай неотличимым от случая неверной опции.</p>
      <p>Таким образом, помещение в качестве первого символа <code>optstring</code> двоеточия является хорошей мыслью, поскольку это позволяет различать «неверную опцию» и «отсутствующий аргумент опции». Расплатой за это является то, что <code>getopt()</code> в этом случае также не предпринимает никаких действий, заставляя вас выводить собственные сообщения об ошибках. Вот предыдущий пример, на этот раз с обработкой ошибок:</p>
      <p><code>int ос; /* символ опции */</code></p>
      <p><code>char *b_opt_arg;</code></p>
      <p><code>while ((ос = getopt(argc, argv, ":ab:")) != -1) {</code></p>
      <p><code> switch (oc) {</code></p>
      <p><code> case 'a':</code></p>
      <p><code>  /* обработка -a, установка соответствующего флага */</code></p>
      <p><code>  break;</code></p>
      <p><code> case 'b':</code></p>
      <p><code>  /* обработка -b, получение значения аргумента из optarg */</code></p>
      <p><code>  b_opt_arg = optarg;</code></p>
      <p><code>  break;</code></p>
      <p><code> case ':':</code></p>
      <p><code>  /* отсутствует аргумент опции */</code></p>
      <p><code>  fprintf(stderr, "%s: option '-%c' requires an argument\n",</code></p>
      <p><code>   argv[0], optopt);</code></p>
      <p><code>  break;</code></p>
      <p><code> case '?':</code></p>
      <p><code> default:</code></p>
      <p><code>  /* недействительная опция */</code></p>
      <p><code>  fprintf(stderr, "%s: option '-%c' is invalid: ignored\n",</code></p>
      <p><code>   argv[0], optopt);</code></p>
      <p><code>  break;</code></p>
      <p><code> }</code></p>
      <p><code>}</code></p>
      <p>Замечание о соглашениях по именованию флагов или опций: в большом количестве кода для Unix используются имена в виде <code>xflg</code> для любого данного символа опции <emphasis>x</emphasis> (например, <code>nflg</code> в <code>echo</code> V7; обычным является также <code>xflag</code>). Это может быть замечательным для авторе программы, который без проверки документации знает, что означает опция <emphasis>x</emphasis>. Но это не подходит для кого-то еще, кто пытается прочесть код и не знает наизусть значений всех символов опций. Гораздо лучше использовать имена, передающие смысл опции, как <code>no_newline</code> для опции <code>-n</code> echo.</p>
     </section>
     <section>
      <title>
       <p>2.3.2. GNU <code>getopt()</code> и порядок опций</p>
      </title>
      <p>Стандартная функция <code>getopt()</code> прекращает поиск опций, как только встречает аргумент командной строки, который не начинается с GNU <code>getopt()</code> отличается: она просматривает в поисках опций всю командную строку. По мере продвижения она переставляет элементы <code>argv</code>, так что после ее завершения все опции оказываются переставленными в начало, и код, продолжающий разбирать аргументы с <code>argv[optind]</code> до <code>argv[argc-1]</code>, работает правильно. Во всех случаях специальный аргумент '<code>--</code>' завершает сканирование опций.</p>
      <p>Вы можете изменить поведение по умолчанию, использовав в <code>optstring</code> специальный первый символ следующим образом:</p>
      <p><code>optstring[0] == '+'</code></p>
      <p>GNU <code>getopt()</code> ведет себя, как стандартная <code>getopt()</code>; она возвращает опции по мере их обнаружения, останавливаясь на первом аргументе, не являющемся опцией. Это работает также в том случае, если в окружении присутствует строка <code>POSIXLY_CORRECT</code>.</p>
      <p><code>optstring[0] == '-'</code></p>
      <p>GNU <code>getopt()</code> возвращает каждый аргумент командной строки независимо от того, представляет он аргумент или нет. В этом случае для каждого такого аргумента функция возвращает целое 1, а указатель на соответствующую строку помещает в <code>optarg</code>.</p>
      <p>Как и для стандартной <code>getopt()</code>, если первым символом <code>optstring</code> является '<code>:</code>', GNU <code>getopt()</code> различает «неверную опцию» и «отсутствующий аргумент опции», возвращая соответственно '<code>?</code>' или '<code>:</code>'. Символ '<code>:</code>' в <code>optstring</code> может быть вторым символом, если первым символом является '<code>+</code>' или '<code>-</code>'.</p>
      <p>Наконец, если за символом опции в <code>optstring</code> следуют <emphasis>два</emphasis> двоеточия, эта опция может иметь необязательный аргумент. (Быстро повторите это три раза!) Такой аргумент считается присутствующим, если он находится в том же элементе <code>argv</code>, что и сама опция, и отсутствующим в противном случае. В случае отсутствия аргумента GNU <code>getopt()</code> возвращает символ опции, а в <code>optarg</code> записывает NULL. Например, пусть имеем:</p>
      <p><code>while ((с = getopt(argc, argv, "ab::")) != -1)</code></p>
      <p><code>...</code></p>
      <p>для <code>-bYANKEES</code>, возвращаемое значение будет '<code>b</code>', a <code>optarg</code> указывает на «<code>YANKEES</code>», тогда как для <code>-b</code> или '<code>-b YANKEES</code>' возвращаемое значение будет все то же '<code>b</code>', но в <code>optarg</code> будет помещен NULL. В последнем случае «<code>YANKEES</code>» представляет отдельный аргумент командной строки.</p>
     </section>
     <section>
      <title>
       <p>2.3.3. Длинные опции</p>
      </title>
      <section>
       <p>Функция <code>getopt_long()</code> осуществляет разбор длинных опций в описанном ранее виде. Дополнительная процедура <code>getopt_long_only()</code> работает идентичным образом, но она используется для программ, в которых все опции являются длинными и начинаются с единичного символа '<code>-</code>'. В остальных случаях обе функции работают точно так же, как более простая функция GNU <code>getopt()</code>. (Для краткости, везде, где мы говорим «<code>getopt_long()</code>», можно было бы сказать «<code>getopt_long()</code> и <code>getopt_long_only()</code>».) Вот объявления функций из справки getopt(3) GNU/Linux:</p>
       <p><code>#include &lt;getopt.h&gt; /* GLIBC */</code></p>
       <empty-line/>
       <p><code>int getopt_long(int argc, char *const argv[],</code></p>
       <p><code> const char *optstring,</code></p>
       <p><code> const struct option *longopts, int *longindex);</code></p>
       <p><code>int getopt_long_only(int argc, char *const argv[],</code></p>
       <p><code> const char *optstring,</code></p>
       <p><code> const struct option *longopts, int *longindex);</code></p>
       <p>Первые три аргумента те же, что и в <code>getopt()</code>. Следующая опция является указателем на массив <code>struct option</code>, который мы назовем <emphasis>таблицей длинных опций</emphasis> и который вскоре опишем. Параметр <code>longindex</code>, если он не установлен в NULL, указывает на переменную, в которую помешается индекс обнаруженной длинной опции в <code>longopts</code>. Это полезно, например, при диагностике ошибок.</p>
      </section>
      <section>
       <title>
        <p>2.3.3.1. Таблица длинных опций</p>
       </title>
       <p>Длинные опции описываются с помощью массива структур <code>struct option</code>. Структура <code>struct option</code> определена в <code>&lt;getopt.h&gt;</code>; она выглядит следующим образом:</p>
       <p><code>struct option {</code></p>
       <p><code> const char *name;</code></p>
       <p><code> int has_arg;</code></p>
       <p><code> int *flag;</code></p>
       <p><code> int val;</code></p>
       <p><code>};</code></p>
       <p>Элементы структуры следующие:</p>
       <p><code>const char *name</code></p>
       <p>Это имя опции <emphasis>без</emphasis> предшествующих черточек, например, «<code>help</code>» или «<code>verbose</code>».</p>
       <p><code>int has_arg</code></p>
       <p>Переменная описывает, имеет ли длинная опция аргумент, и если да, какого вида этот аргумент. Значение должно быть одно из представленных в табл. 2.1. Макроподстановки являются некоторыми символическими именами для числовых значений, приведенных в таблице. Хотя числовые значения тоже работают, макроподстановки гораздо легче читать, и вы должны их использовать вместо соответствующих чисел в любом коде, который пишете.</p>
       <p><code>int *flag</code></p>
       <p>Если этот указатель равен NULL, <code>getopt_long()</code> возвращает значение поля <code>val</code> структуры. Если он не равен NULL, переменная, на которую он указывает, заполняется значением <code>val</code>, a <code>getopt_long()</code> возвращает 0. Если <code>flag</code> не равен NULL, но длинная опция отсутствует, указанная переменная не изменяется.</p>
       <p><code>int val</code></p>
       <p>Если длинная опция обнаружена, это возвращаемое значение или значение для загрузки в <code>*flag</code>, если <code>flag</code> не равен NULL. Обычно, если <code>flag</code> не равен NULL, <code>val</code> является значением true/false, вроде 1 или 0. С другой стороны, если <code>flag</code> равен NULL, <code>val</code> обычно содержит некоторую символьную константу. Если длинная опция соответствует короткой, эта символьная константа должна быть той же самой, которая появляется в аргументе <code>optstring</code> для этой опции. (Все это станет вскоре ясно, когда мы рассмотрим несколько примеров.)</p>
       <empty-line/>
       <p><strong>Таблица 2.1</strong>. Значения для <code>has_arg</code></p>
       <table>
        <tr align="left">
         <th align="left" valign="top">Макроподстановка</th>
         <th align="left" valign="top">Числовое значение</th>
         <th align="left" valign="top">Смысл</th>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>no_argument</code></td>
         <td align="left" valign="top">0</td>
         <td align="left" valign="top">Опция не принимает аргумент</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>required_argument</code></td>
         <td align="left" valign="top">1</td>
         <td align="left" valign="top">Опции требуется аргумент</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>optional_argument</code></td>
         <td align="left" valign="top">2</td>
         <td align="left" valign="top">Аргумент опции является необязательным</td>
        </tr>
       </table>
       <p>У каждой длинной опции есть один такой элемент с соответствующими заполненными значениями. В последнем элементе массива все значения должны быть равны нулю. Нет необходимости сортировать массив: <code>getopt_long()</code> осуществляет линейный поиск. Однако, сортировка его по длинным именам может упростить его чтение для программиста.</p>
       <p>При первой встрече использование <code>flag</code> и <code>val</code> кажется сбивающим с толку. Давайте сделаем на время шаг назад и рассмотрим, почему это работает именно таким способом В большинстве случаев, обработка опций заключается в установке значений различных флаговых переменных при обнаружении различных символов опций, наподобие этого:</p>
       <p><code>while ((с = getopt(argc, argv, ":af:hv")) != -1) {</code></p>
       <p><code> switch (с) {</code></p>
       <p><code> case 'a':</code></p>
       <p><code>  do_all = 1;</code></p>
       <p><code>  break;</code></p>
       <p><code> case 'f':</code></p>
       <p><code>  myfile = optarg;</code></p>
       <p><code>  break;</code></p>
       <p><code> case 'h':</code></p>
       <p><code>  do_help = 1;</code></p>
       <p><code>  break;</code></p>
       <p><code> case 'v':</code></p>
       <p><code>  do_verbose = 1;</code></p>
       <p><code>  break;</code></p>
       <p><code> ... /* Здесь обработка ошибок */</code></p>
       <p><code> }</code></p>
       <p><code>}</code></p>
       <p>Когда <code>flag</code> не равен NULL, <code>getopt_long()</code> <emphasis>устанавливает значения переменных за вас</emphasis>. Это снижает число операторов <code>case</code> в предыдущем <code>switch</code> с трех до одного. Вот пример таблицы длинных опций и код для работы с ней:</p>
       <p><code>int do_all, do_help, do_verbose; /* флаговые переменные */</code></p>
       <p><code>char *my_file;</code></p>
       <p><code>struct option longopts[] = {</code></p>
       <p><code> { "all", no_argument, &amp;do_all, 1 },</code></p>
       <p><code> { "file", required_argument, NULL, 'f' },</code></p>
       <p><code> { "help", no_argument, &amp;do_help, 1 },</code></p>
       <p><code> { "verbose", no_argument, &amp;do_verbose, 1 },</code></p>
       <p><code> { 0, 0, 0, 0 }</code></p>
       <p><code>};</code></p>
       <empty-line/>
       <p><code>while ((с =</code></p>
       <p><code> getopt_long(argc, argv, ":f:", longopts, NULL)) != -1) {</code></p>
       <p><code> switch (c) {</code></p>
       <p><code> case 'f':</code></p>
       <p><code>  myfile = optarg;</code></p>
       <p><code>  break;</code></p>
       <p><code> case 0:</code></p>
       <p><code>  /* getopt_long() устанавливает значение переменной,</code></p>
       <p><code>     просто продолжить выполнение */</code></p>
       <p><code>  break;</code></p>
       <p><code> ... /* Здесь обработка ошибок */</code></p>
       <p><code> }</code></p>
       <p><code>}</code></p>
       <p>Обратите внимание, что значение, переданное аргументу <code>optstring</code>, не содержит больше '<code>a</code>', '<code>h</code>' или '<code>v</code>'. Это означает, что соответствующие короткие опции неприемлемы. Чтобы разрешить как длинные, так и короткие опции, вам придется восстановить в <code>switch</code> соответствующие <code>case</code> из первого примера.</p>
       <p>На практике следует писать свои программы так, чтобы у каждой короткой опции была также соответствующая длинная опция. В этом случае проще всего установить в <code>flag</code> NULL, а в <code>val</code> соответствующий единичный символ.</p>
      </section>
      <section>
       <title>
        <p>2.3.3.2. Длинные опции в стиле POSIX</p>
       </title>
       <p>Стандарт POSIX резервирует опцию <code>-W</code> для специфических для производителя возможностей. Поэтому по определению <code>-W</code> непереносимо между различными системами.</p>
       <p>Если за <code>W</code> в аргументе <code>optstring</code> следует точка с запятой (обратите внимание не двоеточие), <code>getopt_long()</code> рассматривает <code>-Wlongopt</code> так же, как <code>--longopt</code>. Соответственно в предыдущем примере измените вызов следующим образом:</p>
       <p><code>while ((с =</code></p>
       <p><code> getopt_long(argc, argv, ":f:W;", longopts, NULL)) != -1) {</code></p>
       <p>С этим изменением <code>-Wall</code> является тем же, что и <code>--all</code>, a <code>-Wfile=myfile</code> тем же, что <code>--file=myfile</code>. Использование точки с запятой позволяет программе использовать при желании <code>-W</code> в качестве обычной опции. (Например, GCC использует ее как нормальную опцию, тогда как <code>gawk</code> использует ее для совместимости с POSIX.)</p>
      </section>
      <section>
       <title>
        <p>2.3.3 3. Сводка возвращаемых значений <code>getopt_long()</code></p>
       </title>
       <p>Теперь должно быть ясно, что <code>getopt_long()</code> предоставляет гибкий механизм для разбора опций. В табл. 2.2 приведена сводка всех возможных возвращаемых значений функции и их значение.</p>
       <empty-line/>
       <p><strong>Таблица 2.2</strong>. Возвращаемые значения <code>getopt_long()</code></p>
       <table>
        <tr align="left">
         <th align="left" valign="top">Возвращаемый код</th>
         <th align="left" valign="top">Значение</th>
        </tr>
        <tr align="left">
         <td align="left" valign="top">0</td>
         <td align="left" valign="top"><code>getopt_long()</code> установила флаг, как указано в таблице длинных опций</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top">1</td>
         <td align="left" valign="top"><code>optarg</code> указывает на простой аргумент командной строки</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top">'?'</td>
         <td align="left" valign="top">Недействительная опция</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top">' '</td>
         <td align="left" valign="top">Отсутствующий аргумент опции</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top">'<emphasis>x</emphasis>'</td>
         <td align="left" valign="top">Символ опции '<emphasis>x</emphasis>'</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top">-1</td>
         <td align="left" valign="top">Конец опций</td>
        </tr>
       </table>
       <empty-line/>
       <p>Наконец, мы улучшим предыдущий пример кода, показав оператор <code>switch</code> полностью:</p>
       <p><code>int do_all, do_help, do_verbose; /* флаговые переменные */</code></p>
       <p><code>char *myfile, *user; /* файл ввода, имя пользователя */</code></p>
       <p><code>struct option longopts[] = {</code></p>
       <p><code> { "all", no_argument, &amp;do_all, 1 },</code></p>
       <p><code> { "file", required_argument, NULL, 'f'},</code></p>
       <p><code> { "help", no_argument, &amp;do_help, 1 },</code></p>
       <p><code> { "verbose", no_argument, &amp;do_verbose, 1 },</code></p>
       <p><code> { "user" , optional_argument, NULL, 'u'},</code></p>
       <p><code> { 0, 0, 0, 0 }</code></p>
       <p><code>};</code></p>
       <p><code>...</code></p>
       <p><code>while((c=getopt_long(argc, argv, ":ahvf:u::W;", longopts, NULL)) != -1) {</code></p>
       <p><code> switch (c) {</code></p>
       <p><code> case 'a':</code></p>
       <p><code>  do_all = 1;</code></p>
       <p><code>  break;</code></p>
       <p><code> case 'f':</code></p>
       <p><code>  myfile = optarg;</code></p>
       <p><code>  break;</code></p>
       <p><code> case 'h':</code></p>
       <p><code>  do_help = 1;</code></p>
       <p><code>  break;</code></p>
       <p><code> case 'u':</code></p>
       <p><code>  if (optarg != NULL)</code></p>
       <p><code>   user = optarg;</code></p>
       <p><code>  else</code></p>
       <p><code>   user = "root";</code></p>
       <p><code>  break;</code></p>
       <p><code> case 'v':</code></p>
       <p><code>  do_verbose = 1;</code></p>
       <p><code>  break;</code></p>
       <p><code> case 0:</code></p>
       <p><code>  /* getopt_long() установил переменную, просто продолжить */</code></p>
       <p><code>  break;</code></p>
       <p><code>#if 0</code></p>
       <p><code> case 1:</code></p>
       <p><code>  /*</code></p>
       <p><code>   * Используйте этот case, если getopt_long() должна</code></p>
       <p><code>   * просмотреть все аргументы. В этом случае добавьте к</code></p>
       <p><code>   * optstring ведущий * символ '-'. Действительный код,</code></p>
       <p><code>   * если он есть, работает здесь.</code></p>
       <p><code>   */</code></p>
       <p><code>  break;</code></p>
       <p><code>#endif</code></p>
       <p><code> case ':': /* отсутствует аргумент опции */</code></p>
       <p><code>  fprintf(stderr, "%s: option '-%c' requires an argument\n",</code></p>
       <p><code>   argv[0], optopt);</code></p>
       <p><code>  break;</code></p>
       <p><code> case '?':</code></p>
       <p><code> default: /* недействительная опция */</code></p>
       <p><code>  fprintf(stderr, "%s: option '-%c' is invalid: ignored\n",</code></p>
       <p><code>   argv[0], optopt);</code></p>
       <p><code>  break;</code></p>
       <p><code> }</code></p>
       <p><code>}</code></p>
       <p>В своих программах вы можете захотеть сделать для каждого символа опции комментарии, объясняющие их значение. Однако, если вы использовали описательные имена переменных для каждого символа опции, комментарии уже не так нужны. (Сравните <code>do_verbose</code> и <code>vflag</code>.)</p>
      </section>
      <section>
       <title>
        <p>2.3.3.4. GNU <code>getopt()</code> или <code>getopt_long()</code> в программах пользователей</p>
       </title>
       <p>Вы можете захотеть использовать в своих программах GNU <code>getopt()</code> или <code>getopt_long()</code> и заставить их работать на не-Linux системах/ Это нормально; просто скопируйте исходные файлы из программы GNU или из CVS архива библиотеки С GNU (GLIBC)<a l:href="#n30" type="note">[30]</a>. Исходные файлы <code>getopt.h</code>, <code>getopt.с</code> и <code>getopt1.c</code>. Они лицензированы на условиях меньшей общедоступной лицензии (Lesser General Public License) GNU, которая позволяет включать библиотечные функции даже в патентованные программы. Вы должны включить в свою программу копию файла <code>COPYING.LIB</code> наряду с файлами <code>getopt.h</code>, <code>getopt.с</code> и <code>getopt1.с</code>.</p>
       <p>Включите исходные файлы в свой дистрибутив и откомпилируйте их с другими исходными файлами. В исходном коде, вызывающем <code>getopt_long()</code>, используйте '<code>#include &lt;getopt.h&gt;</code>', а не '<code>#include "getopt.h"</code>'. Затем, при компилировании, добавьте к командной строке компилятора С <code>-I</code>. Таким способом сначала будет найдена локальная копия заголовочного файла.</p>
       <p>Вы можете поинтересоваться: «Вот так, я уже использую GNU/Linux. Почему я должен включать <code>getopt_long()</code> в свой исполняемый модуль, увеличивая его размер, если процедура уже находится в библиотеке С?» Это хороший вопрос. Однако, здесь не о чем беспокоиться. Исходный код построен так, что если он компилируется на системе, которая использует GLIBC, откомпилированные файлы не будут содержать никакого кода! Вот подтверждение на нашей системе:</p>
       <p><code>$ <strong>uname -а</strong> /* Показать имя и тип системы */</code></p>
       <p><code>Linux example 2.4.18-14 #1 Wed Sep 4 13:35:50 EDT 2002 i686 i686 i386 GNU/Linux</code></p>
       <p><code>$ <strong>ls -l getopt.о getopt1.о</strong> /* Показать размеры файлов */</code></p>
       <p><code>-rw-r--r-- 1 arnold devel 9836 Mar 24 13:55 getopt.о</code></p>
       <p><code>-rw-r--r-- 1 arnold devel 10324 Mar 24 13:55 getopt1.о</code></p>
       <p><code>$ <strong>size getopt.о getopt1.о</strong> /* Показать включенные в исполняемый</code></p>
       <p><code>модуль размеры */</code></p>
       <p><code>text data bss dec hex filename</code></p>
       <p><code>0 0 0 0 0 getopt.о</code></p>
       <p><code>0 0 0 0 0 getopt1.о</code></p>
       <p>Команда <code>size</code> печатает размеры различных составных частей двоичного объекта или исполняемого файла. Мы объясним вывод в разделе 3.1 «Адресное пространство Linux/Unix». Что важно понять прямо сейчас, это то, что несмотря на ненулевой размер самих файлов, они не вносят никакого вклада в конечный исполняемый модуль. (Думаем, это достаточно ясно.)</p>
      </section>
     </section>
    </section>
    <section>
     <title>
      <p>2.4. Переменные окружения</p>
     </title>
     <section>
      <p><emphasis>Окружение</emphasis> представляет собой набор пар вида '<code><emphasis>имя</emphasis>=<emphasis>значение</emphasis></code>' для каждой программы. Эти пары называются <emphasis>переменными окружения</emphasis>. Каждое имя состоит от одной до любого числа буквенно-цифровых символов или символов подчеркивания ('<code>_</code>'), но имя не может начинаться с цифры. (Это правило контролируется оболочкой; С API может помешать в окружение все, что захочет, за счет возможного запутывания последующих программ.)</p>
      <p>Переменные окружения часто используются для управления поведением программ. Например, если в окружении существует <code>POSIXLY_CORRECT</code>, многие программы запрещают расширения или историческое поведение, которые несовместимы со стандартом POSIX.</p>
      <p>Вы можете решить использовать (и должны задокументировать) переменные окружения для управления поведением вашей программы. Например, вы можете вместо аргумента командной строки использовать для опций отладки переменную окружения. Преимуществом использования переменных окружения является то, что пользователи могут установить их в своем загрузочном файле и не беспокоиться больше постоянным набором определенных опций в командной строке.</p>
      <p>Конечно, недостатком использования переменных окружения является то, что они могут молча изменять поведение программы. Джим Мейеринг (Jim Meyering), сопроводитель Coreutils, выразил это таким образом:</p>
      <cite>
       <p>Они упрощают пользователю настройку программы без изменения способа ее вызова. Это может быть как благословением, так и проклятием. Если вы пишете сценарий, который зависит от значения определенной переменной окружения, а затем этот сценарий использует еще кто-то, у кого нет таких же установок окружения, он легко может потерпеть неудачу (или, что еще хуже, молча выдать неверные результаты).</p>
      </cite>
     </section>
     <section>
      <title>
       <p>2.4.1. Функции управления окружением</p>
      </title>
      <p>Несколько функций позволяют получать значения переменных окружения, изменять эти значения или удалять их. Вот соответствующие объявления:</p>
      <p><code>#include &lt;stdlib.h&gt;</code></p>
      <empty-line/>
      <p><code>char *getenv(const char *name);</code></p>
      <p><code>/* ISO С: Получить переменную</code></p>
      <p><code>   окружения */</code></p>
      <p><code>int setenv(const char *name, /* POSIX: Установить переменную */</code></p>
      <p><code>           const char *value, /* окружения */</code></p>
      <p><code>           int overwrite);</code></p>
      <p><code>int putenv(char *string); /* XSI: Установить переменную</code></p>
      <p><code>                             окружения, использует строку */</code></p>
      <p><code>void unsetenv(const char *name); /* POSIX: Удалить переменную</code></p>
      <p><code>                                    окружения */</code></p>
      <p><code>int clearenv(void); /* Общее: очистить все окружение */</code></p>
      <p>Функция <code>getenv()</code> — та, которую вы будете использовать в 99% случаев. Ее аргументом является имя переменной окружения, которую нужно искать, такое, как «<code>НОМЕ</code>» или «<code>PATH</code>». Если переменная существует, <code>getenv()</code> возвращает указатель на строковое значение. Если нет, возвращается <code>NULL</code>. Например:</p>
      <p><code>char *pathval;</code></p>
      <p><code>/* Поиск PATH; если нет, использовать значение</code></p>
      <p><code>   по умолчанию */</code></p>
      <p><code>if ((pathval = getenv("PATH")) == NULL)</code></p>
      <p><code> pathval = "/bin:/usr/bin:/usr/ucb";</code></p>
      <p>Иногда переменная окружения существует, но с пустым значением. В этом случае возвращаемое значение не равно <code>NULL</code>, но первый символ, на которую оно указывает, будет нулевым байтом, который в С является символом конца строки, '<code>\0</code>'. Ваш код должен позаботиться проверить, что возвращаемое значение не равно NULL. Если оно не <code>NULL</code>, необходимо также проверить, что строка не пустая, если вы хотите для чего-то использовать значение переменной. В любом случае, не используйте возвращенное значение слепо.</p>
      <p>Для изменения переменной окружения или добавления к окружению еще одной используется <code>setenv()</code>:</p>
      <p><code>if (setenv("PATH", "/bin:/usr/bin:/usr/ucb", 1) != 0) {</code></p>
      <p><code> /* обработать ошибку */</code></p>
      <p><code>}</code></p>
      <p>Возможно, что переменная уже существует в окружении. Если третий аргумент равен true (не ноль), новое значение затирает старое. В противном случае, предыдущее значение не меняется. Возвращаемое значение равно -1, если для новой переменной не хватило памяти, и 0 в противном случае. <code>setenv()</code> для сохранения в окружении делает индивидуальные копии как имени переменной, так и нового ее значения</p>
      <p>Более простой альтернативой <code>setenv()</code> является <code>putenv()</code>, которая берет одну строку «<code><emphasis>имя</emphasis>=<emphasis>значение</emphasis></code>» и помещает ее в окружение:</p>
      <p><code>if (putenv("PATH=/bin:/usr/bin:/usr/ucb") != 0) {</code></p>
      <p><code> /* обработать ошибку */</code></p>
      <p><code>}</code></p>
      <p><code>putenv()</code> слепо заменяет любые предшествующие значения для той же переменной. А также, и это, возможно, более важно, строка, переданная <code>putenv()</code>, помещается непосредственно в окружение. Это означает, что если ваш код позже изменит эту строку (например, если это был массив, а не строковая константа), окружение также будет изменено. Это, в свою очередь, означает, что вам не следует использовать в качестве параметров для <code>putenv()</code> локальную переменную. По всем этим причинам <code>setenv()</code> является более предпочтительной функцией.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. GNU <code>putenv()</code> имеет дополнительную (документированную) особенность в своем поведении. Если строка аргумента является именем без следующего за ним символа <code>=</code>, именованная переменная удаляется. Программа GNU <code>env</code>, которую мы рассмотрим далее в мой главе, полагается на такое поведение.</p>
      </cite>
      <p>Функция <code>unsetenv()</code> удаляет переменную из окружения:</p>
      <p><code>unsetenv("PATH");</code></p>
      <p>Наконец, функция <code>clearenv()</code> полностью очищает окружение:</p>
      <p><code>if (clearenv() != 0) {</code></p>
      <p><code> /* обработать ошибку */</code></p>
      <p><code>}</code></p>
      <p>Эта функция не стандартизирована POSIX, хотя она доступна в GNU/Linux и нескольких коммерческих вариантах Unix. Ее следует использовать, если приложение должно быть очень безопасным и нужно построить собственное окружение с нуля. Если <code>clearenv()</code> недоступна, в справке GNU/Linux для <emphasis>clearenv</emphasis>(3) рекомендуется использовать для выполнения этой задачи '<code>environ = NULL</code>'.</p>
     </section>
     <section>
      <title>
       <p>2.4.2. Окружение в целом: <code>environ</code></p>
      </title>
      <p>Правильным способом работы с окружением является использование функций, описанных в предыдущем разделе. Однако, стоит взглянуть на то, как это работает «под капотом».</p>
      <p>Внешняя переменная <code>environ</code> предоставляет доступ таким же способом, как <code>argv</code> предоставляет доступ к аргументам командной строки. Вы сами должны объявить переменную. Хотя она и стандартизирована POSIX, <code>environ</code> намеренно не объявлена ни в одном стандартном заголовочном файле (Это, кажется, прослеживается из исторической практики.) Вот объявление:</p>
      <p><code>extern char **environ; /* Смотрите, нет заголовочного файла POSIX */</code></p>
      <p>Как и в <code>argv</code>, завершающим элементом <code>environ</code> является <code>NULL</code>. Однако, здесь нет переменной «числа строк окружения», которая соответствовала бы <code>argc</code>. Следующая простая программа распечатывает все окружение:</p>
      <p><code>/* ch02-printenv.c --- Распечатать окружение. */</code></p>
      <p><code>#include &lt;stdio.h&gt;</code></p>
      <empty-line/>
      <p><code>extern char **environ;</code></p>
      <p><code>int main(int argc, char **argv) {</code></p>
      <p><code> int i;</code></p>
      <p><code> if (environ != NULL)</code></p>
      <p><code>  for (i = 0; environ[i] != NULL; i++)</code></p>
      <p><code>   printf("%s\n", environ[i]);</code></p>
      <p><code> return 0;</code></p>
      <p><code>}</code></p>
      <p>Хотя это и маловероятно, перед попыткой использовать <code>environ</code> эта программа проверяет, что она не равна <code>NULL</code>.</p>
      <p>Переменные хранятся в окружении в случайном порядке. Хотя некоторые оболочки Unix хранят переменные окружения в отсортированном по именам переменных виде, это формально не требуется, и многие оболочки не сортируют их.</p>
      <p>В качестве уловки реализации можно получить доступ к окружению, объявив <emphasis>третий</emphasis> параметр <code>main()</code>:</p>
      <p><code>int main(int argc, char **argv, char **envp) {</code></p>
      <p><code> ...</code></p>
      <p><code>}</code></p>
      <p>Затем можно использовать <code>envp</code> также, как <code>environ</code>. Хотя это иногда можно увидеть в старом коде, мы не рекомендуем такое использование; <code>environ</code> является официальным, стандартным, переносимым способом получения доступа ко всему окружению, если это вам необходимо.</p>
     </section>
     <section>
      <title>
       <p>2.4.3. GNU <code>env</code></p>
      </title>
      <p>Чтобы завершить главу, рассмотрим GNU версию команды <code>env</code>. Эта команда добавляет переменные к окружению в ходе выполнения одной команды. Она может использоваться также для очищения окружения в ходе этой команды или для удаления отдельных переменных окружения. Программа обеспечивает нас двойной функциональностью, поскольку проявляет возможности как <code>getopt_long()</code>, так и несколько других возможностей, обсуждавшихся в этом разделе. Вот как вызывается программа:</p>
      <p><code>$ env --help</code></p>
      <p><code>Usage: env [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]</code></p>
      <p><code>/* Устанавливает соответствующее VALUE для каждого NAME и запускает COMMAND */</code></p>
      <p><code>-i, --ignore-environment /* запустить с пустым окружением */</code></p>
      <p><code>-u, --unset=NAME         /* удалить переменную из окружения */</code></p>
      <p><code>--help                   /* показать этот экран справки и выйти */</code></p>
      <p><code>--version                /* вывести информацию о версии и выйти */</code></p>
      <p><code>/* Простое - предполагает -1. Если не указана COMMAND, отображает</code></p>
      <p><code>   имеющееся окружение.</code></p>
      <p><code>Об ошибках сообщайте в &lt;bug-coreutils@gnu.org&gt;. */</code></p>
      <p>Вот несколько примеров вызовов команды:</p>
      <p><code>$ <strong>env - myprog arg1</strong> /* Очистить окружение, запустить программу с args */</code></p>
      <p><code>$ <strong>env - РАТН=/bin:/usr/bin myprog arg1</strong> /* Очистить окружение, добавить PATH, запустить программу */</code></p>
      <p><code>$ <strong>env -u IFS PATH=/bin:/usr/bin myprog arg1</strong> /* Сбросить IFS, добавить PATH, запустить программу */</code></p>
      <p>Код начинается со стандартной формулировки авторских прав GNU и разъясняющего комментария. Мы для краткости их опустили. (Формулировка авторского права обсуждается в Приложении С «Общедоступная лицензия GNU». Показанного ранее вывода <code>--help</code> достаточно для понимания того, как работает программа.) За объявленным авторским правом и комментарием следуют подключаемые заголовочные файлы и объявления. Вызов макроса '<code>N_("string")</code>' (строка 93) предназначен для использования при локализации программного обеспечения, тема, освещенная в главе 13 «Интернационализация и локализация». Пока вы можете рассматривать его, как содержащий строковую константу.</p>
      <p><code>80  #include &lt;config.h&gt;</code></p>
      <p><code>81  #include &lt;stdio.h&gt;</code></p>
      <p><code>82  #include &lt;getopt.h&gt;</code></p>
      <p><code>83  #include &lt;sys/types.h&gt;</code></p>
      <p><code>84  #include &lt;getopt.h&gt;</code></p>
      <p><code>85</code></p>
      <p><code>86  #include "system.h"</code></p>
      <p><code>87  #include "error.h"</code></p>
      <p><code>88  #include "closeout.h"</code></p>
      <p><code>89</code></p>
      <p><code>90  /* Официальное имя этой программы (напр., нет префикса 'g'). */</code></p>
      <p><code>91  #define PROGRAM_NAME "env"</code></p>
      <p><code>92</code></p>
      <p><code>93  #define AUTHORS N_ ("Richard Mlynarik and David MacKenzie")</code></p>
      <p><code>94</code></p>
      <p><code>95  int putenv();</code></p>
      <p><code>96</code></p>
      <p><code>97  extern char **environ;</code></p>
      <p><code>98</code> </p>
      <p><code>99  /* Имя, посредством которого эта программа была запущена. */</code></p>
      <p><code>100 char *program_name;</code></p>
      <p><code>101</code></p>
      <p><code>102 static struct option const longopts[] =</code></p>
      <p><code>103  {</code></p>
      <p><code>104  {"ignore-environment", no_argument, NULL, 'i'},</code></p>
      <p><code>105  {"unset", required_argument, NULL, 'u'},</code></p>
      <p><code>106  {GETOPT_HELP_OPTION_DECL},</code></p>
      <p><code>107  {GETOPT_VERSION_OPTION_DECL},</code></p>
      <p><code>108  {NULL, 0, NULL, 0}</code></p>
      <p><code>109 };</code></p>
      <p>GNU Coreutils содержит большое число программ, многие из которых выполняют одни и те же общие задачи (например, анализ аргументов). Для облегчения сопровождения многие типичные идиомы были определены в виде макросов. Двумя таким макросами являются <code>GETOPT_HELP_OPTION_DECL</code> и <code>GETOPT_VERSION_OPTION</code> (строки 106 и 107). Вскоре мы рассмотрим их определения. Первая функция, <code>usage()</code>, выводит информацию об использовании и завершает программу. Макрос <code>_("string")</code> (строка 115, используется также по всей программе) также предназначен для локализации, пока также считайте его содержащим строковую константу.</p>
      <p><code>111 void</code></p>
      <p><code>112 usage(int status)</code></p>
      <p><code>113 {</code></p>
      <p><code>114  if (status '= 0)</code></p>
      <p><code>115   fprintf(stderr, _("Try '%s --help' for more information.\n"),</code></p>
      <p><code>116    program_name);</code></p>
      <p><code>117  else</code></p>
      <p><code>118  {</code></p>
      <p><code>119   printf (_("\</code></p>
      <p><code>120    Usage: %s [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]\n"),</code></p>
      <p><code>121    program_name);</code></p>
      <p><code>122   fputs (_("\</code></p>
      <p><code>123    Set each NAME to VALUE in the environment and run COMMAND. \n\</code></p>
      <p><code>124    \n\</code></p>
      <p><code>125    -i, --ignore-environment start with an empty environment\n\</code></p>
      <p><code>126    -u, --unset=NAME remove variable from the environment\n\</code></p>
      <p><code>127    "), stdout);</code></p>
      <p><code>128   fputs(HELP_OPTION_DESCRIPTION, stdout);</code></p>
      <p><code>129   fputs(VERSION_OPTION_DESCRIPTION, stdout);</code></p>
      <p><code>130   fputs(_("\</code></p>
      <p><code>131    \n\</code></p>
      <p><code>132    A mere - implies -i. If no COMMAND, print the resulting\</code></p>
      <p><code>133    environment.\n"), stdout);</code></p>
      <p><code>134   printf(_("\nReport bugs to &lt;%s&gt;.\n"), PACKAGE_BUGREPORT);</code></p>
      <p><code>135  }</code></p>
      <p><code>136  exit(status);</code></p>
      <p><code>137 }</code></p>
      <p>Первая часть <code>main()</code> объявляет переменные и настраивает локализацию. Функции <code>setlocale()</code>, <code>bindtextdomain()</code> и <code>textdomain()</code> (строки 147–149) обсуждаются в главе 13 «Интернационализация и локализация». Отметим, что эта программа использует аргумент <code>main() envp</code> (строка 140). Это единственная программа Coreutils, которая так делает. Наконец, вызов <code>atexit()</code> в строке 151 (см. раздел 9.1.5.3. «Функции завершения») регистрирует библиотечную функцию Coreutils, которая очищает все выходные буферы и закрывает <code>stdout</code>, выдавая сообщение при ошибке. Следующая часть программы обрабатывает аргументы командной строки, используя <code>getopt_long()</code>.</p>
      <p><code>139 int</code></p>
      <p><code>140 main(register int argc, register char **argv, char **envp)</code></p>
      <p><code>141 {</code></p>
      <p><code>142  char *dummy_environ[1];</code></p>
      <p><code>143  int optc;</code></p>
      <p><code>144  int ignore_environment = 0;</code></p>
      <p><code>145</code></p>
      <p><code>146  program_name = argv[0];</code></p>
      <p><code>147  setlocale(LC_ALL, "");</code></p>
      <p><code>148  bindtextdomain(PACKAGE, LOCALEDIR);</code></p>
      <p><code>149  textdomain(PACKAGE);</code></p>
      <p><code>150</code></p>
      <p><code>151  atexit(close_stdout);</code></p>
      <p><code>152</code></p>
      <p><code>153  while ((optc = getopt_long(argc, argv, "+iu:", longopts, NULL)) != -1)</code></p>
      <p><code>154  {</code></p>
      <p><code>155   switch (optc)</code></p>
      <p><code>156   {</code></p>
      <p><code>157   case 0:</code></p>
      <p><code>158    break;</code></p>
      <p><code>159   case 'i':</code></p>
      <p><code>160    ignore_environment = 1;</code></p>
      <p><code>161    break;</code></p>
      <p><code>162   case 'u':</code></p>
      <p><code>163    break;</code></p>
      <p><code>164   case_GETOPT_HELP_CHAR;</code></p>
      <p><code>165   case_GETOPT_VERSION_CHAR(PROGRAM_NAME, AUTHORS);</code></p>
      <p><code>166   default:</code></p>
      <p><code>167    usage(2);</code></p>
      <p><code>168   }</code></p>
      <p><code>169  }</code></p>
      <p><code>170</code> </p>
      <p><code>171  if (optind != argc &amp;&amp; !strcmp(argv[optind], "-"))</code></p>
      <p><code>172   ignore_environment = 1;</code></p>
      <p>Вот отрывок из файла <code>src/sys2.h</code> в дистрибутиве Coreutils с упомянутыми ранее определениями и макросом '<code>case_GETOPT_xxx</code>', использованным выше (строки 164–165):</p>
      <p><code>/* Вынесение за скобки общей части кода, обрабатывающего --help и</code></p>
      <p><code>   --version. */</code></p>
      <p><code>/* Эти значения перечисления никак не могут конфликтовать со значениями опций,</code></p>
      <p><code>   обычно используемыми командами, включая CHAR_MAX + 1 и т.д. Избегайте</code></p>
      <p><code>   CHAR_MIN - 1, т.к. оно может равняться -1, значение завершения опций getopt.</code></p>
      <p><code>*/</code></p>
      <p><code>enum {</code></p>
      <p><code> GETOPT_HELP_CHAR = (CHAR_MIN — 2),</code></p>
      <p><code> GETOPT_VERSION_CHAR = (CHAR_MIN - 3)</code></p>
      <p><code>};</code></p>
      <p><code>#define GETOPT_HELP_OPTION_DECL \</code></p>
      <p><code> "help", no_argument, 0, GETOPT_HELP_CHAR</code></p>
      <p><code>#define GETOPT_VERSION_OPTION_DECL \</code></p>
      <p><code> "version", no_argument, 0, GETOPT_VERSION_CHAR</code></p>
      <p><code>#define case_GETOPT_HELP_CHAR \</code></p>
      <p><code> case GETOPT_HELP_CHAR: \</code></p>
      <p><code>  usage(EXIT_SUCCESS); \</code></p>
      <p><code>  break;</code></p>
      <p><code>#define case_GETOPT_VERSION_CHAR(Program_name, Authors) \</code></p>
      <p><code> case GETOPT_VERSION_CHAR: \</code></p>
      <p><code>  version_etc(stdout, Program_name, PACKAGE, VERSION, Authors); \</code></p>
      <p><code>  exit(EXIT_SUCCESS); \</code></p>
      <p><code>  break;</code></p>
      <p>Результатом этого кода является печать сообщения об использовании утилиты для <code>--help</code> и печать информации о версии для <code>--version</code>. Обе опции завершаются успешно («Успешный» и «неудачный» статусы завершения описаны в разделе 9.1.5.1 «Определение статуса завершения процесса».) Поскольку в Coreutils входят десятки утилит, имеет смысл вынести за скобки и стандартизовать как можно больше повторяющегося кода.</p>
      <p>Возвращаясь к <code>env.с</code>:</p>
      <p><code>174 environ = dummy_environ;</code></p>
      <p><code>175 environ[0] = NULL;</code></p>
      <p><code>176</code></p>
      <p><code>177 if (!ignore_environment)</code></p>
      <p><code>178  for (; *envp; envp++)</code></p>
      <p><code>179   putenv(*envp);</code></p>
      <p><code>180</code></p>
      <p><code>181 optind = 0; /* Принудительная реинициализация GNU getopt. */</code></p>
      <p><code>182 while ((optc = getopt_long(argc, argv, "+iu:", longopts, NULL)) != -1)</code></p>
      <p><code>183  if (optc == 'u')</code></p>
      <p><code>184   putenv(optarg); /* Требуется GNU putenv. */</code></p>
      <p><code>185</code></p>
      <p><code>186 if (optind !=argc &amp;&amp; !strcmp(argv[optind], "-")) /* Пропустить опции */</code></p>
      <p><code>187  ++optind;</code></p>
      <p><code>188</code></p>
      <p><code>189 while (optind &lt; argc &amp;&amp; strchr(argv[optind], '=')) /* Установить</code></p>
      <p><code>     переменные окружения * /</code></p>
      <p><code>190 putenv(argv[optind++]);</code></p>
      <p><code>191</code></p>
      <p><code>192 /* Если программа не указана, напечатать переменные окружения и выйти. */</code></p>
      <p><code>193 if (optind == argc)</code></p>
      <p><code>194 {</code></p>
      <p><code>195  while (*environ)</code></p>
      <p><code>196   puts (*environ++);</code></p>
      <p><code>197  exit(EXIT_SUCCESS);</code></p>
      <p><code>198 }</code></p>
      <p>Строки 174–179 переносят существующие переменные в новую копию окружения. В глобальную переменную <code>environ</code> помещается указатель на пустой локальный массив. Параметр <code>envp</code> поддерживает доступ к первоначальному окружению.</p>
      <p>Строки 181–184 удаляют переменные окружения, указанные в опции <code>-u</code>. Программа осуществляет это, повторно сканируя командную строку и удаляя перечисленные там имена. Удаление переменных окружения основывается на обсуждавшейся ранее особенности GNU <code>putenv()</code>: при вызове с одним лишь именем переменной (без указанного значения) <code>putenv()</code> удаляет ее из окружения.</p>
      <p>После опций в командной строке помещаются новые или замещающие переменные окружения. Строки 189–190 продолжают сканирование командной строки, отыскивая установки переменных окружения в виде '<code><emphasis>имя</emphasis>=<emphasis>значение</emphasis></code>'.</p>
      <p>По достижении строки 192, если в командной строке ничего не осталось, предполагается, что <code>env</code> печатает новое окружение и выходит из программы. Она это и делает (строки 195–197).</p>
      <p>Если остались аргументы, они представляют имя команды, которую нужно вызвать, и аргументы для передачи этой новой команде. Это делается с помощью системного вызова <code>execvp()</code> (строка 200), который <emphasis>замещает</emphasis> текущую программу новой. (Этот вызов обсуждается в разделе 9.1.4 «Запуск новой программы: семейство <code>exec()</code>»; пока не беспокойтесь о деталях.) Если этот вызов возвращается в текущую программу, он <emphasis>потерпел неудачу</emphasis>. В таком случае <code>env</code> выводит сообщение об ошибке и завершает программу.</p>
      <p><code>200  execvp(argv[optind], &amp;argv[optind]);</code></p>
      <p><code>201</code></p>
      <p><code>202  {</code></p>
      <p><code>203   int exit_status = (errno == ENOENT ? 127 : 126);</code></p>
      <p><code>204   error(0, errno, "%s", argv[optind]);</code></p>
      <p><code>205   exit(exit_status);</code></p>
      <p><code>206  }</code></p>
      <p><code>207 }</code></p>
      <p>Значения кода завершения <code>126</code> и <code>127</code> (определяемые в строке 203) соответствуют стандарту POSIX. <code>127</code> означает, что программа, которую <code>execvp()</code> попыталась запустить, не существует. (<code>ENOENT</code> означает, что файл не содержит записи в каталоге.) <code>126</code> означает, что файл существует, но была какая-то другая ошибка.</p>
     </section>
    </section>
    <section>
     <title>
      <p>2.5. Резюме</p>
     </title>
     <p>• Программы на С получают аргументы своей командной строки через параметры <code>argc</code> и <code>argv</code>. Функция <code>getopt()</code> предоставляет стандартный способ для последовательного разбора опций и их аргументов GNU версия <code>getopt()</code> предоставляет некоторые расширения, a <code>getopt_long()</code> и <code>getopt_long_only()</code> дает возможность легкого разбора длинных опций.</p>
     <p>• Окружение представляет собой набор пар '<code><emphasis>имя</emphasis>=<emphasis>значение</emphasis></code>', который каждая программа наследует от своего родителя. Программы могут по прихоти своего автора использовать для изменения своего поведения переменные окружения, в дополнение к любым аргументам командной строки. Для получения значений переменных окружения, изменения их значений или удаления существуют стандартные процедуры (<code>getenv()</code>, <code>setenv()</code>, <code>putenv()</code> и <code>unsetenv()</code>). При необходимости можно получить доступ ко всему окружению через внешнюю переменную <code>environ</code> или через третий аргумент <code>char **envp</code> функции <code>main()</code>. Последний способ не рекомендуется.</p>
    </section>
    <section>
     <title>
      <p>Упражнения</p>
     </title>
     <p>1. Предположим, что программа принимает опции <code>-a</code>, <code>-b</code> и <code>-с</code>, и что <code>-b</code> требует наличия аргумента. Напишите для этой программы код ручного разбора аргументов без использования <code>getopt()</code> или <code>getopt_long()</code>. Для завершения обработки опций принимается <code>--</code>. Убедитесь, что -ас работает, также, как <code>-bYANKEES</code>, <code>-b YANKEES</code> и <code>-abYANKEES</code>. Протестируйте программу.</p>
     <p>2. Реализуйте <code>getopt()</code>. Для первой версии вы можете не беспокоиться насчет случая '<code>optstring[0] == ':'</code>'. Можете также игнорировать <code>opterr</code>.</p>
     <p>3. Добавьте код для '<code>optstring[0] == ':'</code>' и <code>opterr</code> к своей версии <code>getopt()</code>.</p>
     <p>4. Распечатайте и прочтите файлы GNU <code>getopt.h</code>, <code>getopt.с</code> и <code>getopt1.с</code>.</p>
     <p>5. Напишите программу, которая объявляет как <code>environ</code>, так и <code>envp</code>, и сравните их значения.</p>
     <p>6. Разбор аргументов командной строки и опций является тем колесом, которое многие люди не могут не изобретать вновь. Вы можете захотеть познакомиться с различными анализирующими аргументы пакетами, помимо <code>getopt()</code> и <code>getopt_long()</code>, такими, как:</p>
     <p> • библиотека анализа аргументов <emphasis>Plan 9 From Bell Labs arg(2)</emphasis><a l:href="#n31" type="note">[31]</a>,</p>
     <p> • Argp<a l:href="#n32" type="note">[32]</a>,</p>
     <p> • Argv<a l:href="#n33" type="note">[33]</a>,</p>
     <p> • Autoopts<a l:href="#n34" type="note">[34]</a>,</p>
     <p> • GNU Gengetopt<a l:href="#n35" type="note">[35]</a>,</p>
     <p> • Opt<a l:href="#n36" type="note">[36]</a>,</p>
     <p> • Popt<a l:href="#n37" type="note">[37]</a>. См. также справочную страницу <emphasis>popt</emphasis>(3) системы GNU/Linux.</p>
     <p>7. Дополнительный балл, почему компилятор С не может полностью игнорировать ключевое слово register? Подсказка: какие действия невозможно совершать с регистровой переменной?</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 3</p>
     <p>Управление памятью на уровне пользователя</p>
    </title>
    <section>
     <p>Без памяти для хранения данных программа не может выполнить никакую работу (Или, скорее, невозможно выполнить никакую <emphasis>полезную</emphasis> работу.) Реальные программы не могут позволить себе полагаться на буферы и массивы структур данных фиксированного размера. Они должны быть способны обрабатывать вводимые данные различных размеров, от незначительных до больших. Это, в свою очередь, ведет к использованию <emphasis>динамически выделяемой памяти</emphasis> — памяти, выделяемой в ходе исполнения, а не при компиляции. Вот как вводится в действие принцип GNU «никаких произвольных ограничений».</p>
     <p>Поскольку динамически выделяемая память является основным строительным блоком для реальных программ, мы рассмотрим этот вопрос в начале, до рассмотрения всего остального. Наше обсуждение фокусируется на рассмотрении процесса и его памяти исключительно на уровне пользователя; оно не имеет ничего общего с архитектурой процессора.</p>
    </section>
    <section>
     <title>
      <p>3.1. Адресное пространство Linux/Unix</p>
     </title>
     <p>В качестве рабочего определения мы приняли, что процесс является запушенной программой. Это означает, что операционная система загрузила исполняемый файл для этой программы в память, сделала доступными аргументы командной строки и переменные окружения и запустила ее. Процесс имеет пять выделенных для него концептуально различных областей памяти:</p>
     <p><emphasis>Код</emphasis></p>
     <p>Часто называемая <emphasis>сегментом текста</emphasis> область, в которой находятся исполняемые инструкции. Linux и Unix организуют вещи таким образом, что несколько запушенных экземпляров одной программы по возможности разделяют свой код; в любое время в памяти находится лишь одна копия инструкций одной и той же программы (Это прозрачно для работающих программ.) Часть исполняемого файла, содержащая сегмент текста, называется секцией текста.</p>
     <p><emphasis>Инициализированные данные</emphasis></p>
     <p>Статически выделенные и глобальные данные, которые инициализированы ненулевыми значениями, находятся в <emphasis>сегменте данных</emphasis>. У каждого процесса с одной и той же запущенной программой свой собственный сегмент данных. Часть исполняемого файла, содержащая сегмент данных, является <emphasis>секцией данных</emphasis>.</p>
     <p><emphasis>Инициализированные нулями данные</emphasis><a l:href="#n38" type="note">[38]</a></p>
     <p>Глобальные и статически выделенные данные, которые по умолчанию инициализированы нулями, хранятся в области процесса, который называют областью <emphasis>BSS</emphasis><a l:href="#n39" type="note">[39]</a>. У каждого процесса, в котором запущена одна и та же программа, своя область BSS. При запуске данные BSS помещаются в сегмент данных. В исполняемом файле они хранятся в <emphasis>секции BSS</emphasis>.</p>
     <p>Формат исполняемого файла Linux/Unix таков, что пространство исполняемого файла на диске занимают лишь переменные, инициализированные ненулевыми значениями. Поэтому большой массив, объявленный как '<code>static char somebuf[2048];</code>', который автоматически заполняется нулями, не занимает 2 Кб пространства на диске. (Некоторые компиляторы имеют опции, позволяющие вам помещать инициализированные нулями данные в сегмент данных.)</p>
     <p><emphasis>Куча (heap)</emphasis></p>
     <p><emphasis>Куча</emphasis> является местом, откуда выделяется динамическая память (получаемая с помощью функции <code>malloc()</code> и подобными ей). Когда из кучи выделяется память, адресное пространство процесса растет, что вы можете заметить, отслеживая запущенный процесс с помощью команды <code>ps</code>.</p>
     <p>Хотя память можно вернуть обратно системе и сократить адресное пространство процесса, этого почти никогда не происходит. (Мы различаем освобождение больше не использующейся динамической памяти и сокращение адресного пространства; подробнее это обсуждается далее в этой главе.)</p>
     <p>Для кучи характерен «рост вверх». Это означает, что последовательные элементы, добавляемые к куче, добавляются по адресам, численно превосходящим предыдущие. Куча обычно начинается сразу после области BSS сегмента данных.</p>
     <p><emphasis>Стек</emphasis></p>
     <p><emphasis>Сегмент стека</emphasis> — это область, в которой выделяются локальные переменные. Локальными являются все переменные, объявленные внутри левой открывающей фигурной скобки тела функции (или другой левой фигурной скобки) и не имеющие ключевого слова <code>static</code>.</p>
     <p>В большинстве архитектур параметры функций также помещаются в стек наряду с «невидимой» учетной информацией, генерируемой компилятором, такой, как возвращаемое функцией значение и адрес возврата для перехода из функции к месту, откуда произошел вызов. (В некоторых архитектурах для этого используются регистры.) Именно использование стека для параметров функций и возвращаемых ими значений делает удобным написание <emphasis>рекурсивных</emphasis> функций (тех, которые вызывают сами себя) Переменные, хранящиеся в стеке, «исчезают», когда функция, их содержащая, возвращается, пространство стека используется повторно для последующих вызовов функций. В большинстве современных архитектур стек «растет вниз», это означает, что элементы, находящиеся глубже в цепи вызова, находятся по численно меньшим адресам. В работающей программе области инициализированных данных, BSS и кучи обычно размещаются в единой протяженной области: сегменте данных. Сегменты стека и кода отделены от сегмента данных и друг от друга. Это показано на рис. 3.1.</p>
     <image l:href="#img_3.png"/>
     <p><strong>Рис. 3.1</strong>. Адресное пространство Linux/Unix</p>
     <p>Хотя перекрывание стека и кучи теоретически возможно, операционная система предотвращает этот случай, и любая программа, пытающаяся это сделать, напрашивается на неприятности. Это особенно верно для современных систем, в которых адресные пространства большие и интервал между верхушкой стека и концом кучи значителен. Различные области памяти могут иметь различную установленную на память аппаратную защиту. Например, сегмент текста может быть помечен «только для исполнения», тогда как у сегментов данных и стека разрешение на исполнение может отсутствовать. Такая практика может предотвратить различные виды атак на безопасность. Подробности, конечно, специфичны для оборудования и операционной системы, и они могут со временем меняться. Стоит заметить, что стандартные как С, так и C++ позволяют размещать элементы с атрибутом <code>const</code> в памяти только для чтения. Сводка взаимоотношений различных сегментов приведена в табл. 3.1.</p>
     <empty-line/>
     <p><strong>Таблица 3.1</strong>. Сегменты исполняемой программы и их размещение</p>
     <table>
      <tr align="left">
       <th align="left" valign="top">Память программы</th>
       <th align="left" valign="top">Сегмент адресного пространства</th>
       <th align="left" valign="top">Секция исполняемого файла</th>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Код</td>
       <td align="left" valign="top">Text</td>
       <td align="left" valign="top">Text</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Инициализированные данные</td>
       <td align="left" valign="top">Data</td>
       <td align="left" valign="top">Data</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">BSS</td>
       <td align="left" valign="top">Data</td>
       <td align="left" valign="top">BSS</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Куча</td>
       <td align="left" valign="top">Data</td>
       <td align="left" valign="top"/>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Стек</td>
       <td align="left" valign="top">Stack</td>
       <td align="left" valign="top"/>
      </tr>
     </table>
     <p>Программа <code>size</code> распечатывает размеры в байтах каждой из секций text, data и BSS вместе с общим размером в десятичном и шестнадцатеричном виде. (Программа <code>ch03-memaddr.с</code> показана далее в этой главе; см. раздел 3.2.5 «Исследование адресного пространства».)</p>
     <p><code>$ <strong>cc -o ch03-memaddr.с -о ch03-memaddr</strong> /* Компилировать программу */</code></p>
     <p><code>$ <strong>ls -l ch03-memaddr</strong> /* Показать общий размер */</code></p>
     <p><code>-rwxr-xr-x 1 arnold devel 12320 Nov 24 16:45 ch03-memaddr</code></p>
     <p><code>$ <strong>size ch03-memaddr</strong> /* Показать размеры компонентов */</code></p>
     <p><code>text data bss dec  hex filename</code></p>
     <p><code>1458 276  8   1742 6ce ch03-memaddr</code></p>
     <empty-line/>
     <p><code>$ <strong>strip ch03-memaddr</strong> /* Удалить символы */</code></p>
     <p><code>$ <strong>ls -l ch03-memaddr</strong> /* Снова показать общий размер */</code></p>
     <p><code>-rwxr-xr-x 1 arnold devel 3480 Nov 24 16:45 ch03-memaddr</code></p>
     <p><code>$ <strong>size ch03-memaddr</strong> /* Размеры компонентов не изменились */</code></p>
     <p><code>text data bss dec  hex filename</code></p>
     <p><code>1458 276  8   1742 6ce ch03-memaddr</code></p>
     <p>Общий размер загруженного в память из файла в 12 320 байтов всего лишь 1742 байта. Большую часть этого места занимают <emphasis>символы (symbols)</emphasis>, список имен переменных и функций программы. (Символы не загружаются в память при запуске программы.) Программа <code>strip</code> удаляет символы из объектного файла. Для большой программы это может сохранить значительное дисковое пространство ценой невозможности отладки дампа ядра<a l:href="#n40" type="note">[40]</a>, если таковой появится (На современных системах об этом не стоит беспокоиться, не используйте <code>strip</code>.) Даже после удаления символов файл все еще больше, чем загруженный в память образ, поскольку формат объектного файла содержат дополнительные данные о программе, такие, как использованные разделяемые библиотеки, если они есть.<a l:href="#n41" type="note">[41]</a></p>
     <p>Наконец, упомянем <emphasis>потоки (threads)</emphasis>, которые представляют несколько цепочек исполнения в рамках <emphasis>единственного</emphasis> адресного пространства. Обычно у каждого потока имеется свой собственный стек, а также способ получения <emphasis>локальных данных потока</emphasis>, т.е. динамически выделяемых данных для персонального использования этим потоком. Мы больше не будем рассматривать в данной книге потоки, поскольку это является продвинутой темой.</p>
    </section>
    <section>
     <title>
      <p>3.2. Выделение памяти</p>
     </title>
     <section>
      <p>Четыре библиотечные функции образуют основу управления динамической памятью С Мы опишем сначала их, затем последуют описания двух системных вызовов, поверх которых построены эти библиотечные функции. Библиотечные функции С, в свою очередь, обычно используются для реализации других выделяющих память библиотечных функций и операторов C++ <code>new</code> и <code>delete</code>.</p>
      <p>Наконец, мы обсудим функцию, которую часто используют, но которую мы не рекомендуем использовать.</p>
     </section>
     <section>
      <title>
       <p>3.2.1. Библиотечные вызовы: <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code>, <code>free()</code></p>
      </title>
      <section>
       <p>Динамическую память выделяют с помощью функций <code>malloc()</code> или <code>calloc()</code>. Эти функции возвращают указатели на выделенную память. Когда у вас есть блок памяти определенного первоначального размера, вы можете изменить его размер с помощью функции <code>realloc()</code>. Динамическая память освобождается функцией <code>free()</code>.</p>
       <p>Отладка использования динамической памяти сама по себе является важной темой. Инструменты для этой цели мы обсудим в разделе 15.5.2 «Отладчики выделения памяти».</p>
      </section>
      <section>
       <title>
        <p>3.2.1.1. Исследование подробностей на языке С</p>
       </title>
       <p>Вот объявления функций из темы справки GNU/Linux <emphasis>malloc</emphasis>(3):</p>
       <p><code>#include &lt;stdlib.h&gt; /* ISO С */</code></p>
       <empty-line/>
       <p><code>void *calloc(size_t nmemb, size_t size);</code></p>
       <p><code> /* Выделить и инициализировать нулями */</code></p>
       <p><code>void *malloc(size_t size);</code></p>
       <p><code> /* Выделить без инициализации */</code></p>
       <p><code>void free(void *ptr);</code></p>
       <p><code> /* Освободить память */</code></p>
       <p><code>void *realloc(void *ptr, size_t size);</code></p>
       <p><code> /* Изменить размер выделенной памяти */</code></p>
       <p>Функции выделения памяти возвращают тип <code>void*</code>. Это бестиповый или общий указатель, все, что с ним можно делать — это привести его к другому типу и назначить типизированному указателю. Примеры впереди.</p>
       <p>Тип <code>size_t</code> является беззнаковым целым типом, который представляет размер памяти. Он используется для динамического выделения памяти, и далее в книге мы увидим множество примеров его использования. На большинстве современных систем <code>size</code>_t является <code>unsigned long</code>, но лучше явно использовать <code>size_t</code> вместо простого целого типа <code>unsigned</code>.</p>
       <p>Тип <code>ptrdiff_t</code> используется для вычисления адреса в арифметике указателей, как в случае вычисления указателя в массиве:</p>
       <p><code>#define MAXBUF ...</code></p>
       <p><code>char *p;</code></p>
       <p><code>char buf[MAXBUF];</code></p>
       <p><code>ptrdiff_t where;</code></p>
       <empty-line/>
       <p><code>p = buf;</code></p>
       <p><code>while (/* некоторое условие */) {</code></p>
       <p><code> ...</code></p>
       <p><code> p += something;</code></p>
       <p><code> ...</code></p>
       <p><code> where = p - buf; /* какой у нас индекс? */</code></p>
       <p><code>}</code></p>
       <p>Заголовочный файл <code>&lt;stdlib.h&gt;</code> объявляет множество стандартных библиотечных функций С и типов (таких, как <code>size_t</code>), он определяет также константу препроцессора <code>NULL</code>, которая представляет «нуль» или недействительный указатель. (Это нулевое значение, такое, как 0 или '<code>((void*)0)</code>'. Явное использование 0 относится к стилю С++; в С, однако, <code>NULL</code> является предпочтительным, мы находим его гораздо более читабельным для кода С.)</p>
      </section>
      <section>
       <title>
        <p>3.2.1.2. Начальное выделение памяти: <code>malloc()</code></p>
       </title>
       <p>Сначала память выделяется с помощью <code>malloc()</code>. Передаваемое функции значение является общим числом затребованных байтов. Возвращаемое значение является указателем на вновь выделенную область памяти или <code>NULL</code>, если память выделить невозможно. В последнем случае для обозначения ошибки будет установлен <code>errno</code>. (errno является специальной переменной, которую системные вызовы и библиотечные функции устанавливают для указания произошедшей ошибки. Она описывается в разделе 4.3 «Определение ошибок».) Например, предположим, что мы хотим выделить переменное число некоторых структур. Код выглядит примерно так:</p>
       <p><code>struct coord { /* 3D координаты */</code></p>
       <p><code> int x, y, z;</code></p>
       <p><code>} *coordinates;</code></p>
       <p><code>unsigned int count; /* сколько нам нужно */</code></p>
       <p><code>size_t amount; /* общий размер памяти */</code></p>
       <p><code>/* ... как-нибудь определить нужное число... */</code></p>
       <p><code>amount = count * sizeof(struct coord); /* сколько байт выделить */</code></p>
       <p><code>coordinates = (struct coord*)malloc(amount); /* выделить память */</code></p>
       <p><code>if (coordinates == NULL) {</code></p>
       <p><code> /* сообщить об ошибке, восстановить или прервать */</code></p>
       <p><code>}</code></p>
       <p><code>/* ... использовать координаты... */</code></p>
       <p>Представленные здесь шаги являются стереотипными. Порядок следующий:</p>
       <p>1. Объявить указатель соответствующего типа для выделенной памяти.</p>
       <p>2. Вычислить размер выделяемой памяти в байтах. Для этого нужно умножить число нужных объектов на размер каждого из них. Последний получается с помощью оператора С <code>sizeof</code>, который для этой цели и существует (наряду с другими). Таким образом, хотя размер определенной структуры среди различных компиляторов и архитектур может различаться, <code>sizeof</code> всегда возвращает верное значение, а исходный код остается правильным и переносимым.</p>
       <p>При выделении массивов для строк символов или других данных типа <code>char</code> нет необходимости умножения на <code>sizeof(char)</code>, поскольку последнее по определению всегда равно 1. Но в любом случае это не повредит.</p>
       <p>3. Выделить память с помощью <code>malloc()</code>, присвоив возвращаемое функцией значение переменной указателя. Хорошей практикой является приведение возвращаемого <code>malloc()</code> значения к типу переменной, которой это значение присваивается. В С этого не требуется (хотя компилятор может выдать предупреждение). Мы настоятельно рекомендуем всегда приводить возвращаемое значение.</p>
       <p>Обратите внимание, что на C++ присвоение знамения указателя одного типа указателю другого типа требует приведения типов, какой бы ни был контекст. Для управления динамической памятью программы C++ должны использовать <code>new</code> и <code>delete</code>, а не <code>malloc()</code> и <code>free()</code>, чтобы избежать проблем с типами.</p>
       <p>4. Проверить возвращенное значение. <emphasis>Никогда</emphasis> не предполагайте, что выделение памяти было успешным. Если выделение памяти завершилось неудачей, <code>malloc()</code> возвращает <code>NULL</code>. Если вы используете значение без проверки, ваша программа может быть немедленно завершена из-за <emphasis>нарушения сегментации (segmentation violation)</emphasis>, которое является попыткой использования памяти за пределами своего адресного пространства.</p>
       <p>Если вы проверите возвращенное значение, вы можете по крайней мере выдать диагностическое сообщение и корректно завершить программу. Или можете попытаться использовать какой-нибудь другой способ восстановления.</p>
       <p>Выделив блок памяти и установив в <code>coordinates</code> указатель на него, мы можем затем интерпретировать <code>coordinates</code> как массив, хотя он в действительности указатель:</p>
       <p><code>int cur_x, cur_y, cur_z;</code></p>
       <p><code>size_t an_index;</code></p>
       <p><code>an_index = something;</code></p>
       <p><code>cur_x = coordinates[an_index].x;</code></p>
       <p><code>cur_y = coordinates[an_index].y;</code></p>
       <p><code>cur_z = coordinates[an_index].z;</code></p>
       <p>Компилятор создает корректный код для индексирования через указатель при получении доступа к членам структуры <code>coordinates[an_index]</code>.</p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. Блок памяти, возвращенный <code>malloc()</code>, не инициализирован. Он может содержать любой случайный мусор. Необходимо сразу же инициализировать память нужными значениями или хотя бы нулями. В последнем случае используйте функцию <code>memset()</code> (которая обсуждается в разделе 12.2 «Низкоуровневая память, функции <code>memXXX()</code>):</p>
        <p><code>memset(coordinates, '\0', amount);</code></p>
        <p>Другой возможностью является использование <code>calloc()</code>, которая вскоре будет описана.</p>
       </cite>
       <p>Джефф Колье (Geoff Collyer) рекомендует следующую методику для выделения памяти:</p>
       <p><code>some_type *pointer;</code></p>
       <p><code>pointer = malloc(count * sizeof(*pointer));</code></p>
       <p>Этот подход гарантирует, что <code>malloc()</code> выделит правильное количество памяти без необходимости смотреть объявление pointer. Если тип <code>pointer</code> впоследствии изменится, оператор <code>sizeof</code> автоматически гарантирует, что выделяемое число байтов остается правильным. (Методика Джеффа опускает приведение типов, которое мы только что обсуждали. Наличие там приведения типов также гарантирует диагностику, если тип <code>pointer</code> изменится, а вызов <code>malloc()</code> не будет обновлен.)</p>
      </section>
      <section>
       <title>
        <p>3.2.1.3. Освобождение памяти: <code>free()</code></p>
       </title>
       <p>Когда вы завершили использование памяти, «верните ее обратно», используя функцию <code>free()</code>. Единственный аргумент является указателем, предварительно полученным с использованием другой функции выделения. Можно (хотя это бесполезно) передать функции <code>free()</code> пустой указатель:</p>
       <p><code>free(coordinates);</code></p>
       <p><code>coordinates = NULL; /* не требуется, но хорошая мысль */</code></p>
       <p>После вызова f<code>ree(coordinates)</code> доступ к памяти, на которую указывает <code>coordinates</code>, <emphasis>запрещен</emphasis>. Она теперь «принадлежит» процедурам выделения, и они могут поступать с ней как сочтут нужным. Они могут изменить содержимое памяти или даже удалить ее из адресного пространства процесса! Таким образом, есть несколько типичных ошибок, которых нужно остерегаться при использовании <code>free()</code>:</p>
       <p><emphasis>Доступ к освобожденной памяти</emphasis></p>
       <p>Если она не была освобождена, переменная <code>coordinates</code> продолжает указывать на блок памяти, который больше не принадлежит приложению. Это называется <emphasis>зависшим указателем (dangling pointer)</emphasis>. На многих системах вы можете уйти от наказания, продолжая использовать эту память, по крайней мере до следующего выделения или освобождения памяти. На других системах, однако, такой доступ не будет работать. В общем, доступ к освобожденной памяти является плохой мыслью: это непереносимо и ненадежно, и <emphasis>GNU Coding Standards</emphasis> отвергает его. По этой причине неплохо сразу же установить в указателе программы значение <code>NULL</code>. Если затем вы случайно попытаетесь получить доступ к освобожденной памяти, программа немедленно завершится с ошибкой нарушения сегментации (надеемся, до того, как вы успели вашу программу выпустить в свет).</p>
       <p><emphasis>Освобождение одного и того же указателя дважды</emphasis></p>
       <p>Это создает «неопределенное поведение». После передачи блока памяти обратно выделяющим процедурам они могут объединить освобожденный блок с другой свободной памятью, которая есть в их распоряжении. Освобождение чего-то уже освобожденного ведет к неразберихе и в лучшем случае к крушению; известно, что так называемые двойные освобождения приводили к проблемам безопасности.</p>
       <p><emphasis>Передача указателя, полученного не от функций</emphasis> <code><emphasis>malloc()</emphasis></code><emphasis>,</emphasis> <code><emphasis>calloc()</emphasis></code> <emphasis>или</emphasis> <code><emphasis>realloc()</emphasis></code></p>
       <p>Это кажется очевидным, но тем не менее важно. Плоха даже передача указателя на адрес где-то в середине динамически выделенной памяти:</p>
       <p><code>free(coordinates + 10);</code></p>
       <p><code>/* Освободить все кроме первых 10 элементов */</code></p>
       <p>Этот вызов не будет работать и, возможно, приведет к пагубным последствиям, таким как крушение. (Это происходит потому, что во многих реализациях <code>malloc()</code> «учетная» информация хранится перед возвращенными данными. Когда <code>free()</code> пытается использовать эту информацию, она обнаружит там недействительные данные. В других реализациях, где учетная информация хранится в конце выделенного блока; возникают те же проблемы.)</p>
       <p><emphasis>Выход за пределы буфера</emphasis></p>
       <p>Доступ к памяти за пределами выделенного блока также ведет к неопределенному поведению, опять из-за того, что она может содержать учетную информацию или, возможно, вообще не принадлежать адресному пространству процесса. Запись в такой участок памяти гораздо хуже, поскольку это может уничтожить учетные данные.</p>
       <p><emphasis>Отказ в освобождении памяти</emphasis></p>
       <p>Любая динамическая память, которая больше не нужна, должна быть освобождена. В частности, необходимо тщательно управлять памятью и освобождать ее, когда она выделяется внутри циклов или рекурсивных или глубоко вложенных вызовов функций. Отказ от этого ведет к <emphasis>утечкам памяти</emphasis>, при которых память процесса может неограниченно расти; в конце концов, процесс завершается из-за нехватки памяти. Эта ситуация может быть особенно разрушительной, если память выделяется для ввода записи или как-то еще связана с вводом: утечка памяти будет незаметна при использовании незначительных объемов ввода, но внезапно станет очевидной (и приведет в замешательство) при больших. Эта ошибка еще хуже для систем, которые должны работать непрерывно, как в системах телефонных коммутаторов. Утечка памяти, вызывающая крушение такой системы, может привести к значительным денежным или другим потерям.</p>
       <p>Даже если программа никогда не завершается из-за недостатка памяти, постоянно увеличивающиеся программы теряют производительность, поскольку операционная система должна сохранять использующиеся данные в физической памяти. В худшем случае, это может привести к поведению, известному как <emphasis>пробуксовка (thrashing)</emphasis>, при которой операционная система так занята перекачкой содержимого адресного пространства в и из физической памяти, что реальная работа не делается.</p>
       <p>Хотя <code>free()</code> может вернуть освобожденную память системе и сократить адресное пространство процесса, это почти никогда не делается. Вместо этого освобожденная память готова для нового выделения при следующем вызове <code>malloc()</code>, <code>calloc()</code> или <code>realloc()</code>.</p>
       <p>При условии, что освобожденная память продолжает оставаться в адресном пространстве процесса, стоит обнулить ее перед освобождением. Например, такой способ может оказаться предпочтительным для программ с повышенными требованиями к безопасности.</p>
       <p>Обсуждение ряда полезных инструментов для отладки динамической памяти см в разделе 15.5.2 «Отладчики выделения памяти».</p>
      </section>
      <section>
       <title>
        <p>3.2.1.4. Изменение размера: <code>realloc()</code></p>
       </title>
       <p>Динамическая память имеет существенное преимущество перед статически объявленными массивами, поскольку это позволяет использовать столько памяти, сколько нужно, и не больше. Не нужно объявлять глобальный, статический или локальный массив фиксированного размера и надеяться, что он: (а) достаточно большой и (б) не слишком большой. Вместо этого можно выделить ровно столько, сколько нужно, не больше и не меньше.</p>
       <p>Вдобавок, можно изменять размер динамически выделенной области памяти. Хотя можно сократить размер блока памяти, обычно его увеличивают. Изменение размера осуществляется с помощью <code>realloc()</code>. Продолжая пример с <code>coordinates</code>, типичный код выглядит следующим образом:</p>
       <p><code>int new_count;</code></p>
       <p><code>size_t new_amount;</code></p>
       <p><code>struct coord *newcoords; /* установить, например: */</code></p>
       <p><code>new_count = count * 2; /* удвоить размер памяти */</code></p>
       <p><code>new_amount = new_count * sizeof(struct coord);</code></p>
       <p><code>newcoords =</code></p>
       <p><code> (struct coord*)realloc(coordinates, new_amount);</code></p>
       <p><code>if (newcoords == NULL) {</code></p>
       <p><code> /* сообщить об ошибке, восстановить или прервать */</code></p>
       <p><code>}</code></p>
       <p><code>coordinates = newcoords;</code></p>
       <p><code>/* продолжить использование coordinates ... */</code></p>
       <p>Как и в случае с <code>malloc()</code>, шаги стереотипны по природе и сходны по идее.</p>
       <p>1. Вычислить новый выделяемый размер в байтах.</p>
       <p>2. Вызвать <code>realloc()</code> с оригинальным указателем, полученным от <code>malloc()</code> (или от <code>calloc()</code> или предыдущего вызова <code>realloc()</code>) и с новым размером.</p>
       <p>3. Привести тип и присвоить возвращенное <code>realloc()</code> значение. Подробнее обсудим дальше.</p>
       <p>4. Как и для <code>malloc()</code>, <emphasis>проверить</emphasis> возвращенное значение, чтобы убедиться, что оно не равно NULL. Вызов любой функции выделения памяти может завершиться неудачей.</p>
       <p>При увеличении размера блока памяти <code>realloc()</code> часто выделяет новый блок нужного размера, копирует данные из старого блока в новый и возвращает указатель уже на новый блок. При сокращении размера блока данных <code>realloc()</code> часто обновляет внутреннюю учетную информацию и возвращает тот же указатель. Это избавляет от необходимости копировать первоначальные данные. Однако, если это случится, <emphasis>не думайте, что можно использовать память за пределами нового размера</emphasis>!</p>
       <p>В любом случае вы можете предположить, что если <code>realloc()</code> не возвращает <code>NULL</code>, старые данные были скопированы для вас в новый участок памяти. Более того, старый указатель больше недействителен, как если бы вы вызвали <code>free()</code> с ним, и использовать его больше не следует. Это верно для всех указателей на этот блок данных, а не только для того, который использовался при вызове <code>free()</code>.</p>
       <p>Возможно, вы заметили, что в нашем примере для указания на измененный блок памяти использовалась отдельная переменная. Можно было бы (хотя это плохая идея) использовать ту же самую переменную, как здесь:</p>
       <p><code>coordinates = realloc(coordinates, new_amount);</code></p>
       <p>Это плохо по следующей причине. Когда <code>realloc()</code> возвращает <code>NULL</code>, первоначальный указатель все еще действителен; можно безопасно продолжить использовать эту память. Но если вы повторно используете ту же самую переменную и <code>realloc()</code> возвращает <code>NULL</code>, вы <emphasis>теряете</emphasis> указатель на первоначальную память. Эту память больше нельзя использовать. Что еще важнее, эту память невозможно освободить! Это создает утечку памяти, которую нужно избежать.</p>
       <p>Для версии <code>realloc()</code> в стандартном С есть некоторые особые случаи: когда аргумент <code>ptr</code> равен <code>NULL</code>, <code>realloc()</code> действует подобно <code>malloc()</code> и выделяет свежий блок памяти. Когда аргумент <code>size</code> равен 0, <code>realloc()</code> действует подобно <code>free()</code> и <emphasis>освобождает</emphasis> память, на которую указывает <code>ptr</code>. Поскольку (а) это может сбивать с толку и (б) более старые системы не реализуют эту возможность, мы рекомендуем использовать <code>malloc()</code>, когда вы имеете в виду <code>malloc()</code>, и <code>free()</code>, когда вы имеете в виду <code>free()</code>.</p>
       <p>Вот другой довольно тонкий момент<a l:href="#n42" type="note">[42]</a>. Рассмотрим процедуру, которая содержит статический указатель на динамически выделяемые данные, которые время от времени должны расти. Процедура может содержать также автоматические (т.е. локальные) указатели на эти данные. (Для краткости, мы опустим проверки ошибок. В коде продукта не делайте этого.) Например:</p>
       <p><code>void manage_table(void) {</code></p>
       <p><code> static struct table *table;</code></p>
       <p><code> struct table *cur, *p;</code></p>
       <p><code> int i;</code></p>
       <p><code> size_t count;</code></p>
       <p><code> ...</code></p>
       <p><code> table =</code></p>
       <p><code>  (struct table*)malloc(count * sizeof(struct table));</code></p>
       <p><code> /* заполнить таблицу */</code></p>
       <p><code> cur = &amp;table[i]; /* указатель на 1-й элемент */</code></p>
       <p><code> ...</code></p>
       <p><code> cur-&gt;i = j; /* использование указателя */</code></p>
       <p><code> ...</code></p>
       <p><code> if (/* некоторое условие */) {</code></p>
       <p><code>  /* нужно увеличить таблицу */</code></p>
       <p><code>  count += count/2;</code></p>
       <p><code>  p =</code></p>
       <p><code>  (struct table*)realloc(table, count * sizeof(struct table));</code></p>
       <p><code>  table = p;</code></p>
       <p><code> }</code></p>
       <p><code> cur-&gt;i = j; /* ПРОБЛЕМА 1: обновление элемента таблицы */</code></p>
       <p><code> other_routine(); /* ПРОБЛЕМА 2: см. текст */</code></p>
       <p><code> cur-&gt;j = k; /* ПРОБЛЕМА 2: см. текст */</code></p>
       <p><code> ...</code></p>
       <p><code>}</code></p>
       <p>Это выглядит просто; <code>manage_table()</code> размешает данные, использует их, изменяет размер и т.д. Но есть кое-какие проблемы, которые не выходят за рамки страницы (или экрана), когда вы смотрите на этот код.</p>
       <p>В строке, помеченной '<code>ПРОБЛЕМА 1</code>', указатель cur используется для обновления элемента таблицы. Однако, <code>cur</code> был инициализирован начальным значением <code>table</code>. Если некоторое условие верно и <code>realloc()</code> вернула другой блок памяти, <code>cur</code> теперь указывает на первоначальный, освобожденный участок памяти! Каждый раз, когда <code>table</code> меняется, нужно обновить также все указатели на этот участок памяти. Здесь после вызова <code>realloc()</code> и переназначения <code>table</code> недостает строки '<code>cur = &amp;table[i];</code>'.</p>
       <p>Две строки, помеченные '<code>ПРОБЛЕМА 2</code>', еще более тонкие. В частности, предположим, что <code>other_routine()</code> делает рекурсивный вызов <code>manage_table()</code>. Переменная <code>table</code> снова может быть изменена совершенно незаметно! После возвращения из <code>other_routine()</code> значение cur может снова стать недействительным.</p>
       <p>Можно подумать (что мы вначале и сделали), что единственным решением является знать это и добавить после вызова функции переназначение <code>cur</code> с соответствующим комментарием. Однако, Брайан Керниган (Brian Kernighan) любезно нас поправил. Если мы используем индексирование, проблема поддержки указателя даже не возникает:</p>
       <p><code>table =</code></p>
       <p><code> (struct table*)malloc(count * sizeof(struct table));</code></p>
       <p><code>...</code></p>
       <p><code>/* заполнить таблицу */</code></p>
       <p><code>...</code></p>
       <p><code>table[i].i = j; /* Обновить член i-го элемента */</code></p>
       <p><code>...</code></p>
       <p><code>if (/* некоторое условие */) {</code></p>
       <p><code> /* нужно увеличить таблицу */</code></p>
       <p><code> count += count/2;</code></p>
       <p><code> p =</code></p>
       <p><code>  (struct table*)realloc(table, count * sizeof(struct table));</code></p>
       <p><code> table = p;</code></p>
       <p><code>}</code></p>
       <p><code>table[i].i = j; /* ПРОБЛЕМА 1 устраняется */</code></p>
       <p><code>other_routine();</code></p>
       <p><code>/* Рекурсивный вызов, модифицирует таблицу */</code></p>
       <p><code>table[i].j = k; /* ПРОБЛЕМА 2 также устраняется */</code></p>
       <p>Использование индексирования не решает проблему, если вы используете <emphasis>глобальную</emphasis> копию первоначального указателя на выделенные данные; в этом случае, вам все равно нужно побеспокоиться об обновлении своих глобальных структур после вызова <code>realloc()</code>.</p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. Как и в случае с <code>malloc()</code>, когда вы увеличиваете размер памяти, вновь выделенная после <code>realloc()</code> память не инициализируется нулями. Вы сами при необходимости должны очистить память с помощью <code>memset()</code>, поскольку <code>realloc()</code> лишь выделяет новую память и больше ничего не делает.</p>
       </cite>
      </section>
      <section>
       <title>
        <p>3.2.1.5. Выделение с инициализацией нулями: <code>calloc()</code></p>
       </title>
       <p>Функция <code>calloc()</code> является простой оболочкой вокруг <code>malloc()</code>. Главным ее преимуществом является то, что она обнуляет динамически выделенную память. Она также вычисляет за вас размер памяти, принимая в качестве параметра число элементов и размер каждого элемента:</p>
       <p><code>coordinates = (struct coord*)calloc(count, sizeof(struct coord));</code></p>
       <p>По крайней мере идейно, код <code>calloc()</code> довольно простой. Вот одна из возможных реализаций:</p>
       <p><code>void *calloc(size_t nmemb, size_t size) {</code></p>
       <p><code> void *p;</code></p>
       <p><code> size_t total;</code></p>
       <p><code> total = nmemb * size;   /* Вычислить размер */</code></p>
       <p><code> p = malloc(total);      /* Выделить память */</code></p>
       <p><code> if (p != NULL)          /* Если это сработало - */</code></p>
       <p><code> memset(p, '\0', total); /* Заполнить ее нулями */</code></p>
       <p><code> return p; /* Возвращаемое значение NULL или указатель */</code></p>
       <p><code>}</code></p>
       <p>Многие опытные программисты предпочитают использовать <code>calloc()</code>, поскольку в этом случае никогда не возникает вопросов по поводу вновь выделенной памяти.</p>
       <p>Если вы знаете, что вам понадобится инициализированная нулями память, следует также использовать <code>calloc()</code>, поскольку возможно, что память, возвращенная <code>malloc()</code>, уже заполнена нулями. Хотя вы, программист, не можете этого знать, <code>calloc()</code> может это знать и избежать лишнего вызова <code>memset()</code>.</p>
      </section>
      <section>
       <title>
        <p>3.2.1.6. Подведение итогов из GNU Coding Standards</p>
       </title>
       <p>Чтобы подвести итоги, процитируем, что говорит об использовании процедур выделения памяти <emphasis>GNU Coding Standards</emphasis>:</p>
       <cite>
        <p>Проверяйте каждый вызов <code>malloc</code> или <code>realloc</code> на предмет возвращенного нуля. Проверяйте <code>realloc</code> даже в том случае, если вы уменьшаете размер блока; в системе, которая округляет размеры блока до степени двойки, <code>realloc</code> может получить другой блок, если вы запрашиваете меньше памяти.</p>
        <p>В Unix <code>realloc</code> может разрушить блок памяти, если она возвращает ноль. GNU <code>realloc</code> не содержит подобной ошибки: если она завершается неудачей, исходный блок остается без изменений. Считайте, что ошибка устранена. Если вы хотите запустить свою программу на Unix и хотите избежать потерь в этом случае, вы можете использовать GNU <code>malloc</code>.</p>
        <p>Вы должны считать, что <code>free</code> изменяет содержимое освобожденного блока. Все, что вы хотите получить из блока, вы должны получать до вызова <code>free</code>.</p>
       </cite>
       <p>В этих трех коротких абзацах Ричард Столмен (Richard Stallman) выразил суть важных принципов управления динамической памятью с помощью <code>malloc()</code>. Именно использование динамической памяти и принцип «никаких произвольных ограничений» делают программы GNU такими устойчивыми и более работоспособными по сравнению с их Unix-двойниками.</p>
       <p>Мы хотим подчеркнуть, что стандарт С требует, чтобы <code>realloc()</code> <emphasis>не</emphasis> разрушал оригинальный блок памяти, если она возвращает <code>NULL</code>.</p>
      </section>
      <section>
       <title>
        <p>3.2.1.7. Использование персональных программ распределения</p>
       </title>
       <p>Набор функций с <code>malloc()</code> является набором общего назначения по выделению памяти. Он должен быть способен обработать запросы на произвольно большие или маленькие размеры памяти и осуществлять все необходимые учетные действия при освобождении различных участков выделенной памяти. Если ваша программа выделяет значительную динамическую память, вы можете обнаружить, что она тратит большую часть своего времени в функциях <code>malloc()</code>.</p>
       <p>Вы можете написать <emphasis>персональную программу распределения</emphasis> — набор функций или макросов, которые выделяют большие участки памяти с помощью <code>malloc()</code>, а затем дробят их на маленькие кусочки по одному за раз. Эта методика особенно полезна, если вы выделяете множество отдельных экземпляров одной и той же сравнительно небольшой структуры.</p>
       <p>Например, GNU awk (gawk) использует эту методику. Выдержка из файла <code>awk.h</code> в дистрибутиве <code>gawk</code> (слегка отредактировано, чтобы уместилось на странице):</p>
       <p><code>#define getnode(n) if (nextfree) n = nextfree, \</code></p>
       <p><code> nextfree = nextfree-&gt;nextp; else n = more_nodes()</code></p>
       <p><code>#define freenode(n) ((n)-&gt;flags = 0, (n)-&gt;exec_count = 0,\</code></p>
       <p><code> (n)-&gt;nextp = nextfree, nextfree = (n))</code></p>
       <p>Переменная <code>nextfree</code> указывает на связанный список структур NODE. Макрос <code>getnode()</code> убирает из списка первую структуру, если она там есть. В противном случае она вызывает <code>more_nodes()</code>, чтобы выделить новый список свободных структур <code>NODE</code>. Макрос <code>freenode()</code> освобождает структуру <code>NODE</code>, помещая его в начало списка.</p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. Первоначально при написании своего приложения делайте это простым способом: непосредственно используйте <code>malloc()</code> и <code>free()</code>. Написание собственного распределителя вы должны рассмотреть лишь в том и только в том случае, если профилирование вашей программы покажет, что она значительную часть времени проводит в функциях выделения памяти.</p>
       </cite>
      </section>
      <section>
       <title>
        <p>3.2.1.8. Пример: чтение строк произвольной длины</p>
       </title>
       <p>Поскольку это, в конце концов, <emphasis>Программирование на Linux в примерах</emphasis>, настало время для примера из реальной жизни. Следующий код является функцией <code>readline()</code> из GNU Make 3.80 (<code>ftp://ftp.gnu.org/gnu/make/make-3.80.tar.gz</code>). Ее можно найти в файле <code>read.c</code>.</p>
       <p>Следуя принципу «никаких произвольных ограничений», строки в <code>Makefile</code> могут быть любой длины. Поэтому главной задачей этой процедуры является чтение строк произвольной длины и гарантирование того, что они помещаются в используемый буфер.</p>
       <p>Вторичной задачей является распоряжение продлением строк. Как и в С, строки, заканчивающиеся обратным слешем, логически продолжаются со следующей строки. Используется стратегия поддержания буфера. В нем хранится столько строк, сколько помещается в буфер, причем указатели отслеживают начало буфера, текущую строку и следующую строку. Вот структура:</p>
       <p><code>struct ebuffer {</code></p>
       <p><code> char *buffer;      /* Начало текущей строки в буфере. */</code></p>
       <p><code> char *bufnext;     /* Начало следующей строки в буфере. */</code></p>
       <p><code> char *bufstart;    /* Начало всего буфера. */</code></p>
       <p><code> unsigned int size; /* Размер буфера для malloc. */</code></p>
       <p><code> FILE *fp;          /* Файл или NULL, если это внутренний буфер. */</code></p>
       <p><code> struct floc floc;  /* Информация о файле в fp (если он есть). */</code></p>
       <p><code>};</code></p>
       <p>Поле <code>size</code> отслеживает размер всего буфера, a <code>fp</code> является указателем типа <code>FILE</code> для файла ввода. Структура floc не представляет интереса при изучении процедуры.</p>
       <p>Функция возвращает число строк в буфере. (Номера строк здесь даны относительно начала функции, а не исходного файла.)</p>
       <p><code>1  static long</code></p>
       <p><code>2  readline(ebuf) /* static long readline(struct ebuffer *ebuf) */</code></p>
       <p><code>3  struct ebuffer *ebuf;</code></p>
       <p><code>4  {</code></p>
       <p><code>5   char *p;</code></p>
       <p><code>6   char *end;</code></p>
       <p><code>7   char *start;</code></p>
       <p><code>8   long nlines = 0;</code></p>
       <p><code>9</code></p>
       <p><code>10  /* Использование строковых буферов и буферов потоков достаточно</code></p>
       <p><code>11     различается, чтобы использовать разные функции. */</code></p>
       <p><code>12</code></p>
       <p><code>13  if (!ebuf-&gt;fp)</code></p>
       <p><code>14   return readstring(ebuf);</code></p>
       <p><code>15</code></p>
       <p><code>16  /* При чтении из файла для каждой новой строки мы всегда</code></p>
       <p><code>17     начинаем с начала буфера. */</code></p>
       <p><code>18</code></p>
       <p><code>19  p = start = ebuf-&gt;bufstart;</code></p>
       <p><code>20  end = p + ebuf-&gt;size;</code></p>
       <p><code>21  *p = '\0';</code></p>
       <p>Для начала заметим, что GNU Make написан на С K&amp;R для максимальной переносимости. В исходной части объявляются переменные, и если ввод осуществляется из строки (как в случае расширения макроса), код вызывает другую функцию, <code>readstring()</code> (строки 13 и 14). Строка '<code>!ebuf-&gt;fp</code>' (строка 13) является более короткой (и менее понятной, по нашему мнению) проверкой на пустой указатель; это то же самое, что и '<code>ebuf-&gt;fp==NULL</code>'.</p>
       <p>Строки 19-21 инициализируют указатели и вводят байт NUL, который является символом завершения строки С в конце буфера. Затем функция входит в цикл (строки 23–95), который продолжается до завершения всего ввода.</p>
       <p><code>23 while (fgets(p, end - р, ebuf-&gt;fp) != 0)</code></p>
       <p><code>24 {</code></p>
       <p><code>25  char *p2;</code></p>
       <p><code>26  unsigned long len;</code></p>
       <p><code>27  int backslash;</code></p>
       <p><code>28</code></p>
       <p><code>29  len = strlen(p);</code></p>
       <p><code>30  if (len == 0)</code></p>
       <p><code>31  {</code></p>
       <p><code>32   /* Это случается лишь тогда, когда первый символ строки '\0'.</code></p>
       <p><code>33      Это довольно безнадежный случай, но (верите или нет) ляп Афины</code></p>
       <p><code>34      бьет снова! (xmkmf помещает NUL в свои makefile.)</code></p>
       <p><code>35      Здесь на самом деле нечего делать; мы создаем новую строку, чтобы</code></p>
       <p><code>36      следующая строка не была частью данной строки. */</code></p>
       <p><code>37   error (&amp;ebuf-&gt;floc,</code></p>
       <p><code>38    _("warning: NUL character seen; rest of line ignored"));</code></p>
       <p><code>39   p[0] = '\n';</code></p>
       <p><code>40   len = l;</code></p>
       <p><code>41  }</code></p>
       <p>Функция <code>fgets()</code> (строка 23) принимает указатель на буфер, количество байтов для прочтения и переменную <code>FILE*</code> для файла, из которого осуществляется чтение. Она читает на один байт меньше указанного, чтобы можно было завершить буфер символом '<code>\0</code>'. Эта функция подходит, поскольку она позволяет избежать переполнения буфера. Она прекращает чтение, когда встречается с символами конца строки или конца файла; если это символ новой строки, он помещается в буфер. Функция возвращает <code>NULL</code> при неудаче или значение указателя первого аргумента при успешном завершении.</p>
       <p>В этом случае аргументами являются указатель на свободную область буфера, размер оставшейся части буфера и указатель <code>FILE</code> для чтения.</p>
       <p>Комментарии в строках 32–36 очевидны; если встречается нулевой байт, программа выводит сообщение об ошибке и представляет вывод как пустую строку. После компенсирования нулевого байта (строки 30–41) код продолжает работу.</p>
       <p><code>43 /* Обойти только что прочитанный текст. */</code></p>
       <p><code>44 p += len;</code></p>
       <p><code>45</code></p>
       <p><code>46 /* Если последний символ - не конец строки, она не поместилась</code></p>
       <p><code>47    целиком в буфер. Увеличить буфер и попытаться снова. */</code></p>
       <p><code>48 if (p[-1] != '\n')</code></p>
       <p><code>49  goto more_buffer;</code></p>
       <p><code>50</code></p>
       <p><code>51 /* Мы получили новую строку, увеличить число строк. */</code></p>
       <p><code>52 ++nlines;</code></p>
       <p>Строки 43–52 увеличивают указатель на участок буфера за только что прочитанными данными. Затем код проверяет, является ли последний прочитанный символ символом конца строки. Конструкция <code>p[-1]</code> (строка 48) проверяет символ перед p, также как <code>p[0]</code> является текущим символом, а <code>p[1]</code> — следующим. Сначала это кажется странным, но если вы переведете это на язык математики указателей, <code>*(p-1)</code>, это приобретет больший смысл, а индексированная форма, возможно, проще для чтения.</p>
       <p>Если последний символ не был символом конца строки, это означает, что нам не хватило места, и код выходит (с помощью <code>goto</code>) для увеличения размера буфера (строка 49). В противном случае увеличивается число строк.</p>
       <p><code>54 #if !defined(WINDOWS32) &amp;&amp; !defined(__MSDOS__)</code></p>
       <p><code>55 /* Проверить, что строка завершилась CRLF; если так,</code></p>
       <p><code>56    игнорировать CR. */</code></p>
       <p><code>57 if ((p - start) &gt; 1 &amp;&amp; p[-2] == '\r')</code></p>
       <p><code>58 {</code></p>
       <p><code>59  --p;</code></p>
       <p><code>60  p[-1] = '\n';</code></p>
       <p><code>61 }</code></p>
       <p><code>62 #endif</code></p>
       <p>Строки 54–62 обрабатывают вводимые строки, следующие соглашению Microsoft по завершению строк комбинацией символов возврата каретки и перевода строки (CR-LF), а не просто символом перевода строки (новой строки), который является соглашением Linux/Unix. Обратите внимание, что <code>#ifdef</code> <emphasis>исключает</emphasis> этот код на платформе Microsoft, очевидно, библиотека <code>&lt;stdio.h&gt;</code> на этих системах автоматически осуществляет это преобразование. Это верно также для других не-Unix систем, поддерживающих стандартный С.</p>
       <p><code>64  backslash = 0;</code></p>
       <p><code>65  for (p2 = p - 2; p2 &gt;= start; --p2)</code></p>
       <p><code>66  {</code></p>
       <p><code>67   if (*p2 != '\\')</code></p>
       <p><code>68   break;</code></p>
       <p><code>69   backslash = !backslash;</code></p>
       <p><code>70  }</code></p>
       <p><code>71</code></p>
       <p><code>72  if (!backslash)</code></p>
       <p><code>73  {</code></p>
       <p><code>74   p[-1] = '\0';</code></p>
       <p><code>75   break;</code></p>
       <p><code>76  }</code></p>
       <p><code>77</code></p>
       <p><code>78  /* Это была комбинация обратный слеш/новая строка. Если есть</code></p>
       <p><code>79     место, прочесть еще одну строку. */</code></p>
       <p><code>80  if (end - p &gt;= 80)</code></p>
       <p><code>81   continue;</code></p>
       <p><code>82</code></p>
       <p><code>83  /* В конце буфера нужно больше места, поэтому выделить еще.</code></p>
       <p><code>84     Позаботиться о сохранении текущего смещения в p. */</code></p>
       <p><code>85 more_buffer:</code></p>
       <p><code>86  {</code></p>
       <p><code>87   unsigned long off = p - start;</code></p>
       <p><code>88   ebuf-&gt;size *= 2;</code></p>
       <p><code>89   start = ebuf-&gt;buffer=ebuf-&gt;bufstart=(char*)xrealloc(start,</code></p>
       <p><code>90    ebuf-&gt;size);</code></p>
       <p><code>91   p = start + off;</code></p>
       <p><code>92   end = start + ebuf-&gt;size;</code></p>
       <p><code>93   *p = '\0';</code></p>
       <p><code>94  }</code></p>
       <p><code>95 }</code></p>
       <p>До сих пор мы имели дело с механизмом получения в буфер по крайней мере одной полной строки. Следующий участок обрабатывает случай строки с продолжением. Хотя он должен гарантировать, что конечный символ обратного слеша не является частью нескольких обратных слешей в конце строки. Код проверяет, является ли общее число таких символов четным или нечетным путем простого переключения переменной <code>backslash</code> из 0 в 1 и обратно. (Строки 64–70.)</p>
       <p>Если число четное, условие '<code>!backshlash</code>' (строка 72) будет истинным. В этом случае конечный символ конца строки замещается байтом NUL, и код выходит из цикла.</p>
       <p>С другой стороны, если число нечетно, строка содержит четное число пар обратных слешей (представляющих символы \\, как в С), и конечную комбинацию символов обратного слеша и конца строки.<a l:href="#n43" type="note">[43]</a> В этом случае, если в буфере остались по крайней мере 80 свободных байтов, программа продолжает чтение в цикле следующей строки (строки 78–81). (Использование магического числа 80 не очень здорово; было бы лучше определить и использовать макроподстановку.)</p>
       <p>По достижении строки 83 программе нужно больше места в буфере. Именно здесь вступает в игру динамическое управление памятью. Обратите внимание на комментарий относительно сохранения значения <code>p</code> (строки 83-84); мы обсуждали это ранее в терминах повторной инициализации указателей для динамической памяти. Значение end также устанавливается повторно. Строка 89 изменяет размер памяти.</p>
       <p>Обратите внимание, что здесь вызывается функция <code>xrealloc()</code>. Многие программы GNU используют вместо <code>malloc()</code> и <code>realloc()</code> функции-оболочки, которые автоматически выводят сообщение об ошибке и завершают программу, когда стандартные процедуры возвращают <code>NULL</code>. Такая функция-оболочка может выглядеть таким образом:</p>
       <p><code>extern const char *myname; /* установлено в main() */</code></p>
       <empty-line/>
       <p><code>void *xrealloc(void *ptr, size_t amount) {</code></p>
       <p><code> void *p = realloc(ptr, amount);</code></p>
       <p><code> if (p == NULL) {</code></p>
       <p><code>  fprintf(stderr, "%s: out of memory!\n", myname);</code></p>
       <p><code>  exit(1);</code></p>
       <p><code> }</code></p>
       <p><code> return p;</code></p>
       <p><code>}</code></p>
       <p>Таким образом, если функция <code>xrealloc()</code> возвращается, она гарантированно возвращает действительный указатель. (Эта стратегия соответствует принципу «проверки каждого вызова на ошибки», избегая в то же время беспорядка в коде, который происходит при таких проверках с непосредственным использованием стандартных процедур.) Вдобавок, это позволяет эффективно использовать конструкцию '<code>ptr = xrealloc(ptr, new_size)</code>', против которой мы предостерегали ранее.</p>
       <p>Обратите внимание, что не всегда подходит использование такой оболочки. Если вы сами хотите обработать ошибки, не следует использовать оболочку. С другой стороны, если нехватка памяти всегда является фатальной ошибкой, такая оболочка вполне удобна.</p>
       <p><code>97   if (ferror(ebuf-&gt;fp))</code></p>
       <p><code>98    pfatal_with_name(ebuf-&gt;floc.filenm);</code></p>
       <p><code>99</code></p>
       <p><code>100  /* Если обнаружено несколько строк, возвратить их число.</code></p>
       <p><code>101     Если не несколько, но _что-то_ нашли, значит, прочитана</code></p>
       <p><code>102     последняя строка файла без завершающего символа конца</code></p>
       <p><code>103     строки; вернуть 1. Если ничего не прочитано, это EOF;</code></p>
       <p><code>104     возвратить -1. */</code></p>
       <p><code>105  return nlines ? nlines : p == ebuf-&gt;bufstart ? -1 : 1;</code></p>
       <p><code>106 }</code></p>
       <p>В заключение, функция <code>readline()</code> проверяет ошибки ввода/вывода, а затем возвращает описательное значение. Функция <code>pfatal_with_name()</code> (строка 98) не возвращается.<a l:href="#n44" type="note">[44]</a></p>
      </section>
      <section>
       <title>
        <p>3.2.1.9. Только GLIBC: чтение целых строк: <code>getline()</code> и <code>getdelim()</code></p>
       </title>
       <p>Теперь, когда вы увидели, как читать строки произвольной длины, вы можете сделать вздох облегчения, что вам не нужно самим писать такую функцию. GLIBC предоставляет вам для этого две функции:</p>
       <p><code>#define _GNU_SOURCE 1 /* GLIBC */</code></p>
       <p><code>#include &lt;stdio.h&gt;</code></p>
       <p><code>#include &lt;sys/types.h&gt; /* для ssize_t */</code></p>
       <empty-line/>
       <p><code>ssize_t getline(char **lineptr, size_t *n, FILE *stream);</code></p>
       <p><code>ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream);</code></p>
       <p>Определение константы <code>_GNU_SOURCE</code> вводит объявления функций <code>getline()</code> и <code>getdelim()</code>. В противном случае они неявно объявлены как возвращающие <code>int</code>. Для объявления возвращаемого типа <code>ssize_t</code> нужен файл <code>&lt;sys/types.h&gt;</code>. (<code>ssize_t</code> является «знаковым <code>size_t</code>». Он предназначен для такого же использования, что и <code>size_t</code>, но в местах, где может понадобиться использование также и отрицательных значений.)</p>
       <p>Обе функции управляют для вас динамической памятью, гарантируя, что буфер, содержащий входную строку, достаточно большой для размещения всей строки. Их отличие друг от друга в том, что <code>getline()</code> читает до символа конца строки, a <code>getdelim()</code> использует в качестве разделителя символ, предоставленный пользователем. Общие аргументы следующие:</p>
       <p><code>char **lineptr</code></p>
       <p>Указатель на <code>char*</code> указатель для адреса динамически выделенного буфера. Чтобы <code>getline()</code> сделала всю работу, он должен быть инициализирован <code>NULL</code>. В противном случае, он должен указывать на область памяти, выделенную с помощью <code>malloc()</code>.</p>
       <p><code>size_t *n</code></p>
       <p>Указатель на размер буфера. Если вы выделяете свой собственный буфер, <code>*n</code> должно содержать размер буфера. Обе функции обновляют <code>*n</code> новым значением размера буфера, если они его изменяют.</p>
       <p><code>FILE* stream</code></p>
       <p>Место, откуда следует получать входные символы.</p>
       <p>По достижении конца файла или при ошибке функция возвращает -1. Строки содержат завершающий символ конца строки или разделитель (если он есть), а также завершающий нулевой байт. Использование <code>getline()</code> просто, как показано в <code>ch03-getline.с</code>:</p>
       <p><code>/* ch03-getline.c --- демонстрация getline(). */</code></p>
       <p><code>#define _GNU_SOURCE 1</code></p>
       <p><code>#include &lt;stdio.h&gt;</code></p>
       <p><code>#include &lt;sys/types.h&gt;</code></p>
       <empty-line/>
       <p><code>/* main - прочесть строку и отобразить ее, пока не достигнут EOF */</code></p>
       <p><code>int main(void) {</code></p>
       <p><code> char *line = NULL;</code></p>
       <p><code> size_t size = 0;</code></p>
       <p><code> ssize_t ret;</code></p>
       <p><code> while ((ret = getline(&amp;line, &amp;size, stdin)) != -1)</code></p>
       <p><code>  printf("(%lu) %s", size, line);</code></p>
       <p><code> return 0;</code></p>
       <p><code>}</code></p>
       <p>Вот эта функция в действии, показывающая размер буфера. Третья входная и выходная строки намеренно длинные, чтобы заставить <code>getline()</code> увеличить размер буфера:</p>
       <p><code>$ <strong>ch03-getline</strong> /* Запустить программу */</code></p>
       <p><code><strong>this is a line</strong></code></p>
       <p><code>(120) this is a line</code></p>
       <p><code><strong>And another line.</strong></code></p>
       <p><code>(120) And another line.</code></p>
       <p><code><strong>A llllllllllllllllloooooooooooooooooooooooooooooooonnnnnnnnnnnnnnnngnnnggggggggggg llliiiiiiiiiiiiiiiiiiinnnnnnnnnnnnnnnnnnnneeeeeeeeee</strong></code></p>
       <p><code>(240) A llllllllllllllllloooooooooooooooooooooooooooooooonnnnnnnnnnnnnnnngnnnggggggggggg llliiiiiiiiiiiiiiiiiiinnnnnnnnnnnnnnnnnnnneeeeeeeeee</code></p>
      </section>
     </section>
     <section>
      <title>
       <p>3.2.2. Копирование строк: <code>strdup()</code></p>
      </title>
      <p>Одной чрезвычайно типичной операцией является выделение памяти для копирования строки. Это настолько типично, что многие программисты предусматривают для нее простую функцию вместо использования внутритекстового кодирования, и часто эта функция называется <code>strdup()</code>:</p>
      <p><code>#include &lt;string.h&gt;</code></p>
      <empty-line/>
      <p><code>/* strdup --- выделить память с malloc() и скопировать строку */</code></p>
      <p><code>char *strdup(const char *str) {</code></p>
      <p><code> size_t len;</code></p>
      <p><code> char *copy;</code></p>
      <p><code> len = strlen(str) + 1;</code></p>
      <p><code> /* включить место для завершающего '\0' */</code></p>
      <p><code> copy = malloc(len);</code></p>
      <p><code> if (copy != NULL) strcpy(copy, str);</code></p>
      <p><code> return copy; /* при ошибке возвращает NULL */</code></p>
      <p><code>}</code></p>
      <p>С появлением стандарта POSIX 2001 программисты по всему миру могут вздохнуть свободнее: эта функция является теперь частью POSIX в виде расширения XSI:</p>
      <p><code>#include &lt;string.h&gt; /* XSI */</code></p>
      <empty-line/>
      <p><code>char *strdup(const char *str); /* Копировать str */</code></p>
      <p>Возвращаемое значение равно <code>NULL</code>, если была ошибка, или указатель на динамически выделенную память с копией <code>str</code>. Возвращенное значение должно быть освобождено с помощью <code>free()</code>, когда больше не требуется.</p>
     </section>
     <section>
      <title>
       <p>3.2.3. Системные вызовы: <code>brk()</code> и <code>sbrk()</code></p>
      </title>
      <p>Четыре функции, которые мы рассмотрели (<code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code> и <code>free()</code>) являются стандартными, переносимыми функциями для управления динамической памятью.</p>
      <p>На Unix-системах стандартные функции реализованы поверх двух дополнительных, очень примитивных процедур, которые непосредственно изменяют размер адресного пространства процесса. Мы представляем их здесь, чтобы помочь вам понять, как работают GNU/Linux и Unix (снова «под капотом»); крайне маловероятно, что вам когда-нибудь понадобится использовать эти функции в обычных программах. Они определены следующим образом:</p>
      <p><code>#include &lt;unistd.h&gt; /* Обычный */</code></p>
      <p><code>#include &lt;malloc.h&gt; /* Необходим для систем GLIBC 2 */</code></p>
      <empty-line/>
      <p><code>int brk(void *end_data_segment);</code></p>
      <p><code>void *sbrk(ptrdiff_t increment);</code></p>
      <p>Системный вызов <code>brk()</code> действительно изменяет адресное пространство процесса. Адрес является указателем, представляющим окончание сегмента данных (на самом деле, области кучи, как было показано ранее на рис. 3.1). Ее аргумент является абсолютным логическим адресом, представляющим новое окончание адресного пространства. В случае успеха функция возвращает 0, а в случае неуспеха (-1).</p>
      <p>Функцию <code>sbrk()</code> использовать проще; ее аргумент является числом байтов, на которое нужно увеличить адресное пространство. Вызвав ее с приращением 0, можно определить, где в настоящее время заканчивается адресное пространство. Таким образом, чтобы увеличить адресное пространство на 32 байта, используется код следующего вида:</p>
      <p><code>char *p = (char*)sbrk(0); /* получить текущий конец адресного</code></p>
      <p><code>                             пространства */</code></p>
      <p><code>if (brk(p + 32) &lt; 0) {</code></p>
      <p><code> /* обработать ошибку */</code></p>
      <p><code>}</code></p>
      <p><code>/* в противном случае, изменение сработало */</code></p>
      <p>Практически, вам не нужно непосредственно использовать <code>brk()</code>. Вместо этого используется исключительно <code>sbrk()</code> для увеличения (или даже сокращения) адресного пространства. (Вскоре мы покажем, как это делать, в разделе 3.2.5. «Исследование адресного пространства».)</p>
      <p>Еще более практично вообще <emphasis>никогда</emphasis> не использовать эти процедуры. Программа, которая их использует, не может затем использовать также и <code>malloc()</code>, и это создает большую проблему, поскольку многие элементы стандартной библиотеки полагаются на использование <code>malloc()</code>. Поэтому использование <code>brk()</code> или <code>sbrk()</code> может приводить к трудно обнаруживаемым крушениям программы.</p>
      <p>Но знать о низкоуровневых механизмах стоит, и конечно же, набор функций <code>malloc()</code> реализован с помощью <code>sbrk()</code> и <code>brk()</code>.</p>
     </section>
     <section>
      <title>
       <p>3.2.4. Вызовы ленивых программистов: <code>alloca()</code></p>
      </title>
      <epigraph>
       <p>«Опасность, Билл Робинсон! Опасность!»</p>
       <text-author>- Робот -</text-author>
      </epigraph>
      <p>Есть еще одна дополнительная функция выделения памяти, о которой вам нужно знать. Мы обсуждаем ее лишь для того, чтобы вы поняли ее, когда увидите, но не следует использовать ее в новых программах! Эта функция называется <code>alloca()</code>; она объявлена следующим образом:</p>
      <p><code>/* Заголовок в GNU/Linux, возможно, не на всех Unix-системах */</code></p>
      <p><code>#include &lt;alloca.h&gt; /* Обычный */</code></p>
      <empty-line/>
      <p><code>void *alloca(size_t size);</code></p>
      <p>Функция <code>alloca()</code> выделяет <code>size</code> байтов из <emphasis>стека</emphasis>. Хорошо, что выделенная память исчезает после возвращения из функции. Нет необходимости явным образом освобождать память, поскольку это осуществляется автоматически, как в случае с локальными переменными.</p>
      <p>На первый взгляд, <code>alloca()</code> выглядит чем-то типа панацеи для программистов, можно выделять память, о которой можно вовсе не беспокоиться. Подобно Темной Стороне Силы, это, конечно, привлекает. И подобным же образом этого нужно избегать по следующим причинам:</p>
      <p>• Функция не является стандартной; она не включена ни в какой стандарт, ни в ISO, ни в С или POSIX.</p>
      <p>• Функция не переносима. Хотя она существует на многих системах Unix и GNU/Linux, она не существует на не-Unix системах. Это проблема, поскольку код часто должен быть многоплатформенным, выходя за пределы просто Linux и Unix.</p>
      <p>• На некоторых системах <code>alloca()</code> невозможно даже реализовать. Весь мир не является ни процессором Intel x86, ни GCC.</p>
      <p>• Цитируя справку<a l:href="#n45" type="note">[45]</a> (добавлено выделение): «Функция <code>alloca</code> зависит от машины и от компилятора. <emphasis>На многих системах ее реализация ошибочна.</emphasis> Ее использование не рекомендуется».</p>
      <p>• Снова цитируя справку: «На многих системах <code>alloca</code> не может быть использована внутри списка аргументов вызова функции, поскольку резервируемая в стеке при помощи <code>alloca</code> память оказалась бы в середине стека в пространстве для аргументов функции».</p>
      <p>• Она потворствует неряшливому программированию. Тщательная и корректная работа с памятью не сложна; вам просто нужно подумать о том, что вы делаете, и планировать заранее.</p>
      <p>GCC обычно использует встроенную версию функции, которая действует с использованием внутритекстового (inline) кода. В результате есть другие последствия <code>alloca()</code>. Снова цитируя справку:</p>
      <cite>
       <p>Факт, что код является внутритекстовым (inline), означает, что невозможно получить адрес этой функции или изменить ее поведение путем компоновки с другой библиотекой.</p>
       <p>Внутритекстовый код часто состоит из одной инструкции, подгоняющей указатель стека, и не проверяет переполнение стека. Поэтому нет возврата <code>NULL</code> при ошибке.</p>
      </cite>
      <p>Справочная страница не углубляется в описание проблемы со встроенной <code>alloca()</code> GCC. Если есть переполнение стека, возвращаемое значение является <emphasis>мусором</emphasis>. И у вас нет способа сообщить об этом! Это упущение делает невозможным использование GCC <code>alloca()</code> в устойчивом коде.</p>
      <p>Все это должно убедить вас избегать <code>alloca()</code> в любом новом коде, который вы пишете. В любом случае, если приходится писать переносимый код с использованием <code>malloc()</code> и <code>free()</code>, нет причины в использовании также и <code>alloca()</code>.</p>
     </section>
     <section>
      <title>
       <p>3.2.5. Исследование адресного пространства</p>
      </title>
      <p>Следующая программа, <code>ch03-memaddr.c</code>, подводит итог всему, что мы узнали об адресном пространстве. Она делает множество вещей, которые не следует делать на практике, таких, как вызовы <code>alloca()</code> или непосредственные вызовы <code>brk()</code> и <code>sbrk()</code>.</p>
      <p><code>1  /*</code></p>
      <p><code>2   * ch03-memaddr.с --- Показать адреса секций кода, данных и стека,</code></p>
      <p><code>3   * а также BSS и динамической памяти.</code></p>
      <p><code>4   */</code></p>
      <p><code>5</code></p>
      <p><code>6  #include &lt;stdio.h&gt;</code></p>
      <p><code>7  #include &lt;malloc.h&gt; /* для определения ptrdiff_t в GLIBC */</code></p>
      <p><code>8  #include &lt;unistd.h&gt;</code></p>
      <p><code>9  #include &lt;alloca.h&gt; /* лишь для демонстрации */</code></p>
      <p><code>10</code></p>
      <p><code>11 extern void afunc(void); /* функция, показывающая рост стека */</code></p>
      <p><code>12</code></p>
      <p><code>13 int bss_var; /* автоматически инициализируется в 0, должна быть в BSS */</code></p>
      <p><code>14 int data_var = 42; /* инициализируется в не 0, должна быть</code></p>
      <p><code>15                       в сегменте данных */</code></p>
      <p><code>16 int</code></p>
      <p><code>17 main(int argc, char **argv) /* аргументы не используются */</code></p>
      <p><code>18 {</code></p>
      <p><code>19  char *p, *b, *nb;</code></p>
      <p><code>20</code></p>
      <p><code>21  printf("Text Locations:\n");</code></p>
      <p><code>22  printf("\tAddress of main: %p\n", main);</code></p>
      <p><code>23  printf("\tAddress of afunc: %p\n", afunc);</code></p>
      <p><code>24</code></p>
      <p><code>25  printf("Stack Locations.\n");</code></p>
      <p><code>26  afunc();</code></p>
      <p><code>27</code></p>
      <p><code>28  p = (char*)alloca(32);</code></p>
      <p><code>29  if (p != NULL) {</code></p>
      <p><code>30   printf("\tStart of alloca()'ed array: %p\n", p);</code></p>
      <p><code>31   printf("\tEnd of alloca()'ed array: %p\n", p + 31);</code></p>
      <p><code>32  }</code></p>
      <p><code>33</code></p>
      <p><code>34  printf("Data Locations:\n");</code></p>
      <p><code>35  printf("\tAddress of data_var: %p\n", &amp;data_var);</code></p>
      <p><code>36</code></p>
      <p><code>37  printf("BSS Locations:\n");</code></p>
      <p><code>38  printf("\tAddress of bss_var: %p\n", &amp;bss_var);</code></p>
      <p><code>39</code></p>
      <p><code>40  b = sbrk((ptrdiff_t)32); /* увеличить адресное пространство */</code></p>
      <p><code>41  nb = sbrk((ptrdiff_t)0);</code></p>
      <p><code>42  printf("Heap Locations:\n");</code></p>
      <p><code>43  printf("\tInitial end of heap: %p\n", b);</code></p>
      <p><code>44  printf("\tNew end of heap: %p\n", nb);</code></p>
      <p><code>45</code></p>
      <p><code>46  b = sbrk((ptrdiff_t)-16); /* сократить его */</code></p>
      <p><code>47  nb = sbrk((ptrdiff_t)0);</code></p>
      <p><code>48  printf("\tFinal end of heap: %p\n", nb);</code></p>
      <p><code>49 }</code></p>
      <p><code>50</code></p>
      <p><code>51 void</code></p>
      <p><code>52 afunc(void)</code></p>
      <p><code>53 {</code></p>
      <p><code>54  static int level = 0; /* уровень рекурсии */</code></p>
      <p><code>55  auto int stack_var; /* автоматическая переменная в стеке */</code></p>
      <p><code>56</code></p>
      <p><code>57  if (++level == 3) /* избежать бесконечной рекурсии */</code></p>
      <p><code>58   return;</code></p>
      <p><code>59</code></p>
      <p><code>60  printf("\tStack level %d: address of stack_var: %p\n",</code></p>
      <p><code>61   level, &amp;stack_var);</code></p>
      <p><code>62  afunc(); /* рекурсивный вызов */</code></p>
      <p><code>63 }</code></p>
      <p>Эта программа распечатывает местонахождение двух функций <code>main()</code> и <code>afunc()</code> (строки 22–23). Затем она показывает, как стек растет вниз, позволяя <code>afunc()</code> (строки 51–63) распечатать адреса последовательных экземпляров ее локальной переменной <code>stack_var</code>. (<code>stack_var</code> намеренно объявлена как <code>auto</code>, чтобы подчеркнуть, что она находится в стеке.) Затем она показывает расположение памяти, выделенной с помощью <code>alloca()</code> (строки 28–32). В заключение она печатает местоположение переменных данных и BSS (строки 34–38), а затем памяти, выделенной непосредственно через <code>sbrk()</code> (строки 40–48). Вот результаты запуска программы на системе Intel GNU/Linux:</p>
      <p><code>$ <strong>ch03-memaddr</strong></code></p>
      <p><code>Text Locations:</code></p>
      <p><code> Address of main: 0x804838c</code></p>
      <p><code> Address of afunc: 0x80484a8</code></p>
      <p><code>Stack Locations:</code></p>
      <p><code> Stack level 1: address of stack_var: 0xbffff864</code></p>
      <p><code> Stack level 2: address of stack_var: 0xbffff844</code></p>
      <p><code>  /* Стек растет вниз */</code></p>
      <p><code> Start of alloca()'ed array: 0xbffff860</code></p>
      <p><code> End of alloca()'ed array: 0xbffff87f</code></p>
      <p><code>  /* Адреса находятся в стеке */</code></p>
      <p><code>Data Locations:</code></p>
      <p><code> Address of data_var: 0x80496b8</code></p>
      <p><code>BSS Locations:</code></p>
      <p><code> Address of bss_var: 0x80497c4</code></p>
      <p><code>  /* BSS выше инициализированных данных */</code></p>
      <p><code>Heap Locations:</code></p>
      <p><code> Initial end of heap: 0x80497c8</code></p>
      <p><code>  /* Куча непосредственно над BSS */</code></p>
      <p><code> New end of heap: 0x80497e8</code></p>
      <p><code>  /* И растет вверх */</code></p>
      <p><code> Final end of heap: 0x80497d8</code></p>
      <p><code>  /* Адресные пространства можно сокращать */</code></p>
     </section>
    </section>
    <section>
     <title>
      <p>3.3. Резюме</p>
     </title>
     <p>• У каждой программы Linux и (Unix) есть различные области памяти. Они хранятся в разных частях файла исполняемой программы на диске. Некоторые из секций загружаются при запуске программы в одну и ту же область памяти. Все запушенные экземпляры одной и той же программы разделяют исполняемый код (сегмент текста). Программа <code>size</code> показывает размеры различных областей переместимых объектных файлов и полностью скомпонованных исполняемых файлов.</p>
     <p>• В адресном пространстве запушенной программы могут быть дыры, а размер адресного пространства может изменяться при выделении и освобождении памяти. На современных системах адрес 0 не является частью адресного пространства, поэтому не пытайтесь разыменовывать указатели <code>NULL</code>.</p>
     <p>• На уровне языка С память выделяется с помощью одной из функций <code>malloc()</code>, <code>calloc()</code> или <code>realloc()</code>. Память освобождается с помощью <code>free()</code>. (Хотя с помощью <code>realloc()</code> можно делать все, использование ее таким образом не рекомендуется.) Освобожденная память обычно не удаляется из адресного пространства; вместо этого она используется повторно при последующих выделениях.</p>
     <p>• Необходимо предпринять чрезвычайные меры осторожности в следующих случаях</p>
     <p> • освобождать лишь память, выделенную с помощью соответствующих процедур,</p>
     <p> • освобождать память один и только один раз,</p>
     <p> • освобождать неиспользуемую память и</p>
     <p> • не допускать «утечки» динамически выделяемой памяти.</p>
     <p>• POSIX предоставляет для удобства функцию <code>strdup()</code>, a GLIBC предоставляет функции <code>getline()</code> и <code>getdelim()</code> для чтения строк произвольной длины. Функции интерфейса низкоуровневых системных вызовов <code>brk()</code> и <code>sbrk()</code> предоставляют непосредственный, но примитивный доступ к выделению и освобождению памяти. Если вы не создаете свой собственный распределитель памяти, следует избегать их. Существует функция <code>alloca()</code> для выделения памяти в стеке, но ее использование не рекомендуется. Подобно умению распознавать ядовитый плющ, про нее нужно знать лишь для того, чтобы избегать ее.</p>
    </section>
    <section>
     <title>
      <p>Упражнения</p>
     </title>
     <p>1. Начав со структуры —</p>
     <p><code>struct line {</code></p>
     <p><code> size_t buflen;</code></p>
     <p><code> char *buf;</code></p>
     <p><code> FILE* fp;</code></p>
     <p><code>};</code></p>
     <p>— напишите свою собственную функцию <code>readline()</code>, которая будет читать строки любой длины. Не беспокойтесь о строках, продолженных с помощью обратного слеша. Вместо использования <code>fgetc()</code> для чтения строк используйте <code>getc()</code> для чтения одного символа за раз.</p>
     <p>2. Сохраняет ли ваша функция завершающий символ конца строки? Объясните, почему.</p>
     <p>3. Как ваша функция обрабатывает строки, оканчивающиеся CR-LF?</p>
     <p>4. Как вы инициализируете структуру? В отдельной процедуре? С помощью документированных условий для определенных значений в структуре?</p>
     <p>5. Как вы обозначаете конец файла? Как вы указываете, что возникла ошибка ввода/вывода? Должна ли ваша функция сообщать об ошибках? Объясните, почему.</p>
     <p>6. Напишите программу, которая использует вашу функцию для ее тестирования, а также другую программу, создающую входные данные для первой программы. Протестируйте функцию.</p>
     <p>7. Перепишите вашу функцию с использованием <code>fgets()</code> и протестируйте ее. Является ли новый код более сложным или менее сложным? Какова его производительность по сравнению с версией <code>getc()</code>?</p>
     <p>8. Изучите страницу справки V7 для <emphasis>end</emphasis>(3) (<code>/usr/man/man3/end.3</code> в дистрибутиве V7). Пролила ли она свет на то, как может работать '<code>sbrk(0)</code>'?</p>
     <p>9. Усовершенствуйте <code>ch03-memaddr.c</code> так, чтобы она печатала расположение аргументов и переменных окружения. В какой области адресного пространства они находятся?</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 4</p>
     <p>Файлы и файловый ввод/вывод</p>
    </title>
    <section>
     <p>Данная глава описывает базовые файловые операции: открытие и создание файлов, чтение и запись в них, перемещение в них и их закрытие. По ходу дела она представляет стандартные механизмы для обнаружения ошибок и сообщений о них. Глава заканчивается описанием того, как установить длину файла и принудительно сбросить данные файла и вспомогательные данные на диск.</p>
    </section>
    <section>
     <title>
      <p>4.1. Введение в модель ввода/вывода Linux/Unix</p>
     </title>
     <p>Модель API Linux/Unix для ввода/вывода проста. Ее можно суммировать четырьмя словами. открыть, прочитать, записать, закрыть. Фактически, это имена системных вызовов: <code>open()</code>, <code>read()</code>, <code>write()</code>, <code>close()</code>. Вот их объявления:</p>
     <p><code>#include &lt;sys/types.h&gt; /* POSIX */</code></p>
     <p><code>#include &lt;sys/stat.h&gt; /* для mode_t */</code></p>
     <p><code>#include &lt;fcntl.h&gt;    /* для flags для open() */</code></p>
     <p><code>#include &lt;unistd.h&gt;   /* для ssize_t */</code></p>
     <empty-line/>
     <p><code>int open(const char *pathname, int flags, mode_t mode);</code></p>
     <p><code>ssize_t read(int fd, void *buf, size_t count);</code></p>
     <p><code>ssize_t write(int fd, const void *buf, size_t count);</code></p>
     <p><code>int close(int fd);</code></p>
     <p>В следующем и дальнейших разделах мы проиллюстрируем модель, написав очень простую версию <code>cat</code>. Она так проста, что даже не имеет опций; все, что она делает, — объединяет содержимое двух именованных файлов и выводит его в стандартный вывод. Она выводит минимум сообщений об ошибках. Написав, мы сравним ее с V7 <code>cat</code>.</p>
     <p>Мы представим программу сверху вниз, начав с командной строки. В последующих разделах мы представим обработку ошибок, а затем перейдем к сущностным задачам, показав, каким образом осуществляется реальный файловый ввод/вывод.</p>
    </section>
    <section>
     <title>
      <p>4.2. Представление базовой структуры программы</p>
     </title>
     <p>Наша версия cat следует структуре, которая обычно является полезной. Первая часть начинается с комментариев, заголовочных файлов, объявлений и функции main():</p>
     <p><code>1  /*</code></p>
     <p><code>2   * ch04-cat.c --- Демонстрация open(), read(), write(), close(),</code></p>
     <p><code>3   * errno и strerror().</code></p>
     <p><code>4   */</code></p>
     <p><code>5</code></p>
     <p><code>6  #include &lt;stdio.h&gt; /* для fprintf(), stderr, BUFSIZ */</code></p>
     <p><code>7  #include &lt;errno.h&gt; /* объявление errno */</code></p>
     <p><code>8  #include &lt;fcntl.h&gt; /* для flags для open() */</code></p>
     <p><code>9  #include &lt;string.h&gt; /* объявление strerror() */</code></p>
     <p><code>10 #include &lt;unistd.h&gt; /* для ssize_t */</code></p>
     <p><code>11 #include &lt;sys/types.h&gt;</code></p>
     <p><code>12 #include &lt;sys/stat.h&gt; /* для mode_t */</code></p>
     <p><code>13</code></p>
     <p><code>14 char *myname;</code></p>
     <p><code>15 int process(char *file);</code></p>
     <p><code>16</code></p>
     <p><code>17 /* main --- перечислить аргументы файла */</code></p>
     <p><code>18</code></p>
     <p><code>19 int</code></p>
     <p><code>20 main(int argc, char **argv)</code></p>
     <p><code>21 {</code></p>
     <p><code>22  int i;</code></p>
     <p><code>23  int errs = 0;</code></p>
     <p><code>24</code></p>
     <p><code>25  myname = argv[0];</code></p>
     <p><code>26</code></p>
     <p><code>27  if (argc == 1)</code></p>
     <p><code>28   errs = process("-");</code></p>
     <p><code>29  else</code></p>
     <p><code>30   for (i = 1; i &lt; argc; i++)</code></p>
     <p><code>31  errs += process(argv[i]);</code></p>
     <p><code>32</code></p>
     <p><code>33  return (errs != 0);</code></p>
     <p><code>34 }</code></p>
     <p><emphasis>…продолжение далее в главе.</emphasis></p>
     <p>Переменная <code>myname</code> (строка 14) используется далее для сообщений об ошибках; <code>main()</code> первым делом устанавливает в ней имя программы (<code>argv[0]</code>). Затем <code>main()</code> в цикле перечисляет аргументы. Для каждого аргумента она вызывает функцию <code>process()</code>.</p>
     <p>Когда в качестве имени файла дано <code>-</code> (простая черточка, или знак минус), <code>cat</code> Unix вместо попытки открыть файл с именем читает стандартный ввод. Вдобавок, <code>cat</code> читает стандартный ввод, когда нет аргументов. <code>ch04-cat</code> реализует оба этих поведения. Условие '<code>argc == 1</code>' (строка 27) истинно, когда нет аргументов имени файла; в этом случае <code>main()</code> передает «<code>-</code>» функции <code>process()</code>. В противном случае, <code>main()</code> перечисляет аргументы, рассматривая их как файлы, которые необходимо обработать. Если один из них окажется «<code>-</code>», программа обрабатывает стандартный ввод.</p>
     <p>Если <code>process()</code> возвращает ненулевое значение, это означает, что случилась какая- то ошибка. Ошибки подсчитываются в переменной <code>errs</code> (строки 28 и 31). Когда <code>main()</code> завершается, она возвращает 0, если не было ошибок, и 1, если были (строка 33). Это довольно стандартное соглашение, значение которого более подробно обсуждается в разделе 9.1.5.1 «Определение статуса завершения процесса».</p>
     <p>Структура, представленная в <code>main()</code>, довольно общая: <code>process()</code> может делать с файлом все, что мы захотим. Например (игнорируя особый случай «<code>-</code>»), process() также легко могла бы удалять файлы вместо их объединения!</p>
     <p>Прежде чем рассмотреть функцию <code>process()</code>, нам нужно описать, как представлены ошибки системных вызовов и как осуществляется ввод/вывод. Сама функция <code>process()</code> представлена в разделе 4.4.3 «Чтение и запись».</p>
    </section>
    <section>
     <title>
      <p>4.3. Определение ошибок</p>
     </title>
     <epigraph>
      <p>«Если неприятность может произойти, она случается»</p>
      <text-author>- Закон Мерфи -</text-author>
     </epigraph>
     <epigraph>
      <p>«Будь готов»</p>
      <text-author>- Бойскауты -</text-author>
     </epigraph>
     <section>
      <p>Ошибки могут возникнуть в любое время. Диски могут заполниться, пользователи могут ввести неверные данные, сетевой сервер, с которого осуществляется чтение, может отказать, сеть может выйти из строя и т.д. Важно <emphasis>всегда</emphasis> проверять успешность завершения каждой операции.</p>
      <p>Основные системные вызовы Linux почти всегда возвращают при ошибке -1 и 0 или положительное значение при успехе. Это дает возможность узнать, была операция успешной или нет:</p>
      <p><code>int result;</code></p>
      <p><code>result = some_system_call(param1, param2);</code></p>
      <p><code>if (result &lt; 0) {</code></p>
      <p><code> /* ошибка, что-нибудь сделать */</code></p>
      <p><code>} else</code></p>
      <p><code> /* все нормально, продолжить */</code></p>
      <p>Знания того, что произошла ошибка, недостаточно. Нужно знать, <emphasis>какая</emphasis> произошла ошибка. Для этого у каждого процесса есть предопределенная переменная с именем <code>errno</code>. Всякий раз, когда системный вызов завершается ошибкой, <code>errno</code> устанавливается в один из набора предопределенных значений ошибок <code>errno</code> и предопределенные значения ошибок определены в файле заголовка <code>&lt;errno.h&gt;</code>.</p>
      <p><code>#include &lt;errno.h&gt; /* ISO С */</code></p>
      <empty-line/>
      <p><code>extern int errno;</code></p>
      <p>Хотя сама <code>errno</code> может быть макросом, который <emphasis>действует подобно</emphasis> переменной <code>int</code> — она не обязательно является действительной целой переменной. В частности, в многопоточном окружении у каждого потока будет своя индивидуальная версия <code>errno</code>. Несмотря на это, практически для всех системных вызовов и функций в данной книге вы можете рассматривать <code>errno</code> как простую <code>int</code>.</p>
     </section>
     <section>
      <title>
       <p>4.3.1. Значения <code>errno</code></p>
      </title>
      <p>Стандарт POSIX 2001 определяет большое число возможных значений для errno. Многие из них относятся к сетям, IPC или другим специальным задачам. Справочная страница для каждого системного вызова описывает возможные значения <code>errno</code>, которые могут иметь место; поэтому вы можете написать код для проверки отдельных ошибок и соответствующим образом обработать их, если это нужно. Возможные значения определены через символические имена. Предусмотренные GLIBC значения перечислены в табл. 4.1.</p>
      <empty-line/>
      <p><strong>Таблица 4.1</strong>. Значения GLIBC для <code>errno</code></p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Имя</th>
        <th align="left" valign="top">Значение</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>E2BIG</code></td>
        <td align="left" valign="top">Слишком длинный список аргументов</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EACCESS</code></td>
        <td align="left" valign="top">Доступ запрещен</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EADDRINUSE</code></td>
        <td align="left" valign="top">Адрес используется</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EADDRNOTAVAIL</code></td>
        <td align="left" valign="top">Адрес недоступен</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EAFNOSUPPORT</code></td>
        <td align="left" valign="top">Семейство адресов не поддерживается</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EAGAIN</code></td>
        <td align="left" valign="top">Ресурс недоступен, попытайтесь снова (может быть то же самое значение, что <code>EWOULDBLOCK</code>).</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EALREADY</code></td>
        <td align="left" valign="top">Соединение уже устанавливается</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EBADF</code></td>
        <td align="left" valign="top">Ошибочный дескриптор файла.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EBADMSG</code></td>
        <td align="left" valign="top">Ошибочное сообщение.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EBUSY</code></td>
        <td align="left" valign="top">Устройство или ресурс заняты</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ECANCELED</code></td>
        <td align="left" valign="top">Отмена операции.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ECHILD</code></td>
        <td align="left" valign="top">Нет порожденного процесса.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ECONNABORTED</code></td>
        <td align="left" valign="top">Соединение прервано</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ECONNFRFUSED</code></td>
        <td align="left" valign="top">Соединение отклонено</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ECONNRESET</code></td>
        <td align="left" valign="top">Восстановлено исходное состояние соединения.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EDEADLK</code></td>
        <td align="left" valign="top">Возможен тупик (deadlock) в запросе ресурса.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EDESTADDRREQ</code></td>
        <td align="left" valign="top">Требуется адрес назначения</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EDOM</code></td>
        <td align="left" valign="top">Математический аргумент выходит за область определения функции</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EDQUOT</code></td>
        <td align="left" valign="top">Зарезервировано.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EEXIST</code></td>
        <td align="left" valign="top">Файл существует.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EFAULT</code></td>
        <td align="left" valign="top">Ошибочный адрес.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EFBIG</code></td>
        <td align="left" valign="top">Файл слишком большой.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EHOSTUNREACH</code></td>
        <td align="left" valign="top">Хост недоступен.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EIDRM</code></td>
        <td align="left" valign="top">Идентификатор удален</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EILSEQ</code></td>
        <td align="left" valign="top">Ошибочная последовательность байтов.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EINPROGRESS</code></td>
        <td align="left" valign="top">Операция исполняется.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EINTR</code></td>
        <td align="left" valign="top">Прерванная функция.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EINVAL</code></td>
        <td align="left" valign="top">Недействительный аргумент.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EIO</code></td>
        <td align="left" valign="top">Ошибка ввода/вывода.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EISCONN</code></td>
        <td align="left" valign="top">Сокет (уже) соединен.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EISDIR</code></td>
        <td align="left" valign="top">Это каталог.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ELOOP</code></td>
        <td align="left" valign="top">Слишком много уровней символических ссылок.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EMFILE</code></td>
        <td align="left" valign="top">Слишком много открытых файлов.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EMLINK</code></td>
        <td align="left" valign="top">Слишком много ссылок.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EMSGSIZE</code></td>
        <td align="left" valign="top">Сообщение слишком длинное.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EMULTIHOP</code></td>
        <td align="left" valign="top">Зарезервировано.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENAMETOOLONG</code></td>
        <td align="left" valign="top">Имя файла слишком длинное</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENETDOWN</code></td>
        <td align="left" valign="top">Сеть не работает</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENETRESET</code></td>
        <td align="left" valign="top">Соединение прервано сетью</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENETUNREACH</code></td>
        <td align="left" valign="top">Сеть недоступна.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENFILE</code></td>
        <td align="left" valign="top">В системе открыто слишком много файлов.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENOBUFS</code></td>
        <td align="left" valign="top">Буферное пространство недоступно.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENODEV</code></td>
        <td align="left" valign="top">Устройство отсутствует</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENOENT</code></td>
        <td align="left" valign="top">Файл или каталог отсутствуют</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENOEXEC</code></td>
        <td align="left" valign="top">Ошибочный формат исполняемого файла.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENOLCK</code></td>
        <td align="left" valign="top">Блокировка недоступна.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENOLINK</code></td>
        <td align="left" valign="top">Зарезервировано.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENOMEM</code></td>
        <td align="left" valign="top">Недостаточно памяти.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENOMSG</code></td>
        <td align="left" valign="top">Сообщение нужного типа отсутствует</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENOPROTOOPT</code></td>
        <td align="left" valign="top">Протокол недоступен.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENOSPC</code></td>
        <td align="left" valign="top">Недостаточно памяти в устройстве.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENOSYS</code></td>
        <td align="left" valign="top">Функция не поддерживается.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENOTCONN</code></td>
        <td align="left" valign="top">Сокет не соединен.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENOTDIR</code></td>
        <td align="left" valign="top">Это не каталог</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENOTEMPTY</code></td>
        <td align="left" valign="top">Каталог не пустой.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENOTSOCK</code></td>
        <td align="left" valign="top">Это не сокет</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENOTSUP</code></td>
        <td align="left" valign="top">Не поддерживается</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENOTTY</code></td>
        <td align="left" valign="top">Неподходящая операция управления вводом/выводом</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ENXIO</code></td>
        <td align="left" valign="top">Нет такого устройства или адреса.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EOPNOTSUPP</code></td>
        <td align="left" valign="top">Операция сокета не поддерживается</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EOVERFLOW</code></td>
        <td align="left" valign="top">Слишком большое значение для типа данных</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EPERM</code></td>
        <td align="left" valign="top">Операция не разрешена</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EPIPE</code></td>
        <td align="left" valign="top">Канал (pipe) разрушен</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EPROTO</code></td>
        <td align="left" valign="top">Ошибка протокола.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EPROTONOSUPPORT</code></td>
        <td align="left" valign="top">Протокол не поддерживается</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EPROTOTYPE</code></td>
        <td align="left" valign="top">Ошибочный тип протокола для сокета</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ERANGE</code></td>
        <td align="left" valign="top">Результат слишком большой</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EROFS</code></td>
        <td align="left" valign="top">Файловая система только для чтения</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ESPIPE</code></td>
        <td align="left" valign="top">Недействительный поиск</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ESRCH</code></td>
        <td align="left" valign="top">Нет такого процесса</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ESTALE</code></td>
        <td align="left" valign="top">Зарезервировано</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ETIMEDOUT</code></td>
        <td align="left" valign="top">Тайм-аут соединения истек</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ETXTBSY</code></td>
        <td align="left" valign="top">Текстовый файл занят</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EWOULDBLOCK</code></td>
        <td align="left" valign="top">Блокирующая операция (может быть то же значение, что и для <code>EAGAIN</code>)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>EXDEV</code></td>
        <td align="left" valign="top">Ссылка через устройство (cross-device link)</td>
       </tr>
      </table>
      <p>Многие системы предоставляют также другие значения ошибок, а в более старых системах может не быть всех перечисленных значений ошибок. Полный список следует проверить с помощью справочных страниц <emphasis>intro</emphasis>(2) и <emphasis>errno</emphasis>(2) для локальной системы.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. <code>errno</code> следует проверять лишь после того, как возникла ошибка и до того, как сделаны дальнейшие системные вызовы. Начальное значение той переменной 0. Однако, в промежутках между ошибками ничто не изменяет ее значения, это означает, что успешный системный вызов не восстанавливает значение 0. Конечно, вы можете вручную установить ее в 0 в самом начале или когда захотите, однако это делается редко.</p>
      </cite>
      <p>Сначала мы используем <code>errno</code> лишь для сообщений об ошибках. Для этого имеются две полезные функции. Первая — <code>perror()</code>:</p>
      <p><code>#include &lt;stdio.h&gt; /* ISO С */</code></p>
      <empty-line/>
      <p><code>void perror(const char *s);</code></p>
      <p>Функция <code>perror()</code> выводит предоставленную программой строку, за которой следует двоеточие, а затем строка, описывающая значение <code>errno</code>:</p>
      <p><code>if (some_system_call(param1, param2) &lt; 0) {</code></p>
      <p><code> perror("system call failed");</code></p>
      <p><code> return 1;</code></p>
      <p><code>}</code></p>
      <p>Мы предпочитаем функцию <code>strerror()</code>, которая принимает параметр со значением ошибки и возвращает указатель на строку с описанием ошибки:</p>
      <p><code>#include &lt;string.h&gt; /* ISO С */</code></p>
      <empty-line/>
      <p><code>char *strerror(int errnum);</code></p>
      <p><code>strerror()</code> предоставляет для сообщений об ошибках максимальную гибкость, поскольку <code>fprintf()</code> дает возможность выводить ошибки любым нужным нам способом, наподобие этого.</p>
      <p><code>if (some_system_call(param1, param2) &lt; 0) {</code></p>
      <p><code> fprintf(stderr, "%s: %d, %d: some_system_call failed: %s\n",</code></p>
      <p><code>  argv[0], param1, param2, strerror(errno));</code></p>
      <p><code> return 1;</code></p>
      <p><code>}</code></p>
      <p>По всей книге вы увидите множество примеров использования обеих функций.</p>
     </section>
     <section>
      <title>
       <p>4.3.2. Стиль сообщения об ошибках</p>
      </title>
      <p>Для использования в сообщениях об ошибках С предоставляет несколько специальных макросов. Наиболее широкоупотребительными являются <code>__FILE__</code> и <code>__LINE__</code>, которые разворачиваются в имя исходного файла и номер текущей строки в этом файле. В С они были доступны с самого начала. C99 определяет дополнительный предопределенный идентификатор, <code>__func__</code>, который представляет имя текущей функции в виде символьной строки. Макросы используются следующим образом:</p>
      <p><code>if (some_system_call(param1, param2) &lt; 0) {</code></p>
      <p><code> fprintf(stderr, "%s: %s (%s %d): some_system_call(%d, %d) failed: %s\n",</code></p>
      <p><code>  argv[0], __func__, __FILE__, __LINE__,</code></p>
      <p><code>  param1, param2, strerror(errno));</code></p>
      <p><code> return 1;</code></p>
      <p><code>}</code></p>
      <p>Здесь сообщение об ошибке включает не только имя программы, но также и имя функции, имя исходного файла и номер строки. Полный список идентификаторов, полезных для диагностики, приведен в табл. 4.2.</p>
      <empty-line/>
      <p><strong>Таблица 4.2</strong>. Диагностические идентификаторы C99</p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Идентификатор</th>
        <th align="left" valign="top">Версия С</th>
        <th align="left" valign="top">Значение</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>__DATE__</code></td>
        <td align="left" valign="top">C89</td>
        <td align="left" valign="top">Дата компиляции в виде «<code>Mmm nn yyyy</code>»</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>__FILE_</code></td>
        <td align="left" valign="top">Оригинальная</td>
        <td align="left" valign="top">Имя исходного файла в виде «<code>program.c</code>»</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>__LINE__</code></td>
        <td align="left" valign="top">Оригинальная</td>
        <td align="left" valign="top">Номер строки исходного файла в виде 42</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>__TIME__</code></td>
        <td align="left" valign="top">C89</td>
        <td align="left" valign="top">Время компиляции в виде «<code>hh:mm:ss</code>»</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>__func__</code></td>
        <td align="left" valign="top">C99</td>
        <td align="left" valign="top">Имя текущей функции, как если бы было объявлено <code>const char __func__[] = "name"</code></td>
       </tr>
      </table>
      <p>Использование <code>__FILE__</code> и <code>__LINE__</code> было вполне обычно для ранних дней Unix, когда у большинства людей были исходные коды и они могли находить ошибки и устранять их. По мере того, как системы Unix становились все более коммерческими, использование этих идентификаторов постепенно уменьшалось, поскольку знание положения в исходном коде дает немного пользы, когда имеется лишь двоичный исполняемый файл.</p>
      <p>Сегодня, хотя системы GNU/Linux поставляются с исходными кодами, указанный исходный код часто не устанавливается по умолчанию. Поэтому использование этих идентификаторов для сообщений об ошибках не представляет дополнительной ценности. <emphasis>GNU Coding Standard</emphasis>s даже не упоминает их.</p>
     </section>
    </section>
    <section>
     <title>
      <p>4.4. Ввод и вывод</p>
     </title>
     <section>
      <p>Все операции Linux по вводу/выводу осуществляются посредством <emphasis>дескрипторов файлов</emphasis>. Данный раздел знакомит с дескрипторами файлов, описывает, как их получать и освобождать, и объясняет, как выполнять с их помощью ввод/вывод.</p>
     </section>
     <section>
      <title>
       <p>4.4.1. Понятие о дескрипторах файлов</p>
      </title>
      <p><emphasis>Дескриптор файла</emphasis> является целым значением. Действительные дескрипторы файлов начинаются с 0 и растут до некоторого установленного системой предела. Эти целые фактически являются индексами таблицы открытых файлов для каждого процесса (Таблица поддерживается внутри операционной системы; она недоступна запущенным программам.) В большинстве современных систем размеры таблиц большие. Команда '<code>ulimit -n</code>' печатает это значение:</p>
      <p><code>$ <strong>ulimit -n</strong></code></p>
      <p><code>1024</code></p>
      <p>Из С максимальное число открытых файлов возвращается функцией <code>getdtablesize()</code> (получить размер таблицы дескрипторов):</p>
      <p><code>#include &lt;unistd.h&gt; /* Обычный */</code></p>
      <empty-line/>
      <p><code>int getdtablesize(void);</code></p>
      <p>Следующая небольшая программа выводит результат работы этой функции:</p>
      <p><code>/* ch04-maxfds.с --- Демонстрация getdtablesize(). */</code></p>
      <p><code>#include &lt;stdio.h&gt; /* для fprintf(), stderr, BUFSIZ */</code></p>
      <p><code>#include &lt;unistd.h&gt; /* для ssize_t */</code></p>
      <empty-line/>
      <p><code>int main(int argc, char **argv) {</code></p>
      <p><code> printf("max fds: %d\n", getdtablesize());</code></p>
      <p><code> exit(0);</code></p>
      <p><code>}</code></p>
      <p>Неудивительно, что после компиляции и запуска эта программа выводит то же значение, что и <code>ulimit</code>:</p>
      <p><code>$ <strong>ch04-maxfds</strong></code></p>
      <p><code>max fds: 1024</code></p>
      <p>Дескрипторы файлов содержатся в обычных переменных <code>int</code>; для использования с системными вызовами ввода/вывода можно увидеть типичные объявления вида '<code>int fd</code>'. Для дескрипторов файлов нет предопределенного типа.</p>
      <p>В обычном случае каждая программа начинает свою работу с тремя уже открытыми для нее дескрипторами файлов. Это стандартный ввод, стандартный вывод и стандартная ошибка, с дескрипторами файлов 0, 1 и 2 соответственно. (Если не было использовано перенаправление, каждый из них связан с клавиатурой и с экраном.)</p>
      <cite>
       <subtitle>Очевидные символические константы. Оксюморон?</subtitle>
       <p>При работе с системными вызовами на основе дескрипторов файлов и стандартных ввода, вывода и ошибки целые константы 0, 1 и 2 обычно используются прямо в коде. В подавляющем большинстве случаев использование таких <emphasis>символических констант (manifest constants)</emphasis> является плохой мыслью. Вы никогда не знаете, каково значение некоторой случайной целой константы и имеет ли к ней какое-нибудь отношение константа с тем же значением, использованная в другой части кода. С этой целью стандарт POSIX требует объявить следующие <emphasis>именованные константы (symbolic constants)</emphasis> в <code>&lt;unistd.h&gt;</code>:</p>
       <p><code>STDIN_FILENO  </code>«Номер файла» для стандартного ввода: 0.</p>
       <p><code>STDOUT_FILENO </code>Номер файла для стандартного вывода: 1.</p>
       <p><code>STDERR_FILENO </code>Номер файла для стандартной ошибки: 2.</p>
       <p>Однако, по нашему скромному мнению, использование этих макросов избыточно. Во-первых, <emphasis>неприятно</emphasis> набирать 12 или 13 символов вместо 1. Во-вторых, использование 0, 1 и 2 <emphasis>так</emphasis> стандартно и <emphasis>так</emphasis> хорошо известно, что на самом деле нет никаких оснований для путаницы в смысле этих конкретных символических констант.</p>
       <p>С другой стороны, использование этих констант не оставляет сомнений в намерениях программиста. Сравните это утверждение:</p>
       <p><code>int fd = 0;</code></p>
       <p>Инициализируется ли <code>fd</code> значением стандартного ввода, или же программист благоразумно инициализирует свои переменные подходящим значением? Вы не можете этого сказать.</p>
       <p>Один из подходов (рекомендованный Джеффом Колье (Geoff Collyer)) заключается в использовании следующего определения <code>enum</code>:</p>
       <p><code>enum { Stdin, Stdout, Stderr };</code></p>
       <p>Затем эти константы можно использовать вместо 0, 1 и 2. Их легко читать и печатать.</p>
      </cite>
     </section>
     <section>
      <title>
       <p>4.4.2. Открытие и закрытие файлов</p>
      </title>
      <section>
       <p>Новые дескрипторы файлов получают (наряду с другими источниками) в результате системного вызова <code>open()</code>. Этот системный вызов открывает файл для чтения или записи и возвращает новый дескриптор файла для последующих операций с этим файлом. Мы видели объявление раньше:</p>
       <p><code>#include &lt;sys/types.h&gt; /* POSIX */</code></p>
       <p><code>#include &lt;sys/stat.h&gt;</code></p>
       <p><code>#include &lt;fcntl.h&gt;</code></p>
       <p><code>#include &lt;unistd.h&gt;</code></p>
       <empty-line/>
       <p><code>int open(const char *pathname, int flags, mode_t mode);</code></p>
       <p>Три аргумента следующие:</p>
       <p><code>const char *pathname</code></p>
       <p>Строка С, представляющая имя открываемого файла.</p>
       <p><code>int flags</code></p>
       <p>Поразрядное ИЛИ с одной или более констант, определенных в <code>&lt;fcntl.h&gt;</code>. Вскоре мы их рассмотрим.</p>
       <p><code>mode_t mode</code></p>
       <p>Режимы доступа для создаваемого файла. Это обсуждается далее в главе, см. раздел 4.6 «Создание файлов». При открытии существующего файла опустите этот параметр<a l:href="#n46" type="note">[46]</a>.</p>
       <p>Возвращаемое open() значение является либо новым дескриптором файла, либо -1, означающим ошибку, в этом случае будет установлена <code>errno</code>. Для простого ввода/вывода аргумент <code>flags</code> должен быть одним из значений из табл. 4.3.</p>
       <empty-line/>
       <p><strong>Таблица 4.3</strong>. Значения <code>flags</code> для <code>open()</code></p>
       <table>
        <tr align="left">
         <th align="left" valign="top">Именованная константа</th>
         <th align="left" valign="top">Значение</th>
         <th align="left" valign="top">Комментарий</th>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>O_RDONLY</code></td>
         <td align="left" valign="top">0</td>
         <td align="left" valign="top">Открыть файл только для чтения, запись невозможны</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>O_WRONLY</code></td>
         <td align="left" valign="top">1</td>
         <td align="left" valign="top">Открыть файл только для записи, чтение невозможно</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>O_RDWR</code></td>
         <td align="left" valign="top">2</td>
         <td align="left" valign="top">Открыть файл для чтения и записи</td>
        </tr>
       </table>
       <p>Вскоре мы увидим пример кода. Дополнительные значения <code>flags</code> описаны в разделе 4.6 «Создание файлов». Большой объем ранее написанного кода Unix не использовал эти символические значения. Вместо этого использовались числовые значения. Сегодня это рассматривается как плохая практика, но мы представляем эти значения, чтобы вы их распознали, если встретитесь с ними</p>
       <p>Системный вызов <code>close()</code> закрывает файл: его элемент в системной таблице дескрипторов файлов помечается как неиспользуемый, и с этим дескриптором нельзя производить никаких дальнейших действий. Объявление следующее:</p>
       <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
       <empty-line/>
       <p><code>int close(int fd);</code></p>
       <p>В случае успеха возвращается 0, при ошибке (-1). При возникновении ошибки нельзя ничего сделать, кроме сообщения о ней. Ошибки при закрытии файлов являются необычными, но не невозможными, особенно для файлов, доступ к которым осуществляется через сеть. Поэтому хорошей практикой является проверка возвращаемого значения, особенно для файлов, открытых для записи.</p>
       <p>Если вы будете игнорировать возвращаемое значение, специально приведите его к типу <code>void</code>, чтобы указать, что вам не нужен результат:</p>
       <p><code>(void)close(fd); /* отказ от возвращаемого значения */</code></p>
       <p>Легкомысленность этого совета в том, что слишком большое количество приведений к <code>void</code> имеют тенденцию загромождать код. Например, несмотря на принцип «всегда проверять возвращаемое значение», чрезвычайно редко можно увидеть код, проверяющий возвращаемое значение <code>printf()</code> или приводящий его к <code>void</code>. Как и со многими аспектами программирования на С, здесь также требуются опыт и рассудительность.</p>
       <p>Как упоминалось, число открытых файлов, если оно большое, ограничивается, и вам всегда следует закрывать файлы, когда работа с ними закончена. Если вы этого не сделаете, то в конечном счете выйдете за пределы лимита дескрипторов файлов, создав ситуацию, которая ведет к потере устойчивости части вашей программы.</p>
       <p>Система закрывает все открытые файлы, когда процесс завершается, но — за исключением 0, 1 и 2 — плохая манера полагаться на это.</p>
       <p>Когда <code>open()</code> возвращает новый дескриптор файла, она всегда возвращает наименьшее неиспользуемое целое значение. <emphasis>Всегда</emphasis>. Поэтому, если открыты дескрипторы файлов 0–6 и программа закрывает дескриптор файла 5, следующий вызов <code>open()</code> вернет 5, а не 7. Это поведение важно; далее в книге мы увидим, как оно используется для аккуратной реализации многих важных особенностей Unix, таких, как перенаправление ввода/вывода и конвейеризация (piping)</p>
      </section>
      <section>
       <title>
        <p>4.4.2.1. Отображение переменных <code>FILE*</code> на дескрипторы файлов</p>
       </title>
       <p>Стандартные библиотечные функции ввода/вывода и переменные <code>FILE*</code> из <code>&lt;stdio.h&gt;</code>, такие, как <code>stdin</code>, <code>stdout</code> и <code>stderr</code>, построены поверх основанных на дескрипторах файлов системных вызовах.</p>
       <p>Иногда полезно получить непосредственный доступ к дескриптору файла, связанному с указателем файла <code>&lt;stdio.h&gt;</code>, если вам нужно сделать что-либо, не определенное стандартом С ISO. Функция <code>fileno()</code> возвращает лежащий в основе дескриптор файла:</p>
       <p><code>#include &lt;stdio.h&gt; /* POSIX */</code></p>
       <empty-line/>
       <p><code>int fileno(FILE *stream);</code></p>
       <p>Пример мы увидим позже, в разделе 4.4.4. «Пример: Unix cat».</p>
      </section>
      <section>
       <title>
        <p>4.4.2.2. Закрытие всех открытых файлов</p>
       </title>
       <p>Открытые файлы наследуются порожденными процессами от своих родительских процессов. Фактически они являются <emphasis>общими</emphasis>. В частности, общим является положение в файле. Подробности мы оставим для дальнейшего обсуждения в разделе 9.1.1.2 «Разделение дескрипторов файлов».</p>
       <p>Поскольку программы могут наследовать другие файлы, иногда вы можете увидеть программы, которые закрывают все свои файлы, чтобы начать с «чистого состояния» В частности, типичен код наподобие этого:</p>
       <p><code>int i;</code></p>
       <p><code>/* оставить лишь 0, 1, и 2 */</code></p>
       <p><code>for (i = 3; i &lt; getdtablesize(); i++)</code></p>
       <p><code> (void)close(i);</code></p>
       <p>Предположим, что результат <code>getdtablesize()</code> равен 1024. Этот код работает, но он делает (1024-3)*2 = 2042 системных вызова. <code>1020</code> из них не нужны, поскольку возвращаемое значение <code>getdtablesize()</code> не изменяется. Вот лучший вариант этого кода:</p>
       <p><code>int i, fds;</code></p>
       <p><code>for (i = 3, fds = getdtablesize(); i &lt; fds; i++)</code></p>
       <p><code> (void)close(i);</code></p>
       <p>Такая оптимизация не ухудшает читаемость кода, но может быть заметна разница, особенно на медленных системах. В общем, стоит поискать случаи, когда в циклах повторно вычисляется один и тот же результат, чтобы посмотреть, нельзя ли вынести вычисление за пределы цикла. Хотя в таких случаях нужно убедиться, что вы (а) сохраняете правильность кода и (б) сохраняете его читаемость!</p>
      </section>
     </section>
     <section>
      <title>
       <p>4.4.3. Чтение и запись</p>
      </title>
      <p>Ввод/вывод осуществляется системными вызовами <code>read()</code> и <code>write()</code> соответственно:</p>
      <p><code>#include &lt;sys/types.h&gt; /* POSIX */</code></p>
      <p><code>#include &lt;sys/stat.h&gt;</code></p>
      <p><code>#include &lt;fcntl.h&gt;</code></p>
      <p><code>#include &lt;unistd.h&gt;</code></p>
      <empty-line/>
      <p><code>ssize_t read(int fd, void *buf, size_t count);</code></p>
      <p><code>ssize_t write(int fd, const void *buf, size_t count);</code></p>
      <p>Каждая функция сделана как можно проще. Аргументами являются дескриптор открытого файла, указатель на буфер для чтения или записи данных и число читаемых или записываемых байтов.</p>
      <p>Возвращаемое значение является числом действительно прочитанных или записанных байтов. (Это число может быть меньше запрошенного: при операции чтения это происходит, когда в файле осталось меньше <code>count</code> байтов, а при операции записи это случается, когда диск заполнен или произошла еще какая-нибудь ошибка.) Возвращаемое значение -1 означает возникшую ошибку, в этом случае errno указывает эту ошибку. Когда <code>read()</code> возвращает 0, это означает, что достигнут конец файла.</p>
      <p>Теперь мы можем показать оставшуюся часть кода для <code>ch04-cat</code>. Процедура <code>process()</code> использует 0 для стандартного ввода, если именем файла является «<code>-</code>» (строки 50 и 51). В противном случае она открывает данный файл:</p>
      <p><code>36 /*</code></p>
      <p><code>37   * process --- сделать что-то с файлом, в данном случае,</code></p>
      <p><code>38   * послать его в stdout (fd 1).</code></p>
      <p><code>39   * Возвращает 0, если все нормально; в противном случае 1.</code></p>
      <p><code>40   */</code></p>
      <p><code>41</code></p>
      <p><code>42 int</code></p>
      <p><code>43 process(char *file)</code></p>
      <p><code>44 {</code></p>
      <p><code>45  int fd;</code></p>
      <p><code>46  ssize_t rcount, wcount;</code></p>
      <p><code>47  char buffer[BUFSIZ];</code></p>
      <p><code>48  int errors = 0;</code></p>
      <p><code>49</code></p>
      <p><code>50  if (strcmp(file, "-") == 0)</code></p>
      <p><code>51   fd = 0;</code></p>
      <p><code>52  else if ((fd = open(file, O_RDONLY)) &lt; 0) {</code></p>
      <p><code>53   fprintf(stderr, "%s: %s: cannot open for reading: %s\n",</code></p>
      <p><code>54    myname, file, strerror(errno));</code></p>
      <p><code>55   return 1;</code></p>
      <p><code>56  }</code></p>
      <p>Буфер <code>buffer</code> (строка 47) имеет размер <code>BUFSIZ</code>; эта константа определена В <code>&lt;stdio.h&gt;</code> как «оптимальный» размер блока для ввода/вывода. Хотя значение <code>BUFSIZ</code> различается в разных системах, код, использующий эту константу, чистый и переносимый.</p>
      <p>Основой процедуры является следующий цикл, который повторно читает данные до тех пор, пока не будет достигнут конец файла или не возникнет ошибка.</p>
      <p><code>58 while ((rcount = read(fd, buffer, sizeof buffer)) &gt; 0) {</code></p>
      <p><code>59  wcount = write(1, buffer, rcount);</code></p>
      <p><code>60  if (wcount != rcount) {</code></p>
      <p><code>61   fprintf(stderr, "%s: %s: write error: %s\n",</code></p>
      <p><code>62    myname, file, strerror(errno));</code></p>
      <p><code>63   errors++;</code></p>
      <p><code>64   break;</code></p>
      <p><code>65  }</code></p>
      <p><code>66 }</code></p>
      <p>Переменные <code>rcount</code> и <code>wcount</code> (строка 45) имеют тип <code>ssize_t</code>, «знаковый <code>size_t</code>», который позволяет хранить в них отрицательные значения. Обратите внимание, что число байтов, переданное <code>write()</code>, является значением, возвращенным <code>read()</code> (строка 59). Хотя мы хотим читать порциями фиксированного размера в <code>BUFSIZ</code>, маловероятно, что размер самого файла кратен <code>BUFSIZ</code>. При чтении из файла завершающей, меньшей порции байтов, возвращаемое значение указывает, сколько байтов buffer получили новые данные. В стандартный вывод должны быть скопированы только эти байты, а не весь буфер целиком.</p>
      <p>Условие '<code>wcount != rcount</code>' в строке 60 является правильным способом проверки на ошибки; если были записаны некоторые, но не все данные, <code>wcount</code> будет больше нуля, но меньше <code>rcount</code>.</p>
      <p>В заключение <code>process()</code> проверяет наличие ошибок чтения (строки 68–72), а затем пытается закрыть файл. В случае (маловероятном) неудачного завершения <code>close()</code> (строка 75) она выводит сообщение об ошибке. Избежание закрытия стандартного ввода не является абсолютно необходимым в данной программе, но является хорошей привычкой при разработке больших программ, в случае, когда другой код где-то в другом месте хочет что-то с ним делать или если порожденная программа будет наследовать его. Последний оператор (строка 82) возвращает 1, если были ошибки, и 0 в противном случае.</p>
      <p><code>68  if (rcount &lt; 0) {</code></p>
      <p><code>69   fprintf(stderr, "%s: %s: read error: %s\n",</code></p>
      <p><code>70    myname, file, strerror(errno));</code></p>
      <p><code>71   errors++;</code></p>
      <p><code>72  }</code></p>
      <p><code>73</code></p>
      <p><code>74  if (fd != 0) {</code></p>
      <p><code>75   if (close(fd) &lt; 0) {</code></p>
      <p><code>76    fprintf(stderr, "%s: %s: close error: %s\n",</code></p>
      <p><code>77     myname, file, strerror(errno));</code></p>
      <p><code>78    errors++;</code></p>
      <p><code>79   }</code></p>
      <p><code>80  }</code></p>
      <p><code>81</code></p>
      <p><code>82  return (errors != 0);</code></p>
      <p><code>83 }</code></p>
      <p><code>ch04-cat</code> проверяет на ошибки каждый системный вызов. Хотя это утомительно, зато предоставляет устойчивость (или по крайней мере, ясность): когда что-то идет не так, <code>ch04-cat</code> выводит сообщение об ошибке, которое специфично настолько, насколько это возможно. В сочетании с <code>errno</code> и <code>strerror()</code> это просто. Вот все с <code>ch04-cat</code>, всего 88 строк кода!</p>
      <p>Для подведения итогов вот несколько важных моментов, которые нужно понять относительно ввода/вывода в Unix:</p>
      <p><emphasis>Ввод/вывод не интерпретируется</emphasis></p>
      <p>Системные вызовы ввода/вывода просто перемешают байты. Они не интерпретируют данные; вся интерпретация оставлена программе уровня пользователя. Это делает чтение и запись двоичных структур таким же простым, как чтение и запись строк текста (на самом деле, проще, хотя использование двоичных данных привносит проблемы переносимости).</p>
      <p><emphasis>Ввод/вывод гибок</emphasis></p>
      <p>За один раз вы можете прочесть или записать столько байтов, сколько захотите. Вы можете даже читать или записывать данные по одному байту за раз, хотя для больших объемов данных это обходится дороже, чем использование больших порций.</p>
      <p><emphasis>Ввод/вывод прост</emphasis></p>
      <p>Три уровня возвращаемых значений (отрицательные для ошибок, ноль для конца файла и положительные для счета) делают программирование простым и очевидным.</p>
      <p><emphasis>Ввод/вывод может быть частичным</emphasis></p>
      <p>Как <code>read()</code>, так и <code>write()</code> могут переместить меньше байтов, чем запрошено. Код приложения (т.е. ваш код) всегда должен учитывать это.</p>
     </section>
     <section>
      <title>
       <p>4.4.4. Пример: Unix <code>cat</code></p>
      </title>
      <p>Как и было обещано, вот версия cat V7<a l:href="#n47" type="note">[47]</a>. Она начинается с проверки опций, <code>cat</code> V7 принимает единственную опцию, <code>-u</code>, для осуществления небуферированного вывода.</p>
      <p>Общая структура сходна с той, которую мы видели ранее; программа перечисляет файлы, указанные в аргументах командной строки и читает каждый файл, по одному символу за раз, посылая этот символ в стандартный вывод. В отличие от нашей версии, она использует возможности <code>&lt;stdio.h&gt;</code>. Во многих случаях код, использующий стандартную библиотеку ввода/вывода, проще читать и писать, поскольку все проблемы с буферами скрыты библиотекой.</p>
      <p><code>1  /*</code></p>
      <p><code>2   * Объединение файлов.</code></p>
      <p><code>3   */</code></p>
      <p><code>4</code></p>
      <p><code>5  #include &lt;stdio.h&gt;</code></p>
      <p><code>6  #include &lt;sys/types.h&gt;</code></p>
      <p><code>7  #include &lt;sys/stat.h&gt;</code></p>
      <p><code>8</code></p>
      <p><code>9  char stdbuf[BUFSIZ];</code></p>
      <p><code>10</code></p>
      <p><code>11 main(argc, argv) /* int main(int argc, char **argv) */</code></p>
      <p><code>12 char **argv;</code></p>
      <p><code>13 {</code></p>
      <p><code>14  int fflg = 0;</code></p>
      <p><code>15  register FILE *fi;</code></p>
      <p><code>16  register c;</code></p>
      <p><code>17  int dev, ino = -1;</code></p>
      <p><code>18  struct stat statb;</code></p>
      <p><code>19</code></p>
      <p><code>20  setbuf(stdout, stdbuf);</code></p>
      <p><code>21  for( ; argc&gt;1 &amp;&amp; argv[1][0] == '-'; argc--, argv++) {</code></p>
      <p><code>22   switch(argv[1][1]) { /* Обработка опций */</code></p>
      <p><code>23   case 0:</code></p>
      <p><code>24    break;</code></p>
      <p><code>25   case 'u':</code></p>
      <p><code>26    setbuf(stdout, (char*)NULL);</code></p>
      <p><code>27    continue;</code></p>
      <p><code>28   }</code></p>
      <p><code>29   break;</code></p>
      <p><code>30  }</code></p>
      <p><code>31  fstat(fileno(stdout), &amp;statb); /* Строки 31-36 объясняются в главе 5 */</code></p>
      <p><code>32  statb.st_mode &amp;= S_IFMT;</code></p>
      <p><code>33  if (statb.st_mode != S_IFCHR &amp;&amp; statb.st_mode != S_IPBLK) {</code></p>
      <p><code>34   dev = statb.st_dev;</code></p>
      <p><code>35   ino = statb.st_ino;</code></p>
      <p><code>36  }</code></p>
      <p><code>37  if (argc &lt; 2) {</code></p>
      <p><code>38   argc = 2;</code></p>
      <p><code>39   fflg++;</code></p>
      <p><code>40  }</code></p>
      <p><code>41  while (--argc &gt; 0) { // Loop over files</code></p>
      <p><code>42   if (fflg || (*++argv)[0] == '-' &amp;&amp; (*argv)[1] == '\0')</code></p>
      <p><code>43    fi = stdin;</code></p>
      <p><code>44   else {</code></p>
      <p><code>45    if ((fi = fopen(*argv, "r")) == NULL) {</code></p>
      <p><code>46     fprintf(stderr, "cat: can't open %s\n", *argv);</code></p>
      <p><code>47    continue;</code></p>
      <p><code>48   }</code></p>
      <p><code>49  }</code></p>
      <p><code>50  fstat(fileno(fi), &amp;statb); /* Строки 50-56 объясняются в главе 5 */</code></p>
      <p><code>51  if (statb.st_dev == dev &amp;&amp; statb.st_ino == ino) {</code></p>
      <p><code>52   fprintf(stderr, "cat: input %s is output\n",</code></p>
      <p><code>53    fflg ? "-" : *argv);</code></p>
      <p><code>54   fclose(fi);</code></p>
      <p><code>55   continue;</code></p>
      <p><code>56  }</code></p>
      <p><code>57  while ((c=getc(fi)) != EOF) /* Копировать содержимое в stdout */</code></p>
      <p><code>58   putchar(с);</code></p>
      <p><code>59  if (fi != stdin)</code></p>
      <p><code>60   fclose(fi);</code></p>
      <p><code>61  }</code></p>
      <p><code>62  return(0);</code></p>
      <p><code>63 }</code></p>
      <p>Следует заметить, что программа всегда завершается успешно (строка 62); можно было написать ее так, чтобы отмечать ошибки и указывать их в возвращаемом значении <code>main()</code>. (Механизм завершения процесса и значение различных кодов завершения обсуждаются в разделе 9.1.5.1 «Определение статуса завершения процесса».)</p>
      <p>Код, работающий с <code>struct stat</code> и функцией <code>fstat()</code> (строки 31–36 и 50–56), без сомнения, непрозрачен, поскольку мы еще не рассматривали эти функции и не будем рассматривать до следующей главы (Но обратите внимание на использование <code>fileno()</code> в строке 50 для получения нижележащего дескриптора файла, связанного с переменными <code>FILE*</code>.) Идея в основе этого кода заключается в том, чтобы убедиться, что входной и выходной файлы не совпадают. Это предназначено для предотвращения бесконечного роста файла, в случае подобной команды:</p>
      <p><code>$ <strong>cat myfile &gt;&gt; myfile</strong> /* Добавить копию myfile к себе? */</code></p>
      <p>И конечно же, проверка работает:</p>
      <p><code>$ <strong>echo hi &gt; myfile</strong> /* Создать файл */</code></p>
      <p><code>$ <strong>v7cat myfile &gt;&gt; myfile</strong> /* Попытка добавить файл к себе */</code></p>
      <p><code>cat: input myfile is output</code></p>
      <p>Если вы попробуете это с <code>ch04-cat</code>, программа продолжит работу, и <code>myfile</code> будет расти до тех пор, пока вы не прервете ее. GNU версия <code>cat</code> осуществляет эту проверку. Обратите внимание, что что-то вроде этого выходит за рамки контроля <code>cat</code>:</p>
      <p><code>$ <strong>v7cat &lt; myfile &gt; myfile</strong></code></p>
      <p><code>cat: input - is output</code></p>
      <p><code>$ <strong>ls -l myfile</strong></code></p>
      <p><code>-rw-r--r-- 1 arnold devel 0 Mar 24 14:17 myfile</code></p>
      <p>В данном случае это слишком поздно, поскольку <emphasis>оболочка</emphasis> урезала файл <code>myfile</code> (посредством оператора <code>&gt;</code>) еще до того, как <code>cat</code> получила возможность исследовать файл! В разделе 5.4.4.2 «Возвращаясь к V7 cat» мы объясним код с <code>struct stat</code>.</p>
     </section>
    </section>
    <section>
     <title>
      <p>4.5. Произвольный доступ: перемещения внутри файла</p>
     </title>
     <p>До сих пор мы обсуждали <emphasis>последовательный</emphasis> ввод/вывод, при котором данные читаются или записываются с начала файла и продолжаются до его конца. Часто это все, что требуется программе. Однако, возможно осуществление <emphasis>произвольного</emphasis> ввода/вывода; т.е. читать данные из произвольного положения в файле без необходимости предварительного чтения всего, что находится перед этим местом.</p>
     <p><emphasis>Смещение</emphasis> дескриптора файла является положением внутри открытого файла, начиная с которого будет осуществляться следующая операция чтения или записи. Программа устанавливает смещение с помощью системного вызова <code>lseek()</code>:</p>
     <p><code>#include &lt;sys/types.h&gt; /* для off_t; POSIX */</code></p>
     <p><code>#include &lt;unistd.h&gt; /* объявления lseek() и значений whence */</code></p>
     <empty-line/>
     <p><code>off_t lseek(int fd, off_t offset, int whence);</code></p>
     <p>Тип <code>off_t</code> (тип смещения) является знаковым целым, представляющим позиции байтов (смещений от начала) внутри файла. На 32-разрядных системах тип представлен обычно как <code>long</code>. Однако, многие современные системы допускают очень большие файлы, в этом случае <code>off_t</code> может быть более необычным типом, таким, как C99 <code>int64_t</code> или какой-нибудь другой <emphasis>расширенный</emphasis> тип. <code>lseek()</code> принимает три следующих аргумента.</p>
     <p><code>int fd</code></p>
     <p>Дескриптор открытого файла.</p>
     <p><code>off_t offset</code></p>
     <p>Позиция, в которую нужно переместиться. Интерпретация этого значения зависит от параметра <code>whence</code>. <code>offset</code> может быть положительным или отрицательным; отрицательные значения перемещают к началу файла; положительные значения перемещают к концу файла.</p>
     <p><code>int whence</code></p>
     <p>Описывает положение в файле, относительно которого отсчитывается <code>offset</code>. См. табл. 4.4.</p>
     <empty-line/>
     <p><strong>Таблица 4.4</strong>. Значения <code>whence</code> для <code>lseek()</code></p>
     <table>
      <tr align="left">
       <th align="left" valign="top">Именованная константа</th>
       <th align="left" valign="top">Значение</th>
       <th align="left" valign="top">Комментарий</th>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>SEEK_SET</code></td>
       <td align="left" valign="top">0</td>
       <td align="left" valign="top"><code>offset</code> абсолютно, т.е. относительно начала файла</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>SEEK_CUR</code></td>
       <td align="left" valign="top">1</td>
       <td align="left" valign="top"><code>offset</code> относительно текущей позиции в файле</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>SEEK_END</code></td>
       <td align="left" valign="top">2</td>
       <td align="left" valign="top"><code>offset</code> относительно конца файла.</td>
      </tr>
     </table>
     <p>Большое количество старого кода использует числовые значения, приведенные в табл. 4.4. Однако, любой новый код, который вы пишете, должен использовать символические имена, значение которых более ясно.</p>
     <p>Смысл значений и их действие на положение в файле показаны на рис. 4.1. При условии, что файл содержит 3000 байтов и что перед каждым вызовом <code>lseek()</code> текущим является смещение 2000 байтов, новое положение после каждого вызова будет следующим.</p>
     <image l:href="#img_4.png"/>
     <p><strong>Рис. 4.1</strong>. Смещения для <code>lseek()</code></p>
     <p>Отрицательные смещения относительно начала файла бессмысленны; они вызывают ошибку «недействительный параметр».</p>
     <p>Возвращаемое значение является новым положением в файле. Поэтому, чтобы получить ваше текущее местоположение в файле, используйте</p>
     <p><code>off_t curpos;</code></p>
     <p><code>...</code></p>
     <p><code>curpos = lseek(fd, (off_t)0, SEEK_CUR);</code></p>
     <p>Буква <code>l</code> в <code>lseek()</code> означает <code>long</code>. <code>lseek()</code> был введен в V7 Unix, когда размеры файлов были увеличены; в V6 был простой системный вызов <code>seek()</code>. В результате большое количество старой документации (и кода) рассматривает параметр offset как имеющий тип <code>long</code>, и вместо приведения к типу <code>off_t</code> довольно часто можно видеть суффикс L в константных значениях смешений:</p>
     <p><code>curpos = lseek(fd, 0L, SEEK_CUR);</code></p>
     <p>На системах с компилятором стандартного С, где <code>lseek()</code> объявлена с прототипом, такой старый код продолжает работать, поскольку компилятор автоматически преобразует 0L из <code>long</code> в <code>off_t</code>, если это различные типы.</p>
     <p>Одной интересной и важной особенностью <code>lseek()</code> является то, что она способна устанавливать смещение за концом файла. Любые данные, которые впоследствии записываются в это место, попадают в файл, но с образованием «интервала» или «дыры» между концом предыдущих данных файла и началом новых данных. Данные в промежутке читаются, как если бы они содержали все нули.</p>
     <p>Следующая программа демонстрирует создание дыр. Она записывает три экземпляра <code>struct</code> в начало, середину и дальний конец файла. Выбранные смешения (строки 16–18, третий элемент каждой структуры) произвольны, но достаточно большие для демонстрации особенности:</p>
     <p><code>1  /* ch04-holes.c --- Демонстрация lseek() и дыр в файлах. */</code></p>
     <p><code>2</code></p>
     <p><code>3  #include &lt;stdio.h&gt; /* для fprintf(), stderr, BUFSIZ */</code></p>
     <p><code>4  #include &lt;errno.h&gt; /* объявление errno */</code></p>
     <p><code>5  #include &lt;fcntl.h&gt; /* для flags для open() */</code></p>
     <p><code>6  #include &lt;string.h&gt; /* объявление strerror() */</code></p>
     <p><code>7  #include &lt;unistd.h&gt; /* для ssize_t */</code></p>
     <p><code>8  #include &lt;sys/types.h&gt; /* для off_t, etc. */</code></p>
     <p><code>9  #include &lt;sys/stat.h&gt;  /* для mode_t */</code></p>
     <p><code>10</code></p>
     <p><code>11 struct person {</code></p>
     <p><code>12  char name[10]; /* имя */</code></p>
     <p><code>13  char id[10]; /* идентификатор */</code></p>
     <p><code>14  off_t pos; /* положение в файле для демонстрации */</code></p>
     <p><code>15 } people[] = {</code></p>
     <p><code>16  { "arnold", "123456789", 0 },</code></p>
     <p><code>17  { "miriam", "987654321", 10240 },</code></p>
     <p><code>18  { "joe", "192837465", 81920 },</code></p>
     <p><code>19 };</code></p>
     <p><code>20</code></p>
     <p><code>21 int</code></p>
     <p><code>22 main(int argc, char **argv)</code></p>
     <p><code>23 {</code></p>
     <p><code>24  int fd;</code></p>
     <p><code>25  int i, j;</code></p>
     <p><code>26</code></p>
     <p><code>27  if (argc &lt; 2) {</code></p>
     <p><code>28   fprintf(stderr, "usage: %s file\n", argv[0]);</code></p>
     <p><code>29   return 1;</code></p>
     <p><code>30  }</code></p>
     <p><code>31</code></p>
     <p><code>32  fd = open(argv[1], O_RDWR | O_CREAT | O_TRUNC, 0666);</code></p>
     <p><code>33  if (fd &lt; 0) {</code></p>
     <p><code>34   fprintf(stderr, "%s: %s: cannot open for read/write: %s\n",</code></p>
     <p><code>35    argv[0], argv[1], strerror(errno));</code></p>
     <p><code>36   return 1;</code></p>
     <p><code>37  }</code></p>
     <p><code>38</code></p>
     <p><code>39  j = sizeof(people) / sizeof(people[0]); /* число элементов */</code></p>
     <p>Строки 27–30 гарантируют, что программа была вызвана правильно. Строки 32–37 открывают именованный файл и проверяют успешность открытия.</p>
     <p>Вычисление числа элементов <code>j</code> массива в строке 39 использует отличный переносимый трюк число элементов является размером всего массива, поделенного на размер первого элемента. Красота этого способа в том, что он всегда верен: неважно, сколько элементов вы добавляете в массив или удаляете из него, компилятор это выяснит. Он не требует также завершающей <emphasis>сигнальной метки</emphasis>; т.е. элемента, в котором все поля содержат нули, <code>NULL</code> или т.п.</p>
     <p>Работа осуществляется в цикле (строки 41–55), который отыскивает смещение байтов, приведенное в каждой структуре (строка 42), а затем записывает всю структуру (строка 49):</p>
     <p><code>41  for (i = 0; i &lt; j; i++) {</code></p>
     <p><code>42   if (lseek(fd, people[i].pos, SEEK_SET) &lt; 0) {</code></p>
     <p><code>43    fprintf(stderr, "%s: %s: seek error: %s\n",</code></p>
     <p><code>44     argv[0], argv[1], strerror(errno));</code></p>
     <p><code>45    (void)close(fd);</code></p>
     <p><code>46    return 1;</code></p>
     <p><code>47   }</code></p>
     <p><code>48</code></p>
     <p><code>49   if (write(fd, &amp;people[i], sizeof(people[i])) != sizeof(people[i])) {</code></p>
     <p><code>50    fprintf(stderr, "%s: %s: write error: %s\n",</code></p>
     <p><code>51     argv[0], argv[1], strerror(errno));</code></p>
     <p><code>52    (void)close(fd);</code></p>
     <p><code>53    return 1;</code></p>
     <p><code>54   }</code></p>
     <p><code>55  }</code></p>
     <p><code>56</code></p>
     <p><code>57  /* здесь все нормально */</code></p>
     <p><code>58  (void)close(fd);</code></p>
     <p><code>59  return 0;</code></p>
     <p><code>60 }</code></p>
     <p>Вот результаты запуска программы:</p>
     <p><code>$ <strong>ch04-holes peoplelist</strong> /* Запустить программу */</code></p>
     <p><code>$ <strong>ls -ls peoplelist</strong> /* Показать использованные размеры и блоки */</code></p>
     <p><code>16 -rw-r--r-- 1 arnold devel 81944 Mar 23 17:43 peoplelist</code></p>
     <p><code>$ <strong>echo 81944 / 4096 | bc -l</strong> /* Показать блоки, если нет дыр */</code></p>
     <p><code>20.00585937500000000000</code></p>
     <p>Случайно мы знаем, что каждый дисковый блок файла использует 4096 байтов. (Откуда мы это знаем, обсуждается в разделе 5 4.2 «Получение информации о файле». Пока примите это как данное.) Финальная команда bc указывает, что файлу размером 81944 байтов нужен 21 дисковый блок. Однако, опция -s команды ls, которая сообщает нам, сколько блоков использует файл на самом деле, показывает, что файл использует лишь 16 блоков!<a l:href="#n48" type="note">[48]</a> Отсутствующие блоки в файле являются дырами. Это показано на рис. 4.2.</p>
     <image l:href="#img_5.jpeg"/>
     <p><strong>Рис. 4.2</strong>. Дыры в файле</p>
     <cite>
      <p><strong>ЗАМЕЧАНИЕ</strong>. <code>ch04-holes.c</code> не осуществляет непосредственный двоичный ввод/вывод. Это хорошо демонстрирует красоту ввода/вывода с произвольным доступом: вы можете рассматривать дисковый файл, как если бы он был очень большим массивом двоичных структур данных.</p>
      <p>На практике сохранение данных путем использования двоичного ввода/вывода является решением, которое необходимо тщательно взвесить. Например, что если предположить, что вам нужно переместить данные на систему, использующую отличный порядок байтов для целых? Или другие форматы чисел с плавающей точкой? Или на систему с другими требованиями выравнивания? Игнорирование подобных вопросов может стать слишком дорогостоящим.</p>
     </cite>
    </section>
    <section>
     <title>
      <p>4.6. Создание файлов</p>
     </title>
     <section>
      <p>Как было описано ранее, <code>open()</code>, очевидно, открывает лишь существующие файлы. Данный раздел описывает, как создавать новые файлы. Есть две возможности: <code>creat()</code> и <code>open()</code> с дополнительными файлами. Первоначально <code>creat()</code> был единственным способом создания файла, но затем эта возможность была добавлена также и к <code>open()</code>. Оба механизма требуют указания начальных прав доступа к файлу.</p>
     </section>
     <section>
      <title>
       <p>4.6.1. Определение начальных прав доступа к файлу</p>
      </title>
      <p>Как пользователь GNU/Linux, вы знакомы с правами доступа к файлу, выдаваемыми командой '<code>ls -l</code>': на чтение, запись и исполнение для каждого из владельца файла, группы и остальных. Различные сочетания часто выражаются в восьмеричной форме, в частности, для команд <code>chmod</code> и <code>chmask</code>. Например, права доступа к файлу <code>-rw-r--</code>r-- эквивалентны восьмеричному 0644, a <code>-rwxr-xr-x</code> эквивалентно восьмеричному 0755. (Ведущий 0 в нотации С означает восьмеричные значения.)</p>
      <p>Когда вы создаете файл, вы должны знать, какую защиту необходимо назначить новому файлу. Вы можете сделать это с помощью простого восьмеричного числа, если захотите, и такие числа довольно обычно можно увидеть в старом коде. Однако, лучше использовать побитовую операцию OR для одной или более символических имен из <code>&lt;sys/stat.h&gt;</code>, описанных в табл. 4.5.</p>
      <empty-line/>
      <p><strong>Таблица 4.5</strong>. Символические имена POSIX для режимов доступа к файлу</p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Символическое имя</th>
        <th align="left" valign="top">Значение</th>
        <th align="left" valign="top">Комментарий</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>S_IRWXU</code></td>
        <td align="left" valign="top">00700</td>
        <td align="left" valign="top">Разрешение на чтение, запись и исполнение для владельца</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>S_IRUSR</code></td>
        <td align="left" valign="top">00400</td>
        <td align="left" valign="top">Разрешение на чтение для владельца</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>S_IREAD</code></td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">Аналогично <code>S_IRUSR</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>S_IWUSR</code></td>
        <td align="left" valign="top">00200</td>
        <td align="left" valign="top">Разрешение на запись для владельца</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>S_IWRITE</code></td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">Аналогично <code>S_IWUSR</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>S_IXUSR</code></td>
        <td align="left" valign="top">00100</td>
        <td align="left" valign="top">Разрешение на исполнение для владельца.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>S_IEXEC</code></td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">Аналогично <code>S_IXUSR</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>S_IRWXG</code></td>
        <td align="left" valign="top">00070</td>
        <td align="left" valign="top">Разрешение на чтение, запись и исполнение для группы</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>S_IRGRP</code></td>
        <td align="left" valign="top">00040</td>
        <td align="left" valign="top">Разрешение на чтение для группы</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>S_IWGRP</code></td>
        <td align="left" valign="top">00020</td>
        <td align="left" valign="top">Разрешение на запись для группы.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>S_IXGRP</code></td>
        <td align="left" valign="top">00010</td>
        <td align="left" valign="top">Разрешение на исполнение для группы</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>S_IRWXO</code></td>
        <td align="left" valign="top">00007</td>
        <td align="left" valign="top">Разрешение на чтение, запись и исполнение для остальных.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>S_IROTH</code></td>
        <td align="left" valign="top">00004</td>
        <td align="left" valign="top">Разрешение на чтение для остальных.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>S_IWOTH</code></td>
        <td align="left" valign="top">00002</td>
        <td align="left" valign="top">Разрешение на запись для остальных</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>S_IXOTH</code></td>
        <td align="left" valign="top">00001</td>
        <td align="left" valign="top">Разрешение на исполнение для остальных</td>
       </tr>
      </table>
      <p>Следующий фрагмент показывает, как создать переменные, представляющие разрешения <code>-rw-r--r--</code> и <code>-rwxr-xr-x</code> (0644 и 0755 соответственно):</p>
      <p><code>mode_t rw_mode, rwx_mode;</code></p>
      <p><code>rw_mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH; /* 0644 */</code></p>
      <p><code>rwx_mode = S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH; /* 0755 */</code></p>
      <p>Более старый код использовал <code>S_IREAD</code>, <code>S_IWRITE</code> и <code>S_IEXEC</code> вместе со сдвигом битов для получения того же результата:</p>
      <p><code>mode_t rw_mode, rwx_mode;</code></p>
      <p><code>rw_mode = (S_IREAD|S_IWRITE) | (S_IREAD &gt;&gt; 3) | (S_IREAD &gt;&gt; 6); /* 0644 */</code></p>
      <p><code>rwx_mode = (S_IREAD|S_IWRITE|S_IEXEC) |</code></p>
      <p><code> ((S_IREAD|S_IEXEC) &gt;&gt; 3) | ((S_IREAD|S_IEXEC) &gt;&gt; 6); /* 0755 */</code></p>
      <p>К сожалению, ни одна из записей не является очень удобной. Современные версии предпочтительнее, поскольку у каждого бита доступа есть собственное имя и меньше вероятность неправильного выполнения побитовых операций.</p>
      <p>При изменении прав доступа к файлу для использования доступны биты дополнительных разрешений, показанные в табл. 4.6, но они не должны использоваться при первоначальном создании файла. Возможность включения этих битов широко варьирует между операционными системами. Лучше всего не пробовать; вместо этого следует изменить права доступа к файлу явным образом после его создания. (Изменение прав доступа описано в разделе 5.5.2 «Изменение прав доступа: <code>chmod()</code> и <code>fchmod()</code>». Значения этих битов обсуждаются в главе 11 «Права доступа и идентификаторы пользователя и группы».)</p>
      <empty-line/>
      <p><strong>Таблица 4.6</strong>. Дополнительные символические имена POSIX для режимов доступа к файлам</p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Символическое имя</th>
        <th align="left" valign="top">Значение</th>
        <th align="left" valign="top">Смысл</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>S_ISUID</code></td>
        <td align="left" valign="top">04000</td>
        <td align="left" valign="top">Установить ID пользователя</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>S_ISGID</code></td>
        <td align="left" valign="top">02000</td>
        <td align="left" valign="top">Установить ID группы</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>S_ISVTX</code></td>
        <td align="left" valign="top">01000</td>
        <td align="left" valign="top">Сохранить текст</td>
       </tr>
      </table>
      <p>Когда стандартные утилиты создают файлы, они по умолчанию используют права доступа <code>-rw-rw-rw-</code> (или 0666). Поскольку большинство пользователей предпочитают избегать файлов, в которые может записывать кто угодно, каждый процесс имеет при себе <emphasis>umask</emphasis>. <code>umask</code> является набором битов допуска, указывающим те биты, которые никогда не должны устанавливаться <emphasis>при создании новых файлов</emphasis>, (umask не используется при изменении прав доступа.) Концептуально осуществляется операция</p>
      <p><code>действительные_права = (затребованные_права &amp; (~umask));</code></p>
      <p><code>umask</code> обычно устанавливается с помощью команды <code>umask</code> в <code>$НОМЕ/.profile</code>, когда вы входите в систему. Из программы С она устанавливается с помощью системного вызова <code>umask()</code>.</p>
      <p><code>#include &lt;sys/types.h&gt; /* POSIX */</code></p>
      <p><code>#include &lt;sys/stat.h&gt; mode_t umask(mode_t mask);</code></p>
      <p>Возвращается старое значение <code>umask</code>. Поэтому для определения текущей маски нужно установить новое значение, а затем восстановить старое (или изменить его при необходимости):</p>
      <p><code>mode_t mask = umask(0); /* получить текущую маску */</code></p>
      <p><code>(void)umask(mask); /* восстановить ее */</code></p>
      <p>Вот пример работы <code>umask</code> на уровне оболочки:</p>
      <p><code>$ <strong>umask</strong> /* Показать текущую маску */</code></p>
      <p><code>0022</code></p>
      <p><code>$ <strong>touch newfile</strong> /* Создать файл */</code></p>
      <p><code>$ <strong>ls -l newfile</strong> /* Показать права доступа нового файла */</code></p>
      <p><code>-rw-r--r-- 1 arnold devel 0 Mar 24 15:43 newfile</code></p>
      <p><code>$ <strong>umask 0</strong> /* Установить пустую маску */</code></p>
      <p><code>$ <strong>touch newfile2</strong> /* Создать второй файл */</code></p>
      <p><code>$ <strong>ls -l newfile2</strong> /* Показать права доступа нового файла */</code></p>
      <p><code>-rw-rw-rw- 1 arnold devel 0 Mar 24 15:44 newfile2</code></p>
     </section>
     <section>
      <title>
       <p>4.6.2. Создание файлов с помощью <code>creat()</code></p>
      </title>
      <p>Системный вызов <code>creat()</code><a l:href="#n49" type="note">[49]</a> создает новые файлы. Он объявлен следующим образом:</p>
      <p><code>#include &lt;sys/types.h&gt; /* POSIX */</code></p>
      <p><code>#include &lt;sys/stat.h&gt;</code></p>
      <p><code>#include &lt;fcntl.h&gt;</code></p>
      <empty-line/>
      <p><code>int creat(const char *pathname, mode_t mode);</code></p>
      <p>Аргумент <code>mode</code> представляет права доступа к новому файлу (как обсуждалось в предыдущем разделе). Создается файл с именем <code>pathname.с</code> данными правами доступа, модифицированными с использованием <code>umask</code>. Он открыт (только) для чтения, а возвращаемое значение является дескриптором нового файла или -1, если была проблема. В последнем случае <code>errno</code> указывает ошибку. Если файл уже существует, он будет при открытии урезан.</p>
      <p>Во всех остальных отношениях дескрипторы файлов, возвращаемые <code>creat()</code>, являются теми же самыми, которые возвращаются <code>open()</code>; они используются для записи и позиционирования и должны закрываться при помощи <code>close()</code>:</p>
      <p><code>int fd, count;</code></p>
      <p><code>/* Проверка ошибок для краткости опущена */</code></p>
      <p><code>fd = creat("/some/new/file", 0666);</code></p>
      <p><code>count = write(fd, "some data\n", 10);</code></p>
      <p><code>(void)close(fd);</code></p>
     </section>
     <section>
      <title>
       <p>4.6.3. Возвращаясь к open()</p>
      </title>
      <p>Вы можете вспомнить объявление для <code>open()</code>:</p>
      <p><code>int open(const char *pathname, int flags, mode_t mode);</code></p>
      <p>Ранее мы сказали, что при открытии файла для простого ввода/вывода мы можем игнорировать аргумент <code>mode</code>. Хотя, посмотрев на <code>creat()</code>, вы, возможно, догадались, что <code>open()</code> также может использоваться для создания файлов и что в этом случае используется аргумент <code>mode</code>. Это в самом деле так.</p>
      <p>Помимо флагов <code>O_RDONLY</code>, <code>O_WRONLY</code> и <code>O_RDWR</code>, при вызове <code>open()</code> могут добавляться с использованием поразрядного <code>OR</code> дополнительные флаги. Стандарт POSIX предоставляет ряд этих дополнительных флагов. В табл. 4.7 представлены флаги, которые используются для большинства обычных приложений.</p>
      <empty-line/>
      <p><strong>Таблица 4.7</strong>. Дополнительные флаги POSIX для <code>open()</code></p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Флаг</th>
        <th align="left" valign="top">Значение</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>O_APPEND</code></td>
        <td align="left" valign="top">Принудительно осуществляет все записи в конец файла</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>O_CREAT</code></td>
        <td align="left" valign="top">Создает новый файл, если он не существует.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>O_EXCL</code></td>
        <td align="left" valign="top">При использовании вместе с <code>O_CREAT</code> возвращает ошибку, если файл уже существует</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>O_TRUNC</code></td>
        <td align="left" valign="top">Урезает файл (устанавливает его длину в 0), если он существует.</td>
       </tr>
      </table>
      <p>Если даны <code>O_APPEND</code> и <code>O_TRUNC</code>, можно представить, как оболочка могла бы открывать или создавать файлы, соответствующие операторам <code>&gt;</code> и <code>&gt;&gt;</code>. Например:</p>
      <p><code>int fd;</code></p>
      <p><code>extern char *filename;</code></p>
      <p><code>mode_t mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH; /* 0666 */</code></p>
      <p><code>fd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, mode); /* для &gt; */</code></p>
      <p><code>fd = open(filename, O_CREAT | O_WRONLY | O_APPEND, mode); /* для &gt;&gt; */</code></p>
      <p>Обратите внимание, что флаг <code>O_EXCL</code> здесь не используется, поскольку как для <code>&gt;</code>, так и для <code>&gt;&gt;</code> не является ошибкой существование файла. Запомните также, что система применяет к запрошенным правам доступа <code>umask</code>.</p>
      <p>Также легко видеть, что, по крайней мере концептуально, <code>creat()</code> можно было бы легко написать следующим образом:</p>
      <p><code>int creat(const char *path, mode_t mode) {</code></p>
      <p><code> return open(path, O_CREAT | O_WRONLY | O_TRUNC, mode);</code></p>
      <p><code>}</code></p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Если файл открыт с флагом <code>O_APPEND</code>, все данные будут записаны в конец файла, даже если текущее смещение было восстановлено с помощью <code>lseek()</code>.</p>
      </cite>
      <p>Современные системы предоставляют дополнительные флаги с более специализированным назначением. Они кратко описаны в табл. 4.8.</p>
      <empty-line/>
      <p><strong>Таблица 4.8</strong>. Дополнительные расширенные флаги POSIX для <code>open()</code></p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Флаг</th>
        <th align="left" valign="top">Значение</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>O_APPEND</code></td>
        <td align="left" valign="top">Принудительно осуществляет все записи в конец файла</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>O_CREAT</code></td>
        <td align="left" valign="top">Создает новый файл, если он не существует.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>O_EXCL</code></td>
        <td align="left" valign="top">При использовании вместе с <code>O_CREAT</code> возвращает ошибку, если файл уже существует</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>O_TRUNC</code></td>
        <td align="left" valign="top">Урезает файл (устанавливает его длину в 0), если он существует.</td>
       </tr>
      </table>
      <p>Флаги <code>O_DSYNC</code>, <code>O_RSYNC</code> и <code>O_SYNC</code> требуют некоторых пояснений. Системы Unix (включая Linux) содержат внутренний кэш дисковых блоков, который называется <emphasis>буферным кэшем (buffer cache)</emphasis>. Когда возвращается системный вызов <code>write()</code>, данные, переданные операционной системе, были скопированы в буфер в буферном кэше. Они необязательно были записаны на диск.</p>
      <p>Буферный кэш значительно повышает производительность: поскольку дисковый ввод/ вывод часто на порядок и медленнее операций центрального процессора и памяти, программы значительно снизили бы производительность, если бы им пришлось ждать завершения каждой записи на диск. Вдобавок, если данные были недавно записаны на диск, при последующем чтении тех же данных они уже находились бы в буферном кэше, откуда их можно вернуть немедленно, не дожидаясь завершения операции чтения с диска.</p>
      <p>Системы Unix осуществляют также <emphasis>опережающее чтение</emphasis>; поскольку чтение в большинстве случаев последовательное, операционная система после прочтения одного блока осуществляет чтение нескольких дополнительных последовательных блоков таким образом, что эта информация будет уже находиться в кэше, когда программа ее запросит. Если один и тот же файл читают несколько программ, они все получают преимущество, поскольку все получают свои данные из одной копии дисковых блоков файла в буферном кэше.</p>
      <p>Все это кэширование, конечно, замечательно, но бесплатного обеда не бывает. В то время, пока данные находятся в буферном кэше и до того, как они будут записаны на диск, есть небольшое, но вполне реальное окно, в котором может случиться катастрофа; например, если выключат питание. Современные дисковые приводы обостряют эту проблему: у многих из них есть собственные внутренние буферы, поэтому при записи данных на диск они могут оказаться не записанными на носитель при выключении питания! Это может быть значительной проблемой для небольших систем, которые не находятся в информационном центре с контролируемым энергоснабжением или не имеют источников бесперебойного питания (UPS).<a l:href="#n50" type="note">[50]</a></p>
      <p>Для большинства приложений вероятность того, что данные в буферном кэше могут быть нечаянно потеряны, довольно низка. Однако, для некоторых приложений <emphasis>любой</emphasis> такой шанс неприемлем. Поэтому в системе Unix было введено понятие <emphasis>синхронного ввода/вывода</emphasis>, при котором программе гарантируется, что по возвращении из системного вызова данные безопасно записаны на физическое устройство хранения.</p>
      <p>Флаг <code>O_DSYNC</code> гарантирует целостность данных; данные и любая другая информация, которую операционная система должна найти, записываются на диск до возвращения <code>write()</code>. Однако, вспомогательные данные, такие, как время модификации или доступа к файлу, могут быть не записаны на диск. Флаг <code>O_SYNC</code> требует, чтобы эти данные также были записаны на диск до возвращения <code>write()</code>. (Здесь тоже нет бесплатного обеда; синхронные записи могут серьезно повлиять на производительность программы, заметно ее снизив.)</p>
      <p>Флаг <code>O_RSYNC</code> предназначен для чтения данных: если <code>read()</code> находит данные в буферном кэше, которые были назначены для записи на диск, функция не вернет эти данные до тех пор, пока они не будут записаны. Два других флага влияют на это: в частности, <code>O_SYNC</code> заставит <code>read()</code> ждать, пока не будут также записаны и вспомогательные данные.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Что касается ядра версии 2.4, Linux рассматривает все три флага одинаково со значением флага <code>O_SYNC</code>. Более того, Linux определяет дополнительные флаги, которые специфичны для Linux и предназначены для специального использования. Дополнительные подробности см. в справочной странице GNU/Linux для <emphasis>open</emphasis>(2).</p>
      </cite>
     </section>
    </section>
    <section>
     <title>
      <p>4.7. Форсирование записи данных на диск</p>
     </title>
     <p>Ранее мы описали флаги <code>O_DSYNC</code>, <code>O_RSYNC</code> и <code>O_SYNC</code> для <code>open()</code>. Мы отметили, что использование этих флагов может замедлить программу, поскольку <code>write()</code> не возвращается до тех пор, пока все данные не будут записаны на физический носитель.</p>
     <p>Со слегка более высоким уровнем риска мы можем сами испечь свое пирожное и съесть его. Это осуществляется путем открытия файла без указания флагов <code>O_<emphasis>x</emphasis>SYNC</code>, но с последующим использованием одного из следующих двух системных вызовов в любой момент, когда это необходимо для безопасного перемещения данных на физический носитель:</p>
     <p><code>#include &lt;unistd.h&gt;</code></p>
     <empty-line/>
     <p><code>int fsync(int fd); /* POSIX FSC */</code></p>
     <p><code>int fdatasync(int fd); /* POSIX SIO */</code></p>
     <p>Системный вызов <code>fdatasync()</code> подобен <code>O_DSYNC</code>: он форсирует запись данных на конечное физическое устройство. Системный вызов <code>fsync()</code> подобен <code>O_SYNC</code>, форсируя запись на физическое устройство не только данных файла, но и вспомогательных данных. Вызов <code>fsync()</code> более переносим; он существовал в мире Unix в течение более продолжительного времени, и вероятность его наличия среди широкого ряда систем больше.</p>
     <p>Можно использовать эти вызовы с указателями файлов <code>&lt;stdio.h&gt;</code>, вызвав сначала <code>fflush()</code>, а затем <code>fileno()</code> для получения дескриптора нижележащего файла. Вот функция <code>fpsync()</code>, которая может использоваться для заключения обеих операций в один вызов. Она возвращает в случае успеха 0:</p>
     <p><code>/* fpsync --- синхронизация переменной stdio FILE* */</code></p>
     <p><code>int fpsync(FILE *fp) {</code></p>
     <p><code> if (fp == NULL || fflush(fp) == EOF || fsync(fileno(fp)) &lt; 0)</code></p>
     <p><code>  return -1;</code></p>
     <p><code> return 0;</code></p>
     <p><code>}</code></p>
     <p>Технически оба этих вызова являются расширениями базового стандарта POSIX: <code>fsync()</code> в расширении «Синхронизация файлов» (FSC), a <code>fdatasync()</code> в расширении «Синхронизированный ввод и вывод». Тем не менее, можно без проблем использовать их в системе GNU/Linux</p>
    </section>
    <section>
     <title>
      <p>4.8. Установка длины файла</p>
     </title>
     <p>Два системных вызова позволяют настраивать размер файла:</p>
     <p><code>#include &lt;unistd.h&gt;</code></p>
     <p><code>#include &lt;sys/types.h&gt;</code></p>
     <empty-line/>
     <p><code>int truncate(const char *path, off_t length); /* XSI */</code></p>
     <p><code>int ftruncate(int fd, off_t length); /* POSIX */</code></p>
     <p>Как должно быть очевидно из параметров, <code>truncate()</code> принимает аргумент имени файла, тогда как <code>ftruncate()</code> работает с дескриптором открытого файла. (Обычным является соглашение по именованию пар системных вызовов <code><emphasis>xxx()</emphasis></code> и <code><emphasis>fxxxx()</emphasis></code>, работающих с именами файлов и дескрипторами файлов. Мы увидим несколько примеров в данной и последующих главах.) В обоих случаях аргумент <code>length</code> является новым размером файла.</p>
     <p>Этот системный вызов происходит от 4.2 BSD Unix, и на ранних системах мог использоваться лишь для сокращения длины файла, отсюда и название. (Он был создан, чтобы облегчить реализацию операции урезания в Фортране.) На современных системах, включая Linux, имя является неправильным, поскольку с помощью этих вызовов можно также увеличить, а не только сократить длину файла. (Однако, POSIX указывает, что возможность увеличения размера файла относится к расширению XSI.)</p>
     <p>Для этих вызовов сокращаемый файл должен иметь разрешение на запись (для <code>truncate()</code>), или должен быть открыт для записи (для <code>ftruncate()</code>). Если файл сокращается, все данные после нового конца файла теряются. (Поэтому вы не можете сократить файл, снова удлинить его и найти там первоначальные данные.) Если файл-расширен, как в случае записи данных после <code>lseek()</code>, данные между старым концом файла и новым концом файла читаются как нули.</p>
     <p>Эти вызовы сильно отличаются от '<code>open(file, ... | O_TRUNC, mode)</code>', который полностью урезает файл, отбрасывая все его данные. Эти же вызовы просто устанавливают абсолютную длину файла в данное значение.</p>
     <p>Эти функции довольно специализированы; они используются лишь четыре раза во всем коде GNU Coreutils. Мы представляем пример использования <code>ftruncate()</code> в разделе 5.5.3 «Изменение отметок времени: <code>utime()</code>».</p>
    </section>
    <section>
     <title>
      <p>4.9. Резюме</p>
     </title>
     <p>• Когда системный вызов завершается неудачей, он обычно возвращает -1, а в глобальной переменной errno устанавливается предопределенное значение, указывающее на проблему. Для сообщений об ошибках могут использоваться функции <code>perror()</code> и <code>strerror()</code>.</p>
     <p>• Доступ к файлам осуществляется через небольшие целые, которые называются дескрипторами. Дескрипторы файлов для стандартного ввода, стандартного вывода и стандартной ошибки наследуются от родительского процесса программы. Другие получаются через <code>open()</code> или <code>creat()</code>. Для их закрытия используется <code>close()</code>, a <code>getdtablesize()</code> возвращает разрешенное максимальное число открытых файлов. Значение <code>umask</code> (устанавливаемое с помощью <code>umask()</code>) влияет на права доступа, получаемые новыми файлами при создании с помощью <code>creat()</code> или с флагом <code>O_CREAT</code> для <code>open()</code>.</p>
     <p>• Системные вызовы <code>read()</code> и <code>write()</code> соответственно читают и записывают данные. Их интерфейс прост. В частности, они не интерпретируют данные, файлы представлены линейными потоками байтов. Системный вызов <code>lseek()</code> осуществляет ввод/выводе произвольным доступом: возможность перемещаться внутри файла.</p>
     <p>• Для синхронного ввода/вывода предусмотрены дополнительные флаги для <code>open()</code>, при этом данные записываются на физический носитель данных до возвращения <code>write()</code> или <code>read()</code>. Можно также форсировать запись данных на диск на управляемой основе с помощью <code>fsync()</code> или <code>fdatasync()</code>.</p>
     <p>• Системные вызовы <code>truncate()</code> и <code>ftruncate()</code> устанавливают абсолютную длину файла. (На более старых системах они могут использоваться лишь для сокращения длины файла; на современных системах они могут также увеличивать файл.)</p>
    </section>
    <section>
     <title>
      <p>Упражнения</p>
     </title>
     <p>1. Используя лишь <code>open()</code>, <code>read(),</code> <code>write()</code> и <code>close()</code>, напишите простую программу <code>copy</code>, которая копирует файл, имя которого дается в первом аргументе, в файл с именем во втором аргументе.</p>
     <p>2. Усовершенствуйте программу <code>copy</code> так, чтобы она принимала "<code>-</code>" в значении «стандартный ввод» при использовании в качестве первого аргумента и в значении «стандартный вывод» в качестве второго аргумента. Правильно ли работает '<code>copy - -</code>'?</p>
     <p>3. Просмотрите страничку справки для <emphasis>proc</emphasis>(5) на системе GNU/Linux. В частности, посмотрите подраздел <code>fd</code>. Выполните '<code>ls -l /dev/fd</code>' и непосредственно проверьте файлы в <code>/proc/self/fd</code>. Если бы <code>/dev/stdin</code> и дружественные устройства были бы в ранних версиях Unix, как это упростило бы код для программы V7 <code>cat</code>? (Во многих других современных системах Unix есть каталог или файловая система <code>/dev/fd</code>. Если вы не используете GNU/Linux, посмотрите, что вы можете обнаружить в своей версии Unix.)</p>
     <p>4. Даже если вы пока этого не понимаете, постарайтесь скопировать сегмент кода из V7 <code>cat.c</code>, который использует <code>struct stat</code> и функцию <code>fstat()</code>, в <code>ch04-cat.c</code>, чтобы она также сообщала об ошибке для '<code>cat file &gt;&gt; file</code>'.</p>
     <p>5. (Простое) Предположив наличие <code>strerror()</code>, напишите свою версию <code>perror()</code>.</p>
     <p>6. Каков результат выполнения '<code>ulimit -n</code>' на вашей системе?</p>
     <p>7. Напишите простую версию программы <code>umask</code>, назвав ее <code>myumask</code>, которая принимает в командной строке восьмеричную маску. Используйте <code>strtol()</code> с основанием 8 для преобразования строки символов аргумента командной строки в целое значение. Измените <code>umask</code> с помощью системного вызова <code>umask()</code>.</p>
     <p>Откомпилируйте и запустите <code>myumask</code>, затем проверьте значение <code>umask</code> с помощью стандартной команды <code>umask</code>. Объясните результаты. (Подсказка: в оболочке Bash введите '<code>type umask</code>'.)</p>
     <p>8. Измените простую программу <code>copy</code>, которую вы написали ранее, для использования <code>open()</code> с флагом <code>O_SYNC</code>. Используя команду <code>time</code>, сравните характеристики первоначальной и новой версии большого файла.</p>
     <p>9. Мы сказали, что для <code>ftruncate()</code> файл должен быть открыт для записи. Как можно открыть файл для записи, когда у самого файла нет доступа записи?</p>
     <p>10. Напишите программу <code>truncate</code>, которая используется следующим образом: '<code>truncate <emphasis>длина_файла</emphasis></code>'.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 5</p>
     <p>Каталоги и служебные данные файлов</p>
    </title>
    <section>
     <p>Данная глава продолжает подъем по кривой обучения до следующего плато: понимания каталогов и информации о файлах.</p>
     <p>В данной главе мы исследуем то, как информация хранится в каталоге, как читаются, создаются и удаляются сами каталоги, какая информация о файлах доступна и как ее получить. Наконец, мы рассмотрим другие способы обновления служебных данных файлов, таких, как владелец, группа, права доступа и время доступа и изменения файла.</p>
    </section>
    <section>
     <title>
      <p>5.1. Просмотр содержимого каталога</p>
     </title>
     <section>
      <p>Все Unix-системы, включая Linux, используют для хранения файловой информации на диске один и тот же концептуальный дизайн. Хотя в реализации дизайна есть значительные вариации, интерфейс на уровне С остается постоянным, давая возможность писать переносимые программы, которые компилируются и запускаются на многих различных системах.</p>
     </section>
     <section>
      <title>
       <p>5.1.1. Определения</p>
      </title>
      <image l:href="#img_6.png"/>
      <p>Рис. Copyright 1997-2004 © J.D. «Illiad» Frazer. Использовано по разрешению, http://www.userfriendly.org</p>
      <p>Мы начнем обсуждение с определения нескольких терминов.</p>
      <p><emphasis>Раздел (partition)</emphasis></p>
      <p>Единица физического хранилища. <emphasis>Физические разделы</emphasis> обычно являются либо частями диска, либо целым диском. Современные системы дают возможность создавать из нескольких физических <emphasis>логические разделы</emphasis>.</p>
      <p><emphasis>Файловая система (filesystem)</emphasis></p>
      <p>Раздел (физический или логический), содержащий данные файла и <emphasis>служебные данные (metadata)</emphasis>, информацию о файлах (в противоположность содержимому файла, которое является информацией в файле). Такие служебные данные включают владельца файла, права доступа, размер и т.д., а также информацию, использующуюся операционной системой при поиске содержимого файла. Файловые системы размещаются «в» разделах (соотношение одни к одному) посредством записи в них стандартной информации. Это осуществляется программой уровня пользователя, такой, как <code>mke2fs</code> в GNU/Linux или <code>newfs</code> в Unix. (Команда Unix <code>mkfs</code> создает разделы, но ее трудно использовать, непосредственно, <code>newfs</code> вызывает ее с нужными параметрами. Если ваша система является системой Unix, подробности см. в справочных страницах для <emphasis>newfs</emphasis>(8) и <emphasis>mkfs</emphasis>(8).)</p>
      <p>Большей частью GNU/Linux и Unix скрывают наличие файловых систем и разделов. (Дополнительные подробности приведены в разделе 8.1 «Монтирование и демонтирование файловых систем».) Доступ ко всему осуществляется через пути, безотносительно к тому, на каком диске расположен файл. (Сравните это с почти любой коммерческой операционной системой, такой, как OpenVMS, или с поведением по умолчанию любой системы Microsoft.)</p>
      <p><emphasis>Индекс (inode)</emphasis></p>
      <p>Сокращение от '<code>index node</code>' (индексный узел), первоначально сокращалось '<code>i-node</code>', а теперь пишется '<code>inode</code>'. Небольшой блок информации, содержащий все сведения о файле, за исключением имени файла. Число индексов и, следовательно, число уникальных файлов в файловой системе, устанавливается и делается постоянным при создании файловой системы. Команда '<code>df -i</code>' может показать, сколько имеется индексов и сколько из них используется.</p>
      <p><emphasis>Устройство (device)</emphasis></p>
      <p>В контексте файлов, файловых систем и служебных данных файлов, уникальный номер, представляющий используемую («смонтированную») файловую систему. Пара (устройство, индекс) <emphasis>однозначно</emphasis> идентифицирует файл: два различных файла будут гарантированно иметь различные пары (устройство, индекс). Более подробно это обсуждается далее в этой главе.</p>
      <p><emphasis>Каталог (directory)</emphasis></p>
      <p>Специальный файл, содержащий список пар (индекс, имя). Каталоги могут быть открыты для чтения, но не для записи; все изменения в содержимом каталога делает операционная система.</p>
      <p>Концептуально каждый дисковый блок содержит либо некоторое число индексов, либо данные файла. Индекс, в свою очередь, содержит указатели на блоки, содержащие данные файла. См. рис. 5.1.</p>
      <image l:href="#img_7.png"/>
      <p><strong>Рис. 5.1</strong>. Концептуальное представление индексов и блоков данных</p>
      <p>На рисунке показаны все блоки индексов перед разделом и блоки данных после них. Ранние файловые системы Unix были организованы именно таким способом. Однако, хотя все современные системы до сих пор содержат индексы и блоки данных, их организация для повышения эффективности и устойчивости была изменена. Детали меняются от системы к системе, и даже в рамках систем GNU/Linux имеется множество разновидностей файловых систем, но концепция остается той же самой.</p>
     </section>
     <section>
      <title>
       <p>5.1.2. Содержимое каталога</p>
      </title>
      <p>Каталоги устанавливают связь между именем файла и индексом. Элементы каталога содержат номер индекса и имя файла. Они содержат также дополнительную учетную информацию, которая нам здесь не интересна. См. рис. 5.2.</p>
      <image l:href="#img_8.png"/>
      <p><strong>Рис. 5.2</strong>. Концептуальное содержание каталога</p>
      <p>На ранних Unix-системах были двухбайтные номера индексов, а имена файлов — до 14 байтов. Вот полное содержание файла V7 <code>/usr/include/sys/dir.h</code>:</p>
      <p><code>#ifndef DIRSIZ</code></p>
      <p><code>#define DIRSIZ 14</code></p>
      <p><code>#endif</code></p>
      <empty-line/>
      <p><code>struct direct {</code></p>
      <p><code> ino_t d_ino;</code></p>
      <p><code> char d_name[DIRSIZ];</code></p>
      <p><code>};</code></p>
      <p><code>ino_t</code> определен в V7 <code>&lt;sys/types.h&gt;</code> как '<code>typedef unsigned int into_t;</code>'. Поскольку на PDP-11 <code>int</code> является 16-разрядным, таким же является и <code>ino_t</code>. Такая организация упрощала непосредственное чтение каталогов; поскольку размер элемента был фиксирован, код был простым. (Единственно, за чем нужно было следить, это то, что полное 14-символьное <code>d_name</code> не завершалось символом NUL.)</p>
      <p>Управление содержанием каталога для системы также было простым. Когда файл удалялся из каталога, система заменяла номер индекса двоичным нулем, указывая, что элемент каталога не используется. Новые файлы могли потом использовать пустой элемент повторно. Это помогало поддерживать размер самих файлов каталогов в приемлемых рамках. (По соглашению, номер индекса 1 не используется; первым используемым индексом всегда является 2. Дополнительные сведения приведены в разделе 8.1 «Монтирование и демонтирование файловых систем».)</p>
      <p>Современные системы предоставляют длинные имена файлов. Каждый элемент каталога имеет различную длину, с обычным ограничением для компонента имени файла каталога в 255 байтов. Далее мы увидим, как читать на современных системах содержимое каталога. Также в современных системах номера индексов 32 (или даже 64!) разрядные.</p>
     </section>
     <section>
      <title>
       <p>5.1.3. Прямые ссылки</p>
      </title>
      <section>
       <p>Когда файл создается с помощью <code>open()</code> или <code>creat()</code>, система находит не использующийся индекс и присваивает его новому файлу. Она создает для файла элемент каталога с именем файла и номером индекса. Опция <code>-i</code> команды <code>ls</code> отображает номер индекса.</p>
       <p><code>$ <strong>echo hello, world &gt; message</strong> /* Создать новый файл */</code></p>
       <p><code>$ <strong>ls -il message</strong> /* Показать также номер индекса */</code></p>
       <p><code>228786 -rw-r--r-- 1 arnold devel 13 May 4 15:43 message</code></p>
       <p>Поскольку элементы каталога связывают имена файлов с индексами, у одного файла может быть несколько имен. Каждый элемент каталога, ссылающийся на один и тот же индекс, называется <emphasis>ссылкой (link)</emphasis> или <emphasis>прямой ссылкой (hard link)</emphasis> на файл. Ссылки создаются с помощью команды <code>ln</code>. Она используется следующим образом: '<code>ln <emphasis>старый_файл новый_файл</emphasis></code>'.</p>
       <p><code>$ <strong>ln message msg</strong> /* Создать ссылку */</code></p>
       <p><code>$ <strong>cat msg</strong> /* Показать содержание нового имени */</code></p>
       <p><code>hello, world</code></p>
       <p><code>$ <strong>ls -il msg message</strong> /* Показать номера индексов */</code></p>
       <p><code>228786 -rw-r--r-- 2 arnold devel 13 May 4 15:43 message</code></p>
       <p><code>228786 -rw-r--r-- 2 arnold devel 13 May 4 15:43 msg</code></p>
       <p>Вывод показывает, что номера индексов двух файлов одинаковые, а третье поле расширенного вывода теперь равно 2. Это поле показывает <emphasis>счетчик ссылок</emphasis>, указывающий, сколько имеется ссылок (элементов каталога, ссылающихся на данный индекс) на данный файл.</p>
       <p>Нельзя не подчеркнуть: <emphasis>прямые ссылки все относятся к одному и тому же файлу</emphasis>. Если вы измените один файл, изменятся и все остальные:</p>
       <p><code>$ <strong>echo "Hi, how ya doin' ?" &gt; msg</strong> /* Изменить файл через новое имя */</code></p>
       <p><code>$ <strong>cat message </strong>/* Показать содержание через старое имя */</code></p>
       <p><code>Hi, how ya doin' ?</code></p>
       <p><code>$ <strong>ls -il message msg</strong> /* Отобразить сведения. Размер изменился */</code></p>
       <p><code>228786 -rw-r--r-- 2 arnold devel 19 May 4 15:51 message</code></p>
       <p><code>228786 -rw-r--r-- 2 arnold devel 19 May 4 15:51 msg</code></p>
       <p>Хотя мы создали две ссылки на один файл в одном каталоге, прямые ссылки не обязательно должны находиться в одном и том же каталоге; они могут находиться в любом каталоге в той же самой файловой системе. (Несколько подробнее это обсуждается в разделе 5.1.6 «Символические ссылки».)</p>
       <p>Вдобавок, вы можете создать ссылку на файл, который вам не принадлежит, если у вас есть право записи в каталоге, в котором вы создаете ссылку. (Такой файл сохраняет все атрибуты первоначального файла: владельца, права доступа и т.д. Это потому, что это <emphasis>и есть</emphasis> оригинальный файл; просто он получил дополнительное имя.) Код уровня пользователя не может создать прямую ссылку на каталог.</p>
       <p>После удаления ссылки создание еще одного файла с прежним именем создает новый файл:</p>
       <p><code>$ <strong>rm message</strong> /* Удалить старое имя */</code></p>
       <p><code>$ <strong>echo "What's happenin?" &gt; message</strong> /* Повторно использовать имя */</code></p>
       <p><code>$ <strong>ls -il msg message</strong> /* Отобразить сведения */</code></p>
       <p><code>228794 -rw-r--r-- 1 arnold devel 17 May 4 15:58 message</code></p>
       <p><code>228786 -rw-r--r-- 1 arnold devel 19 May 4 15:51 msg</code></p>
       <p>Обратите внимание, что теперь счетчик ссылок каждого из файлов равен 1. На уровне С ссылки создаются с помощью системного вызова <code>link()</code>:</p>
       <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
       <p><code>int link(const char *oldpath, const char *newpath);</code></p>
       <p>При успешном создании ссылки возвращается 0, в противном случае (-1), при этом errno отражает ошибку. Важным-случаем ошибки является тот, когда <code>newpath</code> уже существует. Система не удалит его для вас, поскольку попытка сделать это может вызвать несовместимости в файловой системе.</p>
      </section>
      <section>
       <title>
        <p>5.1.3.1. Программа GNU link</p>
       </title>
       <p>Программа <code>ln</code> сложная и большая. Однако, GNU Coreutils содержит несложную программу <code>link</code>, которая просто вызывает <code>link()</code> со своими двумя аргументами. Следующий пример показывает код из файла <code>link.с</code>, не относящиеся к делу части удалены. Номера строк относятся к действительному файлу.</p>
       <p><code>20  /* Обзор реализации:</code></p>
       <p><code>21</code></p>
       <p><code>22     Просто вызывает системную функцию 'link' */</code></p>
       <p><code>23</code></p>
       <p><code>    /* ...Операторы #include для краткости опущены... */</code></p>
       <p><code>34</code></p>
       <p><code>35  /* Официальное имя этой программы (например, нет префикса 'g'). */</code></p>
       <p><code>36  #define PROGRAM_NAME "link"</code></p>
       <p><code>37</code></p>
       <p><code>38  #define AUTHORS "Michael Stone"</code></p>
       <p><code>39</code></p>
       <p><code>40  /* Имя, под которым была запущена данная программа. */</code></p>
       <p><code>41  char *program_name;</code></p>
       <p><code>42</code></p>
       <p><code>43  void</code></p>
       <p><code>44  usage(int status)</code></p>
       <p><code>45  {</code></p>
       <p><code>     /*  ... для краткости опущено... */</code></p>
       <p><code>62  }</code></p>
       <p><code>63</code></p>
       <p><code>64  int</code></p>
       <p><code>65  main(int argc, char **argv)</code></p>
       <p><code>66  {</code></p>
       <p><code>67   program_name = argv[0];</code></p>
       <p><code>68   setlocale(LC_ALL, "");</code></p>
       <p><code>69   bindtextdomain(PACKAGE, LOCALEDIR);</code></p>
       <p><code>70   textdomain(PACKAGE);</code></p>
       <p><code>71</code></p>
       <p><code>72   atexit(close_stdout);</code></p>
       <p><code>73</code></p>
       <p><code>74   parse_long_options(argc, argv, PROGRAM_NAME, GNU_PACKAGE,</code></p>
       <p><code>75    VERSION, AUTHORS, usage);</code></p>
       <p><code>76</code></p>
       <p><code>77   /* Вышеприведенное обрабатывает --help и --version.</code></p>
       <p><code>78      Поскольку других вызовов getopt нет, обработать здесь '--'. */</code></p>
       <p><code>79   if (1 &lt; argc &amp;&amp; STREQ(argv[1], "--"))</code></p>
       <p><code>80   {</code></p>
       <p><code>81    --argc;</code></p>
       <p><code>82    ++argv;</code></p>
       <p><code>83   }</code></p>
       <p><code>84</code></p>
       <p><code>85   if (argc &lt; 3)</code></p>
       <p><code>86   {</code></p>
       <p><code>87    error(0, 0, _("too few arguments"));</code></p>
       <p><code>88    usage(EXIT_FAILURE);</code></p>
       <p><code>89   }</code></p>
       <p><code>90</code></p>
       <p><code>91   if (3 &lt; argc)</code></p>
       <p><code>92   {</code></p>
       <p><code>93    error(0, 0, _("too many arguments"));</code></p>
       <p><code>94    usage(EXIT_FAILURE);</code></p>
       <p><code>95   }</code></p>
       <p><code>96</code></p>
       <p><code>97   if (link(argv[1], argv[2]) != 0)</code></p>
       <p><code>98    error(EXIT_FAILURE, errno, _("cannot create link %s to %s"),</code></p>
       <p><code>99     quote_n(0, argv[2]), quote_n(1, argv[1]));</code></p>
       <p><code>100</code></p>
       <p><code>101  exit(EXIT_SUCCESS);</code></p>
       <p><code>102 }</code></p>
       <p>Строки 67–75 являются типичным шаблоном Coreutils, устанавливающими интернациональные настройки, выход по завершении и анализ аргументов. Строки 79–95 гарантируют, что <code>link</code> вызывается лишь с двумя аргументами. Сам системный вызов <code>link()</code> осуществляется в строке 97 (Функция <code>quote_n()</code> обеспечивает отображение аргументов в стиле, подходящем для текущей локали; подробности сейчас несущественны.)</p>
      </section>
      <section>
       <title>
        <p>5.1.3.2. Точка и точка-точка</p>
       </title>
       <p>Завершая обсуждение ссылок, давайте взглянем на то, как обрабатываются специальные имена '<code>.</code>' и '<code>..</code>'. На самом деле они просто являются прямыми ссылками. В первом случае '<code>.</code>' является прямой ссылкой на каталог, содержащий ее, а '<code>..</code>' — прямой ссылкой на родительский каталог. Операционная система создает для вас эти ссылки; как упоминалось ранее, код уровня пользователя не может создать прямую ссылку на каталог. Этот пример иллюстрирует ссылки:</p>
       <p><code>$ <strong>pwd</strong> /* Отобразить текущий каталог */</code></p>
       <p><code>/tmp</code></p>
       <p><code>$ <strong>ls -ldi /tmp</strong> /* Показать номер его индекса */</code></p>
       <p><code>225345 drwxrwxrwt 14 root root 4096 May 4 16:15 /tmp</code></p>
       <p><code>$ <strong>mkdir x</strong> /* Создать новый каталог */</code></p>
       <p><code>$ <strong>ls -ldi x</strong> /* И показать номер его индекса */</code></p>
       <p><code>52794 drwxr-xr-x 2 arnold devel 4096 May 4 16:27 x</code></p>
       <p><code>$ <strong>ls -ldi x/. x/..</strong> /* Показать номера индексов . И .. */</code></p>
       <p><code>52794 drwxr-xr-x 2 arnold devel 4096 May 4 16:27 x/.</code></p>
       <p><code>225345 drwxrwxrwt 15 root root 4096 May 4 16:27 x/..</code></p>
       <p>Родительский каталог корневого каталога (<code>/..</code>) является особым случаем; мы отложим его обсуждение до главы 8 «Файловые системы и обход каталогов».</p>
      </section>
     </section>
     <section>
      <title>
       <p>5.1.4. Переименование файлов</p>
      </title>
      <p>При данном способе отображения элементами каталога имен на номера индексов, переименование файла концептуально очень просто:</p>
      <p>1. Если новое имя файла обозначает существующий файл, сначала удалить этот файл.</p>
      <p>2. Создать новую ссылку на файл через новое имя.</p>
      <p>3. Удалить старое имя (ссылку) для файла. (Удаление имен обсуждается в следующем разделе.)</p>
      <p>Ранние версии команды mv работали таким способом. Однако, при таком способе переименование файла не является <emphasis>атомарным</emphasis>; т.е. оно не осуществляется посредством одной непрерываемой операции. И на сильно загруженной системе злонамеренный пользователь мог бы воспользоваться условиями состояния гонки<a l:href="#n51" type="note">[51]</a>, разрушая операцию переименования и подменяя оригинальный файл другим.</p>
      <p>По этой причине 4.2 BSD ввело системный вызов <code>rename()</code>:</p>
      <p><code>#include &lt;stdio.h&gt; /* ISO С */</code></p>
      <p><code>int rename(const char *oldpath, const char *newpath);</code></p>
      <p>На системах Linux операция переименования является атомарной; справочная страница утверждает:</p>
      <cite>
       <p>Если <code>newpath</code> уже существует, он будет атомарно замещен <code>..,</code> таким образом, что при попытке другого процесса получить доступ к <code>newpath</code> он никогда не обнаружит его отсутствующим.</p>
       <p>Если <code>newpath</code> существует, но по какой-либо причине операция завершается неудачей, <code>rename</code> гарантирует, что экземпляр <code>newpath</code> останется на месте. Однако, в ходе переписывания возможно будет окно, в котором как <code>oldpath</code>, так и <code>newpath</code> ссылаются на переименовываемый файл.</p>
      </cite>
      <p>Как и в случае с другими системными вызовами, возвращенный 0 означает успех, а (-1) означает ошибку.</p>
     </section>
     <section>
      <title>
       <p>5.1.5. Удаление файла</p>
      </title>
      <section>
       <p>Удаление файла означает удаление элемента каталога для файла и уменьшение счетчика ссылок на файл, который содержится в индексе. Содержимое файла и дисковые блоки, в котором оно размешается, не освобождаются до тех пор, пока счетчик ссылок не достигнет нуля.</p>
       <p>Системный вызов называется <code>unlink()</code>:</p>
       <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
       <empty-line/>
       <p><code>int unlink(const char *pathname);</code></p>
       <p><emphasis>В нашем обсуждении ссылок на файлы имя имеет смысл; этот вызов удаляет данную ссылку (элемент каталога) для файла</emphasis>. Она возвращает 0 в случае успеха и -1 при ошибке. Возможность удаления файла требует права записи лишь для каталога, а не для самого файла. Этот факт может сбивать с толку, особенно начинающих пользователей Linux/Unix. Однако, поскольку операция в каталоге одна, это имеет смысл; меняется именно содержимое каталога, а не содержимое файла<a l:href="#n52" type="note">[52]</a>.</p>
      </section>
      <section>
       <title>
        <p>5.1.5.1. Удаление открытых файлов</p>
       </title>
       <p>С самых первых дней Unix было возможно удалять открытые файлы. Просто вызовите <code>unlink()</code> с именем файла после успешного вызова <code>open()</code> или <code>creat()</code>.</p>
       <p>На первый взгляд, это кажется странным. Поскольку система освобождает блоки данных, когда счетчик ссылок на файл достигает нуля, возможно ли использовать открытый файл?</p>
       <p>Ответ — да, вы можете продолжить использовать открытый файл обычным способом. Система знает, что файл открыт, поэтому она откладывает освобождение хранилища файла до тех пор, пока не будет закрыт последний дескриптор файла. Когда файл вообще больше не используется, память освобождается.</p>
       <p>Эта операция также оказывается полезной: это простой способ для программы получить временный файл, который гарантированно будет и конфиденциальным, и автоматически освобождаемым по завершении использования.</p>
       <p><code>/* Получение конфиденциального временного хранилища,</code></p>
       <p><code>   проверка ошибок для краткости опущена */</code></p>
       <p><code>int fd;</code></p>
       <p><code>mode_t mode = O_CREAT | O_EXCL | O_TRUNC | O_RDWR;</code></p>
       <p><code>fd = open("/tmp/myfile", mode, 0000); /* Открыть файл */</code></p>
       <p><code>unlink("/tmp/myfile"); /* Удалить его */</code></p>
       <p><code>/* ... продолжить использование файла... *</code></p>
       <p><code>close(fd); /* Закрыть файл, освободить память */</code></p>
       <p>Недостатком такого подхода является то, что вышедшее из-под контроля приложение может заполнить систему открытыми, но анонимными файлами, в этом случае администраторам придется попытаться найти и завершить этот процесс. В прежние дни могли потребоваться перезагрузка и проверка целостности файловой системы; к счастью, на современных системах это требуется исключительно редко.</p>
      </section>
      <section>
       <title>
        <p>5.1.5.2. Использование ISO С: <code>remove()</code></p>
       </title>
       <p>ISO С предоставляет для удаления файлов функцию <code>remove()</code>; она предназначена в качестве обшей функции, годной для любой системы, поддерживающей ISO С, а не только для Unix и GNU/Linux:</p>
       <p><code>#include &lt;stdio.h&gt; /* ISO С */</code></p>
       <empty-line/>
       <p><code>int remove(const char *pathname);</code></p>
       <p>Хотя технически это не системный вызов, возвращаемое значение в том же стиле: 0 в случае успеха и -1 при ошибке, причем <code>errno</code> содержит значение ошибки.</p>
       <p>В GNU/Linux <code>remove()</code> использует для удаления файлов системный вызов <code>unlink()</code>, а для удаления каталогов — системный вызов <code>rmdir()</code> (обсуждаемый далее в главе). (На более старых системах GNU/Linux, не использующих GLIBC, <code>remove()</code> является псевдонимом для <code>unlink()</code>; поэтому для каталогов завершается неудачей. Если у вас такая система, вам, возможно, следует ее обновить.)</p>
      </section>
     </section>
     <section>
      <title>
       <p>5.1.6. Символические ссылки</p>
      </title>
      <p>Мы начали главу с обсуждения разделов, файловых систем и индексов. Мы также увидели, что элементы каталога связывают имена с номерами индексов. Поскольку элементы каталога не содержат другой информации, прямые ссылки ограничены файлами <emphasis>внутри одной и той же файловой системы</emphasis>. Это должно быть; нет способа отличить индекс 2341 одной файловой системы от индекса 2341 другой файловой системы. Вот что случится, если мы попытаемся это сделать:</p>
      <p><code>$ <strong>mount</strong> /* Показать использующиеся файловые системы */</code></p>
      <p><code>/dev/hda2 on / type ext3 (rw)</code></p>
      <p><code>/dev/hda5 on /d type ext3 (rw)</code></p>
      <p><code>...</code></p>
      <p><code>$ <strong>ls -li /tmp/message</strong> /* Предыдущий пример был в файловой системе / */</code></p>
      <p><code>228786 -rw-r--r-- 2 arnold devel 19 May 4 15:51 /tmp/message</code></p>
      <p><code>$ <strong>cat /tmp/message</strong></code></p>
      <p><code>Hi, how ya doin' ?</code></p>
      <p><code>$ <strong>/bin/pwd</strong> /* Текущий каталог в другой файловой системе */</code></p>
      <p><code>/d/home/arnold</code></p>
      <p><code>$ <strong>ln /tmp/message .</strong> /* Попытка создать ссылку */</code></p>
      <p><code>ln: creating hard link './message' to '/tmp/message': Invalid cross-device link</code></p>
      <p>На больших системах часто много разделов как на физически подключенных локальных дисках, так и на удаленно смонтированных файловых системах. Ограничение прямых ссылок одной и той же файловой системой неудобно, например, если некоторые файлы или каталоги должны быть перемешены в новое место, но старое программное обеспечение использует жестко вшитые в код имена файлов для старых местоположений.</p>
      <p>Чтобы обойти это ограничение, 4.2 BSD ввело <emphasis>символические ссылки</emphasis> (<emphasis>symbolic links</emphasis>, называемые также <emphasis>soft links</emphasis>). Символическая ссылка является особой разновидностью файла (также, как особой разновидностью файла является каталог). Содержимое этого файла представляет собой путь к файлу, на который данный файл «указывает». Все современные Unix-системы, включая Linux, предусматривают символические ссылки; конечно, они теперь являются частью POSIX.</p>
      <p>Символические ссылки могут ссылаться на любой файл в системе. Они могут также ссылаться на каталоги. Это упрощает перемещение каталогов с места на место, когда на старом месте остается символическая ссылка, указывающая на новое положение.</p>
      <p>При обработке имени файла система отмечает символические ссылки и осуществляет требуемые действия в файле или каталоге, который указан. Символические ссылки создаются с помощью опции <code>-s</code> команды <code>ln</code>:</p>
      <p><code>$ <strong>/bin/pwd</strong> /* Где мы находимся */</code></p>
      <p><code>/d/home/arnold /* В другой файловой системе */</code></p>
      <p><code>$ <strong>ln -s /tmp/message ./hello</strong> /* Создать символическую ссылку */</code></p>
      <p><code>$ <strong>cat hello</strong> /* Использовать ее */</code></p>
      <p><code>Hi, how ya doin' ?</code></p>
      <p><code>$ <strong>ls -l hello</strong> /* Отобразить информацию о ней */</code></p>
      <p><code>lrwxrwxrwx 1 arnold devel 12 May 4 16:41 hello -&gt; /tmp/message</code></p>
      <p>Файл, на который указывает ссылка, необязательно должен существовать. Система обнаруживает это во время исполнения и действует соответствующим образом:</p>
      <p><code>$ <strong>rm /tmp/message</strong> /* Удалить указываемый файл */</code></p>
      <p><code>$ <strong>cat ./hello</strong> /* Попытка использования через символическую ссылку */</code></p>
      <p><code>cat: ./hello: No such file or directory</code></p>
      <p><code>$ <strong>echo hi again &gt; hello</strong> /* Создать новое содержание файла */</code></p>
      <p><code>$ <strong>ls -l /tmp/message</strong> /* Показать информацию об указываемом файле */</code></p>
      <p><code>-rw-r--r-- 1 arnold devel 9 May 4 16:45 /tmp/message</code></p>
      <p><code>$ <strong>cat /tmp/message</strong> /* ...и содержание */</code></p>
      <p><code>hi again</code></p>
      <p>Символические ссылки создаются с помощью системного вызова <code>symlink()</code>:</p>
      <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
      <empty-line/>
      <p><code>int symlink(const char *oldpath, const char *newpath);</code></p>
      <p>Аргумент <code>oldpath</code> содержит указываемый файл или каталог, a <code>newpath</code> является именем создаваемой символической ссылки. При успехе возвращается 0, а при ошибке (-1), возможные значения <code>errno</code> см. в справочной странице для <emphasis>symlink</emphasis>(2). У символических ссылок есть свои недостатки:</p>
      <p>• Они занимают лишнее дисковое пространство, требуя отдельного индекса и блока данных. Прямые ссылки занимают лишь элемент каталога.</p>
      <p>• Они добавляют лишние накладные расходы. Ядро должно больше работать для разрешения имени пути, содержащего символические ссылки.</p>
      <p>• Они могут создать «циклы». Рассмотрите следующее:</p>
      <p><code>$ <strong>rm -f a b</strong> /* Убедиться, что 'a' и 'b' не существуют */</code></p>
      <p><code>$ <strong>ln -s a b</strong> /* Создать ссылку старого файла 'a' на новый 'b' */</code></p>
      <p><code>$ <strong>ln -s b a</strong> /* Создать ссылку старого файла 'b' на новый 'a' */</code></p>
      <p><code>$ <strong>cat а</strong> /* Что случилось? */</code></p>
      <p><code>cat: a: Too many levels of symbolic links</code></p>
      <p>Ядро должно быть способно определить такой случай и выдать сообщение об ошибке.</p>
      <p>• Они легко обрываются. Если переместить указываемый файл в другое место или переименовать его, символическая ссылка больше не действительна. С прямой ссылкой такого случиться не может.</p>
     </section>
    </section>
    <section>
     <title>
      <p>5.2. Создание и удаление каталогов</p>
     </title>
     <p>Создание и удаление каталогов просто. Двумя системными вызовами, что неудивительно, являются <code>mkdir()</code> и <code>rmdir()</code> соответственно:</p>
     <p><code>#include &lt;sys/types.h&gt; /* POSIX */</code></p>
     <p><code>#include &lt;sys/stat.h&gt;</code></p>
     <empty-line/>
     <p><code>int mkdir(const char *pathname, mode_t mode);</code></p>
     <empty-line/>
     <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
     <empty-line/>
     <p><code>int rmdir(const char *pathname);</code></p>
     <p>Оба возвращают 0 при успехе и (-1) при ошибке, с соответствующим <code>errno</code>. Аргумент <code>mode</code> для <code>mkdir()</code> представляет права доступа, которые должны быть использованы для каталога. Он полностью идентичен аргументам <code>mode</code> для <code>creat()</code> и <code>open()</code>, обсуждавшимся в разделе 4.6 «Создание файлов».</p>
     <p>Обе функции обрабатывают '<code>.</code>' и '<code>..</code>' в создаваемом или удаляемом каталоге. Перед удалением каталог должен быть пуст; если это не так, <code>errno</code> устанавливается в <code>ENOTEMPTY</code>. (В данном случае, «пуст» означает, что каталог содержит только '<code>.</code>' и '<code>..</code>'.)</p>
     <p>Новым каталогам, как и всем файлам, присваивается идентификационный номер группы. К сожалению, его работа запутана. Мы отложим обсуждение до раздела 11.5.1 «Группа по умолчанию для новых файлов и каталогов».</p>
     <p>Обе функции работают <emphasis>на одном уровне каталога за раз</emphasis>. Если <code>/somedir</code> существует, a <code>/somedir/sub1</code> нет, '<code>mkdir("/somedir/sub1/sub2")</code>' завершится неудачей. Каждый компонент в длинном пути должен создаваться отдельно (в соответствии с опцией <code>-р mkdir</code>, см. <emphasis>mkdir</emphasis>(1)).</p>
     <p>Также, если <code>pathname</code> завершается символом '<code>/</code>', на некоторых системах <code>mkdir()</code> и <code>rmdir()</code> потерпят неудачу, а на других нет. Следующая программа, <code>ch05-trymkdir.с</code>, демонстрирует оба аспекта.</p>
     <p><code>1  /* ch05-trymkdir.c --- Демонстрирует поведение mkdir().</code></p>
     <p><code>2     Любезность Nelson H.F. Beebe. */</code></p>
     <p><code>3</code></p>
     <p><code>4  #include &lt;stdio.h&gt;</code></p>
     <p><code>5  #include &lt;stdlib.h&gt;</code></p>
     <p><code>6  #include &lt;errno.h&gt;</code></p>
     <p><code>7</code></p>
     <p><code>8  #if !defined(EXIT_SUCCESS)</code></p>
     <p><code>9  #define EXIT_SUCCESS 0</code></p>
     <p><code>10 #endif</code></p>
     <p><code>11</code></p>
     <p><code>12 void do_test(const char *path)</code></p>
     <p><code>13 {</code></p>
     <p><code>14  int retcode;</code></p>
     <p><code>15</code></p>
     <p><code>16  errno = 0;</code></p>
     <p><code>17  retcode = mkdir(path, 0755);</code></p>
     <p><code>18  printf("mkdir(\"%s\") returns %d: errno = %d [%s)\n",</code></p>
     <p><code>19   path, retcode, errno, strerror(errno));</code></p>
     <p><code>20 }</code></p>
     <p><code>21</code></p>
     <p><code>22 int main(void)</code></p>
     <p><code>23 {</code></p>
     <p><code>24  do_test("/tmp/t1/t2/t3/t4"); /*Попытка создания в подкаталоге*/</code></p>
     <p><code>25  do_test("/tmp/t1/t2/t3");</code></p>
     <p><code>26  do_test("/tmp/t1/t2");</code></p>
     <p><code>27  do_test("/tmp/t1");</code></p>
     <p><code>28</code></p>
     <p><code>29  do_test("/tmp/u1"); /* Создать подкаталоги */</code></p>
     <p><code>30  do_test("/tmp/u1/u2");</code></p>
     <p><code>31  do_test("/tmp/u1/u2/u3");</code></p>
     <p><code>32  do_test("/tmp/u1/u2/u3/u4");</code></p>
     <p><code>33</code></p>
     <p><code>34  do_test("/tmp/v1/"); /* Как обрабатывается завершающий '/'? */</code></p>
     <p><code>35  do_test("/tmp/v1/v2/");</code></p>
     <p><code>36  do_test("/tmp/v1/v2/v3/");</code></p>
     <p><code>37  do_test("/tmp/v1/v2/v3/v4/");</code></p>
     <p><code>38</code></p>
     <p><code>39  return(EXIT_SUCCESS);</code></p>
     <p><code>40 }</code></p>
     <p>Вот результаты для GNU/Linux:</p>
     <p><code>$ <strong>ch05-trymkdir</strong></code></p>
     <p><code>mkdir("/tmp/t1/t2/t3/t4") returns -1: errno = 2 [No such file or directory)</code></p>
     <p><code>mkdir("/tmp/t1/t2/t3") returns -1: errno = 2 [No such file or directory)</code></p>
     <p><code>mkdir("/tmp/t1/t2") returns -1: errno = 2 [No such file or directory]</code></p>
     <p><code>mkdir("/tmp/t1") returns 0: errno = 0 [Success]</code></p>
     <p><code>mkdir("/tmp/u1") returns 0: errno = 0 [Success]</code></p>
     <p><code>mkdir("/tmp/u1/u2") returns 0: errno = 0 [Success]</code></p>
     <p><code>mkdir("/tmp/u1/u2/u3") returns 0: errno = 0 [Success]</code></p>
     <p><code>mkdir("/tmp/u1/u2/u3/u4") returns 0: errno = 0 [Success]</code></p>
     <p><code>mkdir("/tmp/v1/") returns 0: errno = 0 [Success]</code></p>
     <p><code>mkdir("/tmp/v1/v2/") returns 0: errno = 0 (Success]</code></p>
     <p><code>mkdir("/tmp/v1/v2/v3/") returns 0: errno = 0 [Success]</code></p>
     <p><code>mkdir("/tmp/v1/v2/v3/v4/") returns 0: errno = 0 [Success]</code></p>
     <p>Обратите внимание, как GNU/Linux принимает завершающий слеш. Не все системы так делают.</p>
    </section>
    <section>
     <title>
      <p>5.3. Чтение каталогов</p>
     </title>
     <section>
      <p>В оригинальных системах Unix чтение содержимого каталогов было просто. Программа открывала каталог с помощью <code>open()</code> и непосредственно читала двоичные структуры <code>struct direct</code>, по 16 байтов за раз. Следующий фрагмент кода из программы V7 <code>rmdir</code><a l:href="#n53" type="note">[53]</a>, строки 60–74. Он показывает проверку на пустоту каталога.</p>
      <p><code>60 if ((fd = open(name, 0)) &lt; 0) {</code></p>
      <p><code>61  fprintf(stderr, "rmdir: %s unreadable\n", name);</code></p>
      <p><code>62  ++Errors;</code></p>
      <p><code>63  return;</code></p>
      <p><code>64 }</code></p>
      <p><code>65 while (read(fd, (char*)&amp;dir, sizeof dir) == sizeof dir) {</code></p>
      <p><code>66  if (dir.d_ino == 0) continue;</code></p>
      <p><code>67  if (!strcmp(dir.d_name, ".") || !strcmp(dir.d_name, ".."))</code></p>
      <p><code>68   continue;</code></p>
      <p><code>69  fprintf(stderr, "rmdir: %s not empty\n", name);</code></p>
      <p><code>70  ++Errors;</code></p>
      <p><code>71  close(fd);</code></p>
      <p><code>72  return;</code></p>
      <p><code>73 }</code></p>
      <p><code>74 close(fd);</code></p>
      <p>В строке 60 каталог открывается для чтения (второй аргумент равен 0, что означает <code>O_RDONLY</code>). В строке 65 читается <code>struct direct</code>. В строке 66 проверяется, не является ли элемент каталога пустым, т. е. с номером индекса 0. Строки 67 и 68 проверяют на наличие '<code>.</code>' и '<code>..</code>'. По достижении строки 69 мы знаем, что было встречено какое-то другое имя файла, следовательно, этот каталог не пустой.</p>
      <p>(Тест '<code>!strcmp(s1, s2)</code>' является более короткой формой '<code>strcmp(s1, s2) == 0</code>', т.е. проверкой совпадения строк. Стоит заметить, что мы рассматриваем '<code>!strcmp(s1, s2)</code>' как плохой стиль. Как сказал однажды Генри Спенсер (Henry Spencer), «<code>strcmp()</code> это не boolean!».)</p>
      <p>Когда 4.2 BSD представило новый формат файловой системы, который допускал длинные имена файлов и обеспечивал лучшую производительность, были также представлены несколько новых функций для абстрагирования чтения каталогов. Этот набор функций можно использовать независимо от того, какова лежащая в основе файловая система и как организованы каталоги. Основная ее часть стандартизована POSIX, а программы, использующие ее, переносимы между системами GNU/Linux и Unix.</p>
     </section>
     <section>
      <title>
       <p>5.3.1. Базовое чтение каталогов</p>
      </title>
      <section>
       <p>Элементы каталогов представлены <code>struct dirent</code> (<emphasis>не</emphasis> то же самое, что V7 <code>struct direct</code>!):</p>
       <p><code>struct dirent {</code></p>
       <p><code> ...</code></p>
       <p><code> ino_t d_ino;      /* расширение XSI --- см. текст */</code></p>
       <p><code> char d_name[...]; /* О размере этого массива см. в тексте */</code></p>
       <p><code> ...</code></p>
       <p><code>};</code></p>
       <p>Для переносимости POSIX указывает лишь поле <code>d_name</code>, которое является завершающимся нулем массивом байтов, представляющим часть элемента каталога с именем файла. Размер <code>d_name</code> стандартом не указывается, кроме того, что там перед завершающим нулем может быть не более <code>NAME_MAX</code> байтов. (<code>NAME_MAX</code> определен в <code>&lt;limits.h&gt;</code>.) Расширение XSI POSIX предусматривает поле номера индекса <code>d_ino</code>.</p>
       <p>На практике, поскольку имена файлов могут быть различной длины, a <code>NAME_MAX</code> обычно довольно велико (подобно 255), <code>struct dirent</code> содержит дополнительные члены, которые помогают вести на диске учет элементов каталогов с переменными длинами. Эти дополнительные члены не существенны для обычного кода.</p>
       <p>Следующие функции предоставляют интерфейс чтения каталогов:</p>
       <p><code>#include &lt;sys/types.h&gt; /* POSIX */</code></p>
       <p><code>#include &lt;dirent.h&gt;</code></p>
       <empty-line/>
       <p><code>DIR *opendir(const char *name);   /* Открыть каталог для чтения */</code></p>
       <p><code>struct dirent *readdir(DIR *dir); /* Вернуть struct dirent за раз */</code></p>
       <p><code>int closedir(DIR *dir);           /* Закрыть открытый каталог */</code></p>
       <p><code>void rewinddir(DIR *dirp);        /* Вернуться в начало каталога */</code></p>
       <p>Тип <code>DIR</code> является аналогом типа <code>FILE</code> в <code>&lt;stdio.h&gt;</code>. Это <emphasis>непрозрачный тип</emphasis>, что означает, что код приложения не должен знать, что находится внутри него; его содержимое предназначено для использования другими процедурами каталогов. Если <code>opendir()</code> возвращает <code>NULL</code>, именованный каталог не может быть открыт для чтения, а errno содержит код ошибки.</p>
       <p>Открыв переменную <code>DIR*</code>, можно использовать ее для получения указателя на <code>struct dirent</code>, представляющего следующий элемент каталога. <code>readdir()</code> возвращает <code>NULL</code>, если достигнут конец каталога<a l:href="#n54" type="note">[54]</a> или произошла ошибка.</p>
       <p>Наконец, <code>closedir()</code> является аналогичной функции <code>fclose()</code> в <code>&lt;stdio.h&gt;</code>; она закрывает открытую переменную <code>DIR*</code>. Чтобы начать с начала каталога, можно использовать функцию <code>rewinddir()</code>.</p>
       <p>Имея в распоряжении (или по крайней мере в библиотеке С) эти функции, мы можем написать небольшую программу <code>catdir</code>, которая «отображает» содержимое каталога. Такая программа представлена в <code>ch05-catdir.с</code>:</p>
       <p><code>1  /* ch05-catdir.с - Демонстрация opendir(), readdir(), closedir(). */</code></p>
       <p><code>2</code></p>
       <p><code>3  #include &lt;stdio.h&gt; /* для printf() и т.д. */</code></p>
       <p><code>4  #include &lt;errno.h&gt; /* для errno */</code></p>
       <p><code>5  #include &lt;sys/types.h&gt; /* для системных типов */</code></p>
       <p><code>6  #include &lt;dirent.h&gt; /* для функций каталога */</code></p>
       <p><code>7</code></p>
       <p><code>8  char *myname;</code></p>
       <p><code>9  int process(char *dir);</code></p>
       <p><code>10</code></p>
       <p><code>11 /* main --- перечисление аргументов каталога */</code></p>
       <p><code>12</code></p>
       <p><code>13 int main(int argc, char **argv)</code></p>
       <p><code>14 {</code></p>
       <p><code>15  int i;</code></p>
       <p><code>16  int errs = 0;</code></p>
       <p><code>17</code> </p>
       <p><code>18  myname = argv[0];</code></p>
       <p><code>19</code></p>
       <p><code>20  if (argc == 1)</code></p>
       <p><code>21   errs = process("."); /* по умолчанию текущий каталог */</code></p>
       <p><code>22  else</code></p>
       <p><code>23   for (i = 1; i &lt; argc; i++)</code></p>
       <p><code>24    errs += process(argv[i]);</code></p>
       <p><code>25</code></p>
       <p><code>26  return (errs != 0);</code></p>
       <p><code>27 }</code></p>
       <p>Эта программа вполне подобна <code>ch04-cat.c</code> (см. раздел 4.2 «Представление базовой структуры программы»); функция <code>main()</code> почти идентична. Главное различие в том, что по умолчанию используется текущий каталог, если нет аргументов (строки 20–21).</p>
       <p><code>29 /*</code></p>
       <p><code>30  * process --- сделать что-то с каталогом, в данном случае,</code></p>
       <p><code>31  * вывести пары индекс/имя в стандартный вывод.</code></p>
       <p><code>32  * Возвращает 0, если все OK, иначе 1.</code></p>
       <p><code>33  */</code></p>
       <p><code>34</code></p>
       <p><code>35 int</code></p>
       <p><code>36 process(char *dir)</code></p>
       <p><code>37 {</code></p>
       <p><code>38  DIR *dp;</code></p>
       <p><code>39  struct dirent *ent;</code></p>
       <p><code>40</code></p>
       <p><code>41  if ((dp = opendir(dir)) == NULL) {</code></p>
       <p><code>42   fprintf(stderr, "%s: %s: cannot open for reading: %s\n",</code></p>
       <p><code>43   myname, dir, strerror(errno));</code></p>
       <p><code>44   return 1;</code></p>
       <p><code>45  }</code></p>
       <p><code>46</code></p>
       <p><code>47  errno = 0;</code></p>
       <p><code>48  while ((ent = readdir(dp)) != NULL)</code></p>
       <p><code>49   printf("%8ld %s\n", ent-&gt;d_ino, ent-&gt;d_name);</code></p>
       <p><code>50</code></p>
       <p><code>51  if (errno != 0) {</code></p>
       <p><code>52   fprintf(stderr, "%s: %s: reading directory entries: %s\n",</code></p>
       <p><code>53   myname, dir, strerror(errno));</code></p>
       <p><code>54   return 1;</code></p>
       <p><code>55  }</code></p>
       <p><code>56</code></p>
       <p><code>57  if (closedir(dp) != 0) {</code></p>
       <p><code>58   fprintf(stderr, "%s: %s: closedir: %s\n",</code></p>
       <p><code>59    myname, dir, strerror(errno));</code></p>
       <p><code>60   return 1;</code></p>
       <p><code>61  }</code></p>
       <p><code>62</code></p>
       <p><code>63  return 0;</code></p>
       <p><code>64 }</code></p>
       <p>Функция <code>process()</code> делает всю работу и большую часть кода проверки ошибок. Основой функции являются строки 48 и 49:</p>
       <p><code>while ((ent = readdir(dp)) != NULL)</code></p>
       <p><code>printf("%8ld %s\n", ent-&gt;d_ino, ent-&gt;d_name);</code></p>
       <p>Этот цикл читает элементы каталога, по одной за раз, до тех пор, пока <code>readdir()</code> не возвратит <code>NULL</code>. Тело цикла отображает для каждого элемента номер индекса и имя файла. Вот что происходит при запуске программы:</p>
       <p><code>$ <strong>ch05-catdir</strong> /* По умолчанию текущий каталог */</code></p>
       <p><code>639063 .</code></p>
       <p><code>639062 ..</code></p>
       <p><code>639064 proposal.txt</code></p>
       <p><code>639012 lightsabers.url</code></p>
       <p><code>688470 code</code></p>
       <p><code>638976 progex.texi</code></p>
       <p><code>639305 texinfo.tex</code></p>
       <p><code>639007 15-processes.texi</code></p>
       <p><code>639011 00-preface.texi</code></p>
       <p><code>639020 18-tty.texi</code></p>
       <p><code>638980 Makefile</code></p>
       <p><code>639239 19-i18n.texi</code></p>
       <p><code>...</code></p>
       <p>Вывод никаким образом не сортируется; он представляет линейное содержимое каталога. (Как сортировать содержимое каталога мы опишем в разделе 6.2 «Функции сортировки и поиска»).</p>
      </section>
      <section>
       <title>
        <p>5.3.1.1. Анализ переносимости</p>
       </title>
       <p>Есть несколько соображений по переносимости. Во-первых, не следует предполагать, что двумя первыми элементами, возвращаемыми <code>readdir()</code>, всегда будут '<code>.</code>' и '<code>..</code>'. Многие файловые системы используют организацию каталогов, которые отличаются от первоначального дизайна Unix, и '<code>.</code>' и '<code>..</code>' могут быть в середине каталога или даже вовсе не присутствовать<a l:href="#n55" type="note">[55]</a>.</p>
       <p>Во-вторых, стандарт POSIX ничего не говорит о возможных значениях <code>d_info</code>. Он говорит, что возвращенные структуры представляют элементы каталогов для файлов; это предполагает, что <code>readdir()</code> не возвращает пустые элементы, поэтому реализация GNU/Linux <code>readdir()</code> не беспокоится с возвратом элементов, когда '<code>d_ino == 0</code>'; она переходит к следующему действительному элементу.</p>
       <p>Поэтому по крайней мере на системах GNU/Linux и Unix маловероятно, что <code>d_ino</code> когда-нибудь будет равен нулю. Однако, лучше по возможности вообще избегать использования этого поля.</p>
       <p>Наконец, некоторые системы используют <code>d_fileno</code> вместо <code>d_ino</code> в <code>struct dirent</code>. Знайте об этом, когда нужно перенести на такие системы код, читающий каталоги.</p>
       <cite>
        <subtitle>Косвенные системные вызовы</subtitle>
        <p><emphasis>«Не пробуйте это дома, дети!»</emphasis></p>
        <p><strong>- М-р Wizard -</strong></p>
        <p>Многие системные вызовы, такие, как <code>open()</code>, <code>read()</code> и <code>write()</code>, предназначены для вызова непосредственно из кода пользователя: другими словами, из кода, который пишете вы как разработчик GNU/Linux.</p>
        <p>Однако, другие системные вызовы существуют лишь для того, чтобы дать возможность реализовать стандартные библиотечные функции более высокого уровня, и никогда не должны вызываться непосредственно. Одним из таких системных вызовов является GNU/Linux <code>getdents()</code>; он читает несколько элементов каталога в буфер, предоставленный вызывающим — в данном случае, кодом реализации <code>readdir()</code>. Затем код <code>readdir()</code> возвращает действительные элементы каталога, по одному за раз, пополняя при необходимости буфер.</p>
        <p>Эти системные вызовы только-для-библиотечного-использования можно отличить от вызовов для-использования-пользователем по их представлению в странице справки. Например, из <emphasis>getdents</emphasis>(2).</p>
        <p><code>ИМЯ</code></p>
        <p><code>  getdents - получить элементы каталога</code></p>
        <p><code>ОПИСАНИЕ</code></p>
        <p><code>  #include &lt;unistd.h&gt;</code></p>
        <p><code>  #include &lt;linux/types.h&gt;</code></p>
        <p><code>  #include &lt;linux/dirent.h&gt;</code></p>
        <p><code>  #include &lt;linux/unistd.h&gt;</code></p>
        <p><code>  _syscall3(int, getdents, uint, fd, struct dirent*,</code></p>
        <p><code>            dirp, uint, count);</code></p>
        <p><code>  int getdents(unsigned int fd, struct dirent *dirp,</code></p>
        <p><code>               unsigned int count);</code></p>
        <p>Любой системный вызов, использующий макрос <code>_syscallX()</code>, не должен вызываться кодом приложения. (Дополнительную информацию об этих вызовах можно найти в справочной странице для <emphasis>intro</emphasis>(2); вам следует прочесть эту справочную страницу, если вы этого еще не сделали.)</p>
        <p>В случае <code>getdents()</code> на многих других системах Unix есть сходный системный вызов; иногда с тем же именем, иногда с другим. Поэтому попытка использования этих вызовов привела бы в любом случае лишь к большому беспорядку с переносимостью; гораздо лучше во всех случаях использовать <code>readdir()</code>, интерфейс которого хорошо определен, стандартизован и переносим.</p>
       </cite>
      </section>
      <section>
       <title>
        <p>5.3.1.2. Элементы каталогов Linux и BSD</p>
       </title>
       <p>Хотя мы только что сказали, что вам следует использовать лишь члены <code>d_ino</code> и <code>d_name</code> структуры <code>struct dirent</code>, стоит знать о члене <code>d_type</code> в <code>struct dirent</code> BSD и Linux. Это значение <code>unsigned char</code>, в котором хранится тип файла, имя которого находится в элементе каталога:</p>
       <p><code>struct dirent {</code></p>
       <p><code> ...</code></p>
       <p><code> ino_t d_ino;          /* Как ранее */</code></p>
       <p><code> char d_name[...];     /* Как ранее */</code></p>
       <p><code> unsigned char d_type; /* Linux и современная BSD */</code></p>
       <p><code> ...</code></p>
       <p><code>};</code></p>
       <p><code>d_type</code> может принимать любые значения, описанные в табл. 5.1.</p>
       <empty-line/>
       <p><strong>Таблица 5.1</strong>. Значения для <code>d_type</code></p>
       <table>
        <tr align="left">
         <th align="left" valign="top">Имя</th>
         <th align="left" valign="top">Значение</th>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>DT_BLK</code></td>
         <td align="left" valign="top">Файл блочного устройства</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>DT_CHR</code></td>
         <td align="left" valign="top">Файл символьного устройства</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>DT_DIR</code></td>
         <td align="left" valign="top">Каталог</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>DT_FIFO</code></td>
         <td align="left" valign="top">FIFO или именованный канал</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>DT_LNK</code></td>
         <td align="left" valign="top">Символическая ссылка</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>DT_REG</code></td>
         <td align="left" valign="top">Обычный файл</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>DT_SOCK</code></td>
         <td align="left" valign="top">Сокет</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>DT_UNKNOWN</code></td>
         <td align="left" valign="top">Неизвестный тип файла</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>DT_WHT</code></td>
         <td align="left" valign="top">Нет элемента (только системы BSD)</td>
        </tr>
       </table>
       <p>Знание типа файла просто путем чтения элемента каталога очень удобно; это может сэкономить на возможно дорогом системном вызове <code>stat()</code>. (Вызов <code>stat()</code> вскоре будет описан в разделе 5.4.2 «Получение информации о файле».)</p>
      </section>
     </section>
     <section>
      <title>
       <p>5.3.2. Функции размещения каталогов BSD</p>
      </title>
      <p>Иногда полезно отметить текущее положение в каталоге для того, чтобы иметь возможность позже к нему вернуться. Например, вы пишете код, обходящий дерево каталога, и хотите рекурсивно входить в каждый подкаталог, когда его проходите. (Как отличить файлы от каталогов обсуждается в следующем разделе). По этой причине первоначальный интерфейс BSD включал две дополнительные процедуры:</p>
      <p><code>#include &lt;dirent.h&gt; /* XSI */</code></p>
      <p><code>/* Предупреждение: POSIX XSI использует для обеих функций long, а не off_t */</code></p>
      <empty-line/>
      <p><code>off_t telldir(DIR *dir);              /* Вернуть текущее положение */</code></p>
      <p><code>void seekdir(DIR *dir, off_t offset); /* Переместиться в данное положение */</code></p>
      <p>Эти процедуры подобны функциям <code>ftell()</code> и <code>fseek()</code> и <code>&lt;stdio.h&gt;</code>. Они возвращают текущее положение в каталоге и устанавливают текущее положение в ранее полученное значение соответственно.</p>
      <p>Эти процедуры включены в часть XSI стандарта POSIX, поскольку они имеют смысл лишь для каталогов, которые реализованы с линейным хранением элементов каталога</p>
      <p>Помимо предположений, сделанных относительно лежащей в основе структуры каталога, эти процедуры рискованнее использовать, чем простые процедуры чтения каталога. Это связано с тем, что содержание каталога может изменяться динамически: когда файлы добавляются или удаляются из каталога, операционная система приводит в порядок содержание каталога. Поскольку элементы каталога имеют различный размер, может оказаться, что сохраненное ранее абсолютное смещение больше не представляет начало элемента каталога! Поэтому мы не рекомендуем вам использовать эти функции, если вам они действительно не нужны<a l:href="#n56" type="note">[56]</a>.</p>
     </section>
    </section>
    <section>
     <title>
      <p>5.4. Получение информации о файлах</p>
     </title>
     <section>
      <p>Чтение каталога для получения имен файлов лишь половина дела. Получив имя файла, нужно знать, как получить остальную информацию, связанную с файлом, такую, как тип файла, права доступа к нему, владельца и т.д.</p>
     </section>
     <section>
      <title>
       <p>5.4.1. Типы файлов Linux</p>
      </title>
      <p>Linux (и Unix) поддерживает следующие различные типы файлов:</p>
      <p><emphasis>Обычные файлы</emphasis></p>
      <p>Как предполагает имя, данный тип используется для данных, исполняемых программ и всего прочего, что вам может понравиться. В листинге '<code>ls -l</code>' они обозначаются в виде первого символа '<code>-</code>' поля прав доступа (режима).</p>
      <p><emphasis>Каталоги</emphasis></p>
      <p>Специальные файлы для связывания имен файлов с индексами. В листинге '<code>ls -l</code>' они обозначаются первым символом <code>d</code> поля прав доступа.</p>
      <p><emphasis>Символические ссылки</emphasis></p>
      <p>Как описано ранее в главе. В листинге '<code>ls -l</code>' обозначаются первым символом <code>l</code> (буква «эль», не цифра 1) поля прав доступа.</p>
      <p><emphasis>Устройства</emphasis></p>
      <p>Файлы, представляющие как физические аппаратные устройства, так и программные псевдоустройства. Есть две разновидности:</p>
      <p><emphasis>Блочные устройства</emphasis></p>
      <p>Устройства, ввод/вывод которых осуществляется порциями некоторого фиксированного размера физической записи, такие, как дисковые и ленточные приводы. Доступ к таким устройствам осуществляется через буферный кэш ядра. В листинге '<code>ls -l</code>' они обозначаются первым символом <code>b</code> поля прав доступа.</p>
      <p><emphasis>Символьные устройства</emphasis></p>
      <p>Известны также как <emphasis>непосредственные (raw)</emphasis> устройства. Первоначально символьными устройствами были те, в которых ввод/вывод осуществлялся по несколько байтов за раз, как в терминалах. Однако, символьное устройство используется также для непосредственного ввода/вывода на блочные устройства, такие, как ленты и диски, минуя буферный кэш<a l:href="#n57" type="note">[57]</a>. В листинге '<code>ls -l</code>' они отображаются первым символом <code>с</code> поля прав доступа.</p>
      <p><emphasis>Именованные каналы (named pipes)</emphasis></p>
      <p>Известны также файлы <emphasis>FIFO</emphasis> («first-in first-out» — «первым вошел, первым обслужен»). Эти специальные файлы действуют подобно конвейерам (pipes); данные, записанные в них одной программой, могут быть прочитаны другой; данные не записываются на диск и не считываются с диска. FIFO создаются с помощью команды <code>mkfifo</code>; они обсуждаются в разделе 9.3.2 «FIFO». В листинге '<code>ls -l</code>' они отображаются первым символом <code>p</code> поля прав доступа.</p>
      <p><emphasis>Сокеты</emphasis></p>
      <p>Сходные по назначению с именованными каналами<a l:href="#n58" type="note">[58]</a>, они управляются системными вызовами межпроцессных взаимодействий (IPC) сокетов, и мы не будем в данной книге иметь с ними дело в других отношениях. В листинге '<code>ls -l</code>' они отображаются первым символом <code>s</code> поля прав доступа.</p>
     </section>
     <section>
      <title>
       <p>5.4.2. Получение информации о файле</p>
      </title>
      <p>Три системных вызова возвращают информацию о файлах:</p>
      <p><code>#include &lt;sys/types.h&gt; /* POSIX */</code></p>
      <p><code>#include &lt;sys/stat.h&gt;</code></p>
      <p><code>#include &lt;unistd.h&gt;</code></p>
      <empty-line/>
      <p><code>int stat(const char *file_name, struct stat *buf);</code></p>
      <p><code>int fstat(int filedes, struct stat *buf);</code></p>
      <p><code>int lstat(const char *file_name, struct stat *buf);</code></p>
      <p>Функция <code>stat()</code> получает имя файла с путем и возвращает сведения о данном файле. Она <emphasis>следует</emphasis> по символическим ссылкам; т. е. при применении к символической ссылке <code>stat()</code> возвращает информацию об указываемом файле, а не о самой ссылке. В тех случаях, когда вам нужно знать, является ли файл символической ссылкой, используйте вместо нее функцию <code>lstat()</code>; последняя не следует по символическим ссылкам.</p>
      <p>Функция <code>fstat()</code> получает сведения об уже открытом файле. Это особенно полезно для дескрипторов файлов 0, 1 и 2 (стандартных ввода, вывода и ошибки), которые уже открыты при запуске процесса. Однако, она может использоваться с любым открытым файлом. (Дескриптор открытого файла никогда не будет относиться к символической ссылке; убедитесь, что понимаете, почему.)</p>
      <p>Значение, переданное в качестве второго параметра, должно быть адресом <code>struct stat</code>, объявленной в <code>&lt;sys/stat.h&gt;</code>. Как в случае с <code>struct dirent</code>, <code>struct stat</code> содержит по крайней мере следующие члены:</p>
      <p><code>struct stat {</code></p>
      <p><code> ...</code></p>
      <p><code> dev_t st_dev;         /* устройство */</code></p>
      <p><code> ino_t st_ino;         /* индекс */</code></p>
      <p><code> mode_t st_mode;       /* тип и защита */</code></p>
      <p><code> nlink_t st_nlink;     /* число прямых (hard) ссылок */</code></p>
      <p><code> uid_t st_uid;         /* ID владельца */</code></p>
      <p><code> gid_t st_gid;         /* ID группы */</code></p>
      <p><code> dev_t st_rdev;        /* тип устройства (блочное или символьное) */</code></p>
      <p><code> off_t st_size;        /* общий размер в байтах */</code></p>
      <p><code> blksize_t st_blksize; /* размер блока для ввода/вывода файл, с-мы */</code></p>
      <p><code> blkcnt_t st_blocks;   /* число выделенных блоков */</code></p>
      <p><code> time_t st_atime;      /* время последнего доступа */</code></p>
      <p><code> time_t st_mtime;      /* время последнего изменения */</code></p>
      <p><code> time_t st_ctime;      /* время последнего изменения индекса */</code></p>
      <p><code> ...</code></p>
      <p><code>};</code></p>
      <p>(Размещение на разных системах может быть разное.) Эта структура использует ряд определенных через <code>typedef</code> типов. Хотя они все (обычно) целые типы, использование специально определенных типов позволяет использовать для них различные размеры на разных системах. Это сохраняет переносимость кода пользователя, который их использует. Вот более полное описание каждого поля.</p>
      <p><code>st_dev</code></p>
      <p>Устройство для монтируемой файловой системы. У каждой монтируемой файловой системы уникальное значение <code>st_dev</code>.</p>
      <p><code>st_ino</code></p>
      <p>Номер индекса файла в пределах файловой системы. Пара (<code>st_dev</code>, <code>st_ino</code>) <emphasis>уникально</emphasis> идентифицирует файл.</p>
      <p><code>st_mode</code></p>
      <p>Тип файла и права доступа к нему, закодированные в одном поле. Вскоре мы рассмотрим, как извлечь эту информацию.</p>
      <p><code>st_nlink</code></p>
      <p>Число прямых ссылок на файл (счетчик ссылок). Может равняться нулю, если файл был удален после открытия.</p>
      <p><code>st_uid</code></p>
      <p>UID файла (номер владельца).</p>
      <p><code>st_gid</code></p>
      <p>GID файла (номер группы).</p>
      <p><code>st_rdev</code></p>
      <p>Тип устройства, если файл является блочным или символьным устройством. <code>st_rdev</code> содержит закодированную информацию об устройстве. Вскоре мы увидим, как извлечь эту информацию. Это поле не имеет смысла, если файл не является блочным или символьным устройством.</p>
      <p><code>st_size</code></p>
      <p>Логический размер файла. Как упоминалось в разделе 4.5 «Произвольный доступ: перемещение внутри файла», файл может содержать в себе дыры, в этом случае размер может не отражать истинного значения занимаемого им места.</p>
      <p><code>st_blksize</code></p>
      <p>«Размер блока» файла. Представляет предпочтительный размер блока данных для ввода/вывода данных в или из файла. Почти всегда превышает размер физического сектора диска. У более старых систем Unix нет этого поля (или поля <code>st_blocks</code>) в <code>struct stat</code>. Для файловых систем Linux ext2 и ext3 это значение составляет 4096.</p>
      <p><code>st_blocks</code></p>
      <p>Число «блоков», используемых файлом. В Linux это значение представлено в единицах 512-байтных блоков. На других системах размер блока может быть различным, проверьте свою локальную страницу справки для <emphasis>stat</emphasis>(2). (Это число происходит от константы <code>DEV_BSIZE</code> в <code>&lt;sys/param.h&gt;</code>. Эта константа не стандартизована, но довольно широко используется в системах Unix.)</p>
      <p>Число блоков может быть больше, чем '<code>st_size / 512</code>'; кроме блоков данных, файловая система может использовать дополнительные блоки для хранения размещений блоков данных. Это особенно необходимо для больших файлов.</p>
      <p><code>st_atime</code></p>
      <p>Время доступа к файлу; т.е. когда в последний раз читались данные файла.</p>
      <p><code>st_mtime</code></p>
      <p>Время модификации файла; т е. когда в последний раз данные файла записывались или урезались.</p>
      <p><code>st_ctime</code></p>
      <p>Время изменения индекса файла. Указывает время последнего изменения служебных данных файла, таких, как права доступа или владелец.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Поле <code>st_ctime</code> не является «временем создания»! В системе Linux или Unix нет такой вещи. Часть более ранней документации называла поле <code>st_ctime</code> временем создания. Это была вводящая в заблуждение попытка упростить представление служебных данных файла</p>
      </cite>
      <p>Тип <code>time_t</code>, использованный для полей <code>st_atime</code>, <code>st_mtime</code> и <code>st_ctime</code>, представляет дату и время. Эти относящиеся ко времени значения иногда называют <emphasis>временными метками (timestamps)</emphasis>. Обсуждение того, как использовать значение <code>time_t</code>, отложено до раздела 6.1 «Время и даты». Подобным же образом типы <code>uid_t</code> и <code>gid_t</code> представляют номера владельца и группы, которые обсуждаются в разделе 6.3 «Имена пользователя и группы». Большинство других типов не представляют широкого интереса.</p>
     </section>
     <section>
      <title>
       <p>5.4.3. Только Linux: указание файлового времени повышенной точности</p>
      </title>
      <p>Ядра Linux 2.6 и более поздние предоставляют в <code>struct stat</code> три дополнительных поля. Они предусматривают точность файлового времени до наносекунд:</p>
      <p><code>st_atime_nsec  </code>Наносекундная компонента времени доступа к файлу.</p>
      <p><code>st_mtime_nsec  </code>Наносекундная компонента времени изменения файла</p>
      <p><code>st_ctime_nsec  </code>Наносекундная компонента времени изменения служебных данных файла.</p>
      <p>Некоторые другие системы также предоставляют такие поля с повышенной точностью времени, но имена соответствующих членов структуры <code>struct stat</code> <emphasis>не</emphasis> стандартизованы, что затрудняет написание переносимого кода, использующего эти времена. (Связанные с этим расширенные системные вызовы см. в разделе 14.3.2 «Файловое время в микросекундах: <code>utimes()</code>».)</p>
     </section>
     <section>
      <title>
       <p>5.4.4. Определение типа файла</p>
      </title>
      <section>
       <p>Вспомните, что в поле <code>st_mode</code> закодированы как тип файла, так и права доступа к нему. <code>&lt;sys/stat.h&gt;</code> определяет ряд макросов, которые определяют тип файла. В частности, эти макросы возвращают <code>true</code> или <code>false</code> при использовании с полем <code>st_mode</code>. У каждого описанного ранее типа файла есть свой макрос. Предположим, выполняется следующий код:</p>
       <p><code>struct stat stbuf;</code></p>
       <p><code>char filename[PATH_МАХ]; /* PATH_MAX из &lt;limits.h&gt; */</code></p>
       <p><code>/* ... поместить имя файла в filename ... */</code></p>
       <p><code>if (stat(filename, &amp;stbuf) &lt; 0) {</code></p>
       <p><code> /* обработать ошибку */</code></p>
       <p><code>}</code></p>
       <p>Когда система заполнила <code>stbuf</code>, можно вызывать следующие макросы, причем в качестве аргумента передается <code>stbuf.st_mode</code>:</p>
       <p><code>S_ISREG(stbuf.st_mode)</code></p>
       <p>Возвращает <code>true</code>, если <code>filename</code> является обычным файлом.</p>
       <p><code>S_ISDIR(stbuf.st_mode)</code></p>
       <p>Возвращает <code>true</code>, если <code>filename</code> является каталогом.</p>
       <p><code>S_ISCHR(stbuf.st_mode)</code></p>
       <p>Возвращает <code>true</code>, если <code>filename</code> является символьным устройством. Устройства вскоре будут обсуждены более подробно.</p>
       <p><code>S_ISBLK(stbuf.st_mode)</code></p>
       <p>Возвращает <code>true</code>, если <code>filename</code> является блочным устройством.</p>
       <p><code>S_ISFIFO(stbuf.st_mode)</code></p>
       <p>Возвращает <code>true</code>, если <code>filename</code> является FIFO.</p>
       <p><code>S_ISLNK(stbuf.st_mode)</code></p>
       <p>Возвращает <code>true</code>, если <code>filename</code> является символической ссылкой. (Это может никогда не вернуть <code>true</code>, если вместо <code>lstat()</code> использовались <code>stat()</code> или <code>fstat()</code>.)</p>
       <p><code>S_ISSOCK(stbuf.st_mode)</code></p>
       <p>Возвращает <code>true</code>, если <code>filename</code> является сокетом.</p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. В GNU/Linux эти макросы возвращают 1 для <code>true</code> и 0 для <code>false</code>. Однако, на других системах возможно, что они будут возвращать для <code>true</code> вместо 1 произвольное неотрицательное число. (POSIX определяет лишь ненулевое значение в противоположность нулевому). Поэтому всегда следует использовать эти макросы как автономные тесты вместо проверки возвращаемого значения.</p>
        <p><code>/* Корректное использование */</code></p>
        <p><code>if (S_ISREG(stbuf.st_mode)) ...</code></p>
        <p><code>/* Heкорректное использование */</code></p>
        <p><code>if (S_ISREG(stbuf.st_mode) ==1) ...</code></p>
       </cite>
       <p>Наряду с макросами <code>&lt;sys/stat.h&gt;</code> предоставляет два набора битовых масок. Один набор для проверки прав доступа, а другой - для проверки типа файла. Мы видели маски прав доступа в разделе 4.6 «Создание файлов», когда обсуждали тип <code>mode_t</code> и значения для <code>open()</code> и <code>creat()</code>. Битовые маски, их числовые значения для GNU/Linux и смысл приведены в табл. 5.2.</p>
       <empty-line/>
       <p><strong>Таблица 5.2</strong>. Битовые маски POSIX для типов файлов и прав доступа в <code>&lt;sys/stat.h&gt;</code></p>
       <table>
        <tr align="left">
         <th align="left" valign="top">Маска</th>
         <th align="left" valign="top">Значение</th>
         <th align="left" valign="top">Комментарий</th>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IFMT</code></td>
         <td align="left" valign="top">0170000</td>
         <td align="left" valign="top">Маска для битовых полей типа файла</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IFSOCK</code></td>
         <td align="left" valign="top">0140000</td>
         <td align="left" valign="top">Сокет.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IFLNK</code></td>
         <td align="left" valign="top">0120000</td>
         <td align="left" valign="top">Символическая ссылка</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IFREG</code></td>
         <td align="left" valign="top">0100000</td>
         <td align="left" valign="top">Обычный файл.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IFBLK</code></td>
         <td align="left" valign="top">0060000</td>
         <td align="left" valign="top">Блочное устройство.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IFDIR</code></td>
         <td align="left" valign="top">0040000</td>
         <td align="left" valign="top">Каталог.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IFCHR</code></td>
         <td align="left" valign="top">0020000</td>
         <td align="left" valign="top">Символьное устройство.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IFIFO</code></td>
         <td align="left" valign="top">0010000</td>
         <td align="left" valign="top">FIFO.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_ISUID</code></td>
         <td align="left" valign="top">0004000</td>
         <td align="left" valign="top">Бит setuid.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_ISGID</code></td>
         <td align="left" valign="top">0002000</td>
         <td align="left" valign="top">Бит setgid</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_ISVTX</code></td>
         <td align="left" valign="top">0001000</td>
         <td align="left" valign="top">«Липкий» (sticky) бит.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IRWXU</code></td>
         <td align="left" valign="top">0000700</td>
         <td align="left" valign="top">Маска для прав доступа владельца.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IRUSR</code></td>
         <td align="left" valign="top">0000400</td>
         <td align="left" valign="top">Доступ на чтение для владельца.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IWUSR</code></td>
         <td align="left" valign="top">0000200</td>
         <td align="left" valign="top">Доступ на запись для владельца.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IXUSR</code></td>
         <td align="left" valign="top">0000100</td>
         <td align="left" valign="top">Доступ на исполнение для владельца.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IRWXG</code></td>
         <td align="left" valign="top">0000070</td>
         <td align="left" valign="top">Маска для прав доступа группы.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IRGRP</code></td>
         <td align="left" valign="top">0000040</td>
         <td align="left" valign="top">Доступ на чтение для группы.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IWGRP</code></td>
         <td align="left" valign="top">0000020</td>
         <td align="left" valign="top">Доступ на запись для группы.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IXGRP</code></td>
         <td align="left" valign="top">0000010</td>
         <td align="left" valign="top">Доступ на исполнение для группы.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IRWXO</code></td>
         <td align="left" valign="top">0000007</td>
         <td align="left" valign="top">Маска для прав доступа остальных.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IROTH</code></td>
         <td align="left" valign="top">0000004</td>
         <td align="left" valign="top">Доступ на чтение для остальных.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IWOTH</code></td>
         <td align="left" valign="top">0000002</td>
         <td align="left" valign="top">Доступ на запись для остальных.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>S_IXOTH</code></td>
         <td align="left" valign="top">0000001</td>
         <td align="left" valign="top">Доступ на исполнение для остальных.</td>
        </tr>
       </table>
       <p>Некоторые из этих масок служат цели изолирования различных наборов битов, закодированных в поле <code>st_mode</code>:</p>
       <p>• <code>S_IFMT</code> представляет биты 12–15, которыми закодированы различные типы файлов.</p>
       <p>• <code>S_IRWXU</code> представляет биты 6–8, являющиеся правами доступа владельца (на чтение, запись, исполнение для User).</p>
       <p>• <code>S_IRWXG</code> представляет биты 3–5, являющиеся правами доступа группы (на чтение, запись, исполнение для Group).</p>
       <p>• <code>S_IRWXO</code> представляет биты 0–2, являющиеся правами доступа для «остальных» (на чтение, запись, исполнение для Other).</p>
       <p>Биты прав доступа и типа файла графически изображены на рис. 5.3.</p>
       <image l:href="#img_9.jpeg"/>
       <p><strong>Рис. 5.3</strong>. Биты прав доступа и типа файлов</p>
       <p>Маски типов файлов стандартизованы главным образом для совместимости со старым кодом; они не должны использоваться непосредственно, поскольку такой код менее читаем, чем соответствующие макросы. Случается, что макрос реализован с использованием масок: довольно логично, но это не подходит для кода уровня пользователя.</p>
       <p>Стандарт POSIX явным образом констатирует; что в будущем не будут стандартизированы новые битовые маски и что тесты для любых дополнительных разновидностей типов файлов, которые могут быть добавлены, будут доступны лишь в виде макросов <code>S_IS<emphasis>xxx</emphasis>()</code>.</p>
      </section>
      <section>
       <title>
        <p>5.4.4.1. Сведения об устройстве</p>
       </title>
       <p>Стандарт POSIX не определяет значение типа <code>dev_t</code>, поскольку предполагалось его использование на не-Unix системах также, как на Unix-системах. Однако стоит знать, что находится в <code>dev_t</code>.</p>
       <p>Когда истинно <code>S_ISBLK(sbuf.st_mode)</code> или <code>S_ISCHR(sbuf.st_mode)</code>, сведения об устройстве находятся в поле <code>sbuf.st_rdev</code>. В противном случае это поле не содержит никакой полезной информации.</p>
       <p>Традиционно файлы устройств Unix кодируют <emphasis>старший</emphasis> и <emphasis>младший</emphasis> номера устройства в значении <code>dev_t</code>. По старшему номеру различают тип устройства, такой, как «дисковый привод» или «ленточный привод». Старшие номера различают также разные типы устройств, такие, как диск SCSI в противоположность диску IDE. Младшие номера различают устройства данного типа, например, первый диск или второй. Вы можете увидеть эти значения с помощью '<code>ls -l</code>':</p>
       <p><code>$ <strong>ls -l /dev/hda /dev/hda?</strong> /* Показать номера для первого жесткого диска */</code></p>
       <p><code>brw-rw---- 1 root disk 3, 0 Aug 31 2002 /dev/hda</code></p>
       <p><code>brw-rw---- 1 root disk 3, 1 Aug 31 2002 /dev/hda1</code></p>
       <p><code>brw-rw---- 1 root disk 3, 2 Aug 31 2002 /dev/hda2</code></p>
       <p><code>brw-rw---- 1 root disk 3, 3 Aug 31 2002 /dev/hda3</code></p>
       <p><code>brw-rw---- 1 root disk 3, 4 Aug 31 2002 /dev/hda4</code></p>
       <p><code>brw-rw---- 1 root disk 3, 5 Aug 31 2002 /dev/hda5</code></p>
       <p><code>brw-rw---- 1 root disk 3, 6 Aug 31 2002 /dev/hda6</code></p>
       <p><code>brw-rw---- 1 root disk 3, 7 Aug 31 2002 /dev/hda7</code></p>
       <p><code>brw-rw---- 1 root disk 3, 8 Aug 31 2002 /dev/hda8</code></p>
       <p><code>brw-rw---- 1 root disk 3, 9 Aug 31 2002 /dev/hda9</code></p>
       <p><code>$ <strong>ls -l /dev/null</strong> /* Показать сведения также для /dev/null */</code></p>
       <p><code>crw-rw-rw- 1 root root 1, 3 Aug 31 2002 /dev/null</code></p>
       <p>Вместо размера файла <code>ls</code> отображает старший и младший номера. В случае жесткого диска <code>/dev/hda</code> представляет диск в целом, <code>/dev/hda1</code>, <code>/dev/hda2</code> и т.д. представляют разделы внутри диска. У них у всех общий старший номер устройства (3), но различные младшие номера устройств.</p>
       <p>Обратите внимание, что дисковые устройства являются блочными устройствами, тогда как <code>/dev/null</code> является символьным устройством. Блочные и символьные устройства являются отдельными сущностями; даже если символьное устройство и блочное устройство имеют один и тот же старший номер устройства, они необязательно связаны</p>
       <p>Старший и младший номера устройства можно извлечь из значения <code>dev_t</code> с помощью функций <code>major()</code> и <code>minor()</code>, определенных в <code>&lt;sys/sysmacros.h&gt;</code>:</p>
       <p><code>#include &lt;sys/types.h&gt; /* Обычный */</code></p>
       <p><code>#include &lt;sys/sysmacros.h&gt;</code></p>
       <empty-line/>
       <p><code>int major(dev_t dev);                /* Старший номер устройства */</code></p>
       <p><code>int minor(dev_t dev);                /* Младший номер устройства */</code></p>
       <p><code>dev_t makedev(int major, int minor); /* Создать значение dev_t */</code></p>
       <p>(Некоторые системы реализуют их в виде макросов.)</p>
       <p>Функция <code>makedev()</code> идет другим путем; она принимает отдельные значения старшего и младшего номеров и кодирует их в значении <code>dev_t</code>. В других отношениях ее использование выходит за рамки данной книги; патологически любопытные должны посмотреть <emphasis>mknod</emphasis>(2).</p>
       <p>Следующая программа, <code>ch05-devnum.c</code>, показывает, как использовать системный вызов <code>stat()</code>, макросы проверки типа файла и, наконец, макросы <code>major()</code> и <code>minor()</code>.</p>
       <p><code>/* ch05-devnum.c --- Демонстрация stat(), major(), minor(). */</code></p>
       <p><code>#include &lt;stdio.h&gt;</code></p>
       <p><code>#include &lt;errno.h&gt;</code></p>
       <p><code>#include &lt;sys/types.h&gt;</code></p>
       <p><code>#include &lt;sys/stat.h&gt;</code></p>
       <p><code>#include &lt;sys/sysmacros.h&gt;</code></p>
       <empty-line/>
       <p><code>int main(int argc, char **argv) {</code></p>
       <p><code> struct stat sbuf;</code></p>
       <p><code> char *devtype;</code></p>
       <p><code> if (argc != 2) {</code></p>
       <p><code>  fprintf(stderr, "usage: %s path\n", argv[0]);</code></p>
       <p><code>  exit(1);</code></p>
       <p><code> }</code></p>
       <p><code> if (stat(argv[1], &amp;sbuf) &lt; 0) {</code></p>
       <p><code>  fprintf(stderr, "%s: stat: %s\n", argv[1], strerror(errno));</code></p>
       <p><code>  exit(1);</code></p>
       <p><code> }</code></p>
       <p><code> if (S_ISCHR(sbuf.st_mode))</code></p>
       <p><code>  devtype = "char";</code></p>
       <p><code> else if (S_ISBLK(sbuf.st_mode))</code></p>
       <p><code>  devtype = "block";</code></p>
       <p><code> else {</code></p>
       <p><code>  fprintf(stderr, "%s is not a block or character device\n",</code></p>
       <p><code>   argv[1]);</code></p>
       <p><code>  exit(1);</code></p>
       <p><code> }</code></p>
       <p><code> printf("%s: major: %d, minor: %d\n", devtype,</code></p>
       <p><code>  major(sbuf.st_rdev), minor(sbuf.st_rdev));</code></p>
       <p><code> exit(0);</code></p>
       <p><code>}</code></p>
       <p>Вот что происходит при запуске программы:</p>
       <p><code>$ <strong>ch05-devnum /tmp </strong>/* Попробовать не устройство */</code></p>
       <p><code>/tmp is not a block or character device</code></p>
       <p><code>$ <strong>ch05-devnum /dev/null</strong> /* Символьное устройство */</code></p>
       <p><code>char: major: 1, minor: 3</code></p>
       <p><code>$ <strong>ch05-devnum /dev/hda2</strong> /* Блочное устройство */</code></p>
       <p><code>block: major: 3, minor: 2</code></p>
       <p>К счастью, вывод согласуется с выводом <code>ls</code>, давая нам уверенность<a l:href="#n59" type="note">[59]</a>, что мы в самом деле написали правильный код.</p>
       <p>Воспроизведение вывода ls замечательно и хорошо, но действительно ли это полезно? Ответ — да. Любое приложение, работающее с иерархиями файлов, должно быть способно различать различные типы файлов. Подумайте об архиваторе, таком как <code>tar</code> или <code>cpio</code>. Было бы пагубно, если бы такая программа рассматривала файл дискового устройства как обычный файл, пытаясь прочесть его и сохранить его содержимое в архиве! Или подумайте о <code>find</code>, которая может выполнять произвольные действия, основываясь на типе и других атрибутах файлов, с которыми она сталкивается, (<code>find</code> является сложной программой; посмотрите <emphasis>find</emphasis>(1), если вы с ней не знакомы.) Или даже нечто простое, как пакет, оценивающий свободное дисковое пространство, тоже должно отличать обычные файлы от всего остального.</p>
      </section>
      <section>
       <title>
        <p>5.4.4.2. Возвращаясь к V7 <code>cat</code></p>
       </title>
       <p>В разделе 4.4.4 «Пример: Unix cat» мы обещали вернуться к программе V7 <code>cat</code>, чтобы посмотреть, как она использует системный вызов <code>stat()</code>. Первая группа строк, использовавшая ее, была такой:</p>
       <p><code>31 fstat(fileno(stdout), &amp;statb);</code></p>
       <p><code>32 statb.st_mode &amp;= S_IFMT;</code></p>
       <p><code>33 if (statb.st_mode != S_IFCHR &amp;&amp; statb.st_mode != S_IFBLK) {</code></p>
       <p><code>34  dev = statb.st_dev;</code></p>
       <p><code>35  ino = statb.st_ino;</code></p>
       <p><code>36 }</code></p>
       <p>Этот код теперь должен иметь смысл. В строке 31 вызывается <code>fstat()</code> для стандартного вывода, чтобы заполнить структуру <code>statb</code>. Строка 32 отбрасывает всю информацию в <code>statb.st_mode</code> за исключением типа файла, используя логическое AND с маской <code>S_IFMT</code>. Строка 33 проверяет, что используемый для стандартного вывода файл не является файлом устройства. В таком случае программа сохраняет номера устройства и индекса в <code>dev</code> и <code>ino</code>. Эти значения затем проверяются для каждого входного файла в строках 50–56.</p>
       <p><code>50 fstat(fileno(fi), &amp;statb);</code></p>
       <p><code>51 if (statb.st_dev == dev &amp;&amp; statb.st_ino == ino) {</code></p>
       <p><code>52  fprintf(stderr, "cat: input %s is output\n",</code></p>
       <p><code>53   ffig ? "-" : *argv);</code></p>
       <p><code>54  fclose(fi);</code></p>
       <p><code>55  continue;</code></p>
       <p><code>56 }</code></p>
       <p>Если значения <code>st_dev</code> и <code>st_ino</code> входного файла совпадают с соответствующими значениями выходного файла, <code>cat</code> выдает сообщение и продолжает со следующего файла, указанного в командной строке.</p>
       <p>Проверка сделана безусловно, хотя <code>dev</code> и <code>ino</code> устанавливаются, лишь если вывод не является файлом устройства. Это срабатывает нормально из-за того, как эти переменные объявлены:</p>
       <p><code>int dev, ino = -1;</code></p>
       <p>Поскольку <code>ino</code> инициализирован значением (-1), ни один действительный номер индекса не будет ему соответствовать<a l:href="#n60" type="note">[60]</a>. То, что <code>dev</code> не инициализирован так, является небрежным, но не представляет проблемы, поскольку тест в строке 51 требует, чтобы были равными значения как устройства, так и индекса. (Хороший компилятор выдаст предупреждение, что <code>dev</code> используется без инициализации: '<code>gcc -Wall</code>' сделает это.)</p>
       <p>Обратите также внимание, что ни один вызов <code>fstat()</code> не проверяется на ошибки. Это также небрежность, хотя не такая большая, маловероятно, что <code>fstat()</code> завершится неудачей с действительным дескриптором файла</p>
       <p>Проверка того, что входной файл не равен выходному файлу, осуществляется лишь для файлов, не являющихся устройствами. Это дает возможность использовать <code>cat</code> для копирования ввода из файлов устройств в самих себя, как в случае с терминалами:</p>
       <p><code>$ <strong>tty</strong> /* Вывести имя устройства текущего терминала */</code></p>
       <p><code>/dev/pts/3</code></p>
       <p><code>$ <strong>cat /dev/pts/3 &gt; /dev/pts/3</strong> /* Копировать ввод от клавиатуры на экран */</code></p>
       <p><code><strong>this is a line of text</strong> /* Набираемое в строке */</code></p>
       <p><code>this is a line of text /* cat это повторяет */</code></p>
      </section>
     </section>
     <section>
      <title>
       <p>5.4.5. Работа с символическими ссылками</p>
      </title>
      <p>В общем, символические ссылки ведут себя подобно прямым ссылкам; файловые операции, такие, как <code>open()</code> и <code>stat()</code>, применяются к указываемому файлу вместо самой символической ссылки. Однако, бывают моменты, когда в самом деле необходимо работать с символической ссылкой вместо файла, на которую она указывает.</p>
      <p>По этой причине существует системный вызов <code>lstat()</code>. Он действует точно также, как <code>stat()</code>, но если проверяемый файл окажется символической ссылкой, возвращаемые сведения относятся к символической ссылке, а не к указываемому файлу. А именно:</p>
      <p>• <code>S_ISLNK(sbuf.st_mode)</code> будет <code>true</code>.</p>
      <p>• <code>sbuf.st_size</code> содержит число байтов в имени указываемого файла.</p>
      <p>Мы уже видели, что системный вызов <code>symlink()</code> создает символическую ссылку. Но если дана существующая символическая ссылка, как можно получить имя файла, на которую она указывает? (Очевидно, <code>ls</code> может получить это имя; поэтому мы должны быть способны это сделать.)</p>
      <p>Открывание ссылки с помощью <code>open()</code> для чтения ее с использованием <code>read()</code> не будет работать, <code>open()</code> следует по ссылке на указываемый файл. Таким образом, символические ссылки сделали необходимым дополнительный системный вызов, который называется <code>readlink()</code>:</p>
      <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
      <empty-line/>
      <p><code>int readlink(const char *path, char *buf, size_t bufsiz);</code></p>
      <p><code>readlink()</code> помещает содержимое символической ссылки, на имя которой указывает <code>path</code>, в буфер, на который указывает <code>buf</code>. Копируется не более <code>bufsiz</code> символов. Возвращаемое значение равно числу символов, помещенных в <code>buf</code>, либо -1, если возникла ошибка, <code>readlink()</code> <emphasis>не</emphasis> вставляет завершающий нулевой байт.</p>
      <p>Обратите внимание, что если буфер, переданный <code>readlink()</code>, слишком маленький, информация будет потеряна; полное имя указываемого файла будет недоступно. Чтобы использовать <code>readlink()</code> должным образом, вы должны делать следующее:</p>
      <p>1. Используйте <code>lstat()</code>, чтобы убедиться, что это символическая ссылка.</p>
      <p>2. Убедитесь, что ваш буфер для содержимого символической ссылки составляет по крайней мере '<code>sbuf.st_size + 1</code>' байтов; '<code>+ 1</code>' нужно для завершающего нулевого байта, чтобы сделать буфер годной к употреблению строкой С.</p>
      <p>3. Вызовите <code>readlink()</code>. Не мешает проверить, что возвращенное значение равно <code>sbuf.st_size</code>.</p>
      <p>4. Добавьте '<code>\0</code>' к байту после содержимого ссылки, чтобы превратить его в строку С. Код для всего этого мог бы выглядеть примерно так:</p>
      <p><code>/* Проверка ошибок для краткости опущена */</code></p>
      <p><code>int count;</code></p>
      <p><code>char linkfile[PATH_MAX], realfile[PATH_MAX]; /* PATH_MAX в &lt;limits.h&gt; */</code></p>
      <p><code>strut stat sbuf;</code></p>
      <p><code>/* ...поместить в linkfile путь к нужной символической ссылке... */</code></p>
      <p><code>lstat(linkfile, &amp;sbuf); /* Получить сведения от stat */</code></p>
      <p><code>if (!S_ISLNK(sbuf.st_mode)) /* Проверить, что это ссылка */</code></p>
      <p><code> /* не символическая ссылка, обработать это */</code></p>
      <p><code>if (sbuf.st_size + 1 &gt; PATH_МАХ) /* Проверить размер буфера */</code></p>
      <p><code> /* обработать проблемы с размером буфера */</code></p>
      <p><code>count = readlink(linkfile, realfile, PATH_MAX);</code></p>
      <p><code>/* Прочесть ссылку */</code></p>
      <p><code>if (count != sbuf.st_size)</code></p>
      <p><code> /* происходит что-то странное, обработать это */</code></p>
      <p><code>realfile(count) = '\0'; /* Составить строку С */</code></p>
      <p>Данный пример для простоты представления использует буферы фиксированного размера. Реальный код мог бы использовать для выделения буфера нужного размера <code>malloc()</code>, поскольку массивы фиксированного размера могли бы оказаться слишком маленькими. Файл <code>lib/xreadlink.c</code> в GNU Coreutils делает именно это. Он читает содержимое символической ссылки в память, выделенную <code>malloc()</code>. Мы покажем здесь саму функцию, большая часть файла представляет собой стереотипные определения. Номера строк относятся к началу файла:</p>
      <p><code>55 /* Вызвать readlink для получения значения ссылки FILENAME.</code></p>
      <p><code>56 Вернуть указатель на завершенную NUL строку в выделенной malloc памяти.</code></p>
      <p><code>57 При ошибке readlink вернуть NULL (использовать errno для диагноза).</code></p>
      <p><code>58 При ошибке realloc или если значение ссылки больше SIZE_MAX,</code></p>
      <p><code>59 выдать диагностику и выйти. */</code></p>
      <p><code>60</code></p>
      <p><code>61 char*</code></p>
      <p><code>62 xreadlink(char const* filename)</code></p>
      <p><code>63 {</code></p>
      <p><code>64  /* Начальный размер буфера для ссылки. Степень 2 обнаруживает</code></p>
      <p><code>65     арифметическое переполнение раньше, но не рекомендуется. */</code></p>
      <p><code>66  size_t buf_size = 128;</code></p>
      <p><code>67</code></p>
      <p><code>68  while(1)</code></p>
      <p><code>69  {</code></p>
      <p><code>70   char *buffer = xmalloc(buf_size);</code></p>
      <p><code>71   ssize_t link_length = readlink(filename, buffer, buf_size);</code></p>
      <p><code>72</code></p>
      <p><code>73   if (link_length &lt; 0)</code></p>
      <p><code>74   {</code></p>
      <p><code>75    int saved_errno = errno;</code></p>
      <p><code>76    free(buffer);</code></p>
      <p><code>77    errno = saved_errno;</code></p>
      <p><code>78    return NULL;</code></p>
      <p><code>79   }</code></p>
      <p><code>80</code></p>
      <p><code>81   if ((size_t)link_length &lt; buf_size)</code></p>
      <p><code>82   {</code></p>
      <p><code>83    buffer[link_length] = 0;</code></p>
      <p><code>84    return buffer;</code></p>
      <p><code>85   }</code></p>
      <p><code>86</code></p>
      <p><code>87   free(buffer);</code></p>
      <p><code>88   buf_size *= 2;</code></p>
      <p><code>89   if (SSIZE_MAX &lt; buf_size || (SIZE_MAX / 2 &lt; SSIZE_MAX &amp;&amp; buf_size == 0))</code></p>
      <p><code>90    xalloc_die();</code></p>
      <p><code>91  }</code></p>
      <p><code>92 }</code></p>
      <p>Тело функции состоит из бесконечного цикла (строки 68–91), разрываемого в строке 84, которая возвращает выделенный буфер. Цикл начинается выделением первоначального буфера (строка 70) и чтения ссылки (строка 71). Строки 73–79 обрабатывают случай ошибки, сохраняя и восстанавливая errno таким образом, что она может корректно использоваться вызывающим кодом.</p>
      <p>Строки 81–85 обрабатывают случай «успеха», при котором размер содержимого ссылки меньше размера буфера. В этом случае добавляется завершающий ноль (строка 83), а затем буфер возвращается, прерывая бесконечный цикл. Это гарантирует, что в буфер помещено все содержимое ссылки, поскольку у <code>readlink()</code> нет возможности сообщить о «недостаточном размере буфера».</p>
      <p>Строки 87–88 освобождают буфер и удваивают размер буфера для следующей попытки в начале цикла. Строки 89–90 обрабатывают случай, при котором размер ссылки слишком велик: <code>buf_size</code> больше, чем <code>SSIZE_MAX</code>, или <code>SSIZE_MAX</code> больше, чем значение, которое может быть представлено в знаковом целом того же размера, который использовался для хранения <code>SIZE_MAX</code>, и <code>buf_size</code> обернулся в ноль. (Это маловероятные условия, но странные вещи все же случаются.) Если одно из этих условий верно, программа завершается с сообщением об ошибке. В противном случае функция возвращается в начало цикла, чтобы сделать еще одну попытку выделить буфер и прочесть ссылку.</p>
      <p>Некоторое дополнительное разъяснение: условие '<code>SIZE_MAX / 2 &lt; SSIZE_MAX</code>' верно лишь на системах, в которых '<code>SIZE_MAX &lt; 2 * SSIZE_MAX</code>'; мы не знаем таких, но лишь на таких системах <code>buf_size</code> может обернуться в ноль. Поскольку на практике это условие не может быть истинным, компилятор может оптимизировать все выражение, включив следующую проверку '<code>buf_size == 0</code>'. После прочтения этого кода вы можете спросить: «Почему не использовать <code>lstat()</code> для получения размера символической ссылки, не выделить буфер нужного размера с помощью <code>malloc()</code>, и все?» На это есть несколько причин.<a l:href="#n61" type="note">[61]</a></p>
      <p>• <code>lstat()</code> является системным вызовом — лучше избежать накладных расходов по его вызову, поскольку содержимое большинства символических ссылок поместится в первоначальный размер буфера в 128.</p>
      <p>• Вызов <code>lstat()</code> создает условие состязания: ссылка может измениться между исполнением <code>lstat()</code> и <code>readlink()</code>, в любом случае вынуждая повторение.</p>
      <p>• Некоторые системы не заполняют должным образом член <code>st_size</code> для символической ссылки. (Печально, но верно.) Сходным образом, как мы увидим в разделе 8.4.2 «Получение текущего каталога: <code>getcwd()</code>», Linux в <code>/proc</code> предоставляет специальные символические ссылки, у которых <code>st_size</code> равен нулю, но для которых <code>readlink()</code> возвращает действительное содержимое.</p>
      <p>Наконец, буфер не слишком большой, <code>xreadlink()</code> использует <code>free()</code> и <code>malloc()</code> с большим размером вместо <code>realloc()</code>, чтобы избежать бесполезного копирования, которое делает <code>realloc()</code>. (Поэтому комментарий в строке 58 устарел, поскольку <code>realloc()</code> не используется; это исправлено в версии Coreutils после 5.0.)</p>
     </section>
    </section>
    <section>
     <title>
      <p>5.5. Смена владельца, прав доступа и времени изменения</p>
     </title>
     <section>
      <p>Несколько других системных вызовов дают вам возможность изменять другие относящиеся к файлу сведения: в частности, владельца и группу файла, права доступа к файлу и времена доступа и изменения файла.</p>
     </section>
     <section>
      <title>
       <p>5.5.1. Смена владельца файла: <code>chown()</code>, <code>fchown()</code> и <code>lchown()</code></p>
      </title>
      <p>Владелец и группа файла изменяются с помощью трех сходных системных вызовов.</p>
      <p><code>#include &lt;sys/types.h&gt; /* POSIX */</code></p>
      <p><code>#include &lt;unistd.h&gt;</code></p>
      <empty-line/>
      <p><code>int chown(const char *path, uid_t owner, gid_t group);</code></p>
      <p><code>int fchown(int fd, uid_t owner, gid_t group);</code></p>
      <p><code>int lchown(const char *path, uid_t owner, gid_t group);</code></p>
      <p><code>chown()</code> работает с аргументом имени файла, <code>fchown()</code> работает с открытым файлом, а <code>lchown()</code> работает с символической ссылкой вместо файла, на который эта ссылка указывает. Во всех других отношениях эти три вызова работают идентично, возвращая 0 в случае успеха и -1 при ошибке.</p>
      <p>Стоит заметить, что один системный вызов изменяет как владельца, так и группу файла. Чтобы изменить лишь владельца или лишь группу, передайте (-1) в качестве того идентификационного номера, который должен остаться без изменений.</p>
      <p>Хотя вы могли бы подумать, что можно передать соответствующее значение из полученного заранее <code>struct stat</code> для файла или файлового дескриптора, этот метод больше подвержен ошибкам. Возникает условие состязания: между вызовами <code>stat()</code> и <code>chown()</code> владелец или группа могут измениться.</p>
      <p>Вы могли бы поинтересоваться: «Зачем нужно изменять владельца символической ссылки? Права доступа и владение ей не имеют значения». Но что случится, если пользователь уходит, а все его файлы все еще нужны? Необходима возможность изменения владельца всех файлов этого лица на кого-то еще, включая символические ссылки.</p>
      <p>Системы GNU/Linux обычно не позволяют рядовым пользователям (не root) изменять владельца («отдавать») своих файлов. Смена группы на одну из групп пользователя, конечно, разрешена. Ограничение в смене владельцев идет от BSD систем, у которых тоже есть этот запрет. Главная причина в том, что разрешение пользователям отдавать файлы может нарушить дисковый учет. Рассмотрите такой сценарий:</p>
      <p><code>$ <strong>mkdir mywork</strong> /* Создать каталог */</code></p>
      <p><code>$ <strong>chmod go-rwx mywork</strong> /* Установить права доступа drwx------ */</code></p>
      <p><code>$ <strong>cd mywork</strong> /* Перейти в него */</code></p>
      <p><code>$ <strong>myprogram &gt; large_data_file</strong> /* Создать большой файл */</code></p>
      <p><code>$ <strong>chmod ugo+rw large_data_file</strong> /* Установить доступ -rw-rw-rw- */</code></p>
      <p><code>$ <strong>chown otherguy large_data_file</strong> /* Передать файл otherguy */</code></p>
      <p>В этом примере <code>large_data_file</code> теперь принадлежит пользователю <code>otherguy</code>. Первоначальный пользователь может продолжать читать и записывать файл из-за его прав доступа. Но дисковое пространство, которое он занимает, будет записано на счет <code>otherguy</code>. Однако, поскольку он находится в каталоге, который принадлежит первому пользователю и к которому <code>otherguy</code> не может получить доступ, <code>otherguy</code> не имеет возможности удалить файл.</p>
      <p>Некоторые системы System V разрешают пользователям передавать свои файлы. (При смене владельца соответствующие биты файлов <code>setuid</code> и <code>setgid</code> сбрасываются.) Это может быть особенной проблемой, когда файлы извлекаются из архива <code>.tar</code> или <code>.cpio</code>; извлеченные файлы имеют UID и GID, закодированный в архиве. На таких системах программы <code>tar</code> и <code>cpio</code> имеют опции, предотвращающие это, но важно знать, что поведение <code>chown()</code> действительно отличается на разных системах.</p>
      <p>В разделе 6.3 «Имена пользователя и группы» мы увидим, как соотносить имена пользователя и группы с соответствующими числовыми значениями</p>
     </section>
     <section>
      <title>
       <p>5.5.2. Изменение прав доступа: <code>chmod()</code> и <code>fchmod()</code></p>
      </title>
      <p>Изменение прав доступа осуществляется с помощью одного из двух системных вызовов, <code>chmod()</code> и <code>fchmod()</code>:</p>
      <p><code>#include &lt;sys/types.h&gt; /* POSIX */</code></p>
      <p><code>#include &lt;sys/stat.h&gt;</code></p>
      <empty-line/>
      <p><code>int chmod(const char *path, mode_t mode);</code></p>
      <p><code>int fchmod(int fildes, mode_t mode);</code></p>
      <p><code>chmod()</code> работает с аргументом имени файла, a <code>fchmod()</code> работает с открытым файлом. (В POSIX нет вызова <code>lchmod()</code>, поскольку система игнорирует установки прав доступа для символических ссылок. Хотя на некоторых системах такой вызов действительно есть). Как и для большинства других системных вызовов, они возвращают 0 в случае успеха и -1 при ошибке. Права доступа к файлу может изменить лишь владелец файла или <code>root</code>.</p>
      <p>Значение mode создается таким же образом, как для <code>open()</code> и <code>creat()</code>, как обсуждалось в разделе 4.6 «Создание файлов». См. также табл. 5.2, в которой перечислены константы прав доступа.</p>
      <p>Система не допустит установки бита setgid (<code>S_ISGID</code>), если группа файла не совпадает с ID действующей группы процесса или с одной из его дополнительных групп. (Мы пока не обсуждали подробно эти проблемы; см. раздел 11.1.1 «Реальные и действующие ID».) Разумеется, эта проверка не относится к <code>root</code> или коду, выполняющемуся как <code>root</code>.</p>
     </section>
     <section>
      <title>
       <p>5.5.3. Изменение временных отметок: <code>utime()</code></p>
      </title>
      <section>
       <p>Структура <code>struct stat</code> содержит три поля типа <code>time_t</code>:</p>
       <p><code>st_atime  </code>Время последнего доступа к файлу (чтение)</p>
       <p><code>st_mtime  </code>Время последнего изменения файла (запись).</p>
       <p><code>st_ctime  </code>Время последнего изменения индекса файла (например, переименования)</p>
       <p>Значение <code>time_t</code> представляет время в «секундах с начала эпохи». <emphasis>Эпоха</emphasis> является Началом Времени для компьютерных систем GNU/Linux и Unix используют в качестве начала Эпохи полночь 1 января 1970 г по универсальному скоординированному времени (UTC).<a l:href="#n62" type="note">[62]</a> Системы Microsoft Windows используют в качестве начала Эпохи полночь 1 января 1980 г. (очевидно, местное время).</p>
       <p>Значения <code>time_t</code> иногда называют временными отметками (timestamps). В разделе 6.1 «Время и даты» мы рассмотрим, как получаются эти данные и как они используются. Пока достаточно знать, чем является значение <code>time_t</code> и то, что оно представляет секунды с начала Эпохи.</p>
       <p>Системный вызов <code>utime()</code> позволяет изменять отметки времени доступа к файлу и его изменения:</p>
       <p><code>#include &lt;sys/types.h&gt; /* POSIX */</code></p>
       <p><code>#include &lt;utime.h&gt;</code></p>
       <empty-line/>
       <p><code>int utime(const char *filename, struct utimbuf *buf);</code></p>
       <p>Структура <code>utimbuf</code> выглядит следующим образом:</p>
       <p><code>struct utimbuf {</code></p>
       <p><code> time_t actime;  /* время доступа */</code></p>
       <p><code> time_t modtime; /* время изменения */</code></p>
       <p><code>};</code></p>
       <p>При успешном вызове возвращается 0, в противном случае возвращается -1. Если <code>buf</code> равен <code>NULL</code>, система устанавливает время доступа и время изменения равным текущему времени.</p>
       <p>Чтобы изменить только одну временную отметку, используйте оригинальное значение из <code>struct stat</code>. Например.</p>
       <p><code>/* Для краткости проверка ошибок опущена */</code></p>
       <p><code>struct stat sbuf;</code></p>
       <p><code>struct utimbuf ut;</code></p>
       <p><code>time_t now;</code></p>
       <empty-line/>
       <p><code>time(&amp;now); /* Получить текущее время дня, см. след. главу */</code></p>
       <p><code>stat("/some/file", &amp;sbuf); /* Заполнить sbuf */</code></p>
       <p><code>ut.actime = sbuf.st_atime; /* Время доступа без изменений */</code></p>
       <p><code>ut.modtime = now - (24 * 60 * 60);</code></p>
       <p><code> /* Установить modtime на 24 часа позже */</code></p>
       <p><code>utime("/some/file", &amp;ut); /* Установить значения */</code></p>
       <p>Вы можете спросить себя: «Почему может понадобиться кому-нибудь изменять времена доступа и изменения файла?» Хороший вопрос.</p>
       <p>Чтобы на него ответить, рассмотрите случай программы, создающей дублирующие архивы, такой, как <code>tar</code> или <code>cpio</code>. Эти программы должны прочесть содержание файла, чтобы заархивировать его. Чтение файла, конечно, изменяет время доступа к файлу.</p>
       <p>Однако, этот файл, возможно, не читался человеком в течение 10 лет. Некто, набрав '<code>ls -lu</code>', что отображает время доступа (вместо времени изменения по умолчанию), увидел бы, что последний раз данный файл просматривали 10 лет назад. Поэтому программа архивации должна сохранить оригинальные значения времени доступа и изменения, прочесть файл для архивации, а затем восстановить первоначальное время с помощью <code>utime()</code>.</p>
       <p>Аналогичным образом, рассмотрите случай архивирующей программы, <emphasis>восстанавливающей</emphasis> файл из архива. В архиве хранятся первоначальные значения времени доступа и изменения. Однако, когда файл извлечен из архива во вновь созданную копию на диске, новый файл имеет текущие дату и время для значений времени доступа и изменения.</p>
       <p>Однако полезнее, когда вновь созданный файл <emphasis>выглядит</emphasis>, как если бы он имел тот же возраст, что и оригинальный файл в архиве. Поэтому архиватор должен иметь возможность устанавливать значения времени доступа и изменения в соответствии со значениями в архиве.</p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. В новом коде вы можете захотеть использовать вызов <code>utimes()</code> (обратите внимание на s в имени), который описан далее в книге, в разделе 14.3.2 «Файловое время в микросекундах: <code>utimes()</code>»</p>
       </cite>
      </section>
      <section>
       <title>
        <p>5.5.3.1. Подделка <code>utime(file, NULL)</code></p>
       </title>
       <p>Некоторые более старые системы не устанавливают значения времени доступа и изменения равным текущему времени, когда второй аргумент <code>utime()</code> равен <code>NULL</code>. Однако код более высокого уровня (такой, как GNU <code>touch</code>) проще, если он может полагаться на один стандартизованный интерфейс.</p>
       <p>Поэтому библиотека GNU Coreutils содержит замещающую функцию для <code>utime()</code>, которая обрабатывает этот случай, которую потом может вызвать код более высокого уровня. Это отражает принцип проектирования «выбор лучшего интерфейса для работы», который мы описали в разделе 1.5 «Возвращаясь к переносимости».</p>
       <p>Замещающая функция находится в файле <code>lib/utime.c</code> в дистрибутиве Coreutils Следующий код является версией из Coreutils 5.0. Номера строк относятся к началу файла:</p>
       <p><code>24 #include &lt;sys/types.h&gt;</code></p>
       <p><code>25</code></p>
       <p><code>26 #ifdef HAVE_UTIME_H</code></p>
       <p><code>27 # include &lt;utime.h&gt;</code></p>
       <p><code>28 #endif</code></p>
       <p><code>39</code></p>
       <p><code>30 #include "full-write.h"</code></p>
       <p><code>31 #include "safe-read.h"</code></p>
       <p><code>32</code></p>
       <p><code>33 /* Некоторые системы (даже имеющие &lt;utime.h&gt;) нигде не объявляют</code></p>
       <p><code>34    эту структуру. */</code></p>
       <p><code>35 #ifndef HAVE_STRUCT_UTIMBUF</code></p>
       <p><code>36 struct utimbuf</code></p>
       <p><code>37 {</code></p>
       <p><code>38  long actime;</code></p>
       <p><code>39  long modtime;</code></p>
       <p><code>40 };</code></p>
       <p><code>41 #endif</code></p>
       <p><code>42</code></p>
       <p><code>43 /* Эмулировать utime(file, NULL) для систем (подобных 4.3BSD),</code></p>
       <p><code>44    которые не устанавливают в этом случае текущее время для времени</code></p>
       <p><code>45    доступа и изменения file. Вернуть 0, если успешно, -1 если нет. */</code></p>
       <p><code>46</code></p>
       <p><code>47 static int</code></p>
       <p><code>48 utime_null(const char *file)</code></p>
       <p><code>49 {</code></p>
       <p><code>50 #if HAVE_UTIMES_NULL</code></p>
       <p><code>51  return utimes(file, 0);</code></p>
       <p><code>52 #else</code></p>
       <p><code>53  int fd;</code></p>
       <p><code>54  char c;</code></p>
       <p><code>55  int status = 0;</code></p>
       <p><code>56  struct stat sb;</code></p>
       <p><code>57</code></p>
       <p><code>58  fd = open(file, O_RDWR);</code></p>
       <p><code>59  if (fd &lt; 0</code></p>
       <p><code>60   || fstat(fd, &amp;sb) &lt; 0</code></p>
       <p><code>61   || safe_read(fd, &amp;c, sizeof c) == SAFE_READ_ERROR</code></p>
       <p><code>62   || lseek(fd, (off_t)0, SEEK_SET) &lt; 0</code></p>
       <p><code>63   || full_write(fd, &amp;c, sizeof c) != sizeof с</code></p>
       <p><code>64 /* Можно сделать - это необходимо на SunOS4.1.3 с некоторой комбинацией</code></p>
       <p><code>65    заплат, но та система не использует этот код: у нее есть utimes.</code></p>
       <p><code>66   || fsync(fd) &lt; 0</code></p>
       <p><code>67    */</code></p>
       <p><code>68   || (st.st_size == 0 &amp;&amp; ftruncate(fd, st.st_size) &lt; 0)</code></p>
       <p><code>69   || close(fd) &lt; 0)</code></p>
       <p><code>70   status = -1;</code></p>
       <p><code>71  return status;</code></p>
       <p><code>72 #endif</code></p>
       <p><code>73 }</code></p>
       <p><code>74</code></p>
       <p><code>75 int</code></p>
       <p><code>76 rpl_utime(const char *file, const struct utimbuf *times)</code></p>
       <p><code>77 {</code></p>
       <p><code>78  if (times)</code></p>
       <p><code>79   return utime(file, times);</code></p>
       <p><code>80</code></p>
       <p><code>81  return utime_null(file);</code></p>
       <p><code>82 }</code></p>
       <p>Строки 33–41 определяют структуру <code>struct utimbuf</code>; как сказано в комментарии, некоторые системы не объявляют эту структуру. Работу осуществляет функция <code>utime_null()</code>. Используется системный вызов <code>utimes()</code>, если он доступен (<code>utimes()</code> является сходным, но более развитым системным вызовом, который рассматривается в разделе 14.3.2 «Файловое время в микросекундах: <code>utimes()</code>.» Он допускает также в качестве второго аргумента <code>NULL</code>, что означает использование текущего времени.)</p>
       <p>В случае, когда время должно обновляться вручную, код осуществляет обновление, прочитав сначала из файла байт, а затем записав его обратно. (Первоначальный touch Unix работал таким способом.) Операции следующие:</p>
       <p>1. Открыть файл, строка 58.</p>
       <p>2. Вызвать для файла <code>stat()</code>, строка 60.</p>
       <p>3. Прочесть один байт, строка 61 Для наших целей <code>safe_read()</code> действует подобно <code>read()</code>; это объясняется в разделе 10.4.4 «Повторно запускаемые системные вызовы»).</p>
       <p>4. Переместиться обратно на начало файла с помощью <code>lseek()</code>, строка 62. Это сделано для записи только что прочитанного байта обратно поверх себя.</p>
       <p>5. Записать байт обратно, строка 63. <code>full_write()</code> действует подобно <code>write()</code>; это также рассматривается в разделе 10.4.4 «Повторно запускаемые системные вызовы»).</p>
       <p>6. Если файл имеет нулевой размер, использовать <code>ftruncate()</code> для установки его размера в ноль (строка 68). Это не изменяет файл, но имеет побочный эффект обновления времени доступа и изменения (<code>ftruncate()</code> была описана в разделе 4 8 «Установка длины файла».)</p>
       <p>7. Закрыть файл, строка 69.</p>
       <p>Все эти шаги осуществляются в одной длинной последовательной цепи проверок внутри <code>if</code>. Проверки сделаны так, что если любое сравнение неверно, <code>utime_null()</code> возвращает -1, как обычный системный вызов, <code>errno</code> автоматически устанавливается системой для использования кодом более высокого уровня.</p>
       <p>Функция <code>rpl_utime()</code> (строки 75–82) является «заместителем <code>utime()</code>». Если второй аргумент не равен <code>NULL</code>, она вызывает настоящую <code>utime()</code>. В противном случае она вызывает <code>utime_null()</code>.</p>
      </section>
     </section>
     <section>
      <title>
       <p>5.5.4. Использование <code>fchown()</code> и <code>fchmod()</code> для обеспечения безопасности</p>
      </title>
      <p>В исходных системах Unix были только системные вызовы <code>chown()</code> и <code>chmod()</code>. Однако, на сильно загруженных системах эти системные вызовы попадают в условия состязания, посредством чего злоумышленник может организовать замещение другим файлом файла, у которого изменяется владелец или права доступа.</p>
      <p>Однако, после открытия файла условие состязания больше не представляет проблему. Программа может использовать <code>stat()</code> с именем файла для получения информации о файле. Если получены сведения, которые ожидались, после открытия файла <code>fstat()</code> может проверить, что файл тот же самый (сравнив поля <code>st_dev</code> и <code>st_ino</code> структур <code>struct stat</code> «до» и «после»).</p>
      <p>Когда программа знает, что файлы те же самые, владение или права доступа могут быть изменены с помощью <code>fchown()</code> или <code>fchmod()</code>.</p>
      <p>Эти системные вызовы, также как <code>lchown()</code>, сравнительно недавние;<a l:href="#n63" type="note">[63]</a> в старых системах Unix их не было, хотя в современных совместимых с POSIX системах они есть.</p>
      <p>Соответствующих функций <code>futime()</code> или <code>lutime()</code> нет. В случае <code>futime()</code> это (очевидно) потому, что временные отметки не являются критическими для безопасности системы в том же отношении, что для владения и прав доступа, <code>lutime()</code> отсутствует потому, что временные отметки неуместны для символических ссылок.</p>
     </section>
    </section>
    <section>
     <title>
      <p>5.6. Резюме</p>
     </title>
     <p>• Иерархия файлов и каталогов, как она видится пользователю, является одним логическим деревом, корень которого находится в <code>/</code>. Оно составлено из одного или более разделов, каждый из которых содержит файловую систему. Внутри файловой системы в индексах хранятся данные о файлах (метаданные), включая размещение блоков данных.</p>
     <p>• Каталоги осуществляют связь между именами файлов и индексами. Концептуально содержимое каталога, которое является просто последовательностью пар (индекс, имя). Каждый элемент каталога для файла называется (прямой) ссылкой, а файлы могут иметь множество ссылок. Прямые ссылки, поскольку они работают лишь по номеру индекса, все должны находиться в одной файловой системе. Символические ссылки являются указателями на файлы или каталоги и работают на основе имени файла, а не номера индекса, поэтому их использование не ограничено одной и той же файловой системой.</p>
     <p>• Прямые ссылки создаются с помощью <code>link()</code>, символические ссылки создаются с помощью <code>symlink()</code>, ссылки удаляются с помощью <code>unlink()</code>, а переименовываются файлы (с возможным перемещением в другой каталог) с помощью <code>rename()</code>. Блоки данных файла не освобождаются до тех пор, пока счетчик ссылок не достигнет нуля и не закроется последний открытый дескриптор файла.</p>
     <p>• Каталоги создаются с помощью <code>mkdir()</code>, а удаляются с помощью <code>rmdir()</code>; перед удалением каталог должен быть пустым (не оставлено ничего, кроме '<code>.</code>' и '<code>..</code>'). GNU/Linux версия функции ISO С <code>remove()</code> вызывает соответствующие функции <code>unlink()</code> или <code>rmdir()</code>.</p>
     <p>• Каталоги обрабатываются с помощью функций <code>opendir()</code>, <code>readdir()</code>, <code>rewinddir()</code> и <code>closedir()</code>. <code>struct dirent</code> содержит номер индекса и имя файла. Максимально переносимый код использует в члене <code>d_name</code> только имя файла. Функции BSD <code>telldir()</code> и <code>seekdir()</code> для сохранения и восстановления текущего положения в каталоге широко доступны, но не полностью переносимы, как другие функции работы с каталогами.</p>
     <p>• Вспомогательные данные получаются с помощью семейства системных вызовов <code>stat()</code>, структура <code>struct stat</code> содержит всю информацию о файле <emphasis>за исключением</emphasis> имени файла. (В самом деле, поскольку у файла может быть множество имен или он может совсем не иметь ссылок, невозможно сделать имя доступным.)</p>
     <p>• Макрос <code>S_IS<emphasis>xxx</emphasis>()</code> в <code>&lt;sys/stat.h&gt;</code> дает возможность определить тип файла. Функции <code>major()</code> и <code>minor()</code> из <code>&lt;sys/sysmacros.h&gt;</code> дают возможность расшифровки значений <code>dev_t</code>, представляющих блочные и символьные устройства.</p>
     <p>• Символические ссылки можно проверить, использовав <code>lstat()</code>, а поле <code>st_size</code> структуры <code>struct stat</code> для символической ссылки возвращает число байтов, необходимых для размещения имени указываемого файла. Содержимое символической ссылки читают с помощью <code>readlink()</code>. Нужно позаботиться о том, чтобы размер буфера был правильным и чтобы завершить полученное имя файла нулевым байтом, чтобы можно было его использовать в качестве строки С.</p>
     <p>• Несколько разнообразных системных вызовов обновляют другие данные: семейство <code>chown()</code> используется для смены владельца и группы, процедуры <code>chmod()</code> для прав доступа к файлу, a <code>utime()</code> для изменения значений времени доступа и изменения файла.</p>
    </section>
    <section>
     <title>
      <p>Упражнения</p>
     </title>
     <p>1. Напишите программу '<code>const char *fmt_mode(mode_t mode)</code>'. Ввод представляет собой значение <code>mode_t</code>, полученное из поля <code>st_mode</code> структуры <code>struct stat</code>; т.е. оно содержит как биты прав доступа, так и типа файла.</p>
     <p>Вывод должен представлять строку в 10 символов, идентичную первому полю вывода '<code>ls -l</code>'. Другими словами, первый символ обозначает тип файла, а остальные девять — права доступа.</p>
     <p>Когда установлены биты <code>S_ISUID</code> и <code>S_IXUSR</code>, используйте <code>s</code> вместо <code>x</code>; если установлен лишь бит <code>I_ISUID</code>, используйте <code>S</code>. То же относится к битам <code>S_ISGID</code> и <code>S_IXGRP</code>. Если установлены оба бита <code>S_ISVTX</code> и <code>S_IXOTH</code>, используйте <code>t</code>; для одного <code>S_ISVTX</code> используйте <code>T</code>.</p>
     <p>Для простоты можете использовать статический (<code>static</code>) буфер, содержимое которого перезаписывается при каждом вызове процедуры.</p>
     <p>2. Доработайте <code>ch05-catdir.c</code>, чтобы она вызывала <code>stat()</code> для каждого найденного имени файла. Затем выведите номер индекса, результат вызова <code>fmt_mode()</code>, число ссылок и имя файла.</p>
     <p>3. Доработайте <code>ch05-catdir.c</code> так, что если файл является символической ссылкой, программа будет также выводить имя указываемого файла.</p>
     <p>4. Добавьте такую опцию, что если имя файла является именем подкаталога, программа рекурсивно входит в него и отображает сведения о файлах (и каталогах) этого подкаталога. Необходим лишь один уровень рекурсии.</p>
     <p>5. Если вы не работаете на системе GNU/Linux, запустите <code>ch05-trymkdir</code> (см. раздел 5.2 «Создание и удаление каталогов») на своей системе и сравните результаты с приведенными нами.</p>
     <p>6. Напишите программу <code>mkdir</code>. Посмотрите свою локальную справочную страницу для <emphasis>mkdir</emphasis>(1) и реализуйте все ее опции.</p>
     <p>7. В корневом каталоге, <code>/</code>, как номер устройства, так и номер индекса для '<code>.</code>' и '<code>..</code>' совпадают. Используя эту информацию, напишите программу <code>pwd</code>.</p>
     <p>Вначале программа должна найти имя текущего каталога, прочитав содержимое родительского каталога. Затем она должна продолжить собирать сведения о иерархии файловой системы, пока не достигнет корневого каталога.</p>
     <p>Отображение имени каталога в обратном порядке, от текущего каталога до корневого, легко. Как будет справляться ваша версия <code>pwd</code> с выводом имени каталога правильным образом, от корневого каталога вниз?</p>
     <p>8. Если вы написали <code>pwd</code>, использовав рекурсию, напишите ее снова, использовав итерацию. Если вы использовали итерацию, напишите ее с использованием рекурсии. Что лучше? (Подсказка: рассмотрите очень глубоко вложенные деревья каталогов.)</p>
     <p>9. Тщательно исследуйте функцию <code>rpl_utime()</code> (см. раздел 5.5.3.1 «Подделка <code>utime(file, NULL)</code>»). Какой ресурс не восстанавливается, если одна из проверок в середине <code>if</code> не выполняется? (Спасибо Джеффу Колье (Geoff Collyer).)</p>
     <p>10. (Трудное) Прочтите страницу справки для <emphasis>chmod</emphasis>(1). Напишите код для анализа аргумента символических опций, который позволяет добавлять, удалять и устанавливать права доступа на основе владельца, группы, других и «всех».</p>
     <p>Когда вы решите, что это работает, напишите свою собственную версию <code>chmod</code>, которая применяет назначенные права доступа к каждому файлу или каталогу, указанному в командной строке. Какую функцию вы использовали, <code>chmod()</code> — или <code>open()</code> и <code>fchmod()</code> — и почему?</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 6</p>
     <p>Общие библиотечные интерфейсы — часть 1</p>
    </title>
    <section>
     <p>В главе 5 «Каталоги и служебные данные файлов» мы видели, что непосредственное чтение каталога возвращает имена файлов в том порядке, в каком они хранятся в каталоге. Мы также видели, что <code>struct stat</code> содержит всю информацию о файле за исключением его имени. Однако, некоторые компоненты этой структуры не могут использоваться непосредственно; они являются просто числовыми значениями.</p>
     <p>В данной главе представлена оставшаяся часть API, необходимая для полного использования значений компонентов <code>struct stat</code>. Мы по порядку рассматриваем следующие темы: значения <code>time_t</code> для представления времени и функций форматирования времени; функции сортировки и поиска (для сортировки имен файлов или других данных); типы <code>uid_t</code> и <code>gid_t</code> для представления пользователей, групп и функций, которые сопоставляют их с соответствующими именами пользователей и групп; и наконец, функцию для проверки того, что дескриптор файла представляет терминал.</p>
    </section>
    <section>
     <title>
      <p>6.1. Времена и даты</p>
     </title>
     <section>
      <p>Значения времени хранятся в типе, который известен как <code>time_t</code>. Стандарт ISO С гарантирует, что это числовой тип, но во всем остальном никак не указывает, чем именно он является (целым или с плавающей точкой), как и не указывает степень точности хранящихся в нем значений.</p>
      <p>На системах GNU/Linux и Unix значения <code>time_t</code> представляют «секунды с начала Эпохи». Эпоха представляет собой начало записываемого времени, которое относится к полночи 1 января 1970 г. по UTC. На большинстве систем <code>time_t</code> является <code>long int</code> С. Для 32-разрядных систем это означает, что <code>time_t</code> переполнится 19 января 2038 г. К тому времени, мы надеемся, тип <code>time_t</code> будет переопределен как по меньшей мере 64-разрядное значение.</p>
      <p>Для получения текущего времени, вычисления разницы между двумя значениями <code>time_t</code>, преобразования значений <code>time_t</code> в более удобное представление и форматирования обоих представлений в виде символьных строк существуют различные функции. Вдобавок, представление даты и времени можно преобразовать обратно в <code>time_t</code>, доступна также ограниченная информация по часовым поясам.</p>
      <p>Отдельный набор функций предоставляет доступ к текущему времени с разрешением, большим чем одна секунда. Функции работают с предоставлением двух различных значений, времени в виде секунд с начала Эпохи и числа микросекунд в текущей секунде. Эти функции описаны далее в разделе 14.3.1 «Время в микросекундах: <code>gettimeofday()</code>».</p>
     </section>
     <section>
      <title>
       <p>6.1.1. Получение текущего времени: <code>time()</code> и <code>difftime()</code></p>
      </title>
      <p>Системный вызов <code>time()</code> получает текущие дату и время; <code>difftime()</code> вычисляет разницу между двумя значениями <code>time_t</code>:</p>
      <p><code>#include &lt;time.h&gt; /* ISO С */</code></p>
      <empty-line/>
      <p><code>time_t time(time_t *t);</code></p>
      <p><code>double difftime(time_t time1, time_t time0);</code></p>
      <p><code>time()</code> возвращает текущее время. Если параметр <code>t</code> не равен <code>NULL</code>, переменная, на которую указывает <code>t</code>, также заполняется значением текущего времени. Функция возвращает <code>(time_t)(-1)</code>, если была ошибка, устанавливая <code>errno</code>.</p>
      <p>Хотя ISO С не указывает, чем является значение <code>time_t</code>, POSIX определяет, что оно представляет время в секундах. Поэтому это предположение является обычным и переносимым. Например, чтобы посмотреть, что значение времени представляет отметку в прошлом шесть месяцев назад или позже, можно использовать код, подобный этому:</p>
      <p><code>/* Для краткости проверка ошибок опущена */</code></p>
      <p><code>time_t now, then, some_time;</code></p>
      <p><code>time(&amp;now); /* Получить текущее время */</code></p>
      <p><code>then = now - (6L * 31 * 24 * 60 * 60); /* Примерно 6 месяцев назад */</code></p>
      <p><code>/* ...установить какое-нибудь время, например, через stat()... */</code></p>
      <p><code>if (some_time &lt; then)</code></p>
      <p><code> /* более 6 месяцев назад */</code></p>
      <p><code>else</code></p>
      <p><code> /* менее 6 месяцев назад */</code></p>
      <p>Однако, поскольку переносимый код может потребоваться запустить на не-POSIX системах, существует функция <code>difftime()</code> для вычисления разницы между двумя значениями времени. Тот же самый тест с использованием <code>difftime()</code> можно было бы написать таким способом:</p>
      <p><code>time_t now, some_value;</code></p>
      <p><code>const double six_months = 6.0 * 31 * 24 * 60 * 60;</code></p>
      <p><code>time(&amp;now); /* Получить текущее время */</code></p>
      <p><code>/* ...установить какое-нибудь время, например, через stat()... */</code></p>
      <p><code>if (difftime(now, some_time) &gt;= six_months)</code></p>
      <p><code> /* более 6 месяцев назад */</code></p>
      <p><code>else</code></p>
      <p><code> /* менее 6 месяцев назад */</code></p>
      <p>Возвращаемым типом <code>difftime()</code> является <code>double</code>, поскольку <code>time_t</code> может также содержать доли секунд. На системах POSIX он всегда представляет целые секунды.</p>
      <p>В обоих предыдущих примерах обратите внимание на использование типизированных констант, чтобы форсировать выполнение вычислений с нужным математическим типом: <code>6L</code> в первом случае для целых <code>long</code>, 6.0 во втором случае для чисел с плавающей точкой</p>
     </section>
     <section>
      <title>
       <p>6.1.2. Разложение времени: <code>gmtime()</code> и <code>localtime()</code></p>
      </title>
      <p>На практике форма представления даты и времени в виде «секунд с начала эпохи» не является очень удобной, кроме очень простых сравнений. Самостоятельное вычисление компонентов времени, таких, как месяц, день, год и т.д., подвержено ошибкам, поскольку необходимо принять во внимание местный часовой пояс (возможно, с учетом перехода на летнее время), правильно вычислить високосные годы и пр. К счастью, две стандартные процедуры делают за вас эту работу:</p>
      <p><code>#include &lt;time.h&gt; /* ISO С */</code></p>
      <empty-line/>
      <p><code>struct tm *gmtime(const time_t *timep);</code></p>
      <p><code>struct tm *localtime(const time_t *timep);</code></p>
      <p><code>gmtime()</code> возвращает указатель на <code>struct tm</code>, которая представляет время UTC. <code>localtime()</code> возвращает указатель на <code>struct tm</code>, представляющий местное время, т.е. в расчет берутся текущий часовой пояс и переход на летнее время. На самом деле это «время для настенных часов», дата и время, которые были бы отображены на настенных или ручных часах. (Как это работает, обсуждается далее в разделе 6.1.5 «Получение сведений о часовом поясе».)</p>
      <p>Обе функции возвращают указатель на <code>struct tm</code>, которая выглядит следующим образом:</p>
      <p><code>struct tm {</code></p>
      <p><code> int tm_sec;   /* секунды */</code></p>
      <p><code> int tm_min;   /* минуты */</code></p>
      <p><code> int tm_hour;  /* часы */</code></p>
      <p><code> int tm_mday;  /* день месяца */</code></p>
      <p><code> int tm_mon;   /* месяц */</code></p>
      <p><code> int tm_year;  /* год */</code></p>
      <p><code> int tm_wday;  /* день недели */</code></p>
      <p><code> int tm_yday;  /* день в году */</code></p>
      <p><code> int tm_isdst; /* летнее время */</code></p>
      <p><code>};</code></p>
      <p><code>struct tm</code> называют <emphasis>разложенным временем (broken-down time)</emphasis>, поскольку значение <code>time_t</code> «разложено» на свои составные части. Составные части, их диапазоны и значения показаны в табл. 6.1.</p>
      <empty-line/>
      <p><strong>Таблица 6.1</strong>. Поля структуры <code>tm</code></p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Член</th>
        <th align="left" valign="top">Диапазон</th>
        <th align="left" valign="top">Значение</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>tm_sec</code></td>
        <td align="left" valign="top">0–60</td>
        <td align="left" valign="top">Секунда минуты. Секунда 60 предусматривает пропущенные (leap) секунды. (В C89 был диапазон 0–61.)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>tm_min</code></td>
        <td align="left" valign="top">0–59</td>
        <td align="left" valign="top">Минута часа.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>tm_hour</code></td>
        <td align="left" valign="top">0–23</td>
        <td align="left" valign="top">Час дня</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>tm_mday</code></td>
        <td align="left" valign="top">1–31</td>
        <td align="left" valign="top">День месяца</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>tm_mon</code></td>
        <td align="left" valign="top">0–11</td>
        <td align="left" valign="top">Месяц года</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>tm_year</code></td>
        <td align="left" valign="top">0–<emphasis>N</emphasis></td>
        <td align="left" valign="top">Год, начиная с 1900 г.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>tm_wday</code></td>
        <td align="left" valign="top">0–6</td>
        <td align="left" valign="top">День недели, воскресенье = 0</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>tm_yday</code></td>
        <td align="left" valign="top">0–365</td>
        <td align="left" valign="top">День года, 1 января = 0.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>tm_isdst</code></td>
        <td align="left" valign="top">&lt;0, 0, &gt;0</td>
        <td align="left" valign="top">Флаг летнего времени.</td>
       </tr>
      </table>
      <p>Стандарт ISO С представляет большинство этих значений как «<code>x</code> после <code>y</code>». Например, <code>tm_sec</code> является числом «секунд после минуты», <code>tm_mon</code> «месяцев после января», <code>tm_wday</code> «дней недели после воскресенья» и т.д. Это помогает понять, почему все значения начинаются с 0. (Единственным исключением, достаточно логичным, является <code>tm_mday</code>, день месяца, имеющий диапазон 1–31.) Конечно, отсчет их с нуля также практичен; поскольку массивы С отсчитываются с нуля, использование этих значений в качестве индексов тривиально:</p>
      <p><code>static const char *const days[] = { /* Массив имен дней */</code></p>
      <p><code> "Sunday", "Monday", "Tuesday", "Wednesday",</code></p>
      <p><code> "Thursday", "Friday", "Saturday",</code></p>
      <p><code>};</code></p>
      <p><code>time_t now;</code></p>
      <p><code>struct tm *curtime;</code></p>
      <empty-line/>
      <p><code>time(&amp;now); /* Получить текущее время */</code></p>
      <p><code>curtime = gmtime(&amp;now); /* Разложить его */</code></p>
      <p><code>printf("Day of the week: %s\n", days[curtime-&gt;tm_wday]);</code></p>
      <p><code> /* Проиндексировать и вывести */</code></p>
      <p>Как <code>gmtime()</code>, так и <code>localtime()</code> возвращают указатель на <code>struct tm</code>. Указатель указывает на static <code>struct tm</code>, содержащуюся в каждой процедуре, и похоже, что эти структуры <code>struct tm</code> переписываются каждый раз, когда вызываются процедуры. Поэтому хорошая мысль сделать <emphasis>копию</emphasis> возвращенной <code>struct</code>. Возвращаясь к предыдущему примеру.</p>
      <p><code>static const char *const days[] = { /* Как ранее */ };</code></p>
      <p><code>time_t now;</code></p>
      <p><code>struct tm curtime; /* Структура, а не указатель */</code></p>
      <p><code>time(&amp;now); /* Получить текущее время */</code></p>
      <p><code>curtime = *gmtime(&amp;now); /* Разложить его и скопировать данные */</code></p>
      <p><code>printf("Day of the week: %s\n", days[curtime.tm_wday]);</code></p>
      <p><code> /* Проиндексировать и напечатать, использовать . , а не -&gt; */</code></p>
      <p>Поле <code>tm_isdst</code> указывает, действует ли в настоящий момент летнее время (DST) Значение 0 означает, что DST не действует, положительное значение означает, что действует, а отрицательное значение — что информация о DST недоступна. (Стандарт С намеренно неконкретен, указывая лишь нулевое, положительное и отрицательное значения; это дает возможность большей свободы при реализации.)</p>
     </section>
     <section>
      <title>
       <p>6.1.3. Форматирование даты и времени</p>
      </title>
      <section>
       <p>Примеры в предыдущем разделе показали, как поля в <code>struct tm</code> могли бы быть использованы в качестве индексов символьных строк для вывода информативных значений даты и времени. Хотя можно было бы написать собственный код, использующий такие массивы для форматирования даты и времени, стандартные процедуры облегчают работу</p>
      </section>
      <section>
       <title>
        <p>6.1.3.1. Простое форматирование времени: <code>asctime()</code> и <code>ctime()</code></p>
       </title>
       <p>Две первые стандартные процедуры, перечисленные ниже, выводят данные в фиксированном формате:</p>
       <p><code>#include &lt;time.h&gt; /* ISO С */</code></p>
       <empty-line/>
       <p><code>char *asctime(const struct tm *tm);</code></p>
       <p><code>char *ctime(const time_t *timep);</code></p>
       <p>Как и в случае с <code>gmtime()</code> и <code>localtime()</code>, <code>asctime()</code> и <code>ctime()</code> возвращают указатели на статические буфера, которые могут быть перезаписаны после каждого вызова. Более того, эти две процедуры возвращают строки в одном и том же формате. Они отличаются лишь видом принимаемых аргументов, <code>asctime()</code> и <code>ctime()</code> должны использоваться тогда, когда все, что вам нужно, это простые сведения о дате и времени.</p>
       <p><code>#include &lt;stdio.h&gt;</code></p>
       <p><code>#include &lt;time.h&gt;</code></p>
       <empty-line/>
       <p><code>int main(void) {</code></p>
       <p><code> time_t now;</code></p>
       <p><code> time(&amp;now);</code></p>
       <p><code> printf("%s", ctime(&amp; now));</code></p>
       <p><code>}</code></p>
       <p>После запуска эта программа выводит результат в виде: '<code>Thu May 22 15:44:21 2003</code>'. Завершающий символ конца строки <emphasis>включен</emphasis> в результат. Точнее, возвращаемое значение указывает на массив из 26 символов, как показано на рис. 6.1.</p>
       <image l:href="#img_10.jpeg"/>
       <p><strong>Рис. 6.1</strong>. Возвращаемая функциями <code>ctime()</code> и <code>asctime()</code> строка</p>
       <p>Значительная часть старого кода Unix полагается на тот факт, что значения в возвращенной строке имеют фиксированную позицию. При использовании этих функций помните, что они включают завершающий символ конца строки. Поэтому наш небольшой пример программы использует для <code>printf()</code> простую форматирующую строку "<code>%s</code>", а не "<code>%s\n</code>", как можно было бы ожидать.</p>
       <p><code>ctime()</code> устраняет необходимость шага вызова <code>localtime()</code>; в сущности, это эквивалентно</p>
       <p><code>time_t now;</code></p>
       <p><code>char *curtime;</code></p>
       <p><code>time(&amp;now);</code></p>
       <p><code>curtime = asctime(localtime(&amp;now));</code></p>
      </section>
      <section>
       <title>
        <p>6.1.3.2. Сложное форматирование времени: <code>strftime()</code></p>
       </title>
       <p>Хотя часто достаточно использования <code>asctime()</code> и <code>ctime()</code>, у них есть также и ограничения:</p>
       <p>• Формат вывода фиксирован. Нет способа изменить порядок элементов.</p>
       <p>• В вывод не включаются сведения о часовом поясе.</p>
       <p>• В выводе используются сокращенные названия месяца и дня.</p>
       <p>• В выводе используются английские названия месяцев и дней.</p>
       <p>По этим причинам C89 ввело стандартную библиотечную процедуру <code>strftime()</code>:</p>
       <p><code>#include &lt;time.h&gt; /* ISO С */</code></p>
       <empty-line/>
       <p><code>size_t strftime(char *s, size_t max, const char *format,</code></p>
       <p><code> const struct tm *tm);</code></p>
       <p><code>strftime()</code> сходна с <code>sprintf()</code>. Ее аргументы следующие:</p>
       <p><code>char *s</code></p>
       <p>Буфер для форматированной строки.</p>
       <p><code>size_t max</code></p>
       <p>Размер буфера.</p>
       <p><code>const char *format</code></p>
       <p>Форматирующая строка.</p>
       <p><code>const struct tm *tm</code></p>
       <p>Указатель на <code>struct tm</code>, представляющий разложенное время, которое надо отформатировать.</p>
       <p>Форматирующая строка содержит символы букв, смешанные о описателями преобразования, указывающими, что должно быть помещено в строку, такими, как полное имя дня недели, час в соответствии с 24-часовым или 12-часовым циклом, наличие указателей am или p.m<a l:href="#n64" type="note">[64]</a>, и т.д. (Вскоре будут приведены примеры.)</p>
       <p>Если всю строку можно отформатировать с использованием не более <code>max</code> символов, возвращаемое значение представляет собой число символов, помещенных в <code>s</code>, <emphasis>не</emphasis> включая завершающий нулевой байт. В противном случае, возвращаемое значение ноль. В последнем случае содержание <code>s</code> «неопределенно». Следующий простой пример дает представление об использовании <code>strftime()</code>:</p>
       <p><code>#include &lt;stdio.h&gt;</code></p>
       <p><code>#include &lt;time.h&gt;</code></p>
       <empty-line/>
       <p><code>int main(void) {</code></p>
       <p><code> char buf[100];</code></p>
       <p><code> time_t now;</code></p>
       <p><code> struct tm *curtime;</code></p>
       <p><code> time(&amp;now);</code></p>
       <p><code> curtime = localtime(&amp;now);</code></p>
       <p><code> (void)strftime(buf, sizeof buf,</code></p>
       <p><code>  "It is now %A, %B %d, %Y, %I:%M %p", curtime);</code></p>
       <p><code> printf("%s\n", buf);</code></p>
       <p><code> exit(0);</code></p>
       <p><code>}</code></p>
       <p>После запуска эта программа выводит что-то типа:</p>
       <p><code>It is now Thursday, May 22, 2003, 04:15 PM</code></p>
       <p>В табл. 6.2 предоставлен полный список описателей преобразования, их возможные альтернативные представления и их значения. Вдобавок стандарт C99 добавил к списку дополнительные описатели; новые для C99 описатели помечены символом &#8730;.</p>
       <empty-line/>
       <p><strong>Таблица 6.2</strong>. Описатели преобразования формата <code>strftime()</code></p>
       <table>
        <tr align="left">
         <th align="left" valign="top">Описатель</th>
         <th align="left" valign="top">C99</th>
         <th align="left" valign="top">Значение</th>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%a</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Локальное сокращенное название дня недели.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%A</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Локальное полное название дня недели.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%b</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Локальное сокращенное название месяца.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%B</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Локальное полное название месяца.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%c, %Ec</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Локальное «подходящее» представление даты и времени</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%C, %EC</code></td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">Век (00–99)</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%d, %Od</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">День месяца (01–31)</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%D</code></td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">То же, что <code>%m/%d/%y</code></td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%e, %Oe</code></td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">День месяца. Одна цифра дополняется пробелом (1–31).</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%F</code></td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">То же, что и <code>%Y-%m-%d</code> (формат даты ISO 8601)</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%g</code></td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">Две последние цифры, основанной на неделе года (00–99).</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%G</code></td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">Основанный на неделе год ISO 8601</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%h</code></td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">То же, что и <code>%b</code></td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%H, %OH</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Час в 24-часовом цикле (00–23)</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%I, %OI</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Час в 12-часовом цикле (01–12)</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%j</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">День года (001–366)</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%m, %Om</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Месяц в виде числа (01–12).</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%M, %OM</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Минута в виде числа (00–59)</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%n</code></td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">Символ конца строки ('<code>\n</code>')</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%p</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Локальное обозначение a.m./p.m.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%r</code></td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">Локальное время в 12-часовом цикле</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%R</code></td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">Тоже, что и <code>%H:%M</code></td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%S, %OS</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Секунда в виде числа (00–60)</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%t</code></td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">Символ табуляции ('<code>\t</code>')</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%T</code></td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">То же, что и <code>%H:%M:%S</code> (формат ISO 8601).</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%u, %Ou</code></td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">Число дня недели ISO 8601, понедельник = 1 (1–7).</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%U, %OU</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Номер недели, первое воскресенье является первым днем недели 1 (00–53)</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%V, %OV</code></td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">Номер недели ISO 8601 (01–53)</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%w, %Ow</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">День недели как число, воскресенье = 0 (0–6).</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%W, %OW</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Номер недели, первый понедельник является первым днем недели 1 (00–53)</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%x, %Ex</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Локальное «подходящее» представление даты</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%X, %EX</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Локальное «подходящее» представление времени.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%y, %Ey, %Oy</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Две последние цифры года (00–99)</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%Y, %EY</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Год как число.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%Z</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Локальный часовой пояс или отсутствие символов, если сведения о часовом поясе недоступны</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%%</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Простой <code>%</code></td>
        </tr>
       </table>
       <p><emphasis>Локаль (locale)</emphasis> является способом описания местной специфики, принимая во внимание такие вещи, как язык, кодировка символов и значения по умолчанию для форматирования дат, времени, денежных сумм и т.д. Мы будем иметь с ними дело в главе 13 «Интернационализация и локализация». Пока достаточно понять, что результаты <code>strftime()</code> для одной и той же форматирующей строки могут быть разными в зависимости от настроек текущей локали.</p>
       <p>Версии, начинающиеся с <code>%E</code> и <code>%O</code>, предназначены для «альтернативного представления». В некоторых локалях есть несколько способов представления одних и тех же сведений; эти описатели предоставляют доступ к дополнительным представлениям. Если определенная локаль не поддерживает альтернативного представления, <code>strftime()</code> использует обычную версию.</p>
       <p>Многие Unix-версии <code>date</code> дают возможность предоставить в командной строке форматирующую строку, начинающуюся с символа '<code>+</code>'. Затем <code>date</code> форматирует текущие дату и время и выводит в соответствии с форматирующей строкой:</p>
       <p><code>$ <strong>date + 'It is now %A, %B %d, %Y, %I:%M %p'</strong></code></p>
       <p><code>It is now Sunday, May 25, 2003, 06:44 PM</code></p>
       <p>Большинство новых описателей C99 происходит от таких существующих реализаций <code>date</code> Unix. Описатели <code>%n</code> и <code>%t</code> не являются в С абсолютно необходимыми, поскольку символы табуляции и конца строки могут быть помещены в строку непосредственно. Однако в контексте форматирующей строки <code>date</code> для командной строки они имеют больше смысла. Поэтому они также включены в спецификацию <code>strftime()</code>.</p>
       <p>Стандарт ISO 8601 определяет (среди других вещей), как нумеруются недели в пределах года. В соответствии с этим стандартом недели отсчитываются с понедельника по воскресенье, а понедельник является днем недели 1, а не 0. Если неделя, в которой оказывается 1 января, содержит по крайней мере четыре дня нового года, она считается неделей 1. В противном случае, это последняя неделя предыдущего года с номером 52 или 53. Эти правила используются для вычислений описателей форматов <code>%g</code>, <code>%G</code> и <code>%V</code>. (Хотя ограниченным американцам, таким, как автор, эти правила могут показаться странными, они обычно повсюду используются в Европе.)</p>
       <p>Многие из описателей стандартов дают результаты, специфичные для текущей локали. Вдобавок некоторые указывают, что они выдают «подходящее» представление для локали (например, <code>%x</code>). Стандарт C99 определяет значения для локали «С». Эти значения перечислены в табл. 6.3</p>
       <empty-line/>
       <p><strong>Таблица 6.3</strong>. Значения локали «С» для определенных форматов <code>strftime()</code></p>
       <table>
        <tr align="left">
         <th align="left" valign="top">Описатель</th>
         <th align="left" valign="top">Значение</th>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%а</code></td>
         <td align="left" valign="top">Первые три символа <code>%А</code>.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%А</code></td>
         <td align="left" valign="top">Один из дней Sunday, Monday, …, Saturday</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%b</code></td>
         <td align="left" valign="top">Первые три символа <code>%В</code></td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%В</code></td>
         <td align="left" valign="top">Один из месяцев January, February, …, December</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%с</code></td>
         <td align="left" valign="top">То же, что и <code>%а %b %е %T %Y</code></td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%p</code></td>
         <td align="left" valign="top">AM или PM</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%r</code></td>
         <td align="left" valign="top">То же, что и <code>%I:%M:%S %p</code></td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%x</code></td>
         <td align="left" valign="top">То же, что и <code>%m/%d/%y</code></td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%X</code></td>
         <td align="left" valign="top">То же, что и <code>%T</code>.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>%Z</code></td>
         <td align="left" valign="top">Определяется реализацией</td>
        </tr>
       </table>
       <p>Должно быть очевидно, что <code>strftime()</code> предоставляет значительную гибкость и контроль над связанным с датой и временем выводом, во многом таким же образом, как <code>printf()</code> и <code>sprintf()</code>. Более того, <code>strftime()</code> не может переполнить буфер, поскольку она проверяет входной параметр размера, что делает ее более безопасной процедурой, чем <code>sprintf()</code>.</p>
       <p>В качестве простого примера рассмотрим создание файлов журнала программы, когда каждый час создается новый файл. Имя файла должно включать дату и время создания:</p>
       <p><code>/* Проверка ошибок для краткости опущена */</code></p>
       <p><code>char fname[PATH_МАХ]; /* PATH_МАХ находится в &lt;limits.h&gt; */</code></p>
       <p><code>time_t now;</code></p>
       <p><code>struct tm *tm;</code></p>
       <p><code>int fd;</code></p>
       <empty-line/>
       <p><code>time(&amp;now);</code></p>
       <p><code>tm = localtime(&amp;now);</code></p>
       <p><code>strftime(fname, sizeof fname, "/var/log/myapp.%Y-%m-%d-%H:%M", tm);</code></p>
       <p><code>fd = creat(name, 0600);</code></p>
       <p><code>...</code></p>
       <p>Формат год-месяц-день-час-минута вызывает сортировку файлов в том порядке, в каком они были созданы.</p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. Некоторые форматы данных более полезны, чем другие. Например, 12-часовое время двусмысленно, также, как чисто числовые форматы дат. (Что означает '<code>9/11</code>'? Это зависит от того, где вы живете) Сходным образом, годы из двух цифр также являются плохой мыслью. Используйте <code>strftime()</code> благоразумно</p>
       </cite>
      </section>
     </section>
     <section>
      <title>
       <p>6.1.4. Преобразование разложенного времени в <code>time_t</code></p>
      </title>
      <p>Получение от системы значений «секунд с начала Эпохи» просто; именно так даты и времена хранятся в индексах и возвращаются с помощью <code>time()</code> и <code>stat()</code>. Эти значения также легко оценивать на равенство или посредством &lt; и &gt; для простых тестов раньше/позже.</p>
      <p>Однако, с датами, введенными людьми, не так легко работать. Например, многие версии команды <code>touch</code> позволяют предусмотреть дату и время, в которое <code>touch</code> должна установить время модификации или доступа к файлу (с помощью <code>utime()</code>, как было описано в разделе 5.5.3 «Изменение отметок времени: <code>utime()</code>»).</p>
      <p>Преобразование даты, введенной человеком, в значение <code>time_t</code> трудно: надо принять во внимание високосные годы, учесть часовые пояса и т.д. Поэтому стандарт C89 ввел функцию <code>mktime()</code>:</p>
      <p><code>#include &lt;time.h&gt; /* ISO С */</code></p>
      <empty-line/>
      <p><code>time_t mktime(struct tm *tm);</code></p>
      <p>Для использования <code>mktime()</code> укажите в <code>struct tm</code> соответствующие значения — год, месяц, день и т.д. Если вы знаете, действовало ли для данной даты летнее время, установите соответствующим образом поле <code>tm_isdst</code>: 0 для «нет» и положительное значение для «да». В противном случае, используйте отрицательное значение для «не знаю». Поля <code>tm_wday</code> и <code>tm_yday</code> игнорируются.</p>
      <p><code>mktime()</code> предполагает, что <code>struct tm</code> представляет локальное время, не UTC. Она возвращает значение <code>time_t</code>, представляющее переданные дату и время, или <code>(time_t)(-1)</code>, если данные дата/время не могут быть правильно представлены. После успешного возвращения все значения <code>struct tm</code> выверены на попадание в правильные диапазоны, a <code>tm_wday</code> и <code>tm_yday</code> также корректно установлены. Вот простой пример:</p>
      <p><code>1  /* ch06-echodate.c --- демонстрирует mktime(). */</code></p>
      <p><code>2</code></p>
      <p><code>3  #include &lt;stdio.h&gt;</code></p>
      <p><code>4  #include &lt;time.h&gt;</code></p>
      <p><code>5</code></p>
      <p><code>6  int main(void)</code></p>
      <p><code>7  {</code></p>
      <p><code>8   struct tm tm;</code></p>
      <p><code>9   time_t then;</code></p>
      <p><code>10</code></p>
      <p><code>11  printf("Enter a Date/time as YYYY/MM/DD HH:MM:SS : ");</code></p>
      <p><code>12  scanf("%d/%d/%d %d:%d:%d",</code></p>
      <p><code>13   &amp;tm.tm_year, &amp;tm.tm_mon, &amp;tm.tm_mday,</code></p>
      <p><code>14   &amp;tm.tm_hour, &amp;tm.tm_min, &amp;tm.tm_sec);</code></p>
      <p><code>15</code></p>
      <p><code>16  /* Проверка ошибок значений для краткости опущена. */</code></p>
      <p><code>17  tm.tm_year -= 1900;</code></p>
      <p><code>18  tm.tm_mon--;</code></p>
      <p><code>19</code></p>
      <p><code>20  tm.tm_isdst = -1; /* He знаю о летнем времени */</code></p>
      <p><code>21</code></p>
      <p><code>22  then = mktime(&amp;tm);</code></p>
      <p><code>23</code></p>
      <p><code>24  printf("Got: %s", ctime(&amp;then));</code></p>
      <p><code>25  exit(0);</code></p>
      <p><code>26 }</code></p>
      <p>В строке 11 запрашиваются дата и время, а в строках 12–14 соответствующие значения считываются. (В коде изделия возвращаемые <code>scanf()</code> значения должны проверяться.) Строки 17 и 18 компенсируют различную базу для лет и месяцев соответственно. Строка 20 указывает, что мы не знаем, представляют ли данные дата и время летнее время. Строка 22 вызывает <code>mktime()</code>, а строка 24 выводит результат преобразования. После компилирования и запуска мы видим, что это работает:</p>
      <p><code>$ <strong>ch06-echodate</strong></code></p>
      <p><code>Enter a Date/time as YYYY/MM/DD HH:MM:SS : 2003/5/25 19:07:23</code></p>
      <p><code>Got: Sun May 25 19:07:23 2003</code></p>
     </section>
     <section>
      <title>
       <p>6.1.5. Получение сведений о часовом поясе</p>
      </title>
      <section>
       <p>На ранних системах Unix сведения о часовом поясе внедрялись в ядро при компиляции. Правила перехода на летнее время обычно были жестко вшиты в код, что создавало трудности для пользователей вне Соединенных Штатов или в местах внутри Соединенных Штатов, в которых не осуществлялся переход на летнее время.</p>
       <p>В современных системах эти сведения выделены в двоичные файлы, которые читаются библиотекой С при извлечении функций, связанных со временем. Эта методика позволяет избежать необходимости в перекомпилировании библиотек и системных файлов при изменении правил и гораздо упрощает обновление правил.</p>
       <p>Интерфейс языка С для сведений о часовых поясах развивался в разных версиях Unix, как на System V, так и Berkley, пока, наконец, не был стандартизован POSIX следующим образом.</p>
       <p><code>#include &lt;time.h&gt; /* POSIX */</code></p>
       <empty-line/>
       <p><code>extern char *tzname[2];</code></p>
       <p><code>extern long timezone;</code></p>
       <p><code>extern int daylight;</code></p>
       <empty-line/>
       <p><code>void tzset(void);</code></p>
       <p>Функция <code>tzset()</code> проверяет переменную окружения <code>TZ</code> для получения сведений о часовом поясе и переходе на летнее время.<a l:href="#n65" type="note">[65]</a> Если эта переменная не установлена, <code>tzset()</code> использует «определенный в реализации часовой пояс по умолчанию», который скорее всего является часовым поясом машины, на которой вы работаете.</p>
       <p>После вызова <code>tzset()</code> сведения о локальном часовом поясе доступны в нескольких переменных:</p>
       <p><code>extern char *tzname[2]</code></p>
       <p>Стандартное имя и имя летнего времени для часового пояса. Например, для областей США в восточном часовом поясе именами часового пояса являются 'EST' (Eastern Standard Time) и 'EDT' (Eastern Daylight Time).</p>
       <p><code>extern long timezone</code></p>
       <p>Разница в секундах между текущим часовым поясом и UTC. Стандарт не определяет, как эта разница работает. На практике отрицательные значения представляют часовые пояса <emphasis>восточнее</emphasis> (перед, или те, которые позже) UTC; положительные значения представляют часовые пояса <emphasis>западнее</emphasis> (за, или те, которые раньше) UTC. Если вы посмотрите на это значение как «насколько изменить местное время, чтобы оно стало равно UTC», тогда знак этого значения имеет смысл.</p>
       <p><code>extern int daylight</code></p>
       <p>Эта переменная равна нулю, если правила перехода на летнее время никогда не должны использоваться для данного часового пояса, и не равны нулю в противном случае.</p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. Переменная <code>daylight</code> не означает, действует ли в настоящий момент летнее время! Вместо этого она просто констатирует, может ли текущий часовой пояс вообще иметь летнее время.</p>
       </cite>
       <p>Стандарт POSIX указывает, что <code>ctime()</code>, <code>localtime()</code>, <code>mktime()</code> и <code>strftime()</code> действуют, «как если бы» они вызывали <code>tzset()</code>. Это означает, что им в действительности не нужно вызывать <code>tzset()</code>, но они должны вести себя, как если бы эта функция была вызвана. (Формулировка призвана дать определенную гибкость при реализации, в то же время гарантируя правильное поведение кода уровня пользователя.)</p>
       <p>На практике это означает, что вы сами почти никогда не будете вызывать <code>tzset()</code>. Но если понадобится, эта функция есть.</p>
      </section>
      <section>
       <title>
        <p>6.1.5.1. Системы BSD: <code>timezone()</code>, не <code>timezone</code></p>
       </title>
       <p>Некоторые производные от BSD 4.4 системы вместо переменной POSIX <code>timezone</code> предоставляют функцию <code>timezone()</code>:</p>
       <p><code>#include &lt;time.h&gt; /* BSD */</code></p>
       <p><code>char *timezone(int zone, int dst);</code></p>
       <p>Аргумент <code>zone</code> является числом <emphasis>минут</emphasis> западнее GMT, a <code>dst</code> истинно, если действует летнее время. Возвращаемое значение является строкой, дающей имя указанного часового пояса, или значение, выраженное относительно GMT. Эта функция обеспечивает совместимость с функцией V7 с тем же именем и поведением.</p>
       <cite>
        <subtitle>Локальное время: откуда оно известно?</subtitle>
        <p>Системы GNU/Linux хранят информацию о часовых поясах в файлах и каталогах в <code>/usr/share/zoneinfo</code>:</p>
        <p><code>$ <strong>cd /usr/share/zoneinfo</strong></code></p>
        <p><code>$ <strong>ls -FC</strong></code></p>
        <p><code>Africa/     Canada/ Factory    Iceland   MST7MDT  Portugal  W-SU</code></p>
        <p><code>America/    Chile/  GB         Indian/   Mexico/  ROC       WET</code></p>
        <p><code>Antarctica/ Cuba    GB-Eire    Iran      Mideast/ ROK       Zulu</code></p>
        <p><code>Arctic/     EET     GMT        Israel    NZ       Singapore iso3166.tab</code></p>
        <p><code>Asia/       EST     GMT+0      Jamaica   NZ-CHAT  SystemV/  posix/</code></p>
        <p><code>Atlantic/   EST5EDT GMT-0      Japan     Navajo   Turkey    posixrules</code></p>
        <p><code>Australia/  Egypt   GMT0       Kwajalein PRC      UCT       right/</code></p>
        <p><code>Brazil/     Eire    Greenwich  Libya     PST8PDT  US/       zone.tab</code></p>
        <p><code>CET         Etc/    HST        MET       Pacific/ UTC</code></p>
        <p><code>CST6CDT     Europe/ Hongkong   MST       Poland   Universal</code></p>
        <p>Когда возможно, этот каталог использует прямые ссылки для предоставления одних и тех же данных с разными именами. Например, файлы <code>EST5EDT</code> и <code>US/Eastern</code> на самом деле одни и те же:</p>
        <p><code>$ <strong>ls -il EST5EDT US/Eastern</strong></code></p>
        <p><code>724350 -rw-r--r-- 5 root root 1267 Sep б 2002 EST5EDT</code></p>
        <p><code>724350 -rw-r--r-- 5 root root 1267 Sep 6 2002 US/Eastern</code></p>
        <p>Частью установки системы является выбор часового пояса. Надлежащий файл данных часового пояса помещается затем в <code>/etc/localtime</code>:</p>
        <p><code>$ <strong>file /etc/localtime</strong></code></p>
        <p><code>/etc/localtime: timezone data</code></p>
        <p>На нашей системе это автономная копия файла для нашего часового пояса. На других системах это может быть символическая ссылка на файл в <code>/usr/share/zoneinfo</code>. Преимуществом использования отдельной копии является то, что все по-прежнему работает, если <code>/usr</code> не смонтирован.</p>
        <p>Переменная окружения <code>TZ</code>, если она установлена, перекрывает значение по умолчанию для часового пояса:</p>
        <p><code>$ <strong>date</strong> /* Дата и время в часовом поясе по умолчанию</code></p>
        <p><code>        */</code></p>
        <p><code>Wed Nov 19 06:44:50 EST 2003</code></p>
        <p><code>$ <strong>export TZ=PST8PDT</strong> /* Смена часового пояса на Западное</code></p>
        <p><code>                       побережье США */</code></p>
        <p><code>$ <strong>date</strong> /* Вывести дату и время */</code></p>
        <p><code>Wed Nov 19 03:45:09 PST 2003</code></p>
       </cite>
       <p>Широкое распространение этой функции делает переносимое использование переменной POSIX <code>timezone</code> трудной. К счастью, мы не видим большой потребности в ней <code>strftime()</code> должно быть достаточно едва ли не для большинства необычных потребностей</p>
      </section>
     </section>
    </section>
    <section>
     <title>
      <p>6.2. Функции сортировки и поиска</p>
     </title>
     <section>
      <p>Сортировка и поиск являются двумя фундаментальными операциями, потребность в которых постоянно возникает во многих приложениях Библиотека С предоставляет ряд стандартных интерфейсов для осуществления этих задач.</p>
      <p>Все процедуры разделяют общий лейтмотив; данные управляются через указатели <code>void*</code>, а сортировку осуществляют предоставленные пользователем функции. Обратите также внимание, что эти API применяются к данным в памяти. Структуры сортировки и поиска в файлах значительно более сложны и выходят за рамки вводного руководства, подобного данному. (Однако, команда <code>sort</code> хорошо работает для текстовых файлов; см. справочную страницу для <emphasis>sort</emphasis>(1). Сортировка двоичных файлов требует написания специальной программы.)</p>
      <p>Поскольку ни один алгоритм не работает одинаково хорошо для всех приложений, имеются несколько различных наборов библиотечных процедур для сопровождения искомых коллекций данных. Данная глава рассматривает лишь один простой интерфейс для поиска. Другой, более развитый интерфейс описан в разделе 14.4 «Расширенный поиск с использованием двоичных деревьев». Более того, мы намеренно не объясняем лежащие в основе алгоритмы, поскольку данная книга об API, а не об алгоритмах и структурах данных. Важно понять, что API можно рассматривать как «черные ящики», выполняющие определенную работу без необходимости понимания подробностей их работы.</p>
     </section>
     <section>
      <title>
       <p>6.2.1. Сортировка: <code>qsort()</code></p>
      </title>
      <section>
       <p>Сортировка выполняется с помощью <code>qsort()</code>:</p>
       <p><code>#include &lt;stdlib.h&gt; /* ISO С */</code></p>
       <empty-line/>
       <p><code>void qsort(void *base, size_t nmemb, size_t size,</code></p>
       <p><code> int (*compare)(const void*, const void*));</code></p>
       <p>Название <code>qsort()</code> происходит от алгоритма машинного поиска Хоара Quicksort (C.A.R. Hoare's Quicksort algorithm), который использовался в первоначальной реализации Unix. (Ничто в стандарте POSIX не требует использования этого алгоритма для <code>qsort()</code>. Реализация GLIBC использует высоко оптимизированную комбинацию Quicksort и Insertion Sort.)</p>
       <p><code>qsort()</code> сортирует массивы произвольных объектов. Она работает, перетасовывая непрозрачные участки памяти из одного места массива в другой и полагаясь на то, что вы, программист, предоставите функцию сравнения, которая позволяет определить относительное расположение одного элемента массива относительно другого. Аргументы следующие:</p>
       <p><code>void *base</code></p>
       <p>Адрес начала массива.</p>
       <p><code>size_t nmemb</code></p>
       <p>Общее число элементов в массиве.</p>
       <p><code>size_t size</code></p>
       <p>Размер каждого элемента массива. Лучший способ получения этого значения — оператор С <code>sizeof</code>.</p>
       <p><code>int (*compare)(const void*, const void*)</code></p>
       <p>Возможно устрашающее объявление <emphasis>указателя функции</emphasis>. Оно говорит, что «<code>compare</code> указывает на функцию, которая принимает два параметра '<code>const void*</code>' и возвращает <code>int</code>».</p>
       <p>Большая часть работы заключается в написании соответствующей функции сравнения. Возвращаемое значение должно имитировать соответствующее значение <code>strcmp()</code>: меньше нуля, если первое значение «меньше» второго, ноль, если они равны, и больше нуля, если первое значение «больше» второго. Именно функция сравнения определяет значения «больше» и «меньше» для всего, что вы сравниваете. Например, для сравнения двух значений <code>double</code> мы могли бы использовать эту функцию:</p>
       <p><code>int dcomp(const void *d1p, const void *d2p) {</code></p>
       <p><code> const double *d1, *d2;</code></p>
       <p><code> d1 = (const double*)d1p; /* Привести указатели к нужному типу */</code></p>
       <p><code> d2 = (const double*)d2p;</code></p>
       <p><code> if (*d1 &lt; *d2) /* Сравнить и вернуть нужное значение */</code></p>
       <p><code>  return -1;</code></p>
       <p><code> else if (*d1 &gt; *d2)</code></p>
       <p><code>  return 1;</code></p>
       <p><code> else if (*d1 == *d2)</code></p>
       <p><code>  return 0;</code></p>
       <p><code> else</code></p>
       <p><code>  return -1; /* NaN сортируется до действительных чисел */</code></p>
       <p><code>}</code></p>
       <p>Это показывает общий стереотип для функций сравнения: привести тип аргументов от <code>void*</code> к указателям на сравниваемый тип, а затем вернуть результат сравнения.</p>
       <p>Для чисел с плавающей точкой простое вычитание, подобное '<code>return *d1 - *d2</code>', не работает, особенно если одно значение очень маленькое или одно или оба значения являются специальными значениями «не число» или «бесконечность». Поэтому нам приходится осуществлять сравнение вручную, принимая во внимание нечисловое значение (которое даже не равно самому себе!)</p>
      </section>
      <section>
       <title>
        <p>6.2.1.1. Пример: сортировка сотрудников</p>
       </title>
       <p>Для более сложных структур требуются более сложные функции. Например, рассмотрите следующую (довольно тривиальную) <code>struct employee</code>:</p>
       <p><code>struct employee {</code></p>
       <p><code>char lastname[30];</code></p>
       <p><code>char firstname[30];</code></p>
       <p><code>long emp_id;</code></p>
       <p><code>time_t start_date;</code></p>
       <p><code>};</code></p>
       <p>Мы могли бы написать функцию для сортировки сотрудников по фамилии, имени и идентификационному номеру:</p>
       <p><code>int emp_name_id_compare(const void *e1p, const void *e2p) {</code></p>
       <p><code> const struct employee *e1, *e2;</code></p>
       <p><code> int last, first;</code></p>
       <p><code> e1 = (const struct employee*)e1p; /* Преобразовать указатели */</code></p>
       <p><code> e2 = (const struct employee*)e2p;</code></p>
       <p><code> if ((last = strcmp(e1-&gt;lastname, e2-&gt;lastname)) != 0)</code></p>
       <p><code>  /* Сравнить фамилии */</code></p>
       <p><code>  return last; /* Фамилии различаются */</code></p>
       <p><code> /* фамилии совпадают, сравнить имена */</code></p>
       <p><code> if ((first = strcmp(e1-&gt;firstname, e2-&gt;firstname)) != 0)</code></p>
       <p><code>  /* Сравнить имена */</code></p>
       <p><code>  return first; /* Имена различаются */</code></p>
       <p><code> /* имена совпадают, сравнить номера ID */</code></p>
       <p><code> if (e1-&gt;emp_id &lt; e2-&gt;emp_id) /* Сравнить ID сотрудника */</code></p>
       <p><code>  return -1;</code></p>
       <p><code> else if (e1-&gt;emp_id == e2-&gt;emp_id)</code></p>
       <p><code>  return 0;</code></p>
       <p><code> else</code></p>
       <p><code>  return 1;</code></p>
       <p><code>}</code></p>
       <p>Логика здесь проста: сначала сравниваются фамилии, затем имена, а затем номера ID, если два имени совпадают. Используя для строк <code>strcmp()</code>, мы автоматически получаем правильное отрицательное/нулевое/положительное значение для возвращения.</p>
       <p>При сравнении ID сотрудников нельзя просто использовать вычитание: представьте, что <code>long</code> 64-разрядный, а <code>int</code> 32-разрядный, а два значения отличаются лишь в старших 32 битах (скажем, младшие 32 бита равны нулю). В таком случае вычитание автоматически привело бы к приведению типа к <code>int</code> с отбрасыванием старших 32 битов и возвращением неверного результата.</p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. Возможно, мы остановились при сравнении имен, в этом случае все сотрудники с совпадающими фамилиями и именами оказались бы сгруппированы, но никак не отсортированы</p>
        <p>Это важный момент <code>qsort()</code> не гарантирует стабильной сортировки. Стабильна сортировка, в которой, если два элемента равны на основе значения какого-либо ключа(-ей), они сохраняют свой первоначальный порядок друг относительно друга в конечном отсортированном массиве. Например, рассмотрите трех сотрудников с одинаковыми фамилиями и именами и с номерами 17, 42 и 81. Их порядок в первоначальном массиве. возможно, был 42, 81 и 17 (Что означает, что сотрудник 42 находится по индексу с меньшим значением, чем сотрудник 81, который, в свою очередь, находится по индексу с меньшим значением, чем сотрудник 17). После сортировки порядок может оказаться 81, 42 и 17. Если ото представляет проблему, процедура сравнения должна рассматривать все важные ключевые значения (Наша так и делает.)</p>
       </cite>
       <p>Просто используя другую функцию, мы можем отсортировать сотрудников по старшинству:</p>
       <p><code>int emp_seniority_compare(const void *e1p,</code></p>
       <p><code> const void *e2p) {</code></p>
       <p><code> const struct employee *e1, *e2;</code></p>
       <p><code> double diff;</code></p>
       <p><code> /* Привести указатели к нужному типу */</code></p>
       <p><code> e1 = (const struct employee*)e1p;</code></p>
       <p><code> e2 = (const struct employee*)e2p;</code></p>
       <p><code> /* Сравнить времена */</code></p>
       <p><code> diff = difftime(e1-&gt;start_date, e2-&gt;start_date);</code></p>
       <p><code> if (diff &lt; 0)</code></p>
       <p><code>  return -1;</code></p>
       <p><code> else if (diff &gt; 0)</code></p>
       <p><code>  return 1;</code></p>
       <p><code> else</code></p>
       <p><code>  return 0;</code></p>
       <p><code>}</code></p>
       <p>Для максимальной переносимости мы использовали <code>difftime()</code>, которая возвращает разницу в секундах между двумя значениями <code>time_t</code>. Для данного конкретного случая приведение, такое, как</p>
       <p><code>return (int)difftime(e1-&gt;start_date, e2-&gt;start_date);</code></p>
       <p>должно сработать, поскольку значения <code>time_t</code> находятся в приемлемом диапазоне. Тем не менее, мы вместо этого использовали полный трехсторонний оператор <code>if</code>, просто из предосторожности.</p>
       <p>Вот пример файла данных со списком пяти президентов США:</p>
       <p><code>$ <strong>cat presdata.txt</strong></code></p>
       <p><code>/* Фамилия, имя, номер президента, инаугурация */</code></p>
       <p><code>Bush George 43 980013600</code></p>
       <p><code>Clinton William 42 727552800</code></p>
       <p><code>Bush George 41 601322400</code></p>
       <p><code>Reagan Ronald 40 348861600</code></p>
       <p><code>Carter James 39 222631200</code></p>
       <p>В <code>ch06-sortemp.c</code> приведена простая программа, которая считывает этот файл в массив <code>struct employee</code>, а затем сортирует его, используя две только что представленные функции сравнения.</p>
       <p><code>1   /* ch06-sortemp.c --- Демонстрирует qsort() с двумя функциями сравнения. */</code></p>
       <p><code>2</code> </p>
       <p><code>3   #include &lt;stdio.h&gt;</code></p>
       <p><code>4   #include &lt;stdlib.h&gt;</code></p>
       <p><code>5   #include &lt;time.h&gt;</code></p>
       <p><code>6</code></p>
       <p><code>7   struct employee {</code></p>
       <p><code>8    char lastname[30];</code></p>
       <p><code>9    char firstname[30];</code></p>
       <p><code>10   long emp_id;</code></p>
       <p><code>11   time_t start_date;</code></p>
       <p><code>12  };</code></p>
       <p><code>13</code></p>
       <p><code>14  /* emp_name_id_compare --- сравнение по имени, затем no ID */</code></p>
       <p><code>15</code></p>
       <p><code>16  int emp_name_id_compare(const void *e1p, const void *e2p)</code></p>
       <p><code>17  {</code></p>
       <p><code>     /* ...как показано ранее, опущено для экономии места... */</code></p>
       <p><code>39  }</code></p>
       <p><code>40</code></p>
       <p><code>41  /* emp_seniority_compare --- сравнение по старшинству */</code></p>
       <p><code>42</code></p>
       <p><code>43  int emp_seniority_compare(const void *e1p, const void *e2p)</code></p>
       <p><code>44  {</code></p>
       <p><code>     /* ...как показано ранее, опущено для экономии места... */</code></p>
       <p><code>58  }</code></p>
       <p><code>59</code></p>
       <p><code>60  /* main --- демонстрация сортировки */</code></p>
       <p><code>61</code></p>
       <p><code>62  int main(void)</code></p>
       <p><code>63  {</code></p>
       <p><code>64   #define NPRES 10</code></p>
       <p><code>65   struct employee presidents[NPRES];</code></p>
       <p><code>66   int i, npres;</code></p>
       <p><code>67   char buf[BUFSIZ];</code></p>
       <p><code>68</code></p>
       <p><code>69   /* Очень простой код для чтения данных: */</code></p>
       <p><code>70   for (npres = 0; npres &lt; NPRES &amp;&amp; fgets(buf, BUFSIZ, stdin) != NULL;</code></p>
       <p><code>71    npres++) {</code></p>
       <p><code>72    sscanf(buf, "%s %s %ld %ld\n",</code></p>
       <p><code>73     presidents[npres].lastname,</code></p>
       <p><code>74     presidents[npres].firstname,</code></p>
       <p><code>75     &amp;presidents[npres].emp_id,</code></p>
       <p><code>76     &amp;presidents[npres].start_date);</code></p>
       <p><code>77   }</code></p>
       <p><code>78</code></p>
       <p><code>79   /* npres теперь содержит число прочитанных строк. */</code></p>
       <p><code>80</code></p>
       <p><code>81   /* Сначала сортировка по имени */</code></p>
       <p><code>82   qsort(presidents, npres, sizeof(struct employee), emp_name_id_compare);</code></p>
       <p><code>83</code></p>
       <p><code>84   /* Вывести результат */</code></p>
       <p><code>85   printf("Sorted by name:\n");</code></p>
       <p><code>86   for (i = 0; i &lt; npres; i++)</code></p>
       <p><code>87    printf("\t%s %s\t%d\t%s",</code></p>
       <p><code>88     presidents[i].lastname,</code></p>
       <p><code>89     presidents[i].firstname,</code></p>
       <p><code>90     presidents[i].emp_id,</code></p>
       <p><code>91     ctime(&amp;presidents[i].start_date));</code></p>
       <p><code>92</code></p>
       <p><code>93   /* Теперь сортировка по старшинству */</code></p>
       <p><code>94   qsort(presidents, npres, sizeof(struct employee), emp_seniority_compare);</code></p>
       <p><code>95</code></p>
       <p><code>96   /* И снова вывести */</code></p>
       <p><code>97   printf("Sorted by seniority:\n");</code></p>
       <p><code>98   for (i = 0; i &lt; npres; i++)</code></p>
       <p><code>99    printf("\t%s %s\t%d\t%s",</code></p>
       <p><code>100    presidents[i].lastname,</code></p>
       <p><code>101    presidents!i].firstname,</code></p>
       <p><code>102    presidents[i].emp_id,</code></p>
       <p><code>103    ctime(&amp;presidents[i].start_date));</code></p>
       <p><code>104 }</code></p>
       <p>Строки 70–77 считывают данные. Обратите внимание, что любое использование <code>scanf()</code> требует от входных данных «хорошего поведения». Если, например, какое-нибудь имя содержит более 29 символов, возникает проблема. В данном случае, мы вне опасности, но в коде изделия нужно быть гораздо более осмотрительным.</p>
       <p>Строка 82 сортирует данные по имени и по ID сотрудника, а затем строки 84–91 выводят отсортированные данные. Сходным образом строка 94 пересортировывает данные, на этот раз по старшинству, а строки 97–103 выводят результаты. После компилирования и запуска программа выдает следующие результаты:</p>
       <p><code>$ <strong>ch06-sortemp &lt; presdata.txt</strong></code></p>
       <p><code>Sorted by name:</code></p>
       <p><code>  Bush George 41 Fri Jan 20 13:00:00 1989</code></p>
       <p><code>  Bush George 43 Sat Jan 20 13:00:00 2001</code></p>
       <p><code>  Carter James 39 Thu Jan 20 13:00:00 1977</code></p>
       <p><code>  Clinton William 42 Wed Jan 20 13:00:00 1993</code></p>
       <p><code>  Reagan Ronald 40 Tue Jan 20 13:00:00 1981 \</code></p>
       <p><code>Sorted by seniority:</code></p>
       <p><code>  Carter James 39 Thu Jan 20 13:00:00 1977</code></p>
       <p><code>  Reagan Ronald 40 Tue Jan 20 13:00:00 1981</code></p>
       <p><code>  Bush George 41 Fri Jan 20 13:00:00 1989</code></p>
       <p><code>  Clinton William 42 Wed Jan 20 13:00:00 1993</code></p>
       <p><code>  Bush George 43 Sat Jan 20 13:00:00 2001</code></p>
       <p>(Мы использовали 1 час пополудни как приблизительное время, когда все президенты начали работать.)<a l:href="#n66" type="note">[66]</a></p>
       <p>Стоит заметить одну вещь: <code>qsort()</code> переставляет данные в массиве. Если каждый элемент массива представляет собой большую структуру, при сортировке массива большое количество данных будут копироваться туда-сюда. Вместо этого может оказаться выгодным создать <emphasis>отдельный массив указателей</emphasis>, каждый из которых указывает на один элемент массива. Затем использовать <code>qsort()</code> для сортировки массива указателей, получая доступ к <emphasis>несортированным</emphasis> данным через <emphasis>сортированные</emphasis> указатели.</p>
       <p>Платой за это является дополнительная память для размещения указателей и модификация функций сравнения для дополнительного перенаправления указателей при сравнении структур. Полученной выгодой может стать значительное ускорение работы, поскольку на каждом шаге перемещается лишь четырех- или восьмибайтный указатель вместо большой структуры. (Наша <code>struct employee</code> имеет размер по крайней мере 68 байтов. При обмене четырехбайтных указателей перемещается в 17 раз меньше данных, чем при обмене структур.) Для тысяч размещенных в памяти структур разница мажет быть существенной.</p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. Если вы являетесь программистом С++, знайте! <code>qsort()</code> может быть опасной для использования с массивами объектов! <code>qsort()</code> осуществляет простые перемещения памяти, копируя байты. Она совершенно ничего не знает о конструкциях С++, таких, как конструкторы копирования или функции <code>operator=()</code>. Вместо этого используйте одну из функций сортировки STL<a l:href="#n67" type="note">[67]</a> или используйте методику отдельного массива указателей.</p>
       </cite>
      </section>
      <section>
       <title>
        <p>6.2.1.2. Пример: сортировка содержимого каталога</p>
       </title>
       <p>В разделе 5.3 «Чтение каталогов» мы продемонстрировали, как элементы каталогов возвращаются в физическом порядке каталога. В большинстве случаев гораздо полезнее иметь содержимое каталога отсортированным каким-нибудь образом, например, по имени или по времени изменения. Хотя и не стандартизованные POSIX, несколько процедур упрощают это, используя <code>qsort()</code> в качестве лежащего в основе сортирующего агента:</p>
       <p><code>#include &lt;dirent.h&gt; /* Обычный */</code></p>
       <empty-line/>
       <p><code>int scandir(const char *dir, struct dirent ***namelist,</code></p>
       <p><code> int (*select)(const struct dirent*),</code></p>
       <p><code> int (*compare)(const struct dirent **, const struct dirent **));</code></p>
       <p><code>int alphasort(const void *a, const void *b);</code></p>
       <p><code>int versionsort(const void *a, const void *b); /* GLIBC */</code></p>
       <p>Функции <code>scandir()</code> и <code>alphasort()</code> были сделаны доступными в 4.2 BSD и широко поддерживаются<a l:href="#n68" type="note">[68]</a>, <code>versionsort()</code> является расширением GNU.</p>
       <p><code>scandir()</code> читает каталог, имя которого дано в <code>dir</code>, создает с использованием <code>malloc()</code> массив указателей <code>struct dirent</code> и устанавливает <code>*namelist</code>, чтобы он указывал на начало этого массива. Как массив указателей, так и указываемые структуры <code>struct dirent</code> выделяются с помощью <code>malloc()</code>; вызывающий код должен использовать <code>free()</code>, чтобы избежать утечек памяти.</p>
       <p>Для выбора нужных элементов используйте указатель функции <code>select</code>. Когда это значение равно <code>NULL</code>, все действительные элементы каталога включаются в конечный массив. В противном случае <code>(*select)()</code> вызывается для каждого элемента, и те элементы, для которых она возвращает ненулевое (истинное) значение, включаются в массив.</p>
       <p>Указатель функции compare сравнивает два элемента каталога. Он передается функции <code>qsort()</code> для использования при сортировке.</p>
       <p><code>alphasort()</code> лексикографически сравнивает имена файлов. Она использует для сравнения функцию <code>strcoll()</code>. <code>strcoll()</code> похожа на <code>strcmp()</code>, но учитывает связанные с местной спецификой правила сортировки (см. раздел 13.4 «Не могли бы вы написать это для меня по буквам?»).</p>
       <p><code>versionsort()</code> является расширением GNU, которое использует для сравнения имен файлов функцию GNU <code>strverscmp()</code> (см. <emphasis>strverscmp</emphasis>(3).) Короче говоря, эта функция понимает обычные соглашения по версиям имен файлов и сравнивает их соответствующим образом.</p>
       <p>В <code>ch06-sortdir.c</code> приведена программа, похожая на <code>ch04-catdir.c</code>. Однако, она использует для работы <code>scandir()</code> и <code>alphasort()</code>.</p>
       <p><code>1  /* ch06-sortdir.c --- Демонстрирует scandir(), alphasort(). */</code></p>
       <p><code>2</code></p>
       <p><code>3  #include &lt;stdio.h&gt; /* для printf() etc. */</code></p>
       <p><code>4  #include &lt;errno.h&gt; /* для errno */</code></p>
       <p><code>5  #include &lt;sys/types.h&gt; /* для системных типов */</code></p>
       <p><code>6  #include &lt;dirent.h&gt; /* для функций каталогов */</code></p>
       <p><code>7</code></p>
       <p><code>8  char *myname;</code></p>
       <p><code>9  int process(const char *dir);</code></p>
       <p><code>10</code></p>
       <p><code>11 /* main --- перечислить аргументы каталога */</code></p>
       <p><code>12</code></p>
       <p><code>13 int main(int argc, char **argv)</code></p>
       <p><code>14 {</code></p>
       <p><code>15  int i;</code></p>
       <p><code>16  int errs = 0;</code></p>
       <p><code>17</code></p>
       <p><code>18  myname = argv[0];</code></p>
       <p><code>19</code></p>
       <p><code>20  if (argc == 1)</code></p>
       <p><code>21   errs = process("."); /* по умолчанию текущий каталог */</code></p>
       <p><code>22  else</code></p>
       <p><code>23   for (i = 1; i &lt; argc; i++)</code></p>
       <p><code>24    errs += process(argv[i]);</code></p>
       <p><code>25</code></p>
       <p><code>26  return (errs != 0);</code></p>
       <p><code>27 }</code></p>
       <p><code>28</code></p>
       <p><code>29 /* nodots --- игнорирует файлы с точкой, для scandir() */</code></p>
       <p><code>30</code></p>
       <p><code>31 int</code></p>
       <p><code>32 nodots(const struct dirent *dp)</code></p>
       <p><code>33 {</code></p>
       <p><code>34  return (dp-&gt;d_name[0] != '.');</code></p>
       <p><code>35 }</code></p>
       <p><code>36</code></p>
       <p><code>37 /*</code></p>
       <p><code>38  * process --- сделать что-то с каталогом, в данном случае,</code></p>
       <p><code>39  * вывести в стандартный вывод пары индекс/имя.</code></p>
       <p><code>40  * Вернуть 0, если все нормально, в противном случае 1.</code></p>
       <p><code>41  */</code></p>
       <p><code>42</code></p>
       <p><code>43 int</code></p>
       <p><code>44 process(const char *dir)</code></p>
       <p><code>45 {</code></p>
       <p><code>46  DIR *dp;</code></p>
       <p><code>47  struct dirent **entries;</code></p>
       <p><code>48  int nents, i;</code></p>
       <p><code>49</code></p>
       <p><code>50  nents = scandir(dir, &amp;entries, nodots, alphasort);</code></p>
       <p><code>51  if (nents &lt; 0) {</code></p>
       <p><code>52   fprintf(stderr, "%s: scandir failed: %s\n", myname,</code></p>
       <p><code>53    strerror(errno));</code></p>
       <p><code>54   return 1;</code></p>
       <p><code>55  }</code></p>
       <p><code>56</code></p>
       <p><code>57  for (i = 0; i &lt; nents; i++) {</code></p>
       <p><code>58   printf("%81d %s\n", entries[i]-&gt;d_ino, entries[i]-&gt;d_name);</code></p>
       <p><code>59   free(entries[i]);</code></p>
       <p><code>60  }</code></p>
       <p><code>61</code></p>
       <p><code>62  free(entries);</code></p>
       <p><code>63</code></p>
       <p><code>64  return 0;</code></p>
       <p><code>65 }</code></p>
       <p>Функция <code>main()</code> программы (строки 1–27) следует стандартному шаблону, который мы использовали до этого. Функция <code>nodots()</code> (строки 31–35) действует как параметр <code>select</code>, выбирая лишь имена файлов, которые не начинаются с точки.</p>
       <p>Функция <code>process()</code> (строки 43–65) довольно проста, причем <code>scandir()</code> делает большую часть работы. Обратите внимание, как каждый элемент отдельно освобождается с помощью <code>free()</code> (строка 59) и как освобождается также весь массив (строка 62).</p>
       <p>При запуске содержимое каталога в самом деле выводится в отсортированном порядке, без '<code>.</code>' и '<code>..</code>'.</p>
       <p><code>$ ch06-sortdir /* Действия по умолчанию отображают текущий каталог */</code></p>
       <p><code>2097176 00-preface.texi</code></p>
       <p><code>2097187 01-intro.texi</code></p>
       <p><code>2097330 02-cmdline.texi</code></p>
       <p><code>2097339 03-memory.texi</code></p>
       <p><code>2097183 03-memory.texi.save</code></p>
       <p><code>2097335 04-fileio.texi</code></p>
       <p><code>2097334 05-fileinfo.texi</code></p>
       <p><code>2097332 06-generall.texi</code></p>
       <p><code>...</code></p>
      </section>
     </section>
     <section>
      <title>
       <p>6.2.2. Бинарный поиск: <code>bsearch()</code></p>
      </title>
      <p><emphasis>Линейный поиск</emphasis> в значительной степени похож на свое название: вы начинаете в начале и проходите искомый массив, пока не встретите то, что нужно. Для чего-нибудь простого, типа поиска целых, это обычно принимает форму цикла <code>for</code>. Рассмотрите эту функцию:</p>
      <p><code>/* ifind --- линейный поиск, возвращает найденный индекс или -1 */</code></p>
      <p><code>int ifind(int x, const int array[], size_t nelems) {</code></p>
      <p><code> size_t i;</code></p>
      <p><code> for (i = 0; i &lt; nelems; i++)</code></p>
      <p><code>  if (array(i) == x) /* найдено */</code></p>
      <p><code>   return i;</code></p>
      <p><code> return -1;</code></p>
      <p><code>}</code></p>
      <p>Преимуществом линейного поиска является его простота; легко с самого начала написать правильный код. Более того, он работает всегда. Даже если в конец массива добавляются элементы или они удаляются из него, нет необходимости сортировать массив.</p>
      <p>Недостатком линейного поиска является то, что он медленный. В среднем для массива, содержащего <code>nelems</code> элементов, при линейном поиске случайного элемента требуется '<code>nelems/2</code>' сравнений, прежде чем найдется нужный элемент. Это становится чрезмерно дорогим даже на современных высокопроизводительных системах, когда <code>nelems</code> принимает большие значения. Поэтому линейный поиск следует использовать лишь с небольшими массивами.</p>
      <p>В отличие от линейного, бинарный поиск требует, чтобы входной массив был уже отсортирован. Недостатком здесь является то, что если добавляются элементы, массив перед новым поиском нужно повторно отсортировать. (Когда элементы удаляются, остальное содержимое массива все равно должно быть перетасовано. Это не так дорого, как повторная сортировка, но все равно может потребовать большого перемещения данных.)</p>
      <p>Преимуществом бинарного поиска, и значительным, является то, что бинарный поиск умопомрачительно быстр, требуя самое большее log<sub>2</sub>(<emphasis>N</emphasis>) сравнений, где <emphasis>N</emphasis> является числом элементов в массиве. Функция <code>bsearch()</code> объявлена следующим образом:</p>
      <p><code>#include &lt;stdlib.h&gt; /* ISO С */</code></p>
      <empty-line/>
      <p><code>void *bsearch(const void *key, const void *base, size_t nmemb,</code></p>
      <p><code> size_t size, int (*compare)(const void*, const void*));</code></p>
      <p>Параметры и их назначение сходны с таковыми для <code>qsort()</code>:</p>
      <p><code>const void *key</code></p>
      <p>Объект, который ищется в массиве.</p>
      <p><code>const void *base</code></p>
      <p>Начало массива.</p>
      <p><code>size_t nmemb</code></p>
      <p>Число элементов в массиве.</p>
      <p><code>size_t size</code></p>
      <p>Размер каждого элемента, полученный с помощью <code>sizeof</code>.</p>
      <p><code>int (*compare)(const void*, const void*)</code></p>
      <p>Функция сравнения. Она должна работать таким же образом, как функция сравнения для <code>qsort()</code>, возвращая отрицательные/нулевые/положительные значения в соответствии с тем, меньше/равен/больше первый параметр по сравнению со вторым.</p>
      <p>Если объект не найден, <code>bsearch()</code> возвращает <code>NULL</code>. В противном случае она возвращает указатель на найденный объект. Если <code>key</code> соответствует более одного объекта, какой из них будет возвращен, не определено. Поэтому, как и в случае с <code>qsort()</code>, убедитесь, что функция сравнения принимает во внимание все существенные части искомой структуры данных.</p>
      <p><code>ch06-searchemp.c</code> показывает <code>bsearch()</code> на практике, расширяя использованный ранее пример <code>struct employee</code>:</p>
      <p><code>1  /* ch06-searchemp.с ---- Демонстрация bsearch(). */</code></p>
      <p><code>2</code></p>
      <p><code>3  #include &lt;stdio.h&gt;</code></p>
      <p><code>4  #include &lt;errno.h&gt;</code></p>
      <p><code>5  #include &lt;stdlib.h&gt;</code></p>
      <p><code>6</code></p>
      <p><code>7  struct employee {</code></p>
      <p><code>8   char lastname[30];</code></p>
      <p><code>9   char firstname[30];</code></p>
      <p><code>10  long emp_id;</code></p>
      <p><code>11  time_t start_date;</code></p>
      <p><code>12 };</code></p>
      <p><code>13</code></p>
      <p><code>14 /* emp_id_compare --- сравнение по ID */</code></p>
      <p><code>15</code></p>
      <p><code>16 int emp_id_compare(const void *e1p, const void *e2p)</code></p>
      <p><code>17 {</code></p>
      <p><code>18  const struct employee *e1, *e2;</code></p>
      <p><code>19</code></p>
      <p><code>20  e1 = (const struct employee*)e1p;</code></p>
      <p><code>21  e2 = (const struct employee*)e2p;</code></p>
      <p><code>22</code></p>
      <p><code>23  if (e1-&gt;emp_id &lt; e2-&gt;emp_id)</code></p>
      <p><code>24   return -1;</code></p>
      <p><code>25  else if (e1-&gt;emp_id == e2-&gt;emp_id)</code></p>
      <p><code>26   return 0;</code></p>
      <p><code>27  else</code></p>
      <p><code>28   return 1;</code></p>
      <p><code>29 }</code></p>
      <p><code>30</code></p>
      <p><code>31 /* print_employee --- напечатать структуру сотрудника */</code></p>
      <p><code>32</code></p>
      <p><code>33 void print_employee(const struct employee *emp)</code></p>
      <p><code>34 {</code></p>
      <p><code>35  printf("%s %s\t%d\t%s", emp-&gt;lastname, emp-&gt;firstname,</code></p>
      <p><code>36  emp-&gt;emp_id, ctime(&amp;emp-&gt;start_date));</code></p>
      <p><code>37 }</code></p>
      <p>Строки 7–12 определяют <code>struct employee</code>; она та же, что и раньше. Строки 16–29 служат в качестве функции сравнения как для <code>qsort()</code>, так и для <code>bsearch()</code>. Они сравнивают лишь ID сотрудников. Строки 33–37 определяют <code>print_employee()</code>, которая является удобной функцией для печати структуры, поскольку это делается из разных мест.</p>
      <p><code>39 /* main --- демонстрация сортировки */</code></p>
      <p><code>40</code></p>
      <p><code>41 int main(int argc, char **argv)</code></p>
      <p><code>42 {</code></p>
      <p><code>43 #define NPRES 10</code></p>
      <p><code>44  struct employee presidents[NPRES];</code></p>
      <p><code>45  int i, npres;</code></p>
      <p><code>46  char buf[BUFSIZ];</code></p>
      <p><code>47  struct employee *the_pres;</code></p>
      <p><code>48  struct employee key;</code></p>
      <p><code>49  int id;</code></p>
      <p><code>50  FILE *fp;</code></p>
      <p><code>51</code></p>
      <p><code>52  if (argc != 2) {</code></p>
      <p><code>53   fprintf(stderr, "usage: %s datafile\n", argv[0]);</code></p>
      <p><code>54   exit(1);</code></p>
      <p><code>55  }</code></p>
      <p><code>56</code></p>
      <p><code>57  if ((fp = fopen(argv[1], "r")) == NULL) {</code></p>
      <p><code>58   fprintf(stderr, "%s: %s: could not open: %s\n", argv[0],</code></p>
      <p><code>59    argv[1], strerror(errno));</code></p>
      <p><code>60   exit(1);</code></p>
      <p><code>61  }</code></p>
      <p><code>62</code></p>
      <p><code>63  /* Очень простой код для чтения данных: */</code></p>
      <p><code>64  for (npres = 0; npres &lt; NPRES &amp;&amp; fgets(buf, BUFSIZ, fp) != NULL;</code></p>
      <p><code>65   npres++) {</code></p>
      <p><code>66   sscanf(buf, "%s %s %ld %ld",</code></p>
      <p><code>67    presidents[npres].lastname,</code></p>
      <p><code>68    presidents[npres].firstname,</code></p>
      <p><code>69    &amp;presidents[npres].emp_id,</code></p>
      <p><code>70    &amp;presidents[npres].start_date);</code></p>
      <p><code>71  }</code></p>
      <p><code>72  fclose(fp);</code></p>
      <p><code>73</code></p>
      <p><code>74  /* В npres теперь число действительно прочитанных строк. */</code></p>
      <p><code>75</code></p>
      <p><code>76  /* Сначала отсортировать по id */</code></p>
      <p><code>77  qsort(presidents, npres, sizeof(struct employee), emp_id_compare);</code></p>
      <p><code>78</code></p>
      <p><code>79  /* Напечатать результат */</code></p>
      <p><code>80  printf("Sorted by ID:\n");</code></p>
      <p><code>81  for (i = 0; i &lt; npres; i++) {</code></p>
      <p><code>82   putchar('\t');</code></p>
      <p><code>83   print_employee(&amp;presidents[i]);</code></p>
      <p><code>84  }</code></p>
      <p><code>85</code></p>
      <p><code>86  for (;;) {</code></p>
      <p><code>87   printf("Enter ID number: ");</code></p>
      <p><code>88   if (fgets(buf, BUFSIZ, stdin) == NULL)</code></p>
      <p><code>89    break;</code></p>
      <p><code>90</code></p>
      <p><code>91   sscanf(buf, "%d\n", &amp;id);</code></p>
      <p><code>92   key.emp_id = id;</code></p>
      <p><code>93   the_pres = (struct employee*)bsearch(&amp;key, presidents,</code></p>
      <p><code>94    npres, sizeof(struct employee), emp_id_compare);</code></p>
      <p><code>95</code></p>
      <p><code>96   if (the_pres != NULL) {</code></p>
      <p><code>97    printf("Found: ");</code></p>
      <p><code>98    print_employee(the_pres);</code></p>
      <p><code>99   } else</code></p>
      <p><code>100   printf("Employee with ID %d not found'\n", id);</code></p>
      <p><code>101  }</code></p>
      <p><code>102</code></p>
      <p><code>103  putchar('\n'); /* Напечатать в конце символ новой строки. */</code></p>
      <p><code>104</code> </p>
      <p><code>105  exit(0);</code></p>
      <p><code>106 }</code></p>
      <p>Функция <code>main()</code> начинается с проверки аргументов (строки 52–55). Затем она читает данные из указанного файла (строки 57–72). Стандартный ввод для данных сотрудников использоваться не может, поскольку он зарезервирован для запроса у пользователя ID искомого сотрудника.</p>
      <p>Строки 77–84 сортируют, а затем печатают данные. Затем программа входит в цикл, начинающийся со строки 86. Она запрашивает идентификационный номер сотрудника, выходя из цикла по достижению конца файла. Для поиска в массиве мы используем <code>struct employee</code> с именем <code>key</code>. Достаточно лишь установить в его поле emp_id введенный номер ID; другие поля при сравнении не используются (строка 92).</p>
      <p>Если найден элемент с подходящим ключом, <code>bsearch()</code> возвращает указатель на него. В противном случае она возвращает <code>NULL</code>. Возвращенное значение проверяется в строке 96, и осуществляется нужное действие. Наконец, строка 102 выводит символ конца строки, чтобы системное приглашение появилось с новой строки. Вот что появляется после компилирования и запуска программы:</p>
      <p><code>$ <strong>ch06-searchemp presdata.txt</strong> /* Запуск программы */</code></p>
      <p><code>Sorted by ID:</code></p>
      <p><code>  Carter James    39 Thu Jan 20 13:00:00 1977</code></p>
      <p><code>  Reagan Ronald   40 Tue Jan 20 13:00:00 1981</code></p>
      <p><code>  Bush George     41 Fri Jan 20 13:00:00 1989</code></p>
      <p><code>  Clinton William 42 Wed Jan 20 13:00:00 1993</code></p>
      <p><code>  Bush George     43 Sat Jan 20 13:00:00 2001</code></p>
      <p><code>Enter ID number: <strong>42</strong> /* Ввод действительного номера */</code></p>
      <p><code>Found: Clinton William 42 Wed Jan 20 13:00:00 1993 /* Найдено */</code></p>
      <p><code>Enter ID number: <strong>29</strong> /* Ввод неверного номера */</code></p>
      <p><code>Employee with ID 29 not found! /* He найдено */</code></p>
      <p><code>Enter ID number: <strong>40</strong> /* Попытка другого верного номера */</code></p>
      <p><code>Found: Reagan Ronald 40 Tue Jan 20 13:00:00 1981 /* Этот тоже найден */</code></p>
      <p><code>Enter ID number: <strong>^D</strong> /* CTRL-D в качестве конца файла */</code></p>
      <p><code>$ /* Готов к приему следующей команды */</code></p>
      <p>Дополнительный, более продвинутый API для поиска коллекций данных описан в разделе 14.4 «Расширенный поиск с использованием двоичных деревьев».</p>
     </section>
    </section>
    <section>
     <title>
      <p>6.3. Имена пользователей и групп</p>
     </title>
     <section>
      <p>Хотя операционная система для сохранения владельцев файлов и проверки прав доступа работает с идентификационными номерами пользователей и групп, люди предпочитают работать с <emphasis>именами</emphasis> пользователей и групп.</p>
      <p>Ранние системы Unix хранили информацию, сопоставляющую имена с номерами ID, в простых текстовых файлах <code>/etc/passwd</code> и <code>/etc/group</code>. На современных системах эти файлы до сих пор существуют, а их формат не изменился после V7 Unix. Однако, они больше не определяют данные полностью. Большие установленные системы с множеством сетевых хостов хранят сведения в <emphasis>сетевых базах данных</emphasis>, которые представляют собой способ хранения информации на небольшом числе серверов, доступ к которым осуществляется через сеть<a l:href="#n69" type="note">[69]</a>. Однако, такое использование <emphasis>прозрачно</emphasis> для большинства приложений, поскольку доступ к информации осуществляется через тот самый API, который использовался для получения сведений из текстовых файлов. Именно по этой причине POSIX стандартизует лишь API; в совместимой с POSIX системе файлы <code>/etc/passwd</code> и <code>/etc/group</code> не обязательно должны существовать.</p>
      <p>API для этих двух баз данных похожи; большая часть обсуждения фокусируется на базе данных пользователей.</p>
     </section>
     <section>
      <title>
       <p>6.3.1. База данных пользователей</p>
      </title>
      <p>Традиционный формат <strong>/etc/passwd</strong> поддерживает по одной строке на пользователя. В каждой строке есть несколько полей, каждое из которых отделено от следующего символом двоеточия:</p>
      <p><code>$ <strong>grep arnold /etc/passwd</strong></code></p>
      <p><code>arnold:x:2076:10:Arnold D. Robbins:/home/arnold:/bin/bash</code></p>
      <p>По порядку эти поля следующие:</p>
      <p><emphasis>Имя пользователя</emphasis></p>
      <p>Это то, что пользователь набирает при регистрации, что отображается с помощью '<code>ls -l</code>', а также используется в любом другом контексте при отображении пользователей.</p>
      <p><emphasis>Поле пароля</emphasis></p>
      <p>На старых системах здесь хранился зашифрованный пароль пользователя. На новых системах в этом поле скорее всего стоит x (как в данном случае), это означает, что сведения о пароле находятся в другом файле. Это разделение является средством обеспечения безопасности; если непривилегированному пользователю недоступен зашифрованный пароль, его значительно сложнее «взломать».</p>
      <p><emphasis>ID пользователя</emphasis></p>
      <p>Должен быть уникальным; один номер на пользователя.</p>
      <p><emphasis>ID группы</emphasis></p>
      <p>Это номер ID начальной группы пользователя. Как обсуждается далее, на современных системах с процессами связаны несколько групп.</p>
      <p><emphasis>Настоящее имя пользователя</emphasis></p>
      <p>Это по крайней мере имя и фамилия пользователя. Некоторые системы допускают разделяемые запятыми поля для местоположения офиса, номера телефона и т.д., но это не стандартизовано.</p>
      <p><emphasis>Входной каталог</emphasis></p>
      <p>Этот каталог становится домашним каталогом для пользователей, когда они зарегистрируются в системе (<code>$HOME</code> — по умолчанию для команды <code>cd</code>).</p>
      <p><emphasis>Входная программа</emphasis></p>
      <p>Программа, которая запускается при регистрации пользователя. Обычно это оболочка, но не обязательно. Если это поле оставлено пустым, по умолчанию используется <code>/bin/sh</code>.</p>
      <p>Доступ к базе данных пользователей осуществляется через процедуры, объявленные в <code>&lt;pwd.h&gt;</code>:</p>
      <p><code>#include &lt;sys/types.h&gt; /* XSI */</code></p>
      <p><code>#include &lt;pwd.h&gt;</code></p>
      <empty-line/>
      <p><code>struct passwd *getpwent(void);</code></p>
      <p><code>void setpwent(void);</code></p>
      <p><code>void endpwent(void);</code></p>
      <empty-line/>
      <p><code>struct passwd *getpwnam(const char *name);</code></p>
      <p><code>struct passwd *getpwuid(uid_t uid);</code></p>
      <p>Поля в <code>struct passwd</code>, использующиеся различными процедурами API, напрямую соответствуют полям файла паролей.</p>
      <p><code>struct passwd {</code></p>
      <p><code> char *pw_name;   /* имя пользователя */</code></p>
      <p><code> char *pw_passwd; /* пароль пользователя */</code></p>
      <p><code> uid_t pw_uid;    /* id пользователя */</code></p>
      <p><code> gid_t pw_gid;    /* id группы */</code></p>
      <p><code> char *pw_gecos;  /* настоящее имя */</code></p>
      <p><code> char *pw_dir;    /* домашний каталог */</code></p>
      <p><code> char *pw_shell;  /* программа оболочки */</code></p>
      <p><code>};</code></p>
      <p>(Имя <code>pw_gecos</code> историческое; когда разрабатывались ранние системы Unix, это поле содержало соответствующие сведения для учетной записи пользователя на системах Bell Labs Honeywell с операционной системой GECOS.)</p>
      <p>Назначение каждой процедуры описано в следующем списке.</p>
      <p><code>struct passwd *getpwent(void)</code></p>
      <p>Возвращает указатель на внутреннюю структуру <code>static struct passwd</code>, содержащую сведения о «текущем» пользователе. Эта процедура читает всю базу данных паролей, по одной записи за раз, возвращая указатель на структуру для каждого пользователя. Каждый раз возвращается тот же самый указатель; т.е. для каждой записи пользователя внутренняя <code>struct passwd</code> переписывается заново. Когда <code>getpwent()</code> достигает конца базы данных паролей, она возвращает <code>NULL</code>. Таким образом, она позволяет пройти через всю базу данных по одному пользователю за раз. Порядок, в котором возвращаются записи, не определен.</p>
      <p><code>void setpwent(void)</code></p>
      <p>Сбрасывает внутреннее состояние, так что следующий вызов <code>getpwent()</code> возвращает первую запись в базе данных паролей.</p>
      <p><code>void endpwent(void)</code></p>
      <p>«Закрывает базу данных», так сказать, будь то простой файл, сетевое соединение или что-нибудь еще.</p>
      <p><code>struct passwd *getpwnam(const char *name)</code></p>
      <p>Ищет пользователя с членом <code>pw_name</code>, соответствующим <code>name</code>, возвращая указатель на <code>static struct passwd</code>, описывающий пользователя, или <code>NULL</code>, если пользователь не найден.</p>
      <p><code>struct passwd *getpwuid(uid_t uid)</code></p>
      <p>Сходным образом ищет пользователя с номером ID, приведенным в <code>uid</code>, возвращая указатель на <code>static struct passwd</code>, описывающий пользователя, или <code>NULL</code>, если пользователь не найден.</p>
      <p><code>getpwuid()</code> — вот что нужно, когда есть номер ID пользователя (такой, как в <code>struct stat</code>) и вам нужно вывести имя соответствующего пользователя. <code>getpwnam()</code> преобразует имя в номер ID пользователя, например, если вы хотите использовать с файлом <code>chown()</code> или <code>fchown()</code>. Теоретически обе эти процедуры осуществляют линейный поиск по базе данных паролей для обнаружения нужных сведений. На практике это верно, когда используется файл паролей, однако, кулуарные базы данных (сетевые или другие, как на системах BSD) склоняются к использованию более эффективных методов хранения, так что эти вызовы, возможно, в таком случае не такие дорогие<a l:href="#n70" type="note">[70]</a>.</p>
      <p><code>getpwent()</code> полезна, когда нужно пройти через всю базу данных паролей. Например, может быть необходимо прочесть ее всю в память, отсортировать, а затем осуществить быстрый поиск с помощью <code>bsearch()</code>. Это очень полезно для избежания множества линейных поисков, свойственных поиску по одному элементу за раз с помощью <code>getpwuid()</code> или <code>getpwnam()</code>.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Указатели, возвращаемые <code>getpwent()</code>, <code>getpwnam()</code> и <code>getpwuid()</code>, все указывают на внутренние <code>static</code> данные. Поэтому следует сделать копию их содержимого, если нужно сохранить сведения.</p>
       <p>Хорошенько рассмотрите определение <code>struct passwd</code>. Члены, представляющие символьные строки, являются указателями, они также указывают на внутренние <code>static</code> данные, и если вы собираетесь скопировать структуру, не забудьте также скопировать и данные, на которые указывает каждый член структуры.</p>
      </cite>
     </section>
     <section>
      <title>
       <p>6.3.2. База данных групп</p>
      </title>
      <p>Формат базы данных групп <code>/etc/group</code> подобен формату <code>/etc/passwd</code>, но с меньшим числом полей.</p>
      <p><code>$ <strong>grep arnold /etc/group</strong></code></p>
      <p><code>mail:x:12:mail,postfix,arnold</code></p>
      <p><code>uucp:x:14:uucp,arnold</code></p>
      <p><code>floppy:x:19:arnold</code></p>
      <p><code>devel:x:42:miriam,arnold</code></p>
      <p><code>arnold:x:2076:arnold</code></p>
      <p>Опять-таки на одну группу отводится одна строка, с полями, разделенными двоеточием. Поля следующие.</p>
      <p><emphasis>Имя группы</emphasis></p>
      <p>Это имя группы, как оно отображается в '<code>ls -l</code>' или в любом другом контексте, когда требуется имя группы.</p>
      <p><emphasis>Пароль группы</emphasis></p>
      <p>Историческое поле. Оно больше не используется.</p>
      <p><emphasis>ID группы</emphasis></p>
      <p>Как и для ID пользователя, должен быть уникальным для каждой группы.</p>
      <p><emphasis>Список пользователей</emphasis></p>
      <p>Разделенный запятыми список пользователей, являющихся членами группы.</p>
      <p>В предыдущем примере мы видели, что пользователь <code>arnold</code> является членом нескольких групп. Это членство на практике отражается в том, что называют <emphasis>набором групп (group set)</emphasis>. Помимо главных номеров ID пользователя и ID группы, которые есть у процессов, набор групп является набором номеров ID дополнительных групп, который имеет при себе каждый процесс. Система проверяет на соответствие с этими ID групп, ID группы файла при осуществлении проверки прав доступа. Эта тема более подробно обсуждается в разделе 11 «Разрешения и ID пользователя и группы».</p>
      <p>API базы данных групп сходна с API для базы данных пользователей. Следующие функции определены в <code>&lt;grp.h&gt;</code>:</p>
      <p><code>#include &lt;sys/types.h&gt; /* XSI */</code></p>
      <p><code>#include &lt;grp.h&gt;</code></p>
      <empty-line/>
      <p><code>struct group *getgrent(void);</code></p>
      <p><code>void setgrent(void);</code></p>
      <p><code>void endgrent(void);</code></p>
      <empty-line/>
      <p><code>struct group *getgrnam(const char *name);</code></p>
      <p><code>struct group *getgrgid(gid_t gid);</code></p>
      <p>struct group соответствует записям в /etc/group:</p>
      <p><code>struct group {</code></p>
      <p><code> char *gr_name;   /* имя группы */</code></p>
      <p><code> char *gr_passwd; /* пароль группы */</code></p>
      <p><code> gid_t gr_gid;    /* id группы */</code></p>
      <p><code> char **gr_mem;   /* члены группы */</code></p>
      <p><code>};</code></p>
      <p>Поле <code>gr_mem</code> требует некоторого объяснения. Хотя оно объявлено в виде указателя на указатель (<code>char**</code>), лучше представить его как массив строк (наподобие <code>argv</code>). Последний элемент в массиве устанавливается в <code>NULL</code>. Когда в списке нет членов, первый элемент массива равен <code>NULL</code>.</p>
      <p><code>ch06-groupinfo.с</code> демонстрирует, как использовать <code>struct group</code> и поле <code>gr_mem</code>. Программа принимает в командной строке имя единственного пользователя и печатает все записи групп, в которых появляется этот пользователь:</p>
      <p><code>1  /* ch06-groupinfo.с --- Демонстрация getgrent() и struct group */</code></p>
      <p><code>2</code> </p>
      <p><code>3  #include &lt;stdio.h&gt;</code></p>
      <p><code>4  #include &lt;sys/types.h&gt;</code></p>
      <p><code>5  #include &lt;grp.h&gt;</code></p>
      <p><code>6</code></p>
      <p><code>7  extern void print_group(const struct group *gr);</code></p>
      <p><code>8</code></p>
      <p><code>9  /* main --- вывести строки групп для пользователя в argv[1] */</code></p>
      <p><code>10</code></p>
      <p><code>11 int</code></p>
      <p><code>12 main(int argc, char **argv)</code></p>
      <p><code>13 {</code></p>
      <p><code>14  struct group *gr;</code></p>
      <p><code>15  int i;</code></p>
      <p><code>16</code></p>
      <p><code>17  if (argc != 2) { /* Проверка аргументов */</code></p>
      <p><code>18   fprintf(stderr, "usage: %s user\n", argv[0]);</code></p>
      <p><code>19   exit(1);</code></p>
      <p><code>20  }</code></p>
      <p><code>21</code></p>
      <p><code>22  while ((gr = getgrent()) != NULL) /* Получить запись каждой группы: */</code></p>
      <p><code>23   for (i = 0; gr-&gt;gr_mem[i] != NULL; i++) /* Рассмотреть каждый член */</code></p>
      <p><code>24    if (strcmp(gr-&gt;gr_mem[i], argv[i]) == 0) /* Если пользователь найден... */</code></p>
      <p><code>25     print_group(gr); /* Вывести запись */</code></p>
      <p><code>26</code></p>
      <p><code>27  endgrent();</code></p>
      <p><code>28</code></p>
      <p><code>29  exit(0);</code></p>
      <p><code>30 }</code></p>
      <p>Функция <code>main()</code> сначала проверяет ошибки (строки 17–20). Основным компонентом программы является вложенный цикл. Внешний цикл (строка 22) перечисляет все записи базы данных группы. Внутренний цикл (строка 23) перечисляет всех членов массива <code>gr_mem</code>. Если один из членов соответствует имени из командной строки (строка 24), для печати записи вызывается <code>print_group()</code> (строка 25):</p>
      <p><code>32 /* print_group --- печать записи группы */</code></p>
      <p><code>33</code></p>
      <p><code>34 void</code></p>
      <p><code>35 print_group(const struct group *gr)</code></p>
      <p><code>36 {</code></p>
      <p><code>37  int i;</code></p>
      <p><code>38</code></p>
      <p><code>39  printf("%s:%s:%ld:gr-&gt;gr_name, gr-&gt;gr_passwd, (long)gr-&gt;gr_gid);</code></p>
      <p><code>40</code></p>
      <p><code>41  for (i = 0; gr-&gt;gr_mem[i] != NULL; i++) {</code></p>
      <p><code>42   printf("%s", gr-&gt;gr_mem[i]);</code></p>
      <p><code>43   if (gr-&gt;gr_mem[i+1) != NULL)</code></p>
      <p><code>44    putchar(',');</code></p>
      <p><code>45  }</code></p>
      <p><code>46</code></p>
      <p><code>47  putchar('\n');</code></p>
      <p><code>48 }</code></p>
      <p>Функция <code>print_group()</code> (строки 34–48) проста, ее логика подобна логике <code>main()</code> для печати списка членов. Члены списка группы разделены запятыми; поэтому тело цикла до вывода запятой должно проверить, что <emphasis>следующий</emphasis> элемент в массиве не является <code>NULL</code>. Этот код работает правильно, даже если в группе нет членов. Однако мы знаем, что для этой программы есть члены, иначе <code>print_group()</code> не была бы вызвана! Вот что происходит при запуске программы:</p>
      <p><code>$ <strong>ch06-groupinfo arnold</strong></code></p>
      <p><code>mail:x:12:mail,postfix,arnold</code></p>
      <p><code>uucp:x:14:uucp,arnold</code></p>
      <p><code>floppy:x:19:arnold</code></p>
      <p><code>devel:x:42:miriam,arnold</code></p>
      <p><code>arnold:x:2076:arnold</code></p>
     </section>
    </section>
    <section>
     <title>
      <p>6.4. Терминалы: <code>isatty()</code></p>
     </title>
     <p>Модель стандартного ввода, стандартного вывода и стандартной ошибки Linux/Unix препятствует специальной трактовке устройств ввода и вывода. Программам обычно не нужно знать или беспокоиться о том, направляется ли их вывод на терминал, в файл, канал, физическое устройство или что-то еще.</p>
     <p>Однако иногда бывают моменты, когда программе действительно нужно знать, с какого рода файлом связан файловый дескриптор. Семейство вызовов <code>stat()</code> часто предоставляет достаточно сведений обычный файл, каталог, устройство и т.д. Хотя иногда даже этого недостаточно, и для интерактивных программ, в частности, вам может потребоваться знать, не представляет ли дескриптор файла <code>tty</code>.</p>
     <p><emphasis>tty</emphasis> (сокращение для Teletype, одного из ранних производителей компьютерных терминалов) является любым устройством, представляющим терминал, т.е. нечто, что человек мог бы использовать для взаимодействия с компьютером. Это может быть либо аппаратное устройство, такое, как клавиатура и монитор персонального компьютера, или старинный терминал видеодисплея, соединенный с компьютером через последовательный порт или модем, или программный <emphasis>псевдотерминал</emphasis>, такой, который используется в оконных системах и при сетевых регистрациях.</p>
     <p>Различить можно с помощью <code>isatty()</code>.</p>
     <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
     <empty-line/>
     <p><code>int isacty(int desc);</code></p>
     <p>Эта функция возвращает 1, если дескриптор файла <code>desc</code> представляет терминал, в противном случае 0. В соответствии с POSIX <code>isatty()</code> может установить <code>errno</code> для указания ошибки; поэтому до вызова <code>isatty()</code> следует установить errno в 0, а затем проверить ее значение, если был возвращен 0. (Справочная страница GNU/Linux <emphasis>isatty</emphasis>(3) не упоминает об использовании <code>errno</code>.) Стандарт POSIX также указывает, что просто возврат <code>isatty()</code> 1 не означает, что на другом конце дескриптора файла находится человек!</p>
     <p>Одним местом, где используется <code>isatty()</code>, является современная версия <code>ls</code>, в которой имена файлов по умолчанию печатаются в столбцы, если терминалом является стандартный вывод, а если нет, они печатаются по одной на строчку.</p>
    </section>
    <section>
     <title>
      <p>6.5. Рекомендуемая литература</p>
     </title>
     <p>1. <emphasis>Mastering Algorithms With C</emphasis> by Kyle Loudon. O'Reilly &amp; Associates, Sebastopol, California, USA, 1999. ISBN: 1-56592-453-3.</p>
     <p>Эта книга предоставляет практическое, утилитарное введение в алгоритмы и структуры данных с использованием С, освещая среди прочих вещей таблицы хэшей, деревья, сортировку и поиск.</p>
     <p>2. <emphasis>The Art of Computer Programming Volume 3</emphasis>. Sorting and Searching, 2nd edition, by Donald E. Knuth Addison-Wesley, Reading Massachusetts, USA, 1998. ISBN: 0-201-89685-0.<a l:href="#n71" type="note">[71]</a></p>
     <p>На эту книгу обычно ссылаются как на последнее слово в сортировке и поиске. Примите во внимание, что она значительно более сжата и труднее для чтения, чем книга Loudon'a.</p>
     <p>3. Проект GTK+<a l:href="#n72" type="note">[72]</a> состоит из нескольких совместно работающих библиотек GTK+ является лежащим в основе инструментарием, используемым проектом GNU GNOME.<a l:href="#n73" type="note">[73]</a> В основе иерархии библиотек располагается Glib, библиотека фундаментальных типов, структур данных и функций для работы с ними. Glib включает возможности для всех основных операций, которые мы до сих пор рассмотрели в данной книге, и многое другое, включая связанные списки и хэш-таблицы. Для просмотра онлайн-документов начните с веб-сайта проекта документации GTK+<a l:href="#n74" type="note">[74]</a>, щелкните на ссылке «Загрузить» (Download) и идите дальше по онлайн-версии.</p>
    </section>
    <section>
     <title>
      <p>6.6. Резюме</p>
     </title>
     <p>• Время внутренне хранится в виде значений <code>time_t</code>, представляющих «секунды с начала Эпохи». Эпоха для систем GNU/Linux и Unix начинается с полночи 1 января 1970 г. по UTC. Текущее время получается от системы с помощью системного вызова <code>time()</code>, а <code>difftime()</code> возвращает разницу в секундах между двумя значениями <code>time_t</code>.</p>
     <p>• Структура <code>struct tm</code> представляет «разложенное время», которое является значительно более удобным представлением даты и времени. <code>gmtime()</code> и <code>localtime()</code> преобразуют значения <code>time_t</code> в значения <code>struct tm</code>, a <code>mktime()</code> действует в обратном направлении.</p>
     <p>• <code>asctime()</code> и <code>ctime()</code> осуществляют упрошенное форматирование значений времени, возвращая указатель на <code>static</code> строку символов фиксированного размера и формата, <code>strftime()</code> предусматривает гораздо более гибкое форматирование, включая значения на основе местных настроек.</p>
     <p>• Сведения о часовом поясе доступны через вызов <code>tzset()</code>. Поскольку стандартные процедуры действуют так, как если бы они автоматически вызывали <code>tzset()</code>, необходимость в непосредственном вызове этой функции возникает редко.</p>
     <p>• Стандартной процедурой для сортировки массивов является <code>qsort()</code>. Используя предоставленную пользователем функцию сравнения и принимая параметры числа элементов массива и их размера, <code>qsort()</code> может сортировать любые виды данных. Это обеспечивает значительную гибкость.</p>
     <p>• <code>scandir()</code> читает в массив <code>struct dirent</code> каталог целиком. Для выбора того, какие элементы включить в массив и для обеспечения упорядочения элементов в массиве могут использоваться предоставленные пользователем функции <code>alphasort()</code> является стандартной функцией для сортировки элементов каталога по имени; <code>scandir()</code> передает функцию сортировки прямо через <code>qsort()</code>.</p>
     <p>• Функция <code>bsearch()</code> работает подобно <code>qsort()</code>. Она осуществляет быстрый бинарный поиск. Используйте ее, если цена линейного поиска перевешивает цену сортировки ваших данных. (Дополнительный API для поиска коллекций данных описан в разделе 14.4 «Расширенный поиск с помощью двоичных деревьев».)</p>
     <p>• Базы данных пользователей и групп могут храниться в файлах на локальном диске или могут быть доступны через сеть. Стандартный API намеренно скрывает это различие. Каждая база данных обеспечивает как линейный просмотр всей базы данных, так и непосредственные запросы имени или ID пользователя/группы.</p>
     <p>• Наконец, для тех случаев, когда недостаточно простого <code>stat()</code>, <code>isatty()</code> может вам сообщить, представляет ли открытый файл устройство терминала.</p>
    </section>
    <section>
     <title>
      <p>Упражнения</p>
     </title>
     <p>1. Напишите простую версию команды <code>date</code>, которая принимает в командной строке строку формата и использует ее для форматирования и вывода текущего времени.</p>
     <p>2. Когда файл старше шести месяцев, '<code>ls -l</code>' использует для печати времени изменения более простой формат. GNU версия файла <code>ls.c</code> использует следующее вычисление:</p>
     <p><code>3043 /* Время считается недавним, если оно в пределах последних 6</code></p>
     <p><code>3044    месяцев. В Григорианском годе 365.2425 * 24 * 60 * 60 ==</code></p>
     <p><code>3045    31556952 секунд в среднем. Запишите это значение как</code></p>
     <p><code>3046    целую константу для избежания трудностей с плавающей точкой.*/</code></p>
     <p><code>3047    six_months_ago = current_time - 31556952 / 2;</code></p>
     <p>Сравните это с нашим примером вычисления шести прошлых месяцев. Каковы преимущества и недостатки каждого из методов?</p>
     <p>3. Напишите простую версию команды <code>touch</code>, которая изменяет время модификации файла, имя которого указано в командной строке, на текущее время</p>
     <p>4. Добавьте к вашей команде <code>touch</code> опцию, которая принимает в командной строке значения даты и времени и использует их в качестве нового времени модификации файлов, указанных в командной строке.</p>
     <p>5. Добавьте к своей версии <code>touch</code> еще одну опцию, которая принимает имя файла и использует время модификации данного файла как новое время модификации файла, указанного в командной строке.</p>
     <p>6. Усовершенствуйте <code>ch06-sortemp.c</code> так, чтобы она сортировала отдельный массив указателей, указывающих на массив сотрудников.</p>
     <p>7. Добавьте к <code>ch06-sortdir.c</code> опции для сортировки по номеру индекса, времени модификации, времени доступа и размеру. Добавьте «обратную опцию», так, чтобы основанная на времени сортировка первым помещала самый <emphasis>недавний</emphasis> файл, а по другим критериям (размеру, индексу) помещала вначале наибольшее значение.</p>
     <p>8. Напишите простую версию команды <code>chown</code>. Она должна использоваться так:</p>
     <p><code>chown пользователь[:группа] файлы ...</code></p>
     <p>Здесь <emphasis>пользователь</emphasis> и <emphasis>группа</emphasis> являются именами пользователя и группы, представляющими новых пользователя и группу для указанных файлов. <emphasis>Группа</emphasis> необязательна; если она присутствует, она отделяется от пользователя двоеточием. Чтобы протестировать свою версию на системе GNU/Linux, вы должны зарегистрироваться в качестве <code>root</code>. Делайте это осторожно!</p>
     <p>9. Усовершенствуйте свою <code>chown</code>, чтобы допустить использование числовых значений пользователя или группы наряду с их именами.</p>
     <p>10. Напишите функции для копирования структур пользователя и группы, включая указываемые данные. Для выделения памяти используйте при необходимости <code>malloc()</code>.</p>
     <p>11. Напишите специализированную библиотеку поиска пользователей, которая считывает в динамически выделяемый массив всю базу данных пользователей. Предусмотрите <emphasis>быстрый</emphasis> поиск пользователей как по ID, так и по именам. Гарантируйте обработку случая, при котором запрошенный пользователь не найден.</p>
     <p>12. Сделайте то же самое для базы данных групп.</p>
     <p>13. Напишите программу <code>stat</code>, которая печатает содержимое <code>struct stat</code> для каждого файла, указанного в командной строке. Она должна выводить все значения в формате, удобном для восприятия человеком: значения <code>time_t</code> в виде дат и времени, значения <code>uid_t</code> и <code>gid_t</code> в виде соответствующих имен (если они доступны), а также содержимое символических ссылок. Выведите поле <code>st_mode</code> таким же образом, как вывела бы <code>ls</code>.</p>
     <p>Сравните свою программу с программой <code>stat</code> GNU Coreutils как по их выводу, так и по исходному коду.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 7</p>
     <p>Соединяя все вместе: <code>ls</code></p>
    </title>
    <section>
     <p>Команда V7 <code>ls</code> хорошо связывает воедино все, что мы до сих пор видели. Она использует почти все API, которые мы рассмотрели, затрагивая многие аспекты программирования Unix: выделение памяти, вспомогательные данные файлов, времена и даты, имена пользователей, чтение каталогов и сортировку.</p>
    </section>
    <section>
     <title>
      <p>7.1. Опции V7 <code>ls</code></p>
     </title>
     <p>По сравнению с современными версиями <code>ls</code>, V7 <code>ls</code> принимает лишь небольшое количество опций, а значение некоторых из них для V7 отличается от значения для современной <code>ls</code>. Эти опции следующие:</p>
     <p><code>-а</code> Выводит все элементы каталога. Без нее '<code>.</code>' и '<code>..</code>' не выводятся. Довольно интересно, V7 игнорирует лишь '<code>.</code>' и '<code>..</code>', тогда как с V1 по V6 игнорируется любой файл, имя которого начинается с точки. Это последнее является также поведением по умолчанию и для современных версий <code>ls</code>.</p>
     <p><code>-n</code> Вместо времени модификации файла использует для <code>-t</code> или <code>-l</code> время изменения индекса.</p>
     <p><code>-d</code> Для аргументов каталогов выводит сведения о самом каталоге, а не о его содержимом.</p>
     <p><code>-f</code> «Заставляет» читать каждый элемент как каталог и печатать найденное в каждом слоте имя. Эта опция отключает <code>-l</code>, <code>-r</code>, <code>-s</code>, <code>-t</code> и включает <code>-а</code>. (Эта опция, очевидно, существует для отладки и исправления файловой системы.)</p>
     <p><code>-g</code> Для '<code>ls -l</code>' использует вместо имени пользователя имя группы.</p>
     <p><code>-i</code> Выводит в первом столбце номер индекса вместе с именем файла или длинным листингом.</p>
     <p><code>-l</code> Осуществляет привычный вывод в длинном формате. Обратите, однако, внимание, что V7 '<code>ls -l</code>' выводила лишь имя владельца, а не имена владельца и группы вместе.</p>
     <p><code>-r</code> Изменяет порядок сортировки, будь то по алфавиту для имен файлов или по времени.</p>
     <p><code>-s</code> Выводит размер файла в 512-байтовых блоках. Справочная страница V7 <emphasis>ls</emphasis>(1) утверждает, что <emphasis>вспомогательные блоки (indirect blocks)</emphasis> — блоки, используемые файловой системой для обнаружения блоков больших файлов — также учитываются при вычислении, но, как мы увидим, это утверждение было неверным.</p>
     <p><code>-t</code> Сортирует вывод вместо имени по времени модификации, сначала более ранние.</p>
     <p><code>-u</code> С опциями <code>-t</code> и/или <code>-l</code> использует время доступа вместо времени модификации. Наибольшие различия между V7 <code>ls</code> и современной <code>ls</code> затрагивают опцию <code>-а</code> и опцию <code>-l</code>. Современные системы опускают все файлы с точками, если не указана <code>-а</code>, и они включают в длинный листинг <code>-l</code> имена и владельца, и группы. На современных системах <code>-g</code> означает вывод лишь имени группы, а <code>-o</code> означает вывод лишь имени владельца. Стоит заметить, что у GNU <code>ls</code> свыше 50 опций!</p>
    </section>
    <section>
     <title>
      <p>7.2. Код V7 <code>ls</code></p>
     </title>
     <p>Файл <code>/usr/src/cmd/ls.c</code> в дистрибутиве V7 содержит код. Весь он занимает 425 строк.</p>
     <p><code>1  /*</code></p>
     <p><code>2   * перечисляет файлы или каталоги</code></p>
     <p><code>3   */</code></p>
     <p><code>4</code></p>
     <p><code>5  #include &lt;sys/param.h&gt;</code></p>
     <p><code>6  #include &lt;sys/stat.h&gt;</code></p>
     <p><code>7  #include &lt;sys/dir.h&gt;</code></p>
     <p><code>8  #include &lt;stdio.h&gt;</code></p>
     <p><code>9</code></p>
     <p><code>10 #define NFILES 1024</code></p>
     <p><code>11 FILE *pwdf, *dirf;</code></p>
     <p><code>12 char stdbuf[BUFSIZ];</code></p>
     <p><code>13</code></p>
     <p><code>14 struct lbuf { /* Собирает необходимые сведения */</code></p>
     <p><code>15  union {</code></p>
     <p><code>16   char lname[15];</code></p>
     <p><code>17   char *namep;</code></p>
     <p><code>18  } ln;</code></p>
     <p><code>19  char ltype;</code></p>
     <p><code>20  short lnum;</code></p>
     <p><code>21  short lflags;</code></p>
     <p><code>22  short lnl;</code></p>
     <p><code>23  short luid;</code></p>
     <p><code>24  short lgid;</code></p>
     <p><code>25  long lsize;</code></p>
     <p><code>26  long lmtime;</code></p>
     <p><code>27 };</code></p>
     <p><code>28</code></p>
     <p><code>29 int aflg, dflg, lflg, sflg, tflg, uflg, lflg, fflg, gflg, cflg;</code></p>
     <p><code>30 int rflg = 1;</code></p>
     <p><code>31 long year; /* Глобальные переменные: инициализируются 0 */</code></p>
     <p><code>32 int flags;</code></p>
     <p><code>33 int lastuid = -1;</code></p>
     <p><code>34 char tbuf[16];</code></p>
     <p><code>35 long tblocks;</code></p>
     <p><code>36 int statreq;</code></p>
     <p><code>37 struct lbuf *flist[NFILES];</code></p>
     <p><code>38 struct lbuf **lastp = flist;</code></p>
     <p><code>39 struct lbuf **firstp = flist;</code></p>
     <p><code>40 char *dotp = ".";</code></p>
     <p><code>41</code></p>
     <p><code>42 char *makename(); /* char *makename(char *dir, char *file); */</code></p>
     <p><code>43 struct lbuf *gstat(); /* struct lbuf *gstat(char *file, int argfl); */</code></p>
     <p><code>44 char *ctime(); /* char *ctime(time_t *t); */</code></p>
     <p><code>45 long nblock(); /* long nblock(long size); */</code></p>
     <p><code>46</code></p>
     <p><code>47 #define ISARG 0100000</code></p>
     <p>Программа начинается с включения файлов (строки 5–8) и объявлений переменных. <code>struct lbuf</code> (строки 14–27) инкапсулирует части <code>struct stat</code>, которые интересны <code>ls</code>. Позже мы увидим, как эта структура заполняется.</p>
     <p>Переменные <code>aflg</code>, <code>dflg</code> и т.д. (строки 29 и 30) все указывают на наличие соответствующей опции. Такой стиль именования переменных типичен для кода V7. Переменные <code>flist</code>, <code>lastp</code> и <code>firstp</code> (строки 37–39) представляют файлы, о которых <code>ls</code> выводит сведения. Обратите внимание, что flist является массивом фиксированного размера, которая позволяет обрабатывать не более 1024 файлов. Вскоре мы увидим, как используются все эти переменные.</p>
     <p>После объявлений переменных идут объявления функций (строки 42–45), а затем определение <code>ISARG</code>, которая различает файл, указанный в командной строке, от файла, найденного при чтении каталога.</p>
     <p><code>49 main(argc, argv) /* int main(int argc, char **argv) */</code></p>
     <p><code>50 char *argv[];</code></p>
     <p><code>51 {</code></p>
     <p><code>52  int i;</code></p>
     <p><code>53  register struct lbuf *ep, **ep1; /* Объявления переменных и функций */</code></p>
     <p><code>54  register struct lbuf **slastp;</code></p>
     <p><code>55  struct lbuf **epp;</code></p>
     <p><code>56  struct lbuf lb;</code></p>
     <p><code>57  char *t;</code></p>
     <p><code>58  int compar();</code></p>
     <p><code>59</code></p>
     <p><code>60  setbuf(stdout, stdbuf);</code></p>
     <p><code>61  time(&amp;lb.lmtime); /* Получить текущее время */</code></p>
     <p><code>62  year = lb.lmtime - 6L*30L*24L*60L*60L; /* 6 месяцев назад */</code></p>
     <p>Функция <code>main()</code> начинается с объявления переменных и функций (строки 52–58), устанавливая буфер для стандартного вывода, получая время дня (строки 60–61) и вычисляя значение секунд с начала Эпохи для примерно шести месяцев (строка 62). Обратите внимание, что у всех констант есть суффикс <code>L</code>, указывающий на использование арифметики <code>long</code>.</p>
     <p><code>63  if (--argc &gt; 0 &amp;&amp; *argv[1] == '-') {</code></p>
     <p><code>64   argv++;</code></p>
     <p><code>65   while (*++*argv) switch(**argv) { /* Разбор опций */</code></p>
     <p><code>66</code></p>
     <p><code>67   case 'a': /* Все элементы каталога */</code></p>
     <p><code>68    aflg++;</code></p>
     <p><code>69    continue;</code></p>
     <p><code>70</code></p>
     <p><code>71   case 's': /* Размер в блоках */</code></p>
     <p><code>72    sflg++;</code></p>
     <p><code>73    statreq++;</code></p>
     <p><code>74    continue;</code></p>
     <p><code>75</code></p>
     <p><code>76   case 'd': /* Сведения о каталоге, не содержание */</code></p>
     <p><code>77    dflg++;</code></p>
     <p><code>78    continue;</code></p>
     <p><code>79</code></p>
     <p><code>80   case 'g': /* Имя группы вместо имени владельца */</code></p>
     <p><code>81    gflg++;</code></p>
     <p><code>82    continue;</code></p>
     <p><code>83</code></p>
     <p><code>84   case 'l': /* Расширенный листинг */</code></p>
     <p><code>85    lflg++;</code></p>
     <p><code>86    statreq++;</code></p>
     <p><code>87    continue;</code></p>
     <p><code>88</code></p>
     <p><code>89   case 'r': /* Обратный порядок сортировки */</code></p>
     <p><code>90    rflg = -1;</code></p>
     <p><code>91    continue;</code></p>
     <p><code>92</code> </p>
     <p><code>93   case 't': /* Сортировка по времени, не по имени */</code></p>
     <p><code>94    tflg++;</code></p>
     <p><code>95    statreq++;</code></p>
     <p><code>96    continue;</code></p>
     <p><code>97</code></p>
     <p><code>98   case 'u': /* Время доступа, а не изменения */</code></p>
     <p><code>99    uflg++;</code></p>
     <p><code>100   continue;</code></p>
     <p><code>101</code></p>
     <p><code>102  case 'c': /* Время изменения индекса, а не файла */</code></p>
     <p><code>103   cflg++;</code></p>
     <p><code>104   continue;</code></p>
     <p><code>105</code></p>
     <p><code>106  case 'i': /* Включить номер индекса */</code></p>
     <p><code>107   iflg++;</code></p>
     <p><code>108   continue;</code></p>
     <p><code>109</code></p>
     <p><code>110  case 'f': /* Форсировать чтение каждого arg как каталога */</code></p>
     <p><code>111   fflg++;</code></p>
     <p><code>112   continue;</code></p>
     <p><code>113</code></p>
     <p><code>114   default: /* Незнакомые буквы опций игнорировать */</code></p>
     <p><code>115    continue;</code></p>
     <p><code>116  }</code></p>
     <p><code>117  argc--;</code></p>
     <p><code>118 }</code></p>
     <p>Строки 63–118 разбирают опции командной строки. Обратите внимание на ручной разбор кода: <code>getopt()</code> еще не была придумана. Переменная <code>statreq</code> устанавливается в <code>true</code>, когда опция требует использования системного вызова <code>stat()</code>.</p>
     <p>Избежание ненужного вызова <code>stat()</code> для каждого файла дает большой выигрыш в производительности. Вызов <code>stat()</code> был чрезвычайно дорогим, поскольку он мог вызвать поиск расположения индекса на файле, дисковое чтение для получения индекса, а затем поиск на диске расположения содержимого каталога (для того, чтобы продолжить чтение элементов каталога).</p>
     <p>В современных системах индексы находятся в группах, распределенных по всей файловой системе, вместо объединения их вместе в начале. Это дает заметный прирост производительности. Тем не менее, вызовы <code>stat()</code> до сих пор не бесплатны, вы должны использовать их лишь при необходимости, но не более.</p>
     <p><code>119 if (fflg) { /* -f аннулирует -l, -s, -t, добавляя -a */</code></p>
     <p><code>120  aflg++;</code></p>
     <p><code>121  lflg = 0;</code></p>
     <p><code>122  sflg = 0;</code></p>
     <p><code>123  tflg = 0;</code></p>
     <p><code>124  statreq = 0;</code></p>
     <p><code>125 }</code></p>
     <p><code>126 if (lflg) { /* Открыть файл паролей или групп */</code></p>
     <p><code>127  t = "/etc/passwd";</code></p>
     <p><code>128  if (gflg)</code></p>
     <p><code>129   t = "/etc/group";</code></p>
     <p><code>130  pwdf = fopen(t, "r");</code></p>
     <p><code>131 }</code></p>
     <p><code>132 if (argc==0) { /* Если нет аргументов, использовать текущий */</code></p>
     <p><code>133  argc++;</code></p>
     <p><code>134  argv = &amp;dotp - 1;</code></p>
     <p><code>135 }</code></p>
     <p>Строки 119–125 обрабатывают опцию <code>-f</code>, выключая <code>-l</code>, <code>-s</code>, <code>-t</code> и <code>statreq</code>. Строки 126–131 обрабатывают <code>-l</code>, устанавливая для файла чтение сведений о владельце или группе. Помните, что V7 показывает лишь одно из этих сведений, но не оба.</p>
     <p>Если аргументов больше не осталось, строки 132–135 устанавливают <code>argv</code> таким образом, что он указывает на строку, представляющую текущий каталог. Назначение '<code>argr = &amp;dotp - 1</code>' действительно, хотя и необычно. '<code>- 1</code>' компенсирует '<code>++argv</code>' в строке 137. Это позволяет избежать в главной части программы специального случая для '<code>argc == 1</code>'.</p>
     <p><code>136  for (i=0; i &lt; argc; i++) { /* Получить сведения о каждом файле */</code></p>
     <p><code>137   if ((ер = gstat(*++argv, 1))==NULL)</code></p>
     <p><code>138    continue;</code></p>
     <p><code>139   ep-&gt;ln.namep = *argv;</code></p>
     <p><code>140   ep-&gt;lflags |= ISARG;</code></p>
     <p><code>141  }</code></p>
     <p><code>142  qsort(firstp, lastp - firstp, sizeof *lastp, compar);</code></p>
     <p><code>143  slastp = lastp;</code></p>
     <p><code>144  for (epp=firstp; epp&lt;slastp; epp++) { /* Глав. код, см. текст */</code></p>
     <p><code>145   ер = *epp;</code></p>
     <p><code>146   if (ep-&gt;ltype=='d' &amp;&amp; dflg==0 || fflg) {</code></p>
     <p><code>147    if (argc&gt;1)</code></p>
     <p><code>148     printf("\n%s:\n", ep-&gt;ln.namep);</code></p>
     <p><code>149    lastp = slastp;</code></p>
     <p><code>150    readdir(ep-&gt;ln.namep);</code></p>
     <p><code>151    if (fflg==0)</code></p>
     <p><code>152     qsort(slastp, lastp - slastp, sizeof *lastp, compar);</code></p>
     <p><code>153    if (lflg || sflg)</code></p>
     <p><code>154     printf("total %D\n", tblocks);</code></p>
     <p><code>155    for (ep1=slastp; ep1&lt;lastp; ep1++)</code></p>
     <p><code>156     pentry(*ep1);</code></p>
     <p><code>157   } else</code></p>
     <p><code>158   pentry(ep);</code></p>
     <p><code>159  }</code></p>
     <p><code>160  exit(0);</code></p>
     <p><code>161 } /* Конец main() */</code></p>
     <p>Строки 136–141 перебирают аргументы, собирая сведения о каждом. Второй аргумент <code>gstat()</code> булевый: <code>true</code>, если имя является аргументом командной строки, в противном случае <code>false</code>. Строка 140 добавляет флаг <code>ISARG</code> к полю <code>lflags</code> для каждого аргумента командной строки.</p>
     <p>Функция <code>gstat()</code> добавляет каждую новую <code>struct lbuf</code> к глобальному массиву <code>flist</code> (строка 137). Она также обновляет глобальный указатель <code>lastp</code>, чтобы он указывал в этом массиве на текущий последний элемент.</p>
     <p>Строки 142–143 сортируют массив, используя <code>qsort()</code>, и сохраняют текущее значение <code>lastp</code> в <code>slastp</code>. Строки 144–159 перебирают в цикле каждый элемент массива, выводя соответствующим образом сведения о файле или каталоге.</p>
     <p>Код для каталогов заслуживает дальнейшего объяснения:</p>
     <p><code>if (ep-&gt;ltype=='d' &amp;&amp; dflg==0 || fflg) ...</code></p>
     <p>Строка 146. Если файл является каталогом и <code>-d</code> не предусмотрено или было установлено <code>-f</code>, <code>ls</code> должна прочесть каталог вместо того, чтобы выводить сведения о самом каталоге.</p>
     <p><code>if (argc&gt;1) printf ("\n%s:\n", ep-&gt;ln.namep)</code></p>
     <p>Строки 147–148. Выводят имя каталога и двоеточие, если в командной строке было указано несколько файлов.</p>
     <p><code>lastp = slastp;</code></p>
     <p><code>readdir(ep-&gt;ln.namep)</code></p>
     <p>Строки 149–150. Восстанавливают <code>lastp</code> из <code>slastp</code>. Массив <code>flist</code> действует как двухуровневый стек имен файлов. Аргументы командной строки хранятся с <code>firstp</code> до <code>slastp - 1</code>. Когда <code>readdir()</code> читает каталог, она помещает структуры <code>struct lbuf</code> для содержимого каталога в стек, начиная с <code>slastp</code> и до <code>lastp</code>. Это показано на рис. 7.1.</p>
     <image l:href="#img_11.jpeg"/>
     <p><strong>Рис. 7.1</strong>. Массив <code>flist</code> как двухуровневый стек</p>
     <p><code>if (fflg==0) qsort(slastp, lastp - slastp, sizeof *lastp, compar)</code></p>
     <p>Строки 151–152. Сортируют элементы подкаталога, если не действует <code>-f</code>.</p>
     <p><code>if (lflg || sflg) printf("total %D\n", tblocks)</code></p>
     <p>Строки 153–154. Выводят для <code>-l</code> или <code>-s</code> общее число блоков, используемых файлами в каталоге. Эта сумма хранится в переменной <code>tblocks</code>, которая сбрасывается для каждого каталога. На современных системах форматирующая строка <code>%D</code> для <code>printf()</code> эквивалентна <code>%ld</code>; она означает «вывести длинное целое». (В V7 есть также <code>%ld</code>, см. строку 192.)</p>
     <p><code>for (ep1=slastp; ep1&lt;lastp; ep1++) pentry(*ep1)</code></p>
     <p>Строки 155–156. Выводит сведения о каждом файле в подкаталоге. Обратите внимание, что V7 <code>ls</code> спускается лишь на один уровень в дереве каталогов. У нее отсутствует современная «рекурсивная» опция <code>-R</code>.</p>
     <p><code>163 pentry(ap) /* void pentry(struct lbuf *ap) */</code></p>
     <p><code>164 struct lbuf *ap;</code></p>
     <p><code>165 {</code></p>
     <p><code>166  struct { char dminor, dmajor;}; /* He использующийся исторический артефакт из V6 ls */</code></p>
     <p><code>167  register t;</code></p>
     <p><code>168  register struct lbuf *p;</code></p>
     <p><code>169  register char *cp;</code></p>
     <p><code>170</code></p>
     <p><code>171  p = ap;</code></p>
     <p><code>172  if (p-&gt;lnum == -1)</code></p>
     <p><code>173   return;</code></p>
     <p><code>174  if (iflg)</code></p>
     <p><code>175   printf("%5u ", p-&gt;lnum); /* Номер индекса */</code></p>
     <p><code>176  if (sflg)</code></p>
     <p><code>177   printf("%4D nblock(p-&gt;lsize)); /* Размер в блоках */</code></p>
     <p>Процедура <code>pentry()</code> выводит сведения о файле. Строки 172–173 проверяют, установлен ли -1 в поле <code>lnum</code>, и если так, функция возвращается. Когда верно '<code>p-&gt;lnum == -1</code>', структура <code>struct lbuf</code> недействительна. В противном случае это поле содержит номер индекса файла.</p>
     <p>Строки 174–175 выводят номер индекса, если действует <code>-i</code>. Строки 176–177 выводят общее число блоков, если действует <code>-s</code>. (Как мы увидим ниже, это число может быть неточным.)</p>
     <p><code>178  if (lflg) { /* Расширенный листинг: */</code></p>
     <p><code>179   putchar(p-&gt;ltype); /* - Тип файла */</code></p>
     <p><code>180   pmode(p-&gt;lflags); /* - Права доступа */</code></p>
     <p><code>181   printf("%2d ", p-&gt;lnl); /* - Число ссылок */</code></p>
     <p><code>182   t = p-&gt;luid;</code></p>
     <p><code>183   if (gflg)</code></p>
     <p><code>184    t = p-&gt;lgid;</code></p>
     <p><code>185   if (getname(t, tbuf)==0)</code></p>
     <p><code>186    printf("%-6.6s", tbuf); /* - Владелец или группа */</code></p>
     <p><code>187   else</code></p>
     <p><code>188    printf("%-6d", t);</code></p>
     <p><code>189   if (p-&gt;ltype=='b' || p-&gt;ltype=='c') /* - Устройство: старший и младший номера */</code></p>
     <p><code>190    printf("%3d,%3d", major((int)p-&gt;lsize), minor((int)p-&gt;lsize));</code></p>
     <p><code>191   else</code></p>
     <p><code>192    printf("%71d", p-&gt;lsize); /* - Размер в байтах */</code></p>
     <p><code>193   cp = ctime(&amp;p-&gt;lmtime);</code></p>
     <p><code>194   if (p-&gt;lmtime &lt; year) /* - Время изменения */</code></p>
     <p><code>195    printf(" %-7.7s %-4.4s ", cp+4, cp+20); else</code></p>
     <p><code>196    printf(" %-12.12s ", cp+4);</code></p>
     <p><code>197  }</code></p>
     <p><code>198  if (p-&gt;lflags &amp; ISARG) /* - Имя файла */</code></p>
     <p><code>199   printf("%s\n", p-&gt;ln.namep);</code></p>
     <p><code>200  else</code></p>
     <p><code>201   printf("%.14s\n", p-&gt;ln.lname);</code></p>
     <p><code>202 }</code></p>
     <p>Строки 178–197 обрабатывают опцию <code>-l</code>. Строки 179–181 выводят тип файла, права доступа и число ссылок. Строки 182–184 устанавливают <code>t</code> на ID владельца или группы, в зависимости от опции <code>-g</code>. Строки 185–188 получают соответствующее имя и выводят его, если оно доступно. В противном случае программа выводит числовое значение.</p>
     <p>Строки 189–192 проверяют, является ли файл блочным или символьным устройством. Если да, они выводят старшее и младшее номера устройств, извлеченные с помощью макросов <code>major()</code> и <code>minor()</code>. В противном случае они выводят размер файла.</p>
     <p>Строки 193–196 выводят соответствующее время. Если оно старше шести месяцев, код выводит месяц, день и год. В противном случае, выводятся месяц, день и время (формат результата с <code>time()</code> см. раздел 6.1.3.1 «Простое форматирование времени: <code>asctime()</code> и <code>ctime()</code>»).</p>
     <p>Наконец, строки 198–201 выводят имя файла. Мы знаем, что для аргумента командной строки это завершающаяся нулем строка, и может быть использована <code>%s</code>. Для файла, прочитанного из каталога, оно может не завершаться нулем, поэтому должна использоваться явно указанная точность, <code>%.14s</code>.</p>
     <p><code>204 getname(uid, buf) /* int getname(int uid, char buf[]) */</code></p>
     <p><code>205 int uid;</code></p>
     <p><code>206 char buf[];</code></p>
     <p><code>207 {</code></p>
     <p><code>208  int j, c, n, i;</code></p>
     <p><code>209</code></p>
     <p><code>210  if (uid==lastuid) /* Простое кэширование, см. текст */</code></p>
     <p><code>211   return(0);</code></p>
     <p><code>212  if (pwdf == NULL) /* Проверка безопасности */</code></p>
     <p><code>213   return(-1);</code></p>
     <p><code>214  rewind(pwdf); /* Начать с начала файла */</code></p>
     <p><code>215  lastuid = -1;</code></p>
     <p><code>216  do {</code></p>
     <p><code>217   i = 0; /* Индекс в массиве buf */</code></p>
     <p><code>218   j = 0; /* Число полей в строке */</code></p>
     <p><code>219   n = 0; /* Преобразование числового значения */</code></p>
     <p><code>220   while ((c=fgetc(pwdf)) != '\n') { /* Прочесть строки */</code></p>
     <p><code>221    if (c==EOF)</code></p>
     <p><code>222     return(-1);</code></p>
     <p><code>223    if (c==':') { /* Число полей*/</code></p>
     <p><code>224     j++;</code></p>
     <p><code>225     c = '0';</code></p>
     <p><code>226    }</code></p>
     <p><code>227    if (j==0) /* первое поле - имя */</code></p>
     <p><code>228     buf[i++] = c;</code></p>
     <p><code>229    if (j==2) /* Третье поле - числовой ID */</code></p>
     <p><code>230     n = n*10 + c - '0';</code></p>
     <p><code>231   }</code></p>
     <p><code>232  } while (n != uid); /* Продолжать до обнаружения ID */</code></p>
     <p><code>233  buf[i++] = '\0';</code></p>
     <p><code>234  lastuid = aid;</code></p>
     <p><code>235  return(0);</code></p>
     <p><code>236 }</code></p>
     <p>Функция <code>getname()</code> преобразует ID владельца или группы в соответствующее имя. Она реализует простую схему кэширования; если переданное <code>uid</code> то же самое, которое находится в глобальной переменной <code>lastuid</code>, функция возвращает 0 (все нормально), буфер уже содержит имя (строки 210–211). <code>lastuid</code> инициализируется в -1 (строка 33), поэтому этот тест не проходит, когда <code>getname()</code> вызывается первый раз.</p>
     <p><code>pwdf</code> уже открыт либо в <code>/etc/passwd</code>, либо в <code>/etc/group</code> (см. строки 126–130). Код здесь проверяет, что открытие было успешным, и если нет, возвращает -1 (строки 212–213).</p>
     <p>Удивительно, <code>ls</code> <emphasis>не</emphasis> использует <code>getpwuid()</code> или <code>getgrgid()</code>. Вместо этого она использует преимущество того факта, что формат <code>/etc/passwd</code> и <code>/etc/group</code> идентичен для трех первых полей (имя, пароль, числовой ID) и что оба используют в качестве разделителя двоеточие.</p>
     <p>Строки 216–232 реализуют линейный поиск по файлу. <code>j</code> содержит число обнаруженных до сих пор двоеточий: 0 для имени и 2 для ID. Таким образом, при сканировании строки она заполняет как имя, так и ID.</p>
     <p>Строки 233–235 завершают буфер <code>name</code>, устанавливают в глобальной <code>lastuid</code> последний найденный ID и возвращают 0 для обозначения успеха.</p>
     <p><code>238 long /* long nblock(long size) */</code></p>
     <p><code>239 nblock(size)</code></p>
     <p><code>240 long size;</code></p>
     <p><code>241 {</code></p>
     <p><code>242  return ((size+511) &gt;&gt;9);</code></p>
     <p><code>243 }</code></p>
     <p>Функция <code>nblock()</code> сообщает, сколько дисковых блоков использует файл. Это вычисление основано на размере файла, возвращенном <code>stat()</code>. Размер блока V7 равен 512 байтам — размер физического сектора диска.</p>
     <p>Вычисление в строке 242 выглядит несколько устрашающим. '<code>&gt;&gt;9</code>' является сдвигом вправо на девять битов. Это осуществляет деление на 512 для получения числа блоков. (На раннем аппаратном обеспечении сдвиг вправо выполнялся гораздо быстрее деления.) Пока все хорошо. Теперь, файл даже размером в один байт все равно занимает целый дисковый блок. Однако, '<code>1 / 512</code>' дает ноль (целое деление срезает), что неверно. Это объясняет '<code>size+511</code>'. Добавляя 511, этот код гарантирует, что сумма дает правильное число блоков при делении на 512.</p>
     <p>Это вычисление, однако, лишь приблизительное. У очень больших файлов есть также дополнительные блоки. Несмотря на заявление в справочной странице V7 <emphasis>ls</emphasis>(1), данное вычисление не принимает в расчет дополнительные блоки.</p>
     <p>Более того, рассмотрите случай файла с большими дырами (созданными установкой указателя файла дальше конца файла с помощью <code>lseek()</code>). Дыры не занимают дисковых блоков; однако, это не отражается в значении размера. Поэтому вычисления, выполненные <code>nblock()</code>, будучи обычно верными, могут давать результаты больше или меньше реальных.</p>
     <p>По этим причинам в <code>struct stat</code> 4 2 BSD были добавлены члены <code>st_blocks</code>, которые затем были приняты для System V и POSIX.</p>
     <p><code>245 int m1[] = { 1, S_IREAD&gt;&gt;0, 'r', '-' };</code></p>
     <p><code>246 int m2[] = { 1, S_IWRITE&gt;&gt;0, 'w', '-' };</code></p>
     <p><code>247 int m3[] = { 2, S_ISUID, 's', S_IEXEC&gt;&gt;0, 'x', '-' };</code></p>
     <p><code>248 int m4[] = { 1, S_IREAD&gt;&gt;3, 'r', '-' };</code></p>
     <p><code>249 int m5[] = { 1, S_IWRITE&gt;&gt;3, 'w', '-' };</code></p>
     <p><code>250 int m6[] = { 2, S_ISGID, 's', S_IEXEC&gt;&gt;3, 'x', '-' };</code></p>
     <p><code>251 int m7[] = { 1, S_IREAD&gt;&gt;6, 'r', '-' };</code></p>
     <p><code>252 int m8[] = { 1, S_IWRITE&gt;&gt;6, 'w', '-' };</code></p>
     <p><code>253 int m9[] = { 2, S_ISVTX, ' t', S_IEXEC&gt;&gt;6, 'x', '-' };</code></p>
     <p><code>254</code></p>
     <p><code>255 int *m[] = { m1, m2, m3, m4, m5, m6, m7, m8, m9 };</code></p>
     <p><code>256</code></p>
     <p><code>257 pmode(aflag) /* void pmode(int aflag) */</code></p>
     <p><code>258 {</code></p>
     <p><code>259  register int **mp;</code></p>
     <p><code>260</code></p>
     <p><code>261  flags = aflag;</code></p>
     <p><code>262  for (mp = &amp;m[0]; mp &lt; &amp;m[sizeof(m)/sizeof(m[0])];)</code></p>
     <p><code>263   select(*mp++);</code></p>
     <p><code>264 }</code></p>
     <p><code>265</code> </p>
     <p><code>266 select(pairp) /* void select(register int *pairp) */</code></p>
     <p><code>267 register int *pairp;</code></p>
     <p><code>268 {</code></p>
     <p><code>269  register int n;</code></p>
     <p><code>270</code></p>
     <p><code>271  n = *pairp++;</code></p>
     <p><code>272  while (--n&gt;=0 &amp;&amp; (flags&amp;*pairp++)==0)</code></p>
     <p><code>273   pairp++;</code></p>
     <p><code>274  putchar(*pairp);</code></p>
     <p><code>275 }</code></p>
     <p>Строки 245–275 выдают права доступа к файлу. Код компактен и довольно элегантен, он требует тщательного изучения.</p>
     <p>• Строки 245–253: массивы с <code>m1</code> по <code>m9</code> кодируют биты прав доступа для проверки вместе с соответствующими буквами для вывода. На каждую выводимую букву режима файла имеется один массив. Первый элемент каждого массива является числом пар (право доступа, буква), закодированных в данном конкретном массиве. Последний элемент является буквой, которая должна быть выведена в случае, если не найден ни один из битов прав доступа.</p>
     <p>Обратите также внимание, что права доступа обозначены как '<code>I_READ&gt;&gt;0</code>', '<code>I_READ&gt;&gt;3</code>', '<code>I_READ&gt;&gt;6</code>' и т.д. Отдельные константы для каждого бита (<code>S_IRUSR</code>, <code>S_IRGRP</code> и т.п.) не были еще придуманы. (См. табл. 4.5 в разделе 4 6.1 «Указание начальных прав доступа к файлу».)</p>
     <p>• Строка 255: массив <code>m</code> указывает на каждый из массивов с <code>m1</code> по <code>m9</code>.</p>
     <p>• Строки 257–264: функция <code>pmode()</code> сначала устанавливает глобальную переменную <code>flags</code> равной переданному параметру <code>aflag</code>. Затем она просматривает в цикле массив <code>m</code>, передавая каждый элемент функции <code>select()</code>. Переданный элемент представляет один из массивов с <code>m1</code> по <code>m9</code>.</p>
     <p>• Строки 266–275: функция <code>select()</code> понимает структуру каждого из массивов с <code>m1</code> по <code>m9</code>. <code>n</code> является числом пар в массиве (первый элемент); его устанавливает строка 271. Строки 272–273 ищут биты прав доступа, проверяя установленную ранее в строке 261 глобальную переменную <code>flags</code>.</p>
     <p>Обратите внимание на использование оператора <code>++</code> как в проверке цикла, так и в теле цикла. Результатом является пропуск пары в массиве, если в <code>flags</code> не обнаружен бит доступа в первом элементе пары.</p>
     <p>Когда цикл завершается, либо бит разрешения был найден, в этом случае <code>pairp</code> указывает на второй элемент пары, являющийся нужным для вывода символом, либо он не был найден, в этом случае <code>pairp</code> указывает на символ по умолчанию. В любом случае, строка 274 выводит символ, на который указывает <code>pairp</code>.</p>
     <p>Последним стоящим внимания моментом является то, что на С символьные константы (такие как '<code>x</code>') имеют тип <code>int</code>, а не <code>char</code><a l:href="#n75" type="note">[75]</a>. Поэтому проблем с помещением этих констант в массив целых нет; все работает правильно.</p>
     <p><code>277 char* /* char *makename(char *dir, char *file) */</code></p>
     <p><code>278 makename(dir, file)</code></p>
     <p><code>279 char *dir, *file;</code></p>
     <p><code>280 {</code></p>
     <p><code>281  static char dfile[100];</code></p>
     <p><code>282  register char *dp, *fp;</code></p>
     <p><code>283  register int i;</code></p>
     <p><code>284</code></p>
     <p><code>285  dp = dfile;</code></p>
     <p><code>286  fp = dir;</code></p>
     <p><code>287  while (*fp)</code></p>
     <p><code>288   *dp++ = *fp++;</code></p>
     <p><code>289  *dp++ = '/';</code></p>
     <p><code>290  fp = file;</code></p>
     <p><code>291  for (i=0; i&lt;DIRSIZ; i++)</code></p>
     <p><code>292   *dp++ = * fp++;</code></p>
     <p><code>293  *dp = 0;</code></p>
     <p><code>294  return(dfile);</code></p>
     <p><code>295 }</code></p>
     <p>Строки 277–295 определяют функцию <code>makename()</code>. Ее работа заключается в соединении имени каталога с именем файла, разделенным символом косой черты, с образованием строки. Она осуществляет это в <code>static</code> буфере <code>dfile</code>. Обратите внимание, что <code>dfile</code> всего лишь 100 символов длиной и что проверка ошибок не выполняется.</p>
     <p>Сам код прост, он копирует по одному символу за раз. <code>makename()</code> используется функцией <code>readdir()</code>.</p>
     <p><code>297 readdir(dir) /* void readdir(char *dir) */</code></p>
     <p><code>298 char *dir;</code></p>
     <p><code>299 {</code></p>
     <p><code>300  static struct direct dentry;</code></p>
     <p><code>301  register int j;</code></p>
     <p><code>302  register struct lbuf *ep;</code></p>
     <p><code>303</code></p>
     <p><code>304  if ((dirf = fopen(dir, "r")) == NULL) {</code></p>
     <p><code>305   printf("%s unreadable\n", dir);</code></p>
     <p><code>306   return;</code></p>
     <p><code>307  }</code></p>
     <p><code>308  tblocks = 0;</code></p>
     <p><code>309  for(;;) {</code></p>
     <p><code>310   if (fread((char*)&amp;dentry, sizeof(dentry), 1, dirf) != 1)</code></p>
     <p><code>311    break;</code></p>
     <p><code>312   if (dentry.d_ino==0</code></p>
     <p><code>313    || aflg==0 &amp;&amp; dentry.d_name[0]=='.' &amp;&amp; (dentry.d_name[1]=='\0'</code></p>
     <p><code>314    || dentry.d_name[1]=='.' &amp;&amp; dentry, d_name[2]=='\0'))</code></p>
     <p><code>315    continue;</code></p>
     <p><code>316   ep = gstat(makename(dir, dentry.d_name), 0);</code></p>
     <p><code>317   if (ep==NULL)</code></p>
     <p><code>318    continue;</code></p>
     <p><code>319   if (ep-&gt;lnum != -1)</code></p>
     <p><code>320    ep-&gt;lnum = dentry.d_ino;</code></p>
     <p><code>321   for (j =0; j&lt;DIRSIZ; j++)</code></p>
     <p><code>322    ep-&gt;ln.lname[j] = dentry.d_name[j];</code></p>
     <p><code>323  }</code></p>
     <p><code>324  fclose(dirf);</code></p>
     <p><code>325 }</code></p>
     <p>Строки 297–325 определяют функцию <code>readdir()</code>, чья работа заключается в чтении содержимого каталогов, указанных в командной строке.</p>
     <p>Строки 304–307 открывают каталог для чтения, завершая функцию, если <code>fopen()</code> возвращает ошибку. Строка 308 инициализирует глобальную переменную <code>tblocks</code> нулем. Ранее (строки 153–154) это использовалось для вывода общего числа блоков, использованных файлами в каталоге.</p>
     <p>Строки 309–323 являются циклом, который читает элементы каталога и добавляет их к массиву <code>flist</code>. Строки 310–311 читают один элемент, выходя из цикла в конце файла.</p>
     <p>Строки 312–315 пропускают неинтересные элементы. Если номер индекса равен нулю, этот слот не используется. В противном случае, если не был указан -а и имя файла является '<code>.</code>' или '<code>..</code>', оно пропускается.</p>
     <p>Строки 316–318 вызывают <code>gstat()</code> с полным именем файла и вторым аргументом, равным <code>false</code>, указывающим, что он не из командной строки. <code>gstat()</code> обновляет глобальный указатель <code>lastp</code> и массив <code>flist</code>. Возвращаемое значение <code>NULL</code> обозначает какую-нибудь разновидность ошибки.</p>
     <p>Строки 319–322 сохраняют номер индекса и имя в <code>struct lbuf</code>. Если <code>ep-&gt;lnum</code> возвращается из <code>gstat()</code> установленным в -1, это означает, что операция <code>stat()</code> с файлом завершилась неудачей. Наконец, строка 324 закрывает каталог.</p>
     <p>Следующая функция, <code>gstat()</code> (строки 327–398), является центральной функцией для получения и сохранения сведений о файле.</p>
     <p><code>327 struct lbuf * /* struct lbuf *gstat(char *file, int argfl) */</code></p>
     <p><code>328 gstat(file, argfl)</code></p>
     <p><code>329 char *file;</code></p>
     <p><code>330 {</code></p>
     <p><code>331  extern char *malloc();</code></p>
     <p><code>332  struct stat statb;</code></p>
     <p><code>333  register struct lbuf *rep;</code></p>
     <p><code>334  static int nomocore;</code></p>
     <p><code>335</code></p>
     <p><code>336  if (nomocore) /* Ранее была нехватка памяти */</code></p>
     <p><code>337   return(NULL);</code></p>
     <p><code>338  rep = (struct lbuf*)malloc(sizeof(struct lbuf));</code></p>
     <p><code>339  if (rep==NULL) {</code></p>
     <p><code>340   fprintf(stderr, "ls: out of memory\n");</code></p>
     <p><code>341   nomocore = 1;</code></p>
     <p><code>342   return(NULL);</code></p>
     <p><code>343  }</code></p>
     <p><code>344  if (lastp &gt;= &amp;flist[NFILES]) { /* Проверить, не дано ли слишком много файлов */</code></p>
     <p><code>345   static int msg;</code></p>
     <p><code>346   lastp--;</code></p>
     <p><code>347   if (msg==0) {</code></p>
     <p><code>348    fprintf(stderr, "ls: too many files\n");</code></p>
     <p><code>349    msg++;</code></p>
     <p><code>350   }</code></p>
     <p><code>351  }</code></p>
     <p><code>352  *lastp++ = rep; /* Заполнить сведения */</code></p>
     <p><code>353  rep-&gt;lflags = 0;</code></p>
     <p><code>354  rep-&gt;lnum = 0;</code></p>
     <p><code>355  rep-&gt;ltype = '-'; /* Тип файла по умолчанию */</code></p>
     <p>Статическая переменная <code>nomocore</code> [важно] указывает, что <code>malloc()</code> при предыдущем вызове завершилась неудачей. Поскольку она статическая, она автоматически инициализируется 0 (т.е. <code>false</code>). Если на входе она равна <code>true</code>, <code>gstat()</code> просто возвращает <code>NULL</code>. В противном случае, если <code>malloc()</code> завершается неудачей, <code>ls</code> выводит сообщение об ошибке, устанавливает в <code>nomocore</code> <code>true</code> и возвращает <code>NULL</code> (строки 334–343).</p>
     <p>Строки 344–351 гарантируют, что в массиве <code>flist</code> все еще остается место. Если нет, <code>ls</code> выдает сообщение (но лишь однажды; заметьте использование статической переменной <code>msg</code>), а затем повторно использует последний слот <code>flist</code>.</p>
     <p>Строка 352 заставляет слот <code>lastp</code> указывать на новую <code>struct lbuf</code> (<code>rep</code>). Это также обновляет <code>lastp</code>, который используется для сортировки в <code>main()</code> (строки 142 и 152). Строки 353–355 устанавливают значения по умолчанию для полей флагов, номеров индексов и типов в <code>struct lbuf</code>.</p>
     <p><code>356  if (argfl || statreq) {</code></p>
     <p><code>357   if (stat(file, &amp;statb)&lt;0) { /* stat() завершилась неудачей */</code></p>
     <p><code>358    printf("%s not found\n", file);</code></p>
     <p><code>359    statb.st_ino = -1;</code></p>
     <p><code>360    statb.st_size = 0;</code></p>
     <p><code>361    statb.st_mode = 0;</code></p>
     <p><code>362    if (argfl) {</code></p>
     <p><code>363     lastp--;</code></p>
     <p><code>364     return(0);</code></p>
     <p><code>365    }</code></p>
     <p><code>366   }</code></p>
     <p><code>367   rep-&gt;lnum = statb.st_ino; /* stat() OK, копировать сведения */</code></p>
     <p><code>368   rep-&gt;lsize = statb.st_size;</code></p>
     <p><code>369   switch(statb.st_mode &amp; S_IFMT) {</code></p>
     <p><code>370</code></p>
     <p><code>371   case S_IFDIR:</code></p>
     <p><code>372    rep-&gt;ltype = 'd';</code></p>
     <p><code>373    break;</code></p>
     <p><code>374</code></p>
     <p><code>375   case S_IFBLK:</code></p>
     <p><code>376    rep-&gt;ltype = 'b';</code></p>
     <p><code>377    rep-&gt;lsize = statb.st_rdev;</code></p>
     <p><code>378    break;</code></p>
     <p><code>379</code></p>
     <p><code>380   case S_IFCHR:</code></p>
     <p><code>381    rep-&gt;ltype = 'c';</code></p>
     <p><code>382    rep-&gt;lsize = statb.st_rdfev;</code></p>
     <p><code>383    break;</code></p>
     <p><code>384   }</code></p>
     <p><code>385   rep-&gt;lflags = statb.st_mode &amp; ~S_IFMT;</code></p>
     <p><code>386   rep-&gt;luid = statb.st_uid;</code></p>
     <p><code>387   rep-&gt;lgid = statb.st_gid;</code></p>
     <p><code>388   rep-&gt;lnl = statb.st_nlink;</code></p>
     <p><code>389   if (uflg)</code></p>
     <p><code>390    rep-&gt;lmtime = statb.st_atime;</code></p>
     <p><code>391   else if (cflg)</code></p>
     <p><code>392    rep-&gt;lmtime = statb.st_ctime;</code></p>
     <p><code>393   else</code></p>
     <p><code>394    rep-&gt;lmtime = statb.st_mtime;</code></p>
     <p><code>395   tblocks += nblock(statb.st_size);</code></p>
     <p><code>396  }</code></p>
     <p><code>397  return(rep);</code></p>
     <p><code>398 }</code></p>
     <p>Строки 356–396 обрабатывают вызов <code>stat()</code>. Если это аргумент командной строки или если <code>statreq</code> установлен в <code>true</code> благодаря опции, код заполняет <code>struct lbuf</code> следующим образом:</p>
     <p>• Строки 357–366: вызывают <code>stat()</code>, при ее неудаче выводится сообщение об ошибке с установкой соответствующих значений, затем возвращается <code>NULL</code> (выраженный в виде 0).</p>
     <p>• Строки 367–368: устанавливают в struct stat поля номера индекса и размера, если вызов <code>stat()</code> был успешным.</p>
     <p>• Строки 369–384: обрабатывают особые случаи каталогов, блочных и символьных устройств. Во всех случаях код обновляет поле <code>ltype</code>. Для устройств значение <code>lsize</code> замещается значением <code>st_rdev</code>.</p>
     <p>• Строки 385–388. заполняются поля <code>lflags</code>, <code>luid</code>, <code>lgid</code> и <code>lnl</code> из соответствующих полей в <code>struct stat</code>. Строка 385 удаляет биты типа файла, оставляя 12 битов прав доступа (на чтение/запись/исполнение для владельца/группы/остальных, а также setuid, setgid и save-text).</p>
     <p>• Строки 389–394: основываясь на опциях командной строки, используют одно из трех полей времени в <code>struct stat</code> для поля <code>lmtime</code> в <code>struct lbuf</code>.</p>
     <p>• Строка 395: обновляет глобальную переменную <code>tblocks</code> числом блоков в файле.</p>
     <p><code>400 compar(pp1, pp2) /* int compar(struct lbuf **pp1, */</code></p>
     <p><code>401 struct lbuf **pp1, **pp2; /* struct lbuf **pp2) */</code></p>
     <p><code>402 {</code></p>
     <p><code>403  register struct lbuf *p1, *p2;</code></p>
     <p><code>404</code></p>
     <p><code>405  p1 = *pp1;</code></p>
     <p><code>406  p2 = *pp2;</code></p>
     <p><code>407  if (dflg==0) {</code></p>
     <p><code>408   if (p1-&gt;lflags&amp;ISARG &amp;&amp; p1-&gt;ltype=='d') {</code></p>
     <p><code>409    if (!(p2-&gt;lflags&amp;ISARG &amp;&amp; p2-&gt;ltype=='d'))</code></p>
     <p><code>410     return(1);</code></p>
     <p><code>411   } else {</code></p>
     <p><code>412    if (p2-&gt;lflags&amp;ISARG &amp;&amp; p2-&gt;ltype=='d')</code></p>
     <p><code>413     return(-1);</code></p>
     <p><code>414   }</code></p>
     <p><code>415  }</code></p>
     <p><code>416  if (tflg) {</code></p>
     <p><code>417   if(p2-&gt;lmtime == p1-&gt;lmtime)</code></p>
     <p><code>418    return(0);</code></p>
     <p><code>419   if (p2-&gt;lmtime &gt; p1-&gt;lmtime)</code></p>
     <p><code>420    return(rflg);</code></p>
     <p><code>421   return(-rflg);</code></p>
     <p><code>422  }</code></p>
     <p><code>423  return(rflg * strcmp(p1-&gt;lflags&amp;ISARG ? p1-&gt;ln.namep : p1-&gt;ln.lname,</code></p>
     <p><code>424   p2-&gt;lflags&amp;ISARG ? p2-&gt;ln.namep : p2-&gt;ln.lname));</code></p>
     <p><code>425 }</code></p>
     <p>Функция <code>compar()</code> сжата: в небольшом пространстве происходит многое. Первая вещь, которую следует запомнить, это смысл возвращаемого значения: отрицательное значение означает, что первый файл должен идти перед вторым, ноль означает, что файлы равны, а положительное значение означает, что второй файл должен идти перед первым</p>
     <p>Следующая вещь, которую нужно понять, это то, что <code>ls</code> выводит содержимое каталогов <emphasis>после</emphasis> выведения сведений о файлах. Поэтому результат сортировки должен быть таким, чтобы все каталоги, <emphasis>указанные в командной строке</emphasis>, следовали за всеми файлами, указанными там же</p>
     <p>Наконец, переменная <code>rflg</code> помогает реализовать опцию <code>-r</code>, которая меняет порядок сортировки. Она инициализируется 1 (строка 30). Если <code>-r</code> используется, <code>rflg</code> устанавливается в -1 (строки 89–91).</p>
     <p>Следующий псевдокод описывает логику <code>compar()</code>; номера строк на левой границе соответствуют номерам строк <code>ls.c</code>:</p>
     <p><code>407 if <emphasis>ls должна прочесть каталоги</emphasis> # dflg == 0</code></p>
     <p><code>408  if <emphasis>p1 аргумент командной строки и p1 каталог</emphasis></code></p>
     <p><code>409   if <emphasis>p2 не аргумент командной строки и не каталог</emphasis></code></p>
     <p><code>410    return 1 # первый идет после второго</code></p>
     <p><code>      else</code></p>
     <p><code>       <emphasis>перейти на тест времени</emphasis></code></p>
     <p><code>411  else</code></p>
     <p><code>      # p1 не каталог командной строки</code></p>
     <p><code>412   if <emphasis>p2 аргумент командной строки и каталог</emphasis></code></p>
     <p><code>413    return -1 # первый идет перед вторым</code></p>
     <p><code>      else</code></p>
     <p><code>       <emphasis>перейти на тест времени</emphasis></code></p>
     <p><code>416 if <emphasis>сортировка основана на времени</emphasis> # tflg равно true</code></p>
     <p><code>     # сравнить времена:</code></p>
     <p><code>417  if <emphasis>время p2 равно времени p1</emphasis></code></p>
     <p><code>418   return 0</code></p>
     <p><code>419  if <emphasis>время p2 &gt; времени p1</emphasis></code></p>
     <p><code>420   return <emphasis>значение rflg (положительное или отрицательное)</emphasis></code></p>
     <p><code>     # время p2 &lt; времени p1</code></p>
     <p><code>421  return <emphasis>противоположное rflg значение (положительное или отрицательное)</emphasis></code></p>
     <p><code>423 <emphasis>Умножить rflg на результат strcmp()</emphasis></code></p>
     <p><code>424 <emphasis>для двух имен и вернуть результат</emphasis></code></p>
     <p>Аргументы <code>strcmp()</code> в строках 423–424 выглядят сбивающими с толку. В зависимости от того, было ли имя файла указано в командной строке или было прочитано из каталога, должны использоваться различные члены объединения <code>ln</code> в <code>struct lbuf</code>.</p>
    </section>
    <section>
     <title>
      <p>7.3. Резюме</p>
     </title>
     <p>• V7 <code>ls</code> является сравнительно небольшой программой, хотя она затрагивает многие фундаментальные аспекты программирования Unix — файловый ввод-вывод, вспомогательные данные файлов, содержание каталогов, пользователи и группы, значения времени и даты, сортировку и динамическое управление памятью.</p>
     <p>• Наиболее примечательным внешним различием между V7 <code>ls</code> и современной <code>ls</code> является трактовка опций <code>-а</code> и <code>-l</code>. У версии V7 значительно меньше опций, чем у современных версий; заметным недостатком является отсутствие рекурсивной опции <code>-R</code>.</p>
     <p>• Управление <code>flist</code> является чистым способом использования ограниченной памяти архитектуры PDP-11, предоставляя в то же время как можно больше сведений, <code>struct lbuf</code> хорошо извлекает нужные сведения из <code>struct stat</code>; это значительно упрощает код. Код для вывода девяти битов доступа компактен и элегантен.</p>
     <p>• Некоторые части <code>ls</code> используют удивительно маленькие лимиты, такие, как верхняя граница числа файлов в 1024 или размер буфера в <code>makename()</code> в 100.</p>
    </section>
    <section>
     <title>
      <p>Упражнения</p>
     </title>
     <p>1. Рассмотрите функцию <code>getname()</code>. Что случится, если запрошенный ID равен 256, а в <code>/etc/passwd</code> есть следующие две строки, в этом порядке:</p>
     <p><code>joe:xyzzy:2160:10:Joe User:/usr/joe:/bin/sh</code></p>
     <p><code>jane:zzyxx:216:12:Jane User:/usr/jane:/bin/sh</code></p>
     <p>2. Рассмотрите функцию <code>makename()</code>. Может ли она использовать <code>sprintf()</code> для составления имени? Почему может или почему нет?</p>
     <p>3. Являются ли строки 319–320 в <code>readdir()</code> действительно необходимыми?</p>
     <p>4. Возьмите программу <code>stat</code>, которую вы написали в качестве упражнения в «Упражнениях» к главе 6. Добавьте функцию <code>nblock()</code> из V7 <code>ls</code> и выведите результаты вместе с полем <code>st_blocks</code> из <code>struct stat</code>. Добавьте видимый маркер, когда они различны.</p>
     <p>5. Как бы вы оценили V7 <code>ls</code> по ее использованию <code>malloc()</code>? (Подсказка: как часто вызывается <code>free()</code>? Где ее следовало бы вызвать?)</p>
     <p>6. Как вы оценили бы ясность кода V7 <code>ls</code>? (Подсказка: сколько там комментариев?)</p>
     <p>7. Очертите шаги, которые нужно было бы сделать, чтобы адаптировать V7 <code>ls</code> для современных систем.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 8</p>
     <p>Файловые системы и обходы каталогов</p>
    </title>
    <section>
     <p>Данная глава завершает обсуждение файловых систем и каталогов Linux (и Unix). Сначала мы опишем, как к логическому пространству имен файловой системы добавляется (и удаляется) раздел диска, содержащий файловую систему, таким образом, что в общем пользователю не нужно ни знать, ни заботиться о месте физического размещения файла, вместе с API для работы с файловыми системами</p>
     <p>Затем мы опишем, как перемещаться по иерархическому пространству имен файлов, как получать полный путь текущего рабочего каталога и как без труда обрабатывать произвольные иерархии (деревья) каталогов, используя функцию <code>nftw()</code>. Наконец, мы опишем специализированный, но важный системный вызов <code>chroot()</code>.</p>
    </section>
    <section>
     <title>
      <p>8.1. Монтирование и демонтирование файловых систем</p>
     </title>
     <section>
      <p>Унифицированное иерархическое пространство имен файлов является большим достоинством дизайна Linux/Unix. Данный раздел рассматривает, как административные файлы, команды и операционная система объединяются для построения пространства имен из отдельных физических устройств, содержащих данные и служебные данные файлов.</p>
     </section>
     <section>
      <title>
       <p>8.1.1. Обзор основ</p>
      </title>
      <p>В главе 5 «Каталоги и служебные данные файлов», были представлены индексы для служебных данных файлов и описано, как элементы каталогов связывают имена файлов с индексами В ней также были описаны разделы и файловые системы, и вы видели, что прямые ссылки ограничены работой в пределах одной файловой системы, поскольку каталоги содержат лишь номера индексов, а последние не уникальны среди всего набора использующихся файловых систем.</p>
      <p>Помимо индексов и блоков данных, файловые системы содержат также одну или более копий <emphasis>суперблока</emphasis>. Это специальный дисковый блок, который описывает файловую систему; его сведения обновляются по мере изменений в самой файловой системе. Например, он содержит число свободных и используемых индексов, свободных и используемых блоков и другие сведения. Он включает также <emphasis>магическое число</emphasis>: специальное уникальное значение в специальном месте, которое идентифицирует тип файловой системы (Вскоре мы увидим, насколько это важно.)</p>
      <p>Обеспечение доступа к разделу, содержащему файловую систему, называется <emphasis>монтированием (mounting)</emphasis> файловой системы. Удаление файловой системы из использования называется, что неудивительно, <emphasis>демонтированием (unmounting)</emphasis> файловой системы.</p>
      <p>Эти две задачи выполняются программами <code>mount</code> и <code>umount</code> [так], названными по соответствующим системным вызовам. У системного вызова <code>mount()</code> каждой системы Unix свой, отличный интерфейс. Поскольку монтирование и демонтирование считаются проблемой реализации, POSIX намеренно не стандартизует эти системные вызовы</p>
      <p>Вы монтируете файловую систему в каталог; такой каталог называется <emphasis>точкой монтирования</emphasis> файловой системы. По соглашению, каталог должен быть пустым, но ничто не принуждает к этому. Однако, если точка монтирования не пуста, все ее содержимое становится , пока в ней не смонтирована файловая система<a l:href="#n76" type="note">[76]</a>.</p>
      <p>Ядро поддерживает уникальный номер, известный как <emphasis>номер устройства</emphasis>, который идентифицирует каждый смонтированный раздел. По этой причине именно пара (устройство, индекс) вместе уникально идентифицируют файл; когда структуры <code>struct stat</code> для двух имен файлов указывают, что оба эти номера одни и те же, можно быть уверенным, что они на самом деле ссылаются на один и тот же файл.</p>
      <p>Как упоминалось ранее, программы уровня пользователя помещают структуры индексов и другие вспомогательные данные на раздел диска, создавая тем самым файловую систему. Эти самые программы создают для файловой системы начальный корневой каталог. Таким образом, нам придется провести различие между «корневым каталогом, названным <code>/</code>», который является каталогом самого верхнего уровня в иерархическом пространстве имен файлов, и «корневым каталогом файловой системы», который является отдельным каталогом верхнего уровня каждой файловой системы. Каталог <code>/</code> является также «корневым каталогом» «корневой файловой системы».</p>
      <p>По причинам, описанным на врезке, у корневого каталога файловой системы номер индекса <emphasis>всегда</emphasis> равен 2 (хотя это не стандартизовано формально). Поскольку может быть несколько файловых систем, у каждой из них один и тот же номер индекса корневого каталога 2. При разрешении пути ядро знает, где смонтирована каждая файловая система и заставляет имя точки монтирования ссылаться на корневой каталог смонтированной файловой системы. Более того, '<code>..</code>' в корне смонтированной файловой системы ссылается на родительский каталог точки монтирования.</p>
      <p>На рис. 8.1 показаны две файловые системы: одна для корневого каталога, а другая для <code>/usr</code>, до того, как <code>/usr</code> смонтирована. На рис. 8.2 показана ситуация после монтирования <code>/usr</code>.</p>
      <image l:href="#img_12.jpeg"/>
      <p><strong>Рис. 8.1</strong>. Отдельные файловые системы до монтирования</p>
      <image l:href="#img_13.jpeg"/>
      <p><strong>Рис. 8.2</strong>. Отдельные файловые системы после монтирования</p>
      <p>Каталог <code>/</code>, корень всей логической иерархии, особый еще в одном отношении: <code>/.</code> и <code>/..</code> ссылаются на один и тот же каталог; это неверно для любого другого каталога в системе. (Таким образом, после команды типа '<code>cd /../../../..</code>' вы все еще будете в <code>/</code>.) Это поведение реализуется простым способом: как <code>/.</code>, так и <code>/..</code> являются прямыми ссылками на корневой каталог файловой системы. (Вы можете видеть это как на рис. 8.1, так и 8.2.) Каждая файловая система работает таким способом, но ядро рассматривает <code>/</code> особым образом и не рассматривает как особый случай каталог '<code>..</code>' для файловой системы, смонтированной в <code>/</code>.</p>
      <cite>
       <subtitle>Номера индексов корневого каталога</subtitle>
       <p>Номер индекса для корневого каталога файловой системы всегда равен 2. Почему это так? Ответ имеет отношение как к технологии, так и к истории.</p>
       <p>Как упоминалось в разделе 5.3 «Чтение каталогов», элемент каталога с номером индекса ноль означает неиспользуемый, или пустой слот. Поэтому индекс 0 не может использоваться для настоящего файла или каталога.</p>
       <p>Хорошо, так что насчет индекса 1? Ну, особенно в 70-80 годах XX века, диски не были сделаны так же хорошо, как сейчас. Когда вы покупали диск, он приходил с (бумажным) списком <emphasis>испорченных блоков</emphasis> — известных мест на диске, которые не могли быть использованы. Каждой операционной системе приходилось отслеживать эти плохие блоки и избегать их использования.</p>
       <p>Под Unix это осуществлялось созданием файла особого назначения, блоки данных которого были известны, как испорченные. Этот файл присоединялся к индексу 1, оставляя 2 в качестве первого индекса, доступного для использования обычными файлами или каталогами.</p>
       <p>На современных дисках присутствует значительное количество встроенной электроники, и они сами управляют испорченными блоками. Поэтому технически было бы осуществимо использовать для файла индекс 1. Однако, поскольку такое большое количество программ Unix, которые предполагают, что индекс 2 является индексом для корневых каталогов файловых систем, Linux также следует этому соглашению. (Однако, Linux иногда использует индекс 1 для не собственных файловых систем, таких, как <code>vfat</code> или <code>/proc</code>.)</p>
      </cite>
     </section>
     <section>
      <title>
       <p>8.1.2. Обзор различных типов файловых систем</p>
      </title>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Обсуждение в данном разделе специфично для Linux. Однако, у многих современных систем Unix также есть сходные особенности. Мы рекомендуем вам изучить документацию своей системы.</p>
      </cite>
      <p>Исторически V7 Unix поддерживал лишь один тип файловой системы; вспомогательные данные и организация каталогов каждого из разделов были структурированы одним и тем же способом. 4.1 BSD использовал файловую систему с такой же как у V7 структурой, но с размером блока 1024 байта вместо 512 байтов. 4.2 BSD ввело «файловую систему BSD», которая разительно изменила расположение индексов и данных на диске и дала возможность использовать гораздо большие размеры блоков. (В общем, использование больших протяженных блоков данных обеспечивает лучшую производительность, особенно для чтения файлов.)</p>
      <p>Вплоть до 4.3 BSD и System V Release 2 в начале и середине 1980-х системы Unix продолжали поддерживать один тип файловой системы. Для переключения компьютера от одной файловой системы на другую<a l:href="#n77" type="note">[77]</a> приходилось сначала резервировать каждую файловую систему на среду архивирования (9-дорожечную ленту), обновлять систему, а затем восстанавливать данные.</p>
      <p>В середине 1980-х Sun Microsystems разработала архитектуру ядра, которая сделала возможным использование нескольких архитектур файловой системы в одно и то же время. Этот проект был реализован в их операционной системе SunOS, сначала для поддержки сетевой файловой системы Sun (Network File System — NFS). Однако, как следствие, стало возможным также поддерживать несколько архитектур на диске. System V Release 3 использовала сходную архитектуру для поддержки удаленной файловой системы (Remote File System — RFS), но она продолжала поддерживать лишь одну архитектуру на диске.<a l:href="#n78" type="note">[78]</a> (RFS никогда широко не использовалась и сейчас является лишь исторической сноской.)</p>
      <p>Общий дизайн Sun стал популярным и широко реализовывался в коммерческих системах Unix, включая System V Release 4. Системы Linux и BSD используют разновидность этого дизайна для поддержки множества форматов файловых систем на диске. В частности, обычным для всех разновидностей Unix на платформе Intel x86 является возможность монтирования файловых систем MS-DOS/Windows FAT, включая поддержку длинных имен, а также форматированные в соответствии с ISO 9660 CD-ROM.</p>
      <p>Linux имеет несколько собственных (т.е. размещаемых на диске) файловых систем. Наиболее популярными являются файловые системы <code>ext2</code> и <code>ext3</code>. Однако, доступно значительно больше файловых систем. Сведения о большинстве из них вы можете найти в каталоге <code>/usr/src/linux/Documentation/filesystems/</code> (если вы установили исходный код ядра). В табл. 8.1 перечислены имена различных файловых систем с кратким описанием каждой из них. Сокращение «RW» означает «чтение/запись», a «RO» означает «только чтение».</p>
      <empty-line/>
      <p><strong>Таблица 8.1</strong>. Поддерживаемые ядром файловые системы Linux (ядро 2.4.x)</p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Имя</th>
        <th align="left" valign="top">Режим</th>
        <th align="left" valign="top">Описание</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>afs</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Andrew File System (файловая система Andrew)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>adfs</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Acorn Advanced Disc Filing System (расширенная дисковая файловая система Acorn)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>affs</code></td>
        <td align="left" valign="top">RO, RW</td>
        <td align="left" valign="top">Amiga Fast File system (быстрая файловая система Amiga) Режим «только для чтения» в противоположность режиму «для записи и чтения» зависит от версии файловой системы</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>autofs</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Файловая система для взаимодействия с демоном автоматического монтирования</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>befs</code></td>
        <td align="left" valign="top">RO</td>
        <td align="left" valign="top">Файловая система BeOS. Помечена как программное обеспечение <emphasis>альфа</emphasis>.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>bfs</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">SCO UnixWare Boot File system (загрузочная файловая система SCO Unix).</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>binfmt-misc</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Специальная файловая система для запуска интерпретаторов компилированных файлов (например, файлов Java)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>efs</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Файловая система, разработанная для варианта Unix SGI, названного Irix</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>coda</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Экспериментальная распределенная файловая система, разработанная в CMU<a l:href="#n79" type="note">[79]</a></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>cramfs</code></td>
        <td align="left" valign="top">RO</td>
        <td align="left" valign="top">Небольшая файловая система для хранения файлов в постоянной памяти (ROM).</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>devfs</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Способ динамического предоставления файлов для <code>/dev</code> (устарело).</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>devpts</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Специальная файловая система для псевдотерминалов.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ext2</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Вторая расширенная файловая система. Файловая система по умолчанию для GNU/Linux, хотя некоторые дистрибутивы используют теперь <code>ext3</code>.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ext3</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Файловая система <code>ext2</code> с журналированием</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>hfs</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Hierarchical File System (иерархическая файловая система) Apple Mac OS.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>hpfs</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">High Performance File System (высокопроизводительная файловая система) OS/2.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>intermezzo</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Экспериментальная распределенная файловая система для работы в отсоединенном от сети состоянии. См веб-сайт InterMezzo (<code>http://www.inter-mezzo.org</code>)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>jffs</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Journalled Flash File system (журналируемая файловая система с групповой записью/считыванием, для встроенных систем)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>jffs2</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Journalled Flash File system 2 (тоже для встроенных систем)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>iso9660</code></td>
        <td align="left" valign="top">RO</td>
        <td align="left" valign="top">Файловая система ISO 9660 для CD-ROM. Поддерживаются также расширения Rock Ridge, заставляющие выглядеть использующие их CD-ROM как нормальная файловая система (но только для чтения).</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>jfs</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Journalled File System (журналируемая файловая система) IBM для Linux.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ncp</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Протокол Novell NCP для NetWare; клиент удаленной файловой системы.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ntfs</code></td>
        <td align="left" valign="top">RO</td>
        <td align="left" valign="top">Поддержка файловой системы NTFS Windows</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>openpromfs</code></td>
        <td align="left" valign="top">RO</td>
        <td align="left" valign="top">Файловая система <code>/proc</code> для PROM на системах SPARC</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>proc</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Доступ к информации о процессах и ядре</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>qnx4</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Файловая система QNX4 (небольшой операционной системы реального времени)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ramfs</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Файловая система для создания RAM-дисков.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>reiserfs</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Развитая журналируемая файловая система</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>romfs</code></td>
        <td align="left" valign="top">RO</td>
        <td align="left" valign="top">Файловая система для создания простых RAM-дисков только для чтения.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>smbfs</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Поддержка клиента для файловых систем SMB (разделяемых файлов Windows)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>sysv</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Файловые системы System V Release 2, Xenix, Minix и Coherent. coherent, minix и xenix являются псевдонимами</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>tmpfs</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Файловая система электронного диска, поддерживающая динамический рост.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>udf</code></td>
        <td align="left" valign="top">RO</td>
        <td align="left" valign="top">Формат файловой системы UDF, используемый в DVD-ROM</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ufs</code></td>
        <td align="left" valign="top">RO, RW</td>
        <td align="left" valign="top">Быстрая файловая система BSD, на современных системах с доступом для чтения и записи.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>umsdos</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Расширение <code>vfat</code>, заставляющее выглядеть ее подобно файловой системе Unix</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>usbfs</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Специальная файловая система для работы с устройствами USB. Первоначальным именем было <code>usbdevfs</code>, это имя до сих пор появляется, например, в выводе <code>mount</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>vfat</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Все варианты файловых систем FAT MS-DOS/Windows Компонентами являются <code>msdos</code> и <code>fat</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>vxfs</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Журналируемая файловая система Veritas VxFS.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>xfs</code></td>
        <td align="left" valign="top">RW</td>
        <td align="left" valign="top">Высокопроизводительная журналирующая файловая система, разработанная SGI для Linux. См веб-сайт XFS (<code>http://oss.sgi.com/projects/xfs/</code>)</td>
       </tr>
      </table>
      <p>Не все из этих файловых систем поддерживаются командой <code>mount</code>; список поддерживаемых см. в <emphasis>mount</emphasis>(8).</p>
      <p><emphasis>Журналирование</emphasis> является методикой, впервые использованной в системах баз данных для увеличения производительности обновлений файлов таким образом, что восстановление файловой системы в случае аварии могло быть сделано быстро и правильно. В момент написания этого были доступны несколько различных журналируемых файловых систем, конкурирующих за продвижение в мире GNU/Linux. Одной из них является <code>ext3</code>; у нее преимущество обратной совместимости с существующими файловыми системами <code>ext2</code>, очень просто конвертировать файловые системы туда-сюда между этими двумя видами (См. <emphasis>tune2fs</emphasis>(8).) ReiserFS и XFS также имеют своих твердых сторонников.</p>
      <p>Файловые системы <code>fat</code>, <code>msdos</code>, <code>umsdos</code> и <code>vfat</code> все разделяют общий исходный код. В общем, можно использовать <code>vfat</code> для монтирования разделов Windows FAT-32 (или другой FAT-xx), a <code>umsdos</code>, если нужно использовать раздел FAT в качестве корневой файловой системы для GNU/Linux.</p>
      <p>Файловые системы Coherent, MINIX, первоначальной System V и Xenix все имеют сходные структуры на диске. Тип файловой системы <code>sysv</code> поддерживает все из них; четыре имени <code>coherent</code>, <code>minix</code>, <code>sysv</code> и <code>xenix</code> являются псевдонимами один для другого. Имена <code>coherent</code> и <code>xenix</code> в конечном счете будут удалены.</p>
      <p>Быстрая файловая система BSD в течение нескольких лет успешно развилась. Файловая система <code>ufs</code> поддерживает операции чтения/записи для версий, начиная с 4.4 BSD, которая является основой для трех широко распространенных операционных систем BSD: FreeBSD, NetBSD и OpenBSD. Она поддерживает также операции чтения/записи для файловой системы Sun Solaris как для SPARC, так и для систем Intel x86. Первоначальный формат BSD и формат операционной системы NeXTStep поддерживаются в режиме только для чтения.</p>
      <p>Обозначения «RO» для <code>befs</code> и <code>ntfs</code> означают, что файловые системы этих типов можно смонтировать и читать, но в них невозможно записать файлы или удалить из них файлы. (Со временем это может измениться; проверьте документацию своей системы.) Файловые системы <code>cramfs</code>, <code>iso9660</code>, <code>romfs</code> и <code>udf</code> отмечены «RO», поскольку лежащее в их основе средство по своей сути является устройством только для чтения.</p>
      <p>Две файловые системы, которых больше не существует, это <code>ext</code>, которая была оригинальной расширенной файловой системой, и <code>xiafs</code>, которая расширяла оригинальную файловую систему MINIX для использования длинных имен и больших размеров файлов, <code>xiafs</code> и <code>ext2</code> появились примерно в одно время, но <code>ext2</code> в конечном счете стала доминирующей файловой системой.<a l:href="#n80" type="note">[80]</a></p>
     </section>
     <section>
      <title>
       <p>8.1.3. Монтирование файловых систем: <code>mount</code></p>
      </title>
      <p>Команда <code>mount</code> монтирует файловые системы, соединяя их содержимое в системную иерархию файлов в их точках монтирования. Под GNU/Linux это иногда запутано, поскольку приходится иметь дело со всеми известными типами файловых систем и их опциями. Обычно запустить <code>mount</code> может лишь <code>root</code>, хотя в некоторых случаях можно сделать исключения, как в случае, обсуждаемом далее в главе.</p>
      <p>Файловую систему вы указываете с помощью опции <code>-t</code>:</p>
      <p><code>mount [<emphasis>опции</emphasis>] <emphasis>устройство точка</emphasis>_монтирования</code></p>
      <p>Например (<code>#</code> является приглашением для <code>root</code>):</p>
      <p><code># <strong>mount -t iso9660 /dev/cdrom /mnt/cdrom</strong> /* Монтировать CD-ROM */</code></p>
      <p><code># <strong>mount -t vfat /dev/fd0 /mnt/floppy</strong> /* Монтировать гибкий диск MS-DOS */</code></p>
      <p><code># <strong>mount -t nfs files.example.com:/ /mnt/files</strong> /* Монтировать файловую систему NFS */</code></p>
      <p>Можно использовать '<code>-t auto</code>', чтобы заставить <code>mount</code> угадать тип файловой системы. Это обычно работает, хотя если вы точно знаете, каков тип файловой системы, опция '<code>-t</code>' помогает указать тип и избежать вероятности ошибочного определения файловой системы, <code>mount</code> по умолчанию угадывает нужный тип, поэтому '<code>-t auto</code>' не является абсолютно необходимым.</p>
      <p>Системы GNU/Linux предусматривают специальную разновидность монтирования посредством <emphasis>кольцевого (loopback)</emphasis> устройства. Таким способом образ файловой системы, содержащийся в обычном файле, может быть смонтирован, как если бы это было настоящее дисковое устройство. Эта возможность очень полезна, например, при использовании образов CD-ROM. Она позволяет создать образ и испытать его без необходимости прожига на болванке CD с последующим его монтированием. Следующий пример использует первый образ CD из дистрибутива GNU/Linux RedHat 9:</p>
      <p><code># <strong>ls -l shrike-i386-discl.iso</strong> /* Исследование файла образа CD */</code></p>
      <p><code>-rw-r--r-- 1 arnold devel 668991488 Apr 11 05:13 shrike-i386-discl.iso</code></p>
      <p><code># <strong>mount -t iso9660 -o ro,loop shrike-i386-discl.iso /mnt/cdrom</strong></code></p>
      <p><code>/* Смонтировать его в /mnt/cdrom */</code></p>
      <p><code># <strong>cd /mnt/cdrom</strong> /* Перейти туда */</code></p>
      <p><code># <strong>ls</strong> /* Посмотреть файлы */</code></p>
      <p><code>autorun              README.it             RELEASE-NOTES-fr.html</code></p>
      <p><code>dosutils             README.ja             RELEASE-NOTES.html</code></p>
      <p><code>EULA                 README.ko             RELEASE-NOTES-it.html</code></p>
      <p><code>GPL                  README.pt             RELEASE-NOTES-ja.html</code></p>
      <p><code>images               README.pt_BR          RELEASE-NOTES-ko.html</code></p>
      <p><code>isolinux             README.zh_CN          RELEASE-NOTES-pt_BR.html</code></p>
      <p><code>README               README.zh_TW          RELEASE-NOTES-pt.html</code></p>
      <p><code>README-Accessibility RedHat                RELEASE-NOTES-zh_CN.html</code></p>
      <p><code>README.de            RELEASE-NOTES         RELEASE-NOTES-zh_TW.html</code></p>
      <p><code>README.es            RELEASE-NOTES-de.html RPM-GPG-KEY</code></p>
      <p><code>README.fr            RELEASE-NOTES-es.html TRANS.TBL</code></p>
      <p><code># <strong>cd</strong> /* Сменить */</code></p>
      <p><code># <strong>umount /mnt/cdrom</strong> /* Демонтировать */</code></p>
      <p>Возможность монтирования таким способом образа ISO 9660 особенно полезна при тестировании сценариев, создающих образы CD. Вы можете создать образ в обычном файле, смонтировать его и проверить, что он подготовлен правильно. Затем, убедившись, что все в порядке, можно скопировать образ на записываемый CD («прожечь» CD). Возможность кольцевого устройства полезна также для монтирования образов гибких дисков</p>
     </section>
     <section>
      <title>
       <p>8.1.4. Демонтирование файловых систем: <code>umount</code></p>
      </title>
      <p>Команда <code>umount</code> демонтирует файловую систему, удаляя ее содержимое из системной иерархии файлов. Использование следующее:</p>
      <p><code>umount <emphasis>файл-или-устройство</emphasis></code></p>
      <p>Демонтируемая файловая система не должна быть <emphasis>занята</emphasis>. Это означает, что нет процессов с открытыми в файловой системе файлами и что ни у одного процесса текущий рабочий каталог не находится в этой файловой системе:</p>
      <p><code>$ <strong>mount</strong> /* Показать, что смонтировано */</code></p>
      <p><code>/dev/hda2 on / type ext3 (rw) /* / находится на настоящем устройстве */</code></p>
      <p><code>none on /proc type proc (rw)</code></p>
      <p><code>usbdevfs on /proc/bus/usb type usbdevfs (rw)</code></p>
      <p><code>/dev/hda5 on /d type ext3 (rw) /* To же c /d */</code></p>
      <p><code>none on /dev/pts type devpts (rw,gid=5,mode=620)</code></p>
      <p><code>none on /dev/shm type tmpfs (rw)</code></p>
      <p><code>none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)</code></p>
      <p><code>$ <strong>su</strong> /* Переключиться на суперпользователя */</code></p>
      <p><code>Password: /* Пароль не отображается */</code></p>
      <p><code># <strong>cd /d</strong> /* Сделать /d текущим каталогом */</code></p>
      <p><code># <strong>umount /d</strong> /* Попытка демонтировать /d */</code></p>
      <p><code>umount: /d: device is busy /* Doesn't work; it's still in use */</code></p>
      <p><code># <strong>cd /</strong> /* Сменить /d */</code></p>
      <p><code># <strong>umount /d</strong> /* Еще одна попытка демонтировать /d */</code></p>
      <p><code># /* Молчание золото: umount работает */</code></p>
     </section>
    </section>
    <section>
     <title>
      <p>8.2. Файлы для администрирования файловой системы</p>
     </title>
     <section>
      <p>Файл <code>/etc/fstab</code><a l:href="#n81" type="note">[81]</a> перечисляет файловые системы, которые могут быть смонтированы. Большинство из них монтируются автоматически, когда система загружается. Формат следующий:</p>
      <p><code><emphasis>устройство точка-монтирования тип-фс опции dump-freq fsck-pass</emphasis></code></p>
      <p>(<code><emphasis>dump-freq</emphasis></code> и <code><emphasis>fsck-pass</emphasis></code> являются административными особенностями, не относящимися к настоящему обсуждению). Например, на нашей системе файл выглядит следующим образом:</p>
      <p><code>$ <strong>cat /etc/fstab</strong></code></p>
      <p><code># device mount-point type options freq passno</code></p>
      <p><code>/dev/hda3 / ext3 defaults 1 1 /* Корневая файловая система */</code></p>
      <p><code>/dev/hda5 /d ext3 defaults 1 2</code></p>
      <p><code>none /dev/pts devpts gid=5,mode=620 0 0</code></p>
      <p><code>none /proc proc defaults 0 0</code></p>
      <p><code>none /dev/shm tmpfs defaults 0 0</code></p>
      <p><code># Windows partition:</code></p>
      <p><code>/dev/hda1 /win vfat noauto,defaults,user,uid=2076,gid=10 0 0</code></p>
      <p><code>/dev/hda3 swap swap defaults 0 0</code></p>
      <p><code>/dev/cdrom /mnt/cdrom iso9660 noauto,owner,ro 0 0 /* Монтируемый */</code></p>
      <p><code>/dev/fd0 /mnt/floppy auto noauto,owner 0 0/* Гибкий диск, то же самое */</code></p>
      <p>Разрешены комментарии, начинающиеся с <code>#</code>. Вскоре, в разделе 8.2 1 «Использование опций монтирования», будет обсуждение различных опций.</p>
      <p>Тот же самый формат файла используется для <code>/etc/mtab</code>, куда <code>mount</code> записывает информацию о файловых системах, когда они смонтированы; <code>umount</code> удаляет информацию из этого файла, когда файловая система демонтирована:</p>
      <p><code>$ <strong>cat /etc/mtab</strong></code></p>
      <p><code>/dev/hda2 / ext3 rw 0 0</code></p>
      <p><code>none /proc proc rw 0 0</code></p>
      <p><code>usbdevfs /proc/bus/usb usbdevfs rw 0 0</code></p>
      <p><code>/dev/hda5 /d ext3 rw 0 0</code></p>
      <p><code>none /dev/pts devpts rw,gid=5,mode=620 0 0</code></p>
      <p><code>none /dev/shm tmpfs rw 0 0</code></p>
      <p><code>none /proc/sys/fs/binfmt_misc binfmt_misc rw 0 0</code></p>
      <p><code>/dev/hda1 /win vfat rw,noexec,nosuid,nodev,uid=2076,gid=10,user=arnold 0 0</code></p>
      <p>Ядро делает доступным (почти) те же самые сведения в <code>/proc/mounts</code>, в том же формате:</p>
      <p><code>$ <strong>cat /proc/mounts</strong></code></p>
      <p><code>rootfs / rootfs rw 0 0</code></p>
      <p><code>/dev/root / ext3 rw 0 0</code></p>
      <p><code>/proc /proc proc rw 0 0</code></p>
      <p><code>usbdevfs /proc/bus/usb usbdevfs rw 0 0</code></p>
      <p><code>/dev/hda5 /d ext3 rw 0 0</code></p>
      <p><code>none /dev/pts devpts rw 0 0</code></p>
      <p><code>none /dev/shm tmpfs rw 0 0</code></p>
      <p><code>none /proc/sys/fs/binfmt_misc binfmt_misc rw 0 0</code></p>
      <p><code>/dev/hda1 /win vfat rw,nosuid,nodev,noexec 0 0</code></p>
      <p>Обратите внимание, что в <code>/etc/mtab</code> есть некоторые сведения, которые отсутствуют в <code>/proc/mounts</code>. (Например, см. строку для точки монтирования <code>/win</code>.) С другой стороны, возможно (используя '<code>mount -f</code>') помещать в <code>/etc/mtab</code> элементы, которые не являются настоящими (эта практика имеет свое применение, см. <emphasis>mount</emphasis>(8)). Подводя итог, <code>/proc/mounts</code> всегда описывает, что смонтировано в действительности; однако, <code>/etc/mtab</code> содержит сведения об опциях <code>mount</code>, которых нет в <code>/proc/mounts</code>. Поэтому, чтобы получить полную картину, вам может понадобиться прочесть <emphasis>оба</emphasis> файла</p>
     </section>
     <section>
      <title>
       <p>8.2.1. Использование опций монтирования</p>
      </title>
      <p>Команда <code>mount</code> поддерживает опции, которые контролируют то, какие операции ядро будет позволять или не позволять применять к файловой системе. Их приличное количество. Лишь две из них полезны на самом деле в командной строке:</p>
      <p><code>ro</code></p>
      <p>Монтирует файловую систему только для чтения. Это необходимо для устройств только для чтения, таких, как CD-ROM и DVD.</p>
      <p><code>loop</code></p>
      <p>Использует кольцевое устройство для интерпретации обычного файла в качестве файловой системы. Пример этого мы показали ранее (см. раздел 8.1.3 «Монтирование файловых систем: <code>mount</code>»).</p>
      <p>Опции передаются с опцией командной строки -о и могут группироваться, отделяясь запятыми. Например, вот использованная ранее командная строка:</p>
      <p><code>mount -t iso9660 -о ro,loop shrike-i386-discl.iso /mnt/cdrom</code></p>
      <p>Оставшиеся опции предназначены для использования в <code>/etc/fstab</code> (хотя они могут использоваться также и в командной строке). Следующий список представляет те опции, которые, как мы полагаем, наиболее важны в повседневном использовании.</p>
      <p><code>auto</code>, <code>noauto</code></p>
      <p>Файловые системы, помеченные <code>auto</code>, должны монтироваться при загрузке системы через '<code>mount -а</code>' (монтировать все файловые системы). Файловые системы <code>noauto</code> должны монтироваться вручную. Они по-прежнему находятся в <code>/etc/fstab</code> вместе с другими файловыми системами. (См., например, элемент <code>/win</code> для показанного ранее файла <code>/etc/fstab</code>).</p>
      <p><code>defaults</code></p>
      <p>Использует по умолчанию опции <code>rw</code>, <code>suid</code>, <code>dev</code>, <code>exec</code>, <code>auto</code>, <code>nouser</code> и <code>async</code>. (<code>async</code> является продвинутой опцией, повышающей производительность ввода/вывода).</p>
      <p><code>dev</code>, <code>nodev</code></p>
      <p>Позволяет (не позволяет) использовать в файловой системе файлы символьных или блочных устройств.</p>
      <p><code>exec</code>, <code>noexec</code></p>
      <p>Позволяет (не позволяет) запускать в файловой системе двоичные исполняемые файлы.</p>
      <p><code>user</code>, <code>nouser</code></p>
      <p>Позволяет (не позволяет) монтировать данную файловую систему любому пользователю. Это полезно для CD-ROM; даже если вы находитесь на рабочей станции с одним пользователем, удобно не переключаться на <code>root</code> просто для монтирования CD. Демонтировать файловую систему может лишь пользователь, который смонтировал ее. <code>user</code> предполагает наличие опций <code>noexec</code>, <code>nosuid</code> и <code>nodev</code>.</p>
      <p><code>suid</code>, <code>nosuid</code></p>
      <p>Поддерживает (не поддерживает) биты <code>setuid</code> и <code>setgid</code> исполняемых файлов в файловой системе.</p>
      <p><code>rw</code></p>
      <p>Монтирует файловую систему в режиме для чтения/записи.</p>
      <p>Опции <code>nodev</code>, <code>noexec</code> и <code>nosuid</code> особенно ценны для безопасности на файловых системах гибких дисков и CD-ROM. Рассмотрите студенческую среду, в которой студентам разрешено монтировать собственные гибкие диски или CD. Тривиально смастерить для жесткого диска файловую систему с оболочкой setuid-root или с файлом устройства с разрешением записи для всех, которая позволила бы предприимчивому пользователю изменить права доступа к системным файлам.</p>
      <p>У каждой файловой системы есть специфичные для нее опции. Важной опцией для <code>ext2</code> и <code>ext3</code> является <code>grpid</code>. Мы отложим обсуждение этой опции до раздела 11.5.1 «Группа по умолчанию для новых файлов и каталогов». Подробности для всех поддерживаемых файловых систем можно найти в справочной странице <emphasis>mount</emphasis>(8).</p>
      <p>В качестве конкретного примера вернемся к строчке для раздела Windows в нашей системе:</p>
      <p><code># device mount-point type options freq passno</code></p>
      <p><code>/dev/hda1 /win vfat noauto,defaults,user,uid=2076,gid=10 0 0</code></p>
      <p>Опция <code>noauto</code> предотвращает монтирование раздела Windows при загрузке. Опция <code>defaults</code> та же самая, что <code>rw</code>, <code>suid</code>, <code>dev</code>, <code>exec</code>, <code>async</code>. Опция <code>user</code> позволяет нам монтировать файловую систему, не будучи <code>root</code>. Опции <code>uid=</code> и <code>gid=</code> делает файлы в <code>/win</code> принадлежащими нам, так что нам не нужно иметь права <code>root</code> при работе с этим разделом.</p>
     </section>
     <section>
      <title>
       <p>8.2.2. Работа со смонтированными файловыми системами: <code>getmntent()</code></p>
      </title>
      <p>Любой из файлов <code>/etc/fstab</code>, <code>/etc/mtab</code> и <code>/proc/mounts</code> может быть прочитан программное использованием набора процедур <code>getmntent()</code>:</p>
      <p><code>#include &lt;stdio.h&gt; /* GLIBC */</code></p>
      <p><code>#include &lt;mntent.h&gt;</code></p>
      <empty-line/>
      <p><code>FILE *setmntent(const char *filename, const char *type);</code></p>
      <p><code>struct mntent *getmntent(FILE *filep);</code></p>
      <p><code>int addmntent(FILE *filep, const struct mntent *mnt);</code></p>
      <p><code>int endmntent(FILE *filep);</code></p>
      <p><code>char *hasmntopt(const struct mntent *mnt, const char *opt);</code></p>
      <p><code>setmntent()</code> открывает файл, содержащий элементы точек монтирования. Аргумент <code>filename</code> является файлом, который должен быть открыт. Аргумент <code>type</code> похож на второй аргумент <code>fopen()</code>, указывая доступ для чтения, записи или чтения/записи. (Рассмотрите команду <code>mount</code>, которой приходится добавлять элемент к <code>/etc/mtab</code> для каждой файловой системы, которую она монтирует, и <code>umount</code>, которая должна удалять этот элемент.) Затем возвращаемое значение типа <code>FILE*</code> используется с оставшимися процедурами.</p>
      <p><code>getmntent()</code> читает файл, возвращая указатель на <code>static struct mntent</code>, которая заполнена соответствующими значениями. Это статическое хранилище переписывается при каждом вызове. Когда больше не осталось элементов, она возвращает <code>NULL</code>. (Это сходно с процедурами для чтения файлов паролей и групп; см раздел 6.3 «Имена пользователей и групп».)</p>
      <p><code>addmntent()</code> вызывается для добавления сведений в конец открытого файла, она предназначена для использования функцией <code>mount</code>.</p>
      <p><code>endmntent()</code> закрывает открытый файл; вызывайте ее после завершения обработки. <emphasis>Не</emphasis> вызывайте просто <code>fclose()</code>; может потребоваться очистить другие внутренние структуры данных, связанные с переменной <code>FILE*</code>.</p>
      <p><code>hasmntopt()</code> является более специализированной функцией. Она просматривает <code>struct mntent</code>, переданную в качестве первого параметра, в поисках опции <code>mount</code>, совпадающей со вторым аргументом. Если опция найдена, она возвращает адрес совпадающей подстроки. В противном случае возвращается <code>NULL</code>.</p>
      <p>Поля в <code>struct mntent</code> непосредственно соответствуют полям в файле <code>/etc/fstab</code>. Структура выглядит следующим образом:</p>
      <p><code>struct mntent {</code></p>
      <p><code> char *mnt_fsname; /* Устройство или сервер для файл. С-мы. */</code></p>
      <p><code> char *mnt_dir;    /* Каталог для монтирования. */</code></p>
      <p><code> char *mnt_type;   /* Тип файловой системы: ufs, nfs и т.д. */</code></p>
      <p><code> char *mnt_opts;   /* Отделяемые запятыми опции для fs. */</code></p>
      <p><code> int mnt_freq;     /* Частота дампа (в днях). */</code></p>
      <p><code> int mnt_passno;    /* Номер для 'fsck'. */</code></p>
      <p><code>};</code></p>
      <p>Обычным принципом работы со смонтированными файловыми системами является создание внешнего цикла, читающего <code>/etc/mtab</code>, обрабатывая по одной <code>struct mntent</code> за раз. Наш первый пример, <code>ch08-mounted.c</code>, делает именно это:</p>
      <p><code>1  /* ch08-mounted.с --- вывод списка смонтированных файловых</code></p>
      <p><code>2     систем */</code></p>
      <p><code>3  /* ЗАМЕЧАНИЕ: специфично для GNU/Linux! */</code></p>
      <p><code>4</code> </p>
      <p><code>5  #include &lt;stdio.h&gt;</code></p>
      <p><code>6  #include &lt;errno.h&gt;</code></p>
      <p><code>7  #include &lt;mntent.h&gt; /* для getmntent() и др. */</code></p>
      <p><code>8  #include &lt;unistd.h&gt; /* для getopt() */</code></p>
      <p><code>9</code></p>
      <p><code>10 void process(const char *filename);</code></p>
      <p><code>11 void print_mount(const struct mntent *fs);</code></p>
      <p><code>12</code></p>
      <p><code>13 char *myname;</code></p>
      <p><code>14</code></p>
      <p><code>15 /* main --- обработка опций */</code></p>
      <p><code>16</code></p>
      <p><code>17 int main(int argc, char **argv)</code></p>
      <p><code>18 {</code></p>
      <p><code>19  int c;</code></p>
      <p><code>20  char *file = "/etc/mtab"; /* файл по умолчанию для чтения */</code></p>
      <p><code>21</code></p>
      <p><code>22  myname = argv[0];</code></p>
      <p><code>23  while ((c = getopt(argc, argv, "f:")) != -1) {</code></p>
      <p><code>24   switch (c) {</code></p>
      <p><code>25   case 'f':</code></p>
      <p><code>26    file = optarg;</code></p>
      <p><code>27    break;</code></p>
      <p><code>28   default:</code></p>
      <p><code>29    fprintf(stderr, "usage: %s [-f fstab-file]\n", argv[0]);</code></p>
      <p><code>30    exit(1);</code></p>
      <p><code>31   }</code></p>
      <p><code>32  }</code></p>
      <p><code>33</code></p>
      <p><code>34  process(file);</code></p>
      <p><code>35  return 0;</code></p>
      <p><code>36 }</code></p>
      <p><code>37</code></p>
      <p><code>38 /* process --- прочесть структуры struct mntent из файла */</code></p>
      <p><code>39</code></p>
      <p><code>40 void process(const char *filename)</code></p>
      <p><code>41 {</code></p>
      <p><code>42  FILE *fp;</code></p>
      <p><code>43  struct mntent *fs;</code></p>
      <p><code>44</code></p>
      <p><code>45  fp = setmntent(filename, "r"); /* только для чтения */</code></p>
      <p><code>46  if (fp == NULL) {</code></p>
      <p><code>47   fprintf(stderr, "%s: %s: could not open: %s\n",</code></p>
      <p><code>48    myname, filename, strerror(errno));</code></p>
      <p><code>49   exit(1);</code></p>
      <p><code>50  }</code></p>
      <p><code>51</code></p>
      <p><code>52  while ((fs = getmntent(fp)) != NULL)</code></p>
      <p><code>53   print_mount(fs);</code></p>
      <p><code>54</code></p>
      <p><code>55  endmntent(fp);</code></p>
      <p><code>56 }</code></p>
      <p><code>57</code></p>
      <p><code>58 /* print_mount --- вывод одного смонтированного элемента */</code></p>
      <p><code>59</code></p>
      <p><code>60 void print_mount(const struct mntent *fs)</code></p>
      <p><code>61 {</code></p>
      <p><code>62  printf("%s %s %s %s %d %d\n",</code></p>
      <p><code>63   fs-&gt;mnt_fsname,</code></p>
      <p><code>64   fs-&gt;mnt_dir,</code></p>
      <p><code>65   fs-&gt;mnt_type,</code></p>
      <p><code>66   fs-&gt;mnt_opts,</code></p>
      <p><code>67   fs-&gt;mnt_freq,</code></p>
      <p><code>68   fs-&gt;mnt_passno);</code></p>
      <p><code>69 }</code></p>
      <p>В отличие от большинства программ, которые мы до сих пор видели, эта специфична для Linux. Во многих Unix-системах есть схожие процедуры, но их идентичность не гарантируется.</p>
      <p>По умолчанию, <code>ch08-mounted</code> читает <code>/etc/mtab</code>, выводя сведения о каждой смонтированной файловой системе. Опция <code>-f</code> позволяет указать другой файл для чтения, такой, как <code>/proc/mounts</code> или даже <code>/etc/fstab</code>.</p>
      <p>Функция <code>main()</code> обрабатывает командную строку (строки 23–32) и вызывает для указанного файла <code>process()</code>. (Эта программа следует нашему стандартному шаблону.)</p>
      <p><code>process()</code>, в свою очередь, открывает файл (строка 45) и проходит в цикле через каждую возвращённую файловую систему (строки 52–53). После завершения она закрывает файл (строка 55).</p>
      <p>Функция <code>print_mount()</code> выводит информацию из <code>struct mnent</code>. Вывод во многом напоминает вывод '<code>cat /etc/mtab</code>':</p>
      <p><code>$ <strong>ch08-mounted</strong> /* Запуск программы */</code></p>
      <p><code>/dev/hda2 / ext3 rw 0 0</code></p>
      <p><code>none /proc proc rw 0 0</code></p>
      <p><code>usbdevfs /proc/bus/usb usbdevfs rw 0 0</code></p>
      <p><code>/dev/hda5 /d ext3 rw 0 0</code></p>
      <p><code>none /dev/pts devpts rw,gid=5,mode=620 0 0</code></p>
      <p><code>none /dev/shm tmpfs rw 0 0</code></p>
      <p><code>none /proc/sys/fs/binfmt_misc binfmt_misc rw 0 0</code></p>
      <p><code>/dev/hda1 /win vfat rw,noexec,nosuid,nodev,uid=2076,gid=10,user=arnold 0 0</code></p>
     </section>
    </section>
    <section>
     <title>
      <p>8.3. Получение сведений о файловой системе</p>
     </title>
     <section>
      <p>Вывод сведений о файловой системе, рассмотренный ранее — это хорошо и замечательно, но это не захватывает. Раз мы знаем, что определенная точка монтирования представляет файловую систему, нам нужны сведения о файловой системе. Это даст нам возможность выводить вещи наподобие сведений, полученных с помощью <code>df</code> и '<code>df -i</code>'.</p>
      <p><code>$ <strong>df</strong> /* Показать свободное/используемое пространство */</code></p>
      <p><code>Filesystem 1K-blocks Used Available Use% Mounted on</code></p>
      <p><code>/dev/hda2 6198436 4940316 943248 84% /</code></p>
      <p><code>/dev/hda5 61431520 27618536 30692360 48% /d</code></p>
      <p><code>none 256616 0 256616 0% /dev/shm</code></p>
      <p><code>/dev/hda1 8369532 2784700 5584832 34% /win</code></p>
      <p><code>$ <strong>df -i</strong> /* Показать свободные/используемые индексы */</code></p>
      <p><code>Filesystem Inodes IUsed IFree IUse% Mounted on</code></p>
      <p><code>/dev/hda2 788704 233216 555488 30% /</code></p>
      <p><code>/dev/hda5 7815168 503243 7311925 7% /d</code></p>
      <p><code>none 64154 1 64153 1% /dev/shm</code></p>
      <p><code>/dev/hda1 0 0 0 - /win</code></p>
     </section>
     <section>
      <title>
       <p>8.3.1. Стиль POSIX: <code>statvfs()</code> и <code>fstatvfs()</code></p>
      </title>
      <p>На ранних системах Unix была только одна разновидность файловой системы. Для них было достаточно, если <code>df</code> считывала суперблок каждой смонтированной файловой системы, извлекала значимые сведения и красиво форматировала их для отображения. (Суперблок обычно был вторым блоком в файловой системе; первым был <emphasis>загрузочный блок</emphasis>, содержащий загрузочный код).</p>
      <p>Однако в современном мире такой подход был бы непригодным. POSIX предоставляет расширение XSI для получения доступа к этой информации. Главная функция называется <code>statvfs()</code> («vfs» часть происходит от лежащей в основе технологии SunOS, использованной позже в System V Release 4, которая называется <emphasis>виртуальной файловой системой</emphasis>.) Имеется две функции:</p>
      <p><code>#include &lt;sys/types.h&gt; /* XSI */</code></p>
      <p><code>#include &lt;sys/statvfs.h&gt;</code></p>
      <empty-line/>
      <p><code>int statvfs(const char *path, struct statvfs *buf);</code></p>
      <p><code>int fstatvfs(int fd, struct statvfs *buf);</code></p>
      <p><code>statvfs()</code> использует для любого файла имя пути; она возвращает сведения о файловой системе, содержащей файл. <code>fstatvfs()</code> принимает в качестве первою аргумента дескриптор открытого файла, здесь также возвращается информация о файловой системе, содержащей открытый файл, <code>struct statvfs</code> содержит следующие члены:</p>
      <p><code>struct statvfs {</code></p>
      <p><code> unsigned long int f_bsize;   /* Размер блока */</code></p>
      <p><code> unsigned long int f_frsize;</code></p>
      <p><code>  /* Размер фрагмента («основной размер блока») */</code></p>
      <p><code> fsblkcnt_t f_blocks;         /* Общее число блоков */</code></p>
      <p><code> fsblkcnt_t f_bfree;          /* Общее число свободных блоков */</code></p>
      <p><code> fsblkcnt_t f_bavail;         /* Число доступных блоков (&#8804;f_bfree) */</code></p>
      <p><code> fsfilcnt_t f_files;          /* Общее число индексов */</code></p>
      <p><code> fsfilcnt_t f_ffree;          /* Общее число свободных индексов */</code></p>
      <p><code> fsfilcnt_t f_favail;         /* Число доступных индексов (&#8804;f_files) */</code></p>
      <p><code> unsigned long int f_fsid;    /* ID файловой системы */</code></p>
      <p><code> unsigned long int f_flag;    /* Флаги: ST_RDONLY и/или ST_NOSUID */</code></p>
      <p><code> unsigned long int f_namemax; /* Максимальная длина имени файла */</code></p>
      <p><code>};</code></p>
      <p>Сведений, которые в ней содержатся, достаточно для написания <code>df</code>:</p>
      <p><code>unsigned long int f_bsize</code></p>
      <p>Размер блока является предпочтительным размером для осуществления ввода/вывода. Файловая система пытается хранить по крайней мере <code>f_bsize</code> байтов стоящих данных в смежных секторах на диске. (<emphasis>Сектор</emphasis> является наименьшим количеством адресуемых данных на диске. Обычно дисковый сектор равен 512 байтам.)</p>
      <p><code>unsigned long int f_frsize</code></p>
      <p>Некоторые файловые системы (такие, как BSD Fast Filesystem) проводят различие между блоками и <emphasis>фрагментами</emphasis> блоков. Небольшие файлы, общий размер которых меньше размера блока, находятся в некотором числе фрагментов. Это позволяет избежать пустой потери дискового пространства (за счет допустимой цепы большей сложности кода ядра). Размер фрагмента выбирается во время создания файловой системы.</p>
      <p><code>fsblkcnt_t f_blocks</code></p>
      <p>Общее число блоков (в единицах <code>f_bsize</code>) в файловой системе.</p>
      <p><code>fsblkcnt_t f_bfree</code></p>
      <p>Общее число свободных блоков в файловой системе.</p>
      <p><code>fsblkcnt_t f_bavail</code></p>
      <p>Число блоков, которые действительно могут использоваться. Некоторые файловые системы резервируют часть блоков файловой системы для использования суперпользователем при заполнении файловой системы. Современные системы резервируют около 5 процентов, хотя это число может быть изменено администратором. (См. <emphasis>tune2fs</emphasis>(8) на системе GNU/Linux и <emphasis>tunefs</emphasis>(8) на системах Unix.)</p>
      <p><code>fsfilcnt_t f_files</code></p>
      <p>Общее число индексов («порядковых номеров файлов» на языке POSIX) в файловой системе. Это число обычно инициализируется и делается постоянным при создании файловой системы.</p>
      <p><code>fsfilcnt_t f_ffree</code></p>
      <p>Общее число свободных узлов.</p>
      <p><code>fsfilcnt_t f_favail</code></p>
      <p>Число индексов, которые действительно могут быть использованы. Некоторая часть индексов резервируются для суперпользователя, точно так же, как для блоков.</p>
      <p><code>unsigned long int f_fsid</code></p>
      <p>ID файловой системы. POSIX не определяет, что оно представляет, и это под Linux не используется.</p>
      <p><code>unsigned long int f_flag</code></p>
      <p>Флаги, дающие информацию о файловой системе. POSIX определяет два флага: <code>ST_RDONLY</code> для файловых систем только для чтения (таких, как CD-ROM) и <code>ST_NOSUID</code>, который запрещает использование битов setuid и setgid в исполняемых файлах. Системы GNU/Linux предусматривают дополнительные флаги: они перечислены в табл. 8.2.</p>
      <empty-line/>
      <p><strong>Таблица 8.2</strong>. Значения GLIBC для <code>f_flag</code></p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Флаг</th>
        <th align="left" valign="top">POSIX</th>
        <th align="left" valign="top">Значение</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ST_MANDLOCK</code></td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">Осуществляет принудительное блокирование (см. раздел 14.2).</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ST_NOATIME</code></td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">Не обновлять при каждом доступе время доступа</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ST_NODEV</code></td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">Запрещает доступ через файлы устройств</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ST_NODIRATIME</code></td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">Не обновлять поле времени доступе каталогов</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ST_NOEXEC</code></td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">Запрещает исполнение двоичных файлов</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ST_NOSUID</code></td>
        <td align="left" valign="top">&#8730;</td>
        <td align="left" valign="top">Файловая система запрещает использование битов setuid и setgid.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ST_RDONLY</code></td>
        <td align="left" valign="top">&#8730;</td>
        <td align="left" valign="top">Файловая система только для чтения.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ST_SYNCHRONOUS</code></td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">Любая запись осуществляется синхронно (см. раздел 4.6.3).</td>
       </tr>
      </table>
      <empty-line/>
      <p><code>unsigned long int f_namemax</code></p>
      <p>Максимальная длина имени файла. Это относится к каждому отдельному компоненту в имени пути; другими словами, максимальная длина для элемента каталога</p>
      <p>Типы <code>fsblkcnt_t</code> и <code>fsfilcnt_t</code> определены в <code>&lt;sys/types.h&gt;</code>. Они обычно являются <code>unsigned long</code>, но на современных системах они могут быть даже 64-разрядными, поскольку диски стали очень большими. Следующая программа, <code>ch08-statvfs.c</code>, показывает, как использовать <code>statvfs()</code>:</p>
      <p><code>1  /* ch08-statvfs.с --- демонстрация statvfs */</code></p>
      <p><code>2</code></p>
      <p><code>3  /* ЗАМЕЧАНИЕ: специфично для GNU/Linux! */</code></p>
      <p><code>4</code></p>
      <p><code>5  #include &lt;stdio.h&gt;</code></p>
      <p><code>6  #include &lt;errno.h&gt;</code></p>
      <p><code>7  #include &lt;mntent.h&gt; /* для getmntent(), et al. */</code></p>
      <p><code>8  #include &lt;unistd.h&gt; /* для getopt() */</code></p>
      <p><code>9  #include &lt;sys/types.h&gt;</code></p>
      <p><code>10 #include &lt;sys/statvfs.h&gt;</code></p>
      <p><code>11</code> </p>
      <p><code>12 void process(const char *filename);</code></p>
      <p><code>13 void do_statvfs(const struct mntent *fs);</code></p>
      <p><code>14</code></p>
      <p><code>15 int errors = 0;</code></p>
      <p><code>16 char *myname;</code></p>
      <p><code>17</code> </p>
      <p><code>18 /* main --- обработка опций */</code></p>
      <p><code>19</code> </p>
      <p><code>20 int main(int argc, char **argv)</code></p>
      <p><code>21 {</code></p>
      <p><code>22  int c;</code></p>
      <p><code>23  char *file = "/etc/mtab"; /* файл для чтения по умолчанию */</code></p>
      <p><code>24</code></p>
      <p><code>25  myname = argv[0];</code></p>
      <p><code>26  while ((c = getopt(argc, argv, "f:")) != -1) {</code></p>
      <p><code>27   switch (c) {</code></p>
      <p><code>28   case 'f':</code></p>
      <p><code>29    file = optarg;</code></p>
      <p><code>30    break;</code></p>
      <p><code>31   default:</code></p>
      <p><code>32    fprintf(stderr, "usage: %s [-f fstab-file]\n", argv[0]);</code></p>
      <p><code>33    exit(1);</code></p>
      <p><code>34   }</code></p>
      <p><code>35  }</code></p>
      <p><code>36</code></p>
      <p><code>37  process(file);</code></p>
      <p><code>38  return (errors != 0);</code></p>
      <p><code>39 }</code></p>
      <p><code>40</code></p>
      <p><code>41 /* process --- чтение структур struct mntent из файла */</code></p>
      <p><code>42</code></p>
      <p><code>43 void process(const char *filename)</code></p>
      <p><code>44 {</code></p>
      <p><code>45  FILE* fp;</code></p>
      <p><code>46  struct mntent *fs;</code></p>
      <p><code>47</code></p>
      <p><code>48  fp = setmntent(filename, "r"); /* только для чтения */</code></p>
      <p><code>49  if (fp == NULL) {</code></p>
      <p><code>50   fprintf(stderr, "%s: %s: could not open: %s\n",</code></p>
      <p><code>51    myname, filename, strerror(errno));</code></p>
      <p><code>52   exit(1);</code></p>
      <p><code>53  }</code></p>
      <p><code>54</code></p>
      <p><code>55  while ((fs = getmntent(fp)) != NULL)</code></p>
      <p><code>56   do_statvfs(fs);</code></p>
      <p><code>57</code></p>
      <p><code>58  endmntent(fp);</code></p>
      <p><code>59 }</code></p>
      <p>Строки 1–59 в сущности те же самые, как и для <code>ch08-mounted.c</code>. <code>main()</code> обрабатывает командную стоку, a <code>process()</code> просматривает в цикле каждую смонтированную файловую систему. <code>do_statvfs()</code> осуществляет действительную работу, выводя для каждой интересующей файловой системы <code>struct statvfs</code>.</p>
      <p><code>61  /* do_statvfs --- Использовать statvfs и вывести сведения */</code></p>
      <p><code>62</code></p>
      <p><code>63  void do_statvfs(const struct mntent *fs)</code></p>
      <p><code>64  {</code></p>
      <p><code>65   struct statvfs vfs;</code></p>
      <p><code>66</code></p>
      <p><code>67   if (fs-&gt;mnt_fsname[0] != '/') /* пропустить ненастоящие файловые системы */</code></p>
      <p><code>68    return;</code></p>
      <p><code>69</code></p>
      <p><code>70   if (statvfs(fs-&gt;mnt_dir, &amp;vfs) != 0) {</code></p>
      <p><code>71    fprintf(stderr, "%s: %s: statvfs failed: %s\n",</code></p>
      <p><code>72     myname, fs-&gt;mnt_dir, strerror(errno));</code></p>
      <p><code>73    errors++;</code></p>
      <p><code>74    return;</code></p>
      <p><code>75   }</code></p>
      <p><code>76</code></p>
      <p><code>77   printf("%s, mounted on %s:\n", fs-&gt;mnt_dir, fs-&gt;mnt_fsname);</code></p>
      <p><code>78   printf("\tf_bsize: %ld\n", (long)vfs.f_bsize);</code></p>
      <p><code>79   printf("\tf_frsize: %ld\n", (long)vfs.f_frsize);</code></p>
      <p><code>80   printf("\tf_blocks: %lu\n", (unsigned long)vfs.f_blocks);</code></p>
      <p><code>81   printf("\tf_bfree: %lu\n", (unsigned long)vfs.f_bfree);</code></p>
      <p><code>82   printf("\tf_bavail: %lu\n", (unsigned long)vfs.f_bavail);</code></p>
      <p><code>83   printf("\tf_files: %lu\n", (unsigned long)vfs.f_files);</code></p>
      <p><code>84   printf("\tf_ffree: %lu\n", (unsigned long)vfs.f_ffree);</code></p>
      <p><code>85   printf("\tf_favail: %lu\n", (unsigned long)vfs.f_favail);</code></p>
      <p><code>86   printf("\tf_fsid: %#lx\n", (unsigned long)vfs.f_fsid);</code></p>
      <p><code>87</code></p>
      <p><code>88   printf("\tf_flag: ");</code></p>
      <p><code>89   if (vfs.f_flag == 0)</code></p>
      <p><code>90    printf("(none)\n");</code></p>
      <p><code>91   else {</code></p>
      <p><code>92    if ((vfs.f_flag &amp; ST_RDONLY) != 0)</code></p>
      <p><code>93     printf("ST_RDONLY ");</code></p>
      <p><code>94    if ((vfs.f_flag &amp; ST_NOSUID) != 0)</code></p>
      <p><code>95     printf("ST_NOSUID");</code></p>
      <p><code>96    printf("\n");</code></p>
      <p><code>97   }</code></p>
      <p><code>98</code></p>
      <p><code>99   printf("\tf_namemax: %#ld\n", (long)vfs.f_namemax);</code></p>
      <p><code>100 }</code></p>
      <p>Строки 67–68 пропускают файловые системы, которые не основываются на реальных дисковых устройствах. Это означает, что файловые системы типа <code>/proc</code> или <code>/dev/pts</code> игнорируются. (Правда, эта проверка эвристическая, но она работает: в <code>/etc/mtab</code> смонтированные устройства перечислены по полному пути устройства: например, <code>/dev/hda1</code>.) Строка 70 вызывает <code>statvfs()</code> с соответствующей проверкой ошибок, а строки 77-99 выводят сведения.</p>
      <p>Строки 89–96 имеют дело с <emphasis>флагами</emphasis>: отдельные биты информации, которые присутствуют или не присутствуют. Обсуждение того, как биты флагов используются в коде С, см. во врезке. Вот вывод <code>ch08-statvfs</code>:</p>
      <p><code>$ <strong>ch08-statvfs</strong> /* Запуск программы */</code></p>
      <p><code>/, mounted on /dev/hda2: /* Результаты для файловой системы ext2 */</code></p>
      <p><code>f_bsize: 4096</code></p>
      <p><code>f_frsize: 4096</code></p>
      <p><code>f_blocks: 1549609</code></p>
      <p><code>f_bfree: 316663</code></p>
      <p><code>f_bavail: 237945</code></p>
      <p><code>f_files: 788704</code></p>
      <p><code>f_ffree: 555482</code></p>
      <p><code>f_favail: 555482</code></p>
      <p><code>f_fsid: 0</code></p>
      <p><code>f_flag: (none)</code></p>
      <p><code>f_namemax: 255</code></p>
      <p><code>...</code></p>
      <p><code>/win, mounted on /dev/hda1: /* Результаты для файл. системы vfat */</code></p>
      <p><code>f_bsize: 4096</code></p>
      <p><code>f_frsize: 4096</code></p>
      <p><code>f_blocks: 2092383</code></p>
      <p><code>f_bfree: 1391952</code></p>
      <p><code>f_bavail: 1391952</code></p>
      <p><code>f_files: 0</code></p>
      <p><code>f_ffree: 0</code></p>
      <p><code>f_favail: 0</code></p>
      <p><code>f_fsid: 0</code></p>
      <p><code>f_flag: ST_NOSUID</code></p>
      <p><code>f_namemax: 260</code></p>
      <p>Во время написания этого, для GLIBC 2.3.2 и ранее, GNU <code>df</code> не использует <code>statvfs()</code>. Это потому, что код читает <code>/etc/mtab</code> и вызывает <code>stat()</code> для каждой смонтированной файловой системы, чтобы найти ту, номер устройства которой совпадает с соответствующим аргументом для файла (или дескриптора файла). Для того, чтобы прочесть опции монтирования, коду нужно найти файловую систему, поэтому он может установить биты <code>f_flag</code>. Проблема в том, что <code>stat()</code> на смонтированной удаленной файловой системе, сервер которой недоступен, может висеть неопределенно долго, вызвав также зависание <code>df</code>. С тех пор эта проблема в GLIBC была исправлена, но <code>df</code> не будет изменяться в течение некоторого времени, так что она сможет продолжать работать на более старых системах.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Хотя POSIX определяет <code>statvfs()</code> и <code>fstatvfs()</code>, не все системы их поддерживают или поддерживают корректно. Многие системы (включая Linux, как вскоре будет описано), имеют свои собственные системные вызовы, предоставляющие сходную информацию. GNU <code>df</code> использует библиотечную процедуру для получения сведений о файловой системе; исходный файл для этой процедуры наполнен <code>#ifdef</code> для большого числа различных систем. Со временем ситуация с переносимостью должна улучшиться.</p>
      </cite>
      <cite>
       <subtitle>Битовые флаги</subtitle>
       <p>Обычной методикой, применимой во многих случаях, является использование набора значений <emphasis>флагов</emphasis>; когда флаг <emphasis>установлен</emphasis> (т.е. true), имеет место некоторый факт или применяется некоторое условие. Значения флагов определены либо через именованные константы <code>#define</code>, либо через перечисления. В данной главе API <code>nftw()</code> (описанный далее) также использует флаги. Для поля <code>f_flag</code> структуры <code>struct statvfs</code> есть только два флага:</p>
       <p><code>#define ST_RDONLY 1 /* файловая система только для чтения */</code></p>
       <p><code>#define ST_NOSUID 2 /* setuid/setgid не разрешены */</code></p>
       <p>Физически каждая именованная константа представляет различные позиции битов в значении <code>f_flag</code>. Логически каждое значение представляет отдельный бит информации о состоянии; т.е. некоторый факт или условие, которое является или не является истинным для данного конкретного экземпляра <code>struct statvfs</code>.</p>
       <p>Флаги устанавливаются, проверяются и очищаются с помощью побитовых операторов С. Например, <code>statvfs()</code> устанавливает эти флаги, используя побитовый оператор ИЛИ:</p>
       <p><code>int statvfs(const char *path, struct statvfs *vfs) {</code></p>
       <p><code> /* заполнить большую часть *vfs */</code></p>
       <p><code> vfs-&gt;f_flag = 0; /* Убедиться, что начинается с нуля */</code></p>
       <p><code> if (<emphasis>файловая система только для чтения</emphasis>)</code></p>
       <p><code>  vfs-&gt;f_flag |= ST_RDONLY; /* Добавить флаг ST_RDONLY */</code></p>
       <p><code> if (<emphasis>файловая система запрещает setuid</emphasis>)</code></p>
       <p><code>  vfs-&gt;f_flag |= ST_NOSUID; /* Добавить флаг ST_NOSUID */</code></p>
       <p><code> /* оставшаяся часть процедуры */</code></p>
       <p><code>}</code></p>
       <p>Побитовый оператор И проверяет, установлен ли флаг, а сочетание побитовых операторов И и дополнения очищает флаг:</p>
       <p><code>if ((vfs.f_flag &amp; ST_RDONLY) != 0) /* True, если флаг ST_RDONLY */</code></p>
       <p><code> vfs.f_flag &amp;= ~(ST_RDONLY|ST_NOSUID); /* Очистить оба флага */</code></p>
       <p>Побитовые операторы отпугивают, если вы не использовали их ранее. Однако, только что показанный код примера представляет обычный стиль С. Тщательно изучите каждую операцию; возможно, нарисуйте себе несколько картин, показывающих работу этих операторов. Однажды разобравшись с ними, вы можете тренировать себя, распознавая эти операторы как <emphasis>высокоуровневые операции для управления значениями флагов</emphasis> вместо их трактовки как <emphasis>низкоуровневых манипуляций с битами</emphasis>.</p>
       <p>Причина использования флагов кроется в том, что они обеспечивают значительную экономию пространства данных. Одно поле <code>unsigned long</code> дает возможность хранить по меньшей мере 32 отдельных бита информации. GLIBC (на момент написания) определяет 11 различных флагов для поля <code>f_flag</code>.<a l:href="#n82" type="note">[82]</a> Если бы вы использовали для каждого флага отдельно поле <code>char</code>, это потребовало бы использования 11 байтов вместо четырех, используемых <code>unsigned long</code>. Если бы у вас было 32 флага, это были бы 32 байта вместо четырёх!</p>
      </cite>
     </section>
     <section>
      <title>
       <p>8.3.2. Стиль Linux: <code>statfs()</code> и <code>fstatfs()</code></p>
      </title>
      <p>Системные вызовы <code>statfs()</code> и <code>fstatfs()</code> специфичны для Linux. Их определения следующие:</p>
      <p><code>#include &lt;sys/types.h&gt; /* GLIBC */</code></p>
      <p><code>#include &lt;sys/vfs.h&gt;</code></p>
      <empty-line/>
      <p><code>int statfs(const char *path, struct statfs *buf);</code></p>
      <p><code>int fstatfs(int fd, struct statfs *buf);</code></p>
      <p>Как и в случае с <code>statvfs()</code> и <code>fstatvfs()</code>, две версии работают с именем файла или с дескриптором открытого файла соответственно, struct statfs выглядит следующим образом:</p>
      <p><code>struct statfs {</code></p>
      <p><code> long f_type;     /* тип файловой системы */</code></p>
      <p><code> long f_bsize;    /* оптимальный размер блока */</code></p>
      <p><code> long f_blocks;   /* общее число блоков в файловой системе */</code></p>
      <p><code> long f_bfree;    /* число свободных блоков в ф.с. */</code></p>
      <p><code> long f_bavail;   /* свободные блоки, доступные пользователям */</code></p>
      <p><code> long f_files;    /* общее число индексов в файловой системе */</code></p>
      <p><code> long f_ffree;    /* свободных индексов в ф.с. */</code></p>
      <p><code> fsid_t f_fsid;   /* id файловой системы */</code></p>
      <p><code> long f_namelen;  /* максимальная длина имен файлов */</code></p>
      <p><code> long f_spare[6]; /* запас для дальнейшего */</code></p>
      <p><code>};</code></p>
      <p>Поля аналогичны полям в <code>struct statvfs</code>. По крайней мере в GLIBC 2.3.2 функции POSIX <code>statvfs()</code> и <code>fstatvfs()</code> являются оболочками вокруг <code>statfs()</code> и <code>fstatfs()</code> соответственно, копируя значения из одной разновидности структуры в другую.</p>
      <p>Преимуществом использования <code>statfs()</code> или <code>fstatfs()</code> является то, что они системные вызовы. Ядро возвращает информацию непосредственно. Поскольку нет поля <code>f_flag</code> с опциями монтирования, нет необходимости просматривать каждую смонтированную файловую систему для нахождения нужной. (Другими словами, для заполнения опций монтирования <code>statfvs()</code> должна проверить каждую смонтированную файловую систему, чтобы найти содержащую файл, имя которого содержится в <code>path</code> или <code>fd</code>. Функция <code>statfs()</code> не нуждается в этом, поскольку она не предоставляет сведений об опциях монтирования.)</p>
      <p>Есть два неудобства в использовании этих вызовов. Во-первых, они специфичны для Linux. Во-вторых, часть сведений из <code>struct statvfs</code> отсутствует в <code>struct statfs</code>, наиболее значительными из них являются флаги (<code>f_flag</code>) и число доступных индексов (<code>f_favail</code>). (Поэтому <code>statvfs()</code> Linux приходится находить опции монтирования из других источников, таких, как <code>/etc/mtab</code>, и она «фабрикует» информацию для тех полей <code>struct statvfs</code>, для которых действительные сведения недоступны.)</p>
      <p>Одно поле <code>struct statfs</code> заслуживает особого замечания. Это поле <code>f_type</code>, указывающее тип файловой системы. Значение является магическим числом файловой системы, извлеченной из суперблока. Справочная страница <emphasis>statfs</emphasis>(2) предоставляет список обычно используемых файловых систем и их магические числа, которые мы используем в <code>ch08-statfs.c</code>. (Увы, отдельного файла <code>#include</code> нет.)</p>
      <p><code>1   /* ch08-statfs.с --- демонстрация statfs Linux */</code></p>
      <p><code>2</code></p>
      <p><code>3   /* ЗАМЕЧАНИЕ: специфично для GNU/Linux! */</code></p>
      <p><code>4</code></p>
      <p><code>5   #include &lt;stdio.h&gt;</code></p>
      <p><code>6   #include &lt;errno.h&gt;</code></p>
      <p><code>7   #include &lt;mntent.h&gt; /* для getmntent() и др. */</code></p>
      <p><code>8   #include &lt;unistd.h&gt; /* для getopt() */</code></p>
      <p><code>9   #include &lt;sys/types.h&gt;</code></p>
      <p><code>10  #include &lt;sys/vfs.h&gt;</code></p>
      <p><code>11</code></p>
      <p><code>12  /* Определения взяты из справочной страницы для statfs(2): */</code></p>
      <p><code>13  #define AFFS_SUPER_MAGIC     0xADFF</code></p>
      <p><code>14  #define EFS_SUPER_MAGIC      0x00414A53</code></p>
      <p><code>15  #define EXT_SUPER_MAGIC      0x137D</code></p>
      <p><code>16  #define EXT2_OLD_SUPER_MAGIC 0xEF51</code></p>
      <p><code>17  #define EXT2_SUPER_MAGIC     0xEF53</code></p>
      <p><code>18  #define HPFS_SUPER_MAGIC     0xF995E849</code></p>
      <p><code>19  #define ISOFS_SUPER_MAGIC    0x9660</code></p>
      <p><code>20  #define MINIX_SUPER_MAGIC    0x137F /* оригинальный minix */</code></p>
      <p><code>21  #define MINIX_SUPER_MAGIC2   0x138F /* 30-симв. minix */</code></p>
      <p><code>22  #define MINIX2_SUPER_MAGIC   0x2468 /* minix V2 */</code></p>
      <p><code>23  #define MINIX2_SUPER_MAGIC2  0x2478 /* minix V2, имена 30 симв. */</code></p>
      <p><code>24  #define MSDOS_SUPER_MAGIC    0x4d44</code></p>
      <p><code>25  #define NCP_SUPER_MAGIC      0x564c</code></p>
      <p><code>26  #define NFS_SUPER_MAGIC      0x6969</code></p>
      <p><code>27  #define PROC_SUPER_MAGIC     0x9fa0</code></p>
      <p><code>28  #define SMB_SUPER_MAGIC      0x517B</code></p>
      <p><code>29  #define XENIX_SUPER_MAGIC    0x012FF7B4</code></p>
      <p><code>30  #define SYSV4_SUPER_MAGIC    0x012FF7B5</code></p>
      <p><code>31  #define SYSV2_SUPER_MAGIC    0x012FF7B6</code></p>
      <p><code>32  #define COH_SUPER_MAGIC      0x012FF7B7</code></p>
      <p><code>33  #define UFS_MAGIC            0x00011954</code></p>
      <p><code>34  #define XFS_SUPER_MAGIC      0x58465342</code></p>
      <p><code>35  #define _XIAFS_SUPER_MAGIC   0x012FD16D</code></p>
      <p><code>36</code></p>
      <p><code>37  void process(const char *filename);</code></p>
      <p><code>38  void do_statfs(const struct mntent *fs);</code></p>
      <p><code>39</code></p>
      <p><code>40  int errors = 0;</code></p>
      <p><code>41  char *myname;</code></p>
      <p><code>42</code></p>
      <p><code>    /* ...main() без изменений, process() почти идентична... */</code></p>
      <p><code>85</code></p>
      <p><code>86  /* type2str --- преобразование типа fs в строку из statfs(2) */</code></p>
      <p><code>87</code></p>
      <p><code>88  const char *type2str(long type)</code></p>
      <p><code>89  {</code></p>
      <p><code>90   static struct fsname {</code></p>
      <p><code>91    long type;</code></p>
      <p><code>92    const char *name;</code></p>
      <p><code>93   } table[] = {</code></p>
      <p><code>94    { AFFS_SUPER_MAGIC, "AFFS" },</code></p>
      <p><code>95    { COH_SUPER_MAGIC, "COH" },</code></p>
      <p><code>96    { EXT2_OLD_SUPER_MAGIC, "OLD EXT2" },</code></p>
      <p><code>97    { EXT2_SUPER_MAGIС, "EXT2" },</code></p>
      <p><code>98    { HPFS_SUPER_MAGIC, "HPFS" },</code></p>
      <p><code>99    { ISOFS_SUPER_MAGIC, "ISOFS" },</code></p>
      <p><code>100   { MINIX2_SUPER_MAGIC, "MINIX V2" },</code></p>
      <p><code>101   { MINIX2_SUPER_MAGIC2, "MINIX V2 30 char" },</code></p>
      <p><code>102   { MINIX_SUPER_MAGIC, "MINIX" },</code></p>
      <p><code>103   { MINIX_SUPER_MAGIC2, "MINIX 30 char" },</code></p>
      <p><code>104   { MSDOS_SUPER_MAGIC, "MSDOS" },</code></p>
      <p><code>105   { NCP_SUPER_MAGIС, "NCP" },</code></p>
      <p><code>106   { NFS_SUPER_MAGIC, "NFS" },</code></p>
      <p><code>107   { PROC_SUPER_MAGIC, "PROC" },</code></p>
      <p><code>108   { SMB_SUPER_MAGIC, "SMB" },</code></p>
      <p><code>109   { SYSV2_SUPER_MAGIC, "SYSV2" },</code></p>
      <p><code>110   { SYSV4_SUPER_MAGIC, "SYSV4" },</code></p>
      <p><code>111   { UFS_MAGIC, "UFS" },</code></p>
      <p><code>112   { XENIX_SUPER_MAGIC, "XENIX" },</code></p>
      <p><code>113   { _XIAFS_SUPER_MAGIC, "XIAFS" },</code></p>
      <p><code>114   { 0, NULL },</code></p>
      <p><code>115  };</code></p>
      <p><code>116  static char unknown[100];</code></p>
      <p><code>117  int i;</code></p>
      <p><code>118</code></p>
      <p><code>119  for (i = 0; table[i].type != 0; i++)</code></p>
      <p><code>120   if (table[i].type == type)</code></p>
      <p><code>121    return table[i].name;</code></p>
      <p><code>122</code></p>
      <p><code>123  sprintf(unknown, "unknown type: %#x", type);</code></p>
      <p><code>124  return unknown;</code></p>
      <p><code>125 }</code></p>
      <p><code>126</code></p>
      <p><code>127 /* do_statfs --- Использовать statfs и вывести сведения */</code></p>
      <p><code>128</code></p>
      <p><code>129 void do_statfs(const struct mntent *fs)</code></p>
      <p><code>130 {</code></p>
      <p><code>131  struct statfs vfs;</code></p>
      <p><code>132</code></p>
      <p><code>133  if (fs-&gt;mnt_fsname[0] != '/') /* пропустить фиктивные файловые системы */</code></p>
      <p><code>134   return;</code></p>
      <p><code>135</code></p>
      <p><code>136  if (statfs(fs-&gt;mnt_dir, &amp;vfs) != 0) {</code></p>
      <p><code>137   fprintf(stderr, "%s: %s: statfs failed: %s\n",</code></p>
      <p><code>138    myname, fs-&gt;mnt_dir, strerror(errno));</code></p>
      <p><code>139   errors++;</code></p>
      <p><code>140   return;</code></p>
      <p><code>141  }</code></p>
      <p><code>142</code></p>
      <p><code>143  printf("%s, mounted on %s:\n", fs-&gt;mnt_dir, fs-&gt;mnt_fsname);</code></p>
      <p><code>144</code></p>
      <p><code>145  printf("\tf_type: %s\n", type2str(vfs.f_type));</code></p>
      <p><code>146  printf("\tf_bsize: %ld\n", vfs.f_bsize);</code></p>
      <p><code>147  printf("\tf_blocks: %ld\n", vfs.f_blocks);</code></p>
      <p><code>148  printf("\tf_bfree: %ld\n", vfs.f_bfree);</code></p>
      <p><code>149  printf("\tf_bavail: %ld\n", vfs.f_bavail);</code></p>
      <p><code>150  printf("\tf_files: %ld\n", vfs.f_files);</code></p>
      <p><code>151  printf("\tf_ffree: %ld\n", vfs.f_ffree);</code></p>
      <p><code>152  printf("\tf_namelen: %ld\n", vfs.f_namelen);</code></p>
      <p><code>153 }</code></p>
      <p>Чтобы сохранить место, мы опустили <code>main()</code>, которая не изменилась с представленной ранее другой программы, мы также опустили <code>process ()</code>, которая теперь вызывает <code>do_statfs()</code> вместо <code>do_statvfs()</code>.</p>
      <p>Строки 13–35 содержат список магических чисел файловых систем из справочной страницы <emphasis>statfs</emphasis>(2). Хотя эти числа можно получить из заголовочных файлов исходного кода ядра, это трудно (мы пробовали), а показанному здесь способу представления следовать легче. Строки 86–125 определяют <code>type2str()</code>, которая преобразует магическое число в выводимую строку. Она осуществляет простой линейный поиск в таблице пар (значение, строка). В (маловероятном) случае, когда магическое число в таблице отсутствует, <code>type2str()</code> создает сообщение «неизвестный тип» и возвращает его (строки 123–124).</p>
      <p><code>do_statfs()</code> (строки 129–153) выводит сведения из <code>struct statfs</code>. Член <code>f_fsid</code> опущен, поскольку <code>fsid_t</code> является непрозрачным типом. Код прост; строка 145 использует <code>type2str()</code> для вывода типа файловой системы. Как для сходной программы, использующей <code>statvfs()</code>, эта функция игнорирует файловые системы, которые не расположены на локальных устройствах (строки 133–134). Вот вывод на нашей системе:</p>
      <p><code>$ <strong>ch08-statfs</strong> /* Запуск программы */</code></p>
      <p><code>/, mounted on /dev/hda2: /* Результаты для файловой системы ext2 */</code></p>
      <p><code>f_type: ЕХТ2</code></p>
      <p><code>f_bsize: 4096</code></p>
      <p><code>f_blocks: 1549609</code></p>
      <p><code>f_bfrее: 316664</code></p>
      <p><code>f_bavail: 237946</code></p>
      <p><code>f_files: 788704</code></p>
      <p><code>f_ffree: 555483</code></p>
      <p><code>f_namelen: 255</code></p>
      <p><code>...</code></p>
      <p><code>/win, mounted on /dev/hda1: /* Результаты для файловой с-мы vfat */</code></p>
      <p><code>f_type: MSDOS</code></p>
      <p><code>f_bsize: 4096</code></p>
      <p><code>f_blocks: 2092383</code></p>
      <p><code>f_bfree: 1391952</code></p>
      <p><code>f_bavail: 1391952</code></p>
      <p><code>f_files: 0</code></p>
      <p><code>f_ffree: 0</code></p>
      <p><code>f_namelen: 260</code></p>
      <p>В заключение, использование <code>statvfs()</code> или <code>statfs()</code> в вашем собственном коде зависит от ваших потребностей. Как описано в предыдущем разделе, GNU <code>df</code> не использует <code>statvfs()</code> под GNU/Linux и в общем имеет тенденцию использовать уникальный для каждой Unix-системы системный вызов «получения сведений о файловой системе». Хотя это работает, это не очень привлекательно. С другой стороны, иногда у вас нет выбора: например, проблемы GLIBC, о которых мы упоминали выше. В этом случае нет безупречного решения.</p>
     </section>
    </section>
    <section>
     <title>
      <p>8.4. Перемещение по иерархии файлов</p>
     </title>
     <section>
      <p>Несколько системных вызовов и стандартных библиотечных функций дают возможность изменять текущий каталог и определять полный путь к текущему каталогу. Более сложные функции позволяют осуществлять произвольные действия с каждым объектом файловой системы в иерархии каталогов.</p>
     </section>
     <section>
      <title>
       <p>8.4.1. Смена каталога: <code>chdir()</code> и <code>fchdir()</code></p>
      </title>
      <p>В разделе 1.2 «Модель процессов Linux/Unix» мы говорили:</p>
      <cite>
       <p>Текущим каталогом является каталог, относительно которого отсчитываются относительные пути (те, которые не начинаются с <code>/</code>). Это каталог, «в» котором вы находитесь, когда даете оболочке команду '<code>cd <emphasis>некоторое_место</emphasis></code>'.</p>
      </cite>
      <p>У каждого процесса есть текущий рабочий каталог. Каждый новый процесс наследует свой текущий каталог от процесса, который его запустил (своего родителя). Две функции позволяют перейти в другой каталог:</p>
      <p><code>#include &lt;unistd.h&gt;</code></p>
      <empty-line/>
      <p><code>int chdir(const char *path); /* POSIX */</code></p>
      <p><code>int fchdir(int fd); /* XSI */</code></p>
      <p>Функция <code>chdir()</code> принимает строку с названием каталога, тогда как <code>fchdir()</code> ожидает дескриптор файла, который был открыт для каталога с помощью <code>open()</code>.<a l:href="#n83" type="note">[83]</a> Обе возвращают 0 при успехе и -1 при ошибке (с <code>errno</code>, установленной соответствующим образом). Обычно, если <code>open()</code> для каталога завершается успешно, <code>fchdir()</code> также достигает цели, если кто-то не изменил права доступа к каталогу между вызовами, (<code>fchdir()</code> сравнительно новая функция; на старых системах Unix ее нет.)</p>
      <p>Использование этих функций почти тривиально. Следующая программа, <code>ch08-chdir.c</code>, демонстрирует обе функции. Она демонстрирует также, что <code>fchdir()</code> может потерпеть неудачу, если права доступа открытого каталога не включают доступа на поиск (исполнение).</p>
      <p><code>1  /* ch08-chdir.c --- демонстрация chdir() и fchdir().</code></p>
      <p><code>2     Для краткости проверка ошибок опущена */</code></p>
      <p><code>3</code></p>
      <p><code>4  #include &lt;stdio.h&gt;</code></p>
      <p><code>5  #include &lt;fcntl.h&gt;</code></p>
      <p><code>6  #include &lt;unistd.h&gt;</code></p>
      <p><code>7  #include &lt;sys/types.h&gt;</code></p>
      <p><code>8  #include &lt;sys/stat.h&gt;</code></p>
      <p><code>9</code></p>
      <p><code>10 int main(void)</code></p>
      <p><code>11 {</code></p>
      <p><code>12  int fd;</code></p>
      <p><code>13  struct stat sbuf;</code></p>
      <p><code>14</code></p>
      <p><code>15  fd = open(".", O_RDONLY); /* открыть каталог для чтения */</code></p>
      <p><code>16  fstat(fd, &amp;sbuf); /* получить сведения, нужны начальные права доступа */</code></p>
      <p><code>17  chdir(".."); /* 'cd ..' */</code></p>
      <p><code>18  fchmod(fd, 0); /* отменить права доступа каталога */</code></p>
      <p><code>19</code></p>
      <p><code>20  if (fchdir(fd) &lt; 0) /* попытаться выполнить 'cd' обратно, должно завершиться неудачей */</code></p>
      <p><code>21   perror("fchdxr back");</code></p>
      <p><code>22</code></p>
      <p><code>23  fchmod(fd, sbuf.st_mode &amp; 07777); /* восстановить первоначальные права доступа */</code></p>
      <p><code>24  close(fd); /* все сделано */</code></p>
      <p><code>25</code></p>
      <p><code>26  return 0;</code></p>
      <p><code>27 }</code></p>
      <p>Строка 15 открывает текущий каталог. Строка 16 вызывает <code>fstat()</code> для открытого каталога, так что мы получаем копию его прав доступа. Строка 17 использует <code>chdir()</code> для перемещения на один уровень в иерархии файлов. Строка 18 выполняет грязную работу, отменяя все права доступа первоначального каталога.</p>
      <p>Строки 20–21 пытаются перейти обратно в первоначальный каталог. Ожидается, что эта попытка будет безуспешной, поскольку текущие права доступа не позволяют это. Строка 23 восстанавливает первоначальные права доступа, '<code>sbuf.st_mode &amp; 07777</code>' получает младшие 12 битов прав доступа; это обычные 9 битов rwxrwxrwx и биты setuid, setgid и «липкий» бит, которые мы обсудим в главе 11 «Права доступа и ID пользователя и группы». Наконец, строка 24 заканчивает работу, закрывая открытый дескриптор файла. Вот что происходит при запуске программы.</p>
      <p><code>$ <strong>ls -ld .</strong> /* Показать текущие права доступа */</code></p>
      <p><code>drwxr-xr-x 2 arnold devel 4096 Sep 9 16:42 .</code></p>
      <p><code>$ <strong>ch08-chdir</strong> /* Запустить программу */</code></p>
      <p><code>fchdir back: Permission denied /* Ожидаемая неудача */</code></p>
      <p><code>$ <strong>ls -ld .</strong> /* Снова посмотреть на права доступа */</code></p>
      <p><code>drwxr-xr-x 2 arnold devel 4096 Sep 9 16:42 /* Все восстановлено как раньше */</code></p>
     </section>
     <section>
      <title>
       <p>8.4.2. Получение текущего каталога: <code>getcwd()</code></p>
      </title>
      <p>Названная должным образом функция <code>getcwd()</code> получает абсолютный путь текущего рабочего каталога.</p>
      <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
      <p><code>char *getcwd(char *buf, size_t size);</code></p>
      <p>Функция заносит в <code>buf</code> путь; ожидается, что размер <code>buf</code> равен <code>size</code> байтам. При успешном завершении функция возвращает свой первый аргумент. В противном случае, если требуется более <code>size</code> байтов, она возвращает <code>NULL</code> и устанавливает в <code>errno ЕRANGE</code>. Смысл в том, что если случится <code>ERANGE</code>, следует попытаться выделить буфер большего размера (с помощью <code>malloc()</code> или <code>realloc()</code>) и попытаться снова.</p>
      <p>Если любой из компонентов каталога, ведущих к текущему каталогу, не допускает чтения или поиска, <code>getcwd()</code> может завершиться неудачей, а <code>errno</code> будет установлен в <code>EACCESS</code>. Следующая простая программа демонстрирует ее использование:</p>
      <p><code>/* ch08-getcwd.c --- демонстрация getcwd().</code></p>
      <p><code>Проверка ошибок для краткости опущена */</code></p>
      <p><code>#include &lt;stdio.h&gt;</code></p>
      <p><code>#include &lt;fcntl.h&gt;</code></p>
      <p><code>#include &lt;unistd.h&gt;</code></p>
      <p><code>#include &lt;sys/types.h&gt;</code></p>
      <p><code>#include &lt;sys/stat.h&gt;</code></p>
      <empty-line/>
      <p><code>int main(void) {</code></p>
      <p><code> char buf[PATH_MAX];</code></p>
      <p><code> char *cp;</code></p>
      <p><code> cp = getcwd(buf, sizeof(buf));</code></p>
      <p><code> printf("Current dir: %s\n", buf);</code></p>
      <p><code> printf("Changing to ..\n");</code></p>
      <p><code> chdir(".."); /* 'cd ..' */</code></p>
      <p><code> cp = getcwd(buf, sizeof(buf));</code></p>
      <p><code> printf("Current dir is now: %s\n", buf);</code></p>
      <p><code> return 0;</code></p>
      <p><code>}</code></p>
      <p>Эта простая программа выводит текущий каталог, переходит в родительский каталог, затем выводит новый текущий каталог. (Переменная <code>cp</code> здесь на самом деле не нужна, но в реальной программе она была бы использована для проверки ошибок). При запуске программа создает следующий вывод:</p>
      <p><code>$ <strong>ch08-getcwd</strong></code></p>
      <p><code>Current dir: /home/arnold/work/prenhall/progex/code/ch08</code></p>
      <p><code>Changing to ..</code></p>
      <p><code>Current dir is now: /home/arnold/work/prenhall/progex/code</code></p>
      <p>Формально, если аргумент <code>buf</code> равен <code>NULL</code>, поведение <code>getcwd()</code> не определено. В данном случае версия GLIBC <code>getcwd()</code> вызовет <code>malloc()</code> за вас, выделяя буфер с размером <code>size</code>. Идя даже дальше, если <code>size</code> равен 0, выделяется «достаточно большой» буфер для вмещения возвращенного имени пути. В любом случае вы должны вызвать для возвращенного указателя <code>free()</code> после завершения работы с буфером.</p>
      <p>Поведение GLIBC полезно, но не переносимо. Для кода, который должен работать на разных платформах, вы можете написать замещающую функцию, которая предоставляет те же самые возможности, в то же время заставив ее непосредственно вызывать <code>getcwd()</code> на системе с GLIBC.</p>
      <p>Системы GNU/Linux предоставляют файл <code>/proc/self/cwd</code>. Этот файл является символической ссылкой на текущий каталог:</p>
      <p><code>$ <strong>cd /tmp</strong> /* Сменить каталог */</code></p>
      <p><code>$ <strong>ls -l /рroc/self/cwd</strong> /* Посмотреть на файл */</code></p>
      <p><code>lrwxrwxrwx 1 arnold devel 0 Sep 9 17:29 /proc/self/cwd -&gt; /tmp</code></p>
      <p><code>$ <strong>cd</strong> /* Перейти в домашний каталог */</code></p>
      <p><code>$ <strong>ls -l /proc/self/cwd</strong> /* Снова посмотреть на него */</code></p>
      <p><code>lrwxrwxrwx 1 arnold devel 0 Sep 9 17:30 /proc/self/cwd -&gt; /home/arnold</code></p>
      <p>Это удобно на уровне оболочки, но представляет проблему на уровне программирования. В частности, размер файла равен нулю! (Это потому, что это файл в <code>/proc</code>, который продуцирует ядро; это не настоящий файл, находящийся на диске.)</p>
      <p>Почему нулевой размер является проблемой? Если вы помните из раздела 5.4.5 «Работа с символическими ссылками», <code>lstat()</code> для символической ссылки возвращает в поле <code>st_size</code> структуры <code>struct stat</code> число символов в имени связанного файла. Это число может затем использоваться для выделения буфера соответствующего размера для использования с <code>readlink()</code>. Здесь это не будет работать, поскольку размер равен нулю. Вам придется использовать (или выделять) буфер, который, как вы полагаете, достаточно большой. Однако, поскольку <code>readlink()</code> не выдает символов больше, чем вы предоставили места, <emphasis>невозможно сказать</emphasis>, достаточен буфер или нет; <code>readlink()</code> не завершается неудачей, когда недостаточно места. (См. в разделе 5.4.5 «Работа с символическими ссылками» функцию Coreutils <code>xreadlink()</code>, которая решает проблему.)</p>
      <p>В дополнение к <code>getcwd()</code> GLIBC имеет несколько других непереносимых процедур. Они избавляют вас от хлопот по управлению буферами и обеспечивают совместимость со старыми системами BSD. Подробности см в <emphasis>getcwd</emphasis>(3).</p>
     </section>
     <section>
      <title>
       <p>8.4.3. Перемещение по иерархии: <code>nftw()</code></p>
      </title>
      <section>
       <p>Обычной задачей программирования является обработка целых иерархий каталогов: выполнение действий над каждым файлом и каждым каталогом и подкаталогом в целостном дереве. Рассмотрите, например, команду <code>du</code>, которая выводит сведения об использовании диска, '<code>chown -R</code>', которая рекурсивно изменяет владельцев, или программу <code>find</code>, которая находит файлы, подходящие по определенным критериям.</p>
       <p>На данный момент вы знаете достаточно, чтобы написать собственный код для открывания и чтения каталогов вручную, вызова <code>stat()</code> (или <code>lstat()</code>) для каждого элемента и рекурсивной обработки подкаталогов. Однако, такой код трудно сделать правильным; можно выйти за пределы дескрипторов файлов, если вы будете оставлять родительские каталоги открытыми при обработке подкаталогов; нужно решить, обрабатывать ли символические ссылки как таковые или как файлы, на которые они указывают; нужно суметь справиться с каталогами, которые недоступны для чтения или поиска и т.д. Также трудно писать один и тот же код снова и снова, когда он требуется в нескольких приложениях.</p>
      </section>
      <section>
       <title>
        <p>8.4.3.1. Интерфейс <code>nftw()</code></p>
       </title>
       <p>Чтобы избавиться от проблем, System V предложила функцию <code>ftw()</code> («file tree walk» — обход дерева файлов), <code>ftw()</code> осуществляла всю работу по «прохождению» дерева (иерархии) файлов. Вы предоставляете ей указатель на функцию, и она вызывает эту функцию для каждого объекта файла, с которым сталкивается. Ваша функция должна затем обработать каждый объект файловой системы, как считает нужным.</p>
       <p>Со временем стало ясно, что интерфейс <code>ftw()</code> не вполне выполнял свою работу;<a l:href="#n84" type="note">[84]</a> например, первоначально он не поддерживал символические ссылки. По этим причинам к X/Open Portability Guide, который теперь является частью POSIX, была добавлена <code>nftw()</code> («new (новая) <code>ftw()</code>» [важно]). Вот прототип:</p>
       <p><code>#include &lt;ftw.h&gt; /* XSI */</code></p>
       <empty-line/>
       <p><code>int nftw(const char *dir,    /* Отправная точка */</code></p>
       <p><code> int (*fn)(const char *file, /* Указатель функции на */</code></p>
       <p><code>  const struct stat *sb,     /* функцию из четырех аргументов */</code></p>
       <p><code>  int flag, struct FTW *s),</code></p>
       <p><code> int depth, int flags);      /* Максимум открытых fds, флаги */</code></p>
       <p>А вот аргументы:</p>
       <p><code>const char *dir</code></p>
       <p>Строка с именем отправной точки иерархии для обработки.</p>
       <p><code>int (*fn)(const char *file, const struct stat *sb, int flag, struct FTW *s)</code></p>
       <p>Указатель на функцию с данными аргументами. Эта функция вызывается для каждого объекта в иерархии. Подробности ниже.</p>
       <p><code>int depth</code></p>
       <p>Этот аргумент назван неверно. Чтобы избежать выхода за пределы дескрипторов файлов, <code>nftw()</code> держит открытыми не более, чем <code>depth</code> одновременно открытых каталогов. Это <emphasis>не</emphasis> препятствует обработке <code>nftw()</code> иерархий, которые глубже уровня <code>depth</code>, но меньшие значения <code>depth</code> означают, что <code>nftw()</code> придется делать больше работы.</p>
       <p><code>flags</code></p>
       <p>Набор флагов, объединяемых побитовым ИЛИ, которые указывают, как <code>nftw()</code> должна обрабатывать иерархию.</p>
       <p>Интерфейс <code>nftw()</code> имеет два <emphasis>отдельных</emphasis> набора флагов. Одни набор контролирует саму <code>nftw()</code> (аргумент <code>flags</code> функции <code>nftw()</code>). Другой набор передается предоставленной пользователем функции, которую вызывает <code>nftw()</code> (аргумент <code>flags</code> для <code>(*fn)()</code>). Однако, интерфейс запутывает, поскольку имена обоих наборов флагов начинаются с префикса '<code>FTW_</code>'. Мы постараемся сделать все, чтобы это прояснить по ходу дела. В табл. 8.3 представлены флаги, которые контролируют <code>nftw()</code>.</p>
       <empty-line/>
       <p><strong>Таблица 8.3</strong>. Управляющие флаги для <code>nftw()</code></p>
       <table>
        <tr align="left">
         <th align="left" valign="top">Флаг</th>
         <th align="left" valign="top">Значение</th>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>FTW_CHDIR</code></td>
         <td align="left" valign="top">При установке перед открытием каждого из каталогов сначала осуществляется переход в него. Это действие более эффективно, но вызывающее приложение должно быть готово оказаться в другом каталоге, когда <code>nftw()</code> завершится</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>FTW_DEPTH</code></td>
         <td align="left" valign="top">При установке осуществляется «сначала глубокий поиск». Это означает, что все файлы и подкаталоги обрабатываются до того, как будет обработан сам каталог</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>FTW_MOUNT</code></td>
         <td align="left" valign="top">При установке остается в той же самой смонтированной файловой системе. Это более специализированная опция</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>FTW_PHYS</code></td>
         <td align="left" valign="top">При установке не следует по символическим ссылкам</td>
        </tr>
       </table>
       <p><code>FTW_CHDIR</code> предоставляет большую эффективность; при обработке глубоких иерархий файлов ядру не приходится обрабатывать снова и снова полные пути имен при осуществлении <code>stat()</code> или открытии каталога. Экономия времени для больших иерархий может быть вполне ощутимой.<a l:href="#n85" type="note">[85]</a></p>
       <p><code>FTW_DEPTH</code> может быть, а может и не быть тем, что вам нужно; для некоторых приложений это безусловно справедливо. Рассмотрите '<code>chmod -R u-rx .</code>'. Эта команда удаляет права чтения и исполнения для владельца для всех файлов и подкаталогов в текущем каталоге. Если это изменение прав доступа применено к каталогу до того, как оно применено к содержимому каталога, любые последующие попытки обработки содержимого потерпят неудачу! Поэтому команда должна применяться к каталогу после обработки его содержимого.<a l:href="#n86" type="note">[86]</a> Справочная страница GNU/Linux <emphasis>nftw</emphasis>(3) отмечает для <code>FTW_PHYS</code>, что «это то, что вам нужно». Это позволяет вам обрабатывать сами символические ссылки, что обычно бывает нужно (Рассмотрите <code>du</code>, она должна подсчитывать занимаемое ссылками пространство отдельно от связанных с ними файлов.)</p>
      </section>
      <section>
       <title>
        <p>8.4.3.2. Функция обратного вызова <code>nftw()</code></p>
       </title>
       <p>После запуска <code>nftw()</code> она вызывает функцию, указатель для которой предоставляете вы. (Такие функции называются функциями обратного вызова (callback functions), поскольку они «вызываются обратно» из библиотечного кода.) Функция обратного вызова получает четыре аргумента:</p>
       <p><code>const char *file</code></p>
       <p>Имя текущего обрабатываемого файла (каталога, символической ссылки и т.д.).</p>
       <p><code>const struct stat *sb</code></p>
       <p>Указатель на <code>struct stat</code> для файла.</p>
       <p><code>int flag</code></p>
       <p>Одно из нескольких значений флагов (описанных ниже), указывающих, какой это вид файла или была ли ошибка для объекта.</p>
       <p><code>struct FTW *s</code></p>
       <p>Эта структура предоставляет две отдельные части информации:</p>
       <p><code>struct FTW {</code></p>
       <p><code> int base;  /* Индекс в файле базовой части имени файла */</code></p>
       <p><code> int level; /* Глубина этого элемента относительно точки отсчета */</code></p>
       <p><code>};</code></p>
       <p>Параметр <code>flag</code> имеет одно из перечисленных в табл. 8.4 значений.</p>
       <empty-line/>
       <p><strong>Таблица 8.4</strong>. Значения флагов для функции обратного вызова <code>nftw()</code></p>
       <table>
        <tr align="left">
         <th align="left" valign="top">Флаг</th>
         <th align="left" valign="top">Значение</th>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>FTW_F</code></td>
         <td align="left" valign="top">Объект является обычным файлом</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>FTW_D</code></td>
         <td align="left" valign="top">Объект является каталогом</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>FTW_DNR</code></td>
         <td align="left" valign="top">Объект является каталогом, который нельзя прочесть</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>FTW_SL</code></td>
         <td align="left" valign="top">Объект является символической ссылкой</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>FTW_NS</code></td>
         <td align="left" valign="top">Объект не является символической ссылкой, а <code>stat()</code> потерпела неудачу</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>FTW_DP</code></td>
         <td align="left" valign="top">Объект является каталогом, элементы которого были уже обработаны. Это может случиться, лишь когда в вызове <code>nftw()</code> использовался <code>FTW_DEPTH</code></td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>FTW_SLN</code></td>
         <td align="left" valign="top">Объект является символической ссылкой, указывающей на несуществующий файл. Это может случиться, лишь когда в вызове <code>nftw()</code> не используется <code>FTW_PHYS</code></td>
        </tr>
       </table>
       <p><code>struct FTW* s</code> предоставляет дополнительную информацию, которая может быть полезной. <code>s-&gt;bas</code>e действует в качестве индекса в <code>file</code>; <code>file</code> является полным путем обрабатываемого объекта (относительно точки отсчета), '<code>file + s-&gt;base</code>' указывает на первый символ компонента имени файла.</p>
       <p><code>s-&gt;level</code> указывает текущую глубину иерархии; считается, что первоначальная точка отсчета находится на уровне 0.</p>
       <p>Функция обратного вызова должна вернуть 0, если все нормально. Любое ненулевое возвращенное значение заставляет <code>nftw()</code> прекратить свою обработку и вернуть то самое ненулевое значение. Справочная страница отмечает, что функция обратного вызова должна останавливать обработку только путем возвращаемого значения, чтобы у <code>nftw()</code> был шанс произвести очистку: т.е. освободить динамически выделенную память, закрыть открытые дескрипторы файлов и т.д. Функции обратного вызова не следует использовать <code>longjmp()</code>, если только программа не завершается немедленно, (<code>longjmp()</code> является продвинутой функцией, которую мы опишем в разделе 12.5 «Нелокальные goto».) Рекомендуемой методикой обработки ошибок является установка глобальной переменной, указывающей на наличие проблем, возвращение 0 из функции обратного вызова и обработка ошибок после завершения перемещения <code>nftw()</code> по иерархии файлов. (GNU <code>du</code> это делает, как мы вскоре увидим.)</p>
       <p>Давайте свяжем все это воедино в примере программы. <code>ch08-nftw.c</code> обрабатывает каждый файл или каталог, указанный в командной строке, запуская для них <code>nftw()</code>. Функция, обрабатывающая каждый файл, выводите отступом имя и тип файла, показывая иерархическое положение каждого файла. Для разнообразия мы сначала покажем результаты, а затем покажем и обсудим программу:</p>
       <p><code>$ <strong>pwd</strong> /* Где мы находимся */</code></p>
       <p><code>/ home/аrnold/work/prenhall/progex</code></p>
       <p><code>$ <strong>code/ch08/ch08-nftw code</strong> /* Обойти каталог 'code' */</code></p>
       <p><code>code (directory) /* Каталог верхнего уровня */</code></p>
       <p><code>  ch02 (directory) /* Подкаталоги с отступом на один уровень */</code></p>
       <p><code>    ch02-printenv.c (file) /* Файлы в подкаталоге с отступом</code></p>
       <p><code>                              на два уровня */</code></p>
       <p><code>  ch03 (directory)</code></p>
       <p><code>    ch03-memaddr.c (file)</code></p>
       <p><code>  ch04 (directory)</code></p>
       <p><code>    ch04-holes.c (file)</code></p>
       <p><code>    ch04-cat.с (file)</code></p>
       <p><code>    ch04-maxfds.c (file)</code></p>
       <p><code>    v7cat.c (file)</code></p>
       <p><code>...</code></p>
       <p>Вот сама программа:</p>
       <p><code>1  /* ch08-nftw.c --- демонстрирует nftw() */</code></p>
       <p><code>2</code></p>
       <p><code>3  #define _XOPEN_SOURCE 1 /* Требуется под GLIBC для nftw() */</code></p>
       <p><code>4  #define _XOPEN_SOURCE_EXTENDED 1 /* To же */</code></p>
       <p><code>5</code></p>
       <p><code>6  #include &lt;stdio.h&gt;</code></p>
       <p><code>7  #include &lt;errno.h&gt;</code></p>
       <p><code>8  #include &lt;getopt.h&gt;</code></p>
       <p><code>9  #include &lt;ftw.h&gt; /* получает для нас &lt;sys/types.h&gt; и &lt;sys/stat.h&gt; */</code></p>
       <p><code>10 #include &lt;limits.h&gt; /* для PATH_MAX */</code></p>
       <p><code>11 #include &lt;unistd.h&gt; /* для объявлений getdtablesize(), getcwd() */</code></p>
       <p><code>12</code></p>
       <p><code>13 #define SPARE_FDS 5 /* fds для использования другими функциями, см. текст */</code></p>
       <p><code>14</code></p>
       <p><code>15 extern int process(const char *file, const struct stat *sb,</code></p>
       <p><code>16  int flag, struct FTW *s);</code></p>
       <p><code>17</code></p>
       <p><code>18 /* usage --- print message and die */</code></p>
       <p><code>19</code></p>
       <p><code>20 void usage(const char *name)</code></p>
       <p><code>21 {</code></p>
       <p><code>22  fprintf(stderr, "usage: %s (-c) directory ...\n", name);</code></p>
       <p><code>23  exit(1);</code></p>
       <p><code>24 }</code></p>
       <p><code>25</code></p>
       <p><code>26 /* main --- вызвать nftw() для каждого аргумента командной строки */</code></p>
       <p><code>27</code></p>
       <p><code>28 int main(int argc, char **argv)</code></p>
       <p><code>29 {</code></p>
       <p><code>30  int i, c, nfds;</code></p>
       <p><code>31  int errors = 0;</code></p>
       <p><code>32  int flags = FTW_PHYS;</code></p>
       <p><code>33  char start[PATH_MAX], finish[PATH_MAX];</code></p>
       <p><code>34</code></p>
       <p><code>35  while ((c = getopt(argc, argv, "с")) != -1) {</code></p>
       <p><code>36   switch (c) {</code></p>
       <p><code>37   case 'c':</code></p>
       <p><code>38    flags |= FTW_CHDIR;</code></p>
       <p><code>39    break;</code></p>
       <p><code>40   default:</code></p>
       <p><code>41    usage(argv[0]);</code></p>
       <p><code>42    break;</code></p>
       <p><code>43   }</code></p>
       <p><code>44  }</code></p>
       <p><code>45</code></p>
       <p><code>46  if (optind == argc)</code></p>
       <p><code>47   usage(argv[0]);</code></p>
       <p><code>48</code></p>
       <p><code>49  getcwd(start, sizeof start);</code></p>
       <p><code>50</code></p>
       <p><code>51  nfds = getdtablesize() - SPARE_FDS; /* оставить несколько запасных дескрипторов */</code></p>
       <p><code>52  for (i = optind; i &lt; argc; i++) {</code></p>
       <p><code>53   if (nftw(argv[i], process, nfds, flags) != 0) {</code></p>
       <p><code>54    fprintf(stderr, "%s: %s: stopped early\n",</code></p>
       <p><code>55     argv[0], argv[i]);</code></p>
       <p><code>56    errors++;</code></p>
       <p><code>57   }</code></p>
       <p><code>58  }</code></p>
       <p><code>59</code></p>
       <p><code>60  if ((flags &amp; FTW_CHDIR) != 0) {</code></p>
       <p><code>61   getcwd(finish, sizeof finish);</code></p>
       <p><code>62   printf("Starting dir: %s\n", start);</code></p>
       <p><code>63   printf("Finishing dir: %s\n", finish);</code></p>
       <p><code>64  }</code></p>
       <p><code>65</code> </p>
       <p><code>66  return (errors != 0);</code></p>
       <p><code>67 }</code></p>
       <p>Строки 3–11 включают заголовочные файлы. По крайней мере в GLIBC 2.3.2 перед включением <emphasis>любого</emphasis> заголовочного файла необходимы <code>#define</code> для <code>_XOPEN_SOURCE</code> и <code>_XOPEN_SOURCE_EXTENDED</code>. Они дают возможность получить объявления и значения флагов, которые <code>nftw()</code> предоставляет свыше предоставляемых <code>ftw()</code>. Это специфично для GLIBC. Потребность в этом в конечном счете исчезнет, когда GLIBC станет полностью совместимой со стандартом POSIX 2001.</p>
       <p>Строки 35–44 обрабатывают опции. Опция <code>-с</code> добавляет к флагам <code>nftw() FTW_CHDIR</code>. Это эксперимент с целью увидеть, сможете ли вы оказаться где-то в другом месте от того, где начинали. Кажется, это возможно, если <code>nftw()</code> завершается неудачей, в противном случае вы заканчиваете там же, где начинали. (POSIX не документирует это явным образом, но целью, похоже, было действительно заканчивать там же, где начинали. Стандарт не говорит, что функция обратного вызова не должна менять текущий каталог.)</p>
       <p>Строка 49 сохраняет начальный каталог для дальнейшего использования, пользуясь <code>getcwd()</code>.</p>
       <p>Строка 51 вычисляет число дескрипторов, которые может использовать <code>nftw()</code>. Мы не хотим, чтобы она использовала все доступные дескрипторы файлов, если функция обратного вызова также хочет открывать файлы. В вычислении используется <code>getdtablesize()</code> (см. раздел 4.4.1 «Понятие о дескрипторах файлов») для получения максимально возможного числа и вычета из него <code>SPARE_FDS</code>, который был вычислен ранее в строке 13.</p>
       <p>Эта процедура служит основанием для больших объяснений. В обычном случае по крайней мере три дескриптора уже используются для стандартного ввода, стандартного вывода и стандартной ошибки. <code>nftw()</code> нужно некоторое количество дескрипторов файлов для открытия и чтения каталогов; внутри себя <code>opendir()</code> использует <code>open()</code> при открытии каталогов для чтения. Если функции обратного вызова также нужно открывать файлы, мы должны предотвратить израсходование функцией <code>nftw()</code> всех доступных дескрипторов файлов для открывания каталогов. Мы делаем это, вычитая некоторое число из максимально допустимого. Для данного примера мы выбрали пять, но если функции обратного вызова нужно открывать файлы, должно использоваться большее число, (<code>nftw()</code> знает, как восстановиться при израсходовании дескрипторов файлов; мы не должны беспокоиться о таком случае.)</p>
       <p>Строки 52–58 являются главным циклом над нашими аргументами; строки 53–57 проверяют ошибки; когда они появляются, код выводит диагностическое сообщение и увеличивает значение переменной <code>errors</code>.</p>
       <p>Строки 60–64 являются частью эксперимента с <code>FTW_CHDIR</code>, выводящего начальный и конечный каталоги, если было использовано <code>-с</code>.</p>
       <p>По-настоящему интересной функцией является <code>process()</code>; это функция обратного вызова, которая обрабатывает каждый файл. Она использует базовый шаблон для функции обратного вызова <code>nftw()</code>, который является оператором <code>switch</code> для значения <code>flag</code>.</p>
       <p><code>69  /* process --- выводит каждый файл на нужном уровне */</code></p>
       <p><code>70</code></p>
       <p><code>71  int process(const char "file, const struct stat *sb,</code></p>
       <p><code>72  int flag, struct FTW *s)</code></p>
       <p><code>73  {</code></p>
       <p><code>74   int retval = 0;</code></p>
       <p><code>75   const char *name = file + s-&gt;base;</code></p>
       <p><code>76</code></p>
       <p><code>77   printf("%*s", s-&gt;level * 4, ""); /* сделать отступ */</code></p>
       <p><code>78</code></p>
       <p><code>79   switch (flag) {</code></p>
       <p><code>80   case FTW_F:</code></p>
       <p><code>81    printf("%s (file)\n", name);</code></p>
       <p><code>82    break;</code></p>
       <p><code>83   case FTW_D:</code></p>
       <p><code>84    printf("%s (directory)\n", name);</code></p>
       <p><code>85    break;</code></p>
       <p><code>86   case FTW_DNR:</code></p>
       <p><code>87    printf("%s (unreadable directory)\n", name);</code></p>
       <p><code>88    break;</code></p>
       <p><code>89   case FTW_SL:</code></p>
       <p><code>90    printf("%s (symbolic link)\n", name);</code></p>
       <p><code>91    break;</code></p>
       <p><code>92   case FTW_NS:</code></p>
       <p><code>93    printf("%s (stat failed): %s\n", name, strerror(errno));</code></p>
       <p><code>94    break;</code></p>
       <p><code>95   case FTW_DP:</code></p>
       <p><code>96   case FTW_SLN:</code></p>
       <p><code>97    printf("%s: FTW_DP or FTW_SLN: can't happen'\n", name);</code></p>
       <p><code>98    retval = 1;</code></p>
       <p><code>99    break;</code></p>
       <p><code>100  default:</code></p>
       <p><code>101   printf("%s: unknown flag %d: can't happen'\n", name, flag);</code></p>
       <p><code>102   retval = 1;</code></p>
       <p><code>103   break;</code></p>
       <p><code>104  }</code></p>
       <p><code>105</code></p>
       <p><code>106  return retval;</code></p>
       <p><code>107 }</code></p>
       <p>Строка 75 использует '<code>file + s-&gt;base</code>' для получения имени из полного пути. Это значение указателя сохраняется в переменной <code>name</code> для повторного использования в функции.</p>
       <p>Строка 77 делает отступ нужного размера, используя красивый трюк. Используя <code>%*s</code>, <code>printf()</code> получает от первого аргумента ширину поля. Это вычисляется динамически как '<code>level * 4</code>'. Строка, которая должна быть выведена — «», пустая строка. Конечным результатом является то, что <code>printf()</code> создает для нас отступ нужного размера без необходимости запуска цикла.</p>
       <p>Строки 79–104 являются оператором <code>switch</code>. В данном случае он не делает ничего весьма интересного, кроме вывода имени файла и его типа (файл, каталог и т.д.)</p>
       <p>Хотя эта программа не использует <code>struct stat</code>, должно быть ясно, что вы могли бы сделать в функции обратного вызова все, что хотите.</p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. Джим Мейеринг (Jim Meyering), сопроводитель GNU Coreutils, замечает, что дизайн <code>nftw()</code> несовершенен из-за ее рекурсивной природы. (Она рекурсивно вызывает себя при обработке подкаталогов.) Если иерархия каталогов становится действительно глубокой, в диапазоне уровней 20 000–40 000 (!), <code>nftw()</code> может выйти за пределы размера стека, уничтожив программу. Есть также и другие проблемы, связанные с дизайном <code>nftw()</code>. Версия GNU Coreutils после 5.0 исправляет это путем использования набора процедур <code>fts()</code> (см. <emphasis>fts</emphasis>(3)).</p>
       </cite>
      </section>
     </section>
    </section>
    <section>
     <title>
      <p>8.5. Обход дерева файлов: GNU <code>du</code></p>
     </title>
     <p>GNU версия <code>du</code> в GNU Coreutils использует <code>nftw()</code> для обхода одной или более иерархии файлов, собирая и выводя сведения, касающиеся количества используемого дискового пространства. У нее большое число опций, которые управляют ее поведением но отношению к символическим ссылкам, форматом вывода чисел и т.д. Это делает разбор кода труднее, чем могло бы быть при более простой версии. (Однако, мы не собираемся позволить этому остановить нас.) Вот сводка опций <code>du</code>, которые вскоре будут полезны, когда мы рассмотрим код.</p>
     <p><code>$ <strong>du --help</strong></code></p>
     <p><code>Usage: du [OPTION]... [FILE]...</code></p>
     <p><code>  Дает сводку использования диска для каждого FILE,</code></p>
     <p><code>  рекурсивно для каталогов.</code></p>
     <p><code>  Обязательные для длинных опций аргументы являются обязательными</code></p>
     <p><code>  также и для коротких опций.</code></p>
     <p><code>-a,  --all              записать число всех файлов, а не только</code></p>
     <p><code>                        каталогов</code></p>
     <p><code>     --apparent-size    вывести видимые размеры, а не использование</code></p>
     <p><code>                        диска; хотя видимый размер обычно меньше, он</code></p>
     <p><code>                        может быть и больше из-за дыр в файлах,</code></p>
     <p><code>                        внутренней фрагментации, косвенных блоков и т.п.</code></p>
     <p><code>-В,  --block-size=SIZE  использовать блоки размером SIZE байтов</code></p>
     <p><code>-b,  --bytes            эквивалентно '--apparent-size --block-size=1'</code></p>
     <p><code>-с,  --total            выводит итоговую сумму</code></p>
     <p><code>-D,  --dereference-args разыменовывать FILE, которые являются</code></p>
     <p><code>                        символическими ссылками</code></p>
     <p><code>-h,  --human-readable   вывести размеры в удобном для восприятия</code></p>
     <p><code>                        формате (например, 1K 234М 2G)</code></p>
     <p><code>-Н,  --si               так же, но использовать степени 1000, не 1024</code></p>
     <p><code>-k                      подобно --block-size=1K</code></p>
     <p><code>-l,  --count-links      считать размеры несколько раз при прямых</code></p>
     <p><code>                        ссылках</code></p>
     <p><code>-L,  --dereference      разыменовывать все символические ссылки</code></p>
     <p><code>-S,  --separate-dirs    не включать размер подкаталогов</code></p>
     <p><code>-s,  --summarize        отобразить для каждого аргумента лишь итоги</code></p>
     <p><code>-х,  --one-file-system  пропускать каталоги на различных файловых</code></p>
     <p><code>                        системах</code></p>
     <p><code>-X   --exclude-         исключить файлы, подходящие под любой</code></p>
     <p><code>FILE from=FILE          образец в FILE</code></p>
     <p><code>     --exclude=PATTERN  исключить файлы, соответствующие PATTERN</code></p>
     <p><code>     --max-depth=N      вывести итог для каталога (или файла, с --all)</code></p>
     <p><code>                        только если он находится на N или менее уровней</code></p>
     <p><code>                        глубже аргумента командной строки;</code></p>
     <p><code>     --max-depth=0      то же самое, что и --summarize</code></p>
     <p><code>     --help             отобразить экран справки и выйти</code></p>
     <p><code>     --version          вывести сведения о версии и выйти</code></p>
     <p><code>SIZE может быть (или может быть целым, за которым</code></p>
     <p><code>может следовать это) одним из</code></p>
     <p><code>следующих: kB 1000, K 1024, MB 1 000 000, M 1 048 576 и т.д.</code></p>
     <p><code>для G, T, Р, E, Z, Y.</code></p>
     <p>Чтобы еще больше усложнить дело, <code>du</code> использует <emphasis>частную</emphasis> версию <code>nftw()</code>, у которой есть несколько расширений. Сначала имеются дополнительные значения флагов для функции обратного вызова:</p>
     <p><code>FTW_DCHP</code></p>
     <p>Это значение означает, что <code>nftw()</code> не может выполнять '<code>chdir("..")</code>'.</p>
     <p><code>FTW_DCH</code></p>
     <p>Это значение означает, что <code>nftw()</code> не может использовать <code>chdir()</code> для перехода в сам каталог.</p>
     <p><code>FTW_DPRE</code></p>
     <p>Частная <code>nftw()</code> вызывает для каталогов функцию обратного вызова <emphasis>дважды</emphasis>. Это значение используется при первой встрече с каталогом. После обработки всех нижележащих объектов каталога используется стандартное значение <code>FTW_DP</code>.</p>
     <p>Частная <code>nftw()</code> добавляет также в <code>struct FTW</code> новый член, <code>int skip</code>. Если текущий объект является каталогом и функция обратного вызова устанавливает в поле <code>skip</code> ненулевое значение, <code>nftw()</code> не будет больше обрабатывать этот каталог. (Функция обратного вызова должна установить <code>skip</code> таким образом, когда <code>flag</code> равен <code>FTW_DPRE</code>; делать это для <code>FTW_DP</code> слишком поздно.)</p>
     <p>С этим объяснением за поясом, вот функция <code>process_file()</code> из <code>du.c</code>. Номера строк приведены относительно начала функции:</p>
     <p><code>1  /* Эта функция вызывается один раз для каждого объекта файловой</code></p>
     <p><code>2     системы, с которой сталкивается nftw. nftw осуществляет сначала</code></p>
     <p><code>3     поиск вглубь. Эта функция знает это и собирает итоги для каталогов</code></p>
     <p><code>4     на основе изменений в глубине текущего элемента. */</code></p>
     <p><code>5</code></p>
     <p><code>6  static int</code></p>
     <p><code>7  process_file(const char *file, const struct stat *sb,</code></p>
     <p><code>8   int file_type, struct FTW *info)</code></p>
     <p><code>9  {</code></p>
     <p><code>10  uintmax_t size;</code></p>
     <p><code>11  uintmax_t size_to_print;</code></p>
     <p><code>12  static int first_call = 1;</code></p>
     <p><code>13  static size_t prev_level;</code></p>
     <p><code>14  static size_t n_alloc;</code></p>
     <p><code>15  static uintmax_t *sum_ent;</code></p>
     <p><code>16  static uintmax_t *sum_subdir;</code></p>
     <p><code>17  int print = 1;</code></p>
     <p><code>18</code></p>
     <p><code>19  /* Всегда определяйте info-&gt;skip перед возвратом. */</code></p>
     <p><code>20  info-&gt;skip = excluded_filename(exclude, file + info-&gt;base);</code></p>
     <p><code>    /* Для --exclude */</code></p>
     <p>Эта функция делает многое, поскольку ей приходится реализовать все опции <code>du</code>. Строка 17 устанавливает <code>print</code> в true (1); по умолчанию выводятся сведения о каждом файле. Дальнейший код устанавливает ее при необходимости в false (0).</p>
     <p>Строка 20 устанавливает <code>info-&gt;skip</code> на основе опции <code>--exclude</code>. Обратите внимание, что это исключает подкаталоги, если каталог совпадает с шаблоном для <code>--exclude</code>.</p>
     <p><code>22 switch (file_type)</code></p>
     <p><code>23 {</code></p>
     <p><code>24 case FTW_NS:</code></p>
     <p><code>25  error (0, errno, _("cannot access %s"), quote(file));</code></p>
     <p><code>26  G_fail = 1; /* Установить глобальную переменную для дальнейшего */</code></p>
     <p><code>27  return 0; /* Вернуть 0 для продолжения */</code></p>
     <p><code>28</code></p>
     <p><code>29 case FTW_DCHP:</code></p>
     <p><code>30  error(0, errno, _("cannot change to parent of directory %s"),</code></p>
     <p><code>31  quote(file));</code></p>
     <p><code>32  G_fail = 1;</code></p>
     <p><code>33  return 0;</code></p>
     <p><code>34</code></p>
     <p><code>35 case FTW_DCH:</code></p>
     <p><code>36  /* Нельзя просто вернуться, поскольку, хотя nftw не может войти в</code></p>
     <p><code>37     каталог, она может использовать stat, постольку у нас есть размер */</code></p>
     <p><code>38  error(0, errno, _("cannot change to directory %s"), quote(file));</code></p>
     <p><code>39  G_fail = 1;</code></p>
     <p><code>40  break;</code></p>
     <p><code>41</code></p>
     <p><code>42 case FTW_DNR:</code></p>
     <p><code>43  /* Нельзя просто вернуться, поскольку, хотя nftw не может прочесть</code></p>
     <p><code>44     каталог, она может вызвать stat, постольку у нас есть размер. */</code></p>
     <p><code>45  error(0, errno, _("cannot read directory %s"), quote(file));</code></p>
     <p><code>46  G_fail = 1;</code></p>
     <p><code>47  break;</code></p>
     <p><code>48</code></p>
     <p><code>49 default:</code></p>
     <p><code>50  break;</code></p>
     <p><code>51 }</code></p>
     <p><code>52</code></p>
     <p><code>53 /* Если это первая (предварительная) встреча с каталогом,</code></p>
     <p><code>54    сразу вернуться. */</code></p>
     <p><code>55 if (file_type == FTW_DPRE)</code></p>
     <p><code>56  return 0;</code></p>
     <p>Строки 22–51 являются стандартным оператором <code>switch</code>. Ошибки, для которых нет информации о размере, устанавливают глобальную переменную <code>G_fail</code> в 1 и возвращают 0, чтобы продолжить обработку (см строки 24–27 и 29–33). Ошибки, для которых есть размер, также устанавливают <code>G_fail</code>, но затем прерывают <code>switch</code> для того, чтобы обработать статистику (см. строки 35–40 и 42–47).</p>
     <p>Строки 55–56 сразу завершают функцию, если это первая встреча с каталогом</p>
     <p><code>58 /* Если файл исключается или если он уже учитывался</code></p>
     <p><code>59    через прямую ссылку, не включать его в сумму. */</code></p>
     <p><code>60 if (info-&gt;skip,</code></p>
     <p><code>61  || (!opt_count_all</code></p>
     <p><code>62  &amp;&amp; 1 &lt; sb-&gt;st_nlink</code></p>
     <p><code>63  &amp;&amp; hash_ins(sb-&gt;st_ino, sb-&gt;st_dev)))</code></p>
     <p><code>64 {</code></p>
     <p><code>65  /* Заметьте, мы не должны здесь просто возвращаться.</code></p>
     <p><code>66     Нам все еще нужно обновить prev_level и, возможно, передать</code></p>
     <p><code>67     некоторые суммы выше по иерархии. */</code></p>
     <p><code>68  size = 0;</code></p>
     <p><code>69  print = 0;</code></p>
     <p><code>70 }</code></p>
     <p><code>71 else</code></p>
     <p><code>72 {</code></p>
     <p><code>73  size = (apparent_size</code></p>
     <p><code>74    ? sb-&gt;st_size</code></p>
     <p><code>75    : ST_NBLOCKS (*sb) * ST_NBLOCKSIZE);</code></p>
     <p><code>76  }</code></p>
     <p>Теперь становится интересно. По умолчанию <code>du</code> подсчитывает пространство, занимаемое прямыми ссылками, лишь одни раз. Опция <code>--count-links</code> заставляет ее подсчитывать пространство для каждой ссылки; переменная <code>opt_count_all</code> равна true, когда указана <code>--count-links</code>. Для отслеживания ссылок <code>du</code> содержит хэш-таблицу<a l:href="#n87" type="note">[87]</a> уже встречавшихся пар (устройство, индекс).</p>
     <p>Строки 60–63 проверяют, следует ли не включать файл в подсчет, либо из-за того, что он был исключен (<code>info-&gt;skip</code> равно true, строка 60), либо потому что не была указана <code>--count-links</code> (строка 61) <emphasis>и</emphasis> у файла несколько ссылок (строка 62) <emphasis>и</emphasis> файл уже находится в хеш-таблице (строка 63). В этом случае размер устанавливается в 0, поэтому он не входит в конечную сумму, a <code>print</code> также устанавливается в false (строки 68–69).</p>
     <p>Если ни одно из этих условий не отмечается, размер вычисляется либо в соответствии с размером в <code>struct stat</code>, либо в соответствии с числом блоков диска (строки 73–75) Это решение основывается на переменной <code>apparent_size</code>, которая установлена при использовании опции <code>--apparent-size</code>.</p>
     <p><code>78 if (first_call)</code></p>
     <p><code>79 {</code></p>
     <p><code>80  n_alloc = info-&gt;level + 10; /* Allocate arrays */</code></p>
     <p><code>81  sum_ent = XCALLOC(uintmax_t, n_alloc); /* to hold sums */</code></p>
     <p><code>82  sum_subdir = XCALLOC(uintmax_t, n_alloc);</code></p>
     <p><code>83 }</code></p>
     <p><code>84 else</code></p>
     <p><code>85 {</code></p>
     <p><code>86  /* FIXME: Стыдно, что нам нужно приводить к типу size_t для избежания</code></p>
     <p><code>87     предупреждений gcc о 'сравнении между знаковым и беззнаковым'.</code></p>
     <p><code>88     Возможно, неизбежно, при условии, что члены структуры FTW</code></p>
     <p><code>89     имеют тип 'int' (исторически), так как мне нужно, чтобы переменные</code></p>
     <p><code>90     вроде n_alloc и prev_level имели осмысленные типы. */</code></p>
     <p><code>91  if (n_alloc &lt;= (size_t)info-&gt;level)</code></p>
     <p><code>92  {</code></p>
     <p><code>93   n_alloc = info-&gt;level * 2; /* Удвоить сумму */</code></p>
     <p><code>94   sum_ent = XREALLOC(sum_ent, uintmax_t, realloc); /* И выделить повторно */</code></p>
     <p><code>95   sum_subdir = XREALLOC(sum_subdir, uintmax_t, n_alloc);</code></p>
     <p><code>96  }</code></p>
     <p><code>97 }</code></p>
     <p><code>98</code></p>
     <p><code>99 size_to_print = size;</code></p>
     <p>Строки 78–97 управляют динамической памятью, используемой для хранения статистики о размере файла, <code>first_call</code> является статической переменной (строка 12), которая равна true при первом вызове <code>process_file()</code>. В этом случае вызывается <code>calloc()</code> (через упаковывающий макрос в строках 81–82; это обсуждалось в разделе 3.2.1.8 «Пример чтение строк произвольной длины»). Остальную часть времени <code>first_call</code> равно false, и используется <code>realloc()</code> (снова через упаковывающий макрос, строки 91–96).</p>
     <p>Строка 99 заносит значение <code>size</code> в <code>size_to_print</code>; эта переменная может обновляться в зависимости от того, должна ли она включать размеры дочерних элементов. Хотя <code>size</code> могла бы использоваться повторно, отдельная переменная упрощает чтение кода.</p>
     <p><code>101 if (!first_call)</code></p>
     <p><code>102 {</code></p>
     <p><code>103  if ((size_t)info-&gt;level == prev_level)</code></p>
     <p><code>104  {</code></p>
     <p><code>105   /* Обычно самый частый случай. Ничего не делать. */</code></p>
     <p><code>106  }</code></p>
     <p><code>107  else if ((size_t)info-&gt;level &gt; prev_level)</code></p>
     <p><code>108  {</code></p>
     <p><code>109   /* Нисхождение по иерархии.</code></p>
     <p><code>110      Очистить аккумуляторы для *всех* уровней между prev_level</code></p>
     <p><code>111      и текущим. Глубина может значительно меняться,</code></p>
     <p><code>112      например, от 1 до 10. */</code></p>
     <p><code>113   int i;</code></p>
     <p><code>114   for (i = prev_level +1; i &lt;= info-&gt;level; i++)</code></p>
     <p><code>115    sum_ent[i] = sum_subdir[i] = 0;</code></p>
     <p><code>116  }</code></p>
     <p><code>117  else /* info-&gt;level &lt; prev_level */</code></p>
     <p><code>118  {</code></p>
     <p><code>119   /* Восхождение по иерархии.</code></p>
     <p><code>120      nftw обрабатывает каталог лишь после всех элементов,</code></p>
     <p><code>121      в которых был обработан каталог. Когда глубина уменьшается,</code></p>
     <p><code>122      передать суммы от детей (prev_level) родителям.</code></p>
     <p><code>123      Здесь текущий уровень всегда меньше, чем</code></p>
     <p><code>124      предыдущий. */</code></p>
     <p><code>125   assert (&lt;size_t) info-&gt;level == prev_level - 1);</code></p>
     <p><code>126   size_to_print += sum_ent[prev_level];</code></p>
     <p><code>127   if (!opt_separate_dirs)</code></p>
     <p><code>128    size_to_print += sum_subdir[prev_level];</code></p>
     <p><code>129   sum_subdir[info-&gt;level] += (sum_ent[prev_level]</code></p>
     <p><code>130    + sum_subdir[prev_level]);</code></p>
     <p><code>131  }</code></p>
     <p><code>132 }</code></p>
     <p>Строки 101–132 сравнивают текущий уровень с предыдущим. Возможны три случая.</p>
     <p><emphasis>Уровни те же самые</emphasis></p>
     <p>В этом случае нет необходимости беспокоиться о статистике дочерних элементов. (Строки 103–106.)</p>
     <p><emphasis>Текущий уровень выше предыдущего</emphasis></p>
     <p>В этом случае мы спустились по иерархии, и статистику нужно восстановить (строки 107–116). Термин «аккумулятор» в комментарии подходящий: каждый элемент аккумулирует общее дисковое пространство, использованное на этом уровне. (На заре вычислительной техники регистры центрального процессора часто назывались «аккумуляторами».)</p>
     <p><emphasis>Текущий уровень ниже предыдущего</emphasis></p>
     <p>В этом случае мы завершили обработку всех дочерних элементов каталога и только что вернулись обратно в родительский каталог (строки 117–131). Код обновляет суммы, включая <code>size_to_print</code>.</p>
     <p><code>134 prev_level = info-&gt;level; /* Установить статические переменные */</code></p>
     <p><code>135 first_call = 0;</code></p>
     <p><code>136</code></p>
     <p><code>137 /* Включить элемент каталога в общую сумму для содержащего</code></p>
     <p><code>138    каталога, если не указана --separate-dirs (-S). */</code></p>
     <p><code>139 if (!(opt_separate_dirs &amp;&amp; IS_FTW_DIR_TYPE(file_type)))</code></p>
     <p><code>140  sum_ent[info-&gt;level] += size;</code></p>
     <p><code>141</code></p>
     <p><code>142 /* Даже если каталог нельзя прочесть или перейти в него,</code></p>
     <p><code>143    включить его размер в общую сумму, ... */</code></p>
     <p><code>144 tot_size += size;</code></p>
     <p><code>145</code></p>
     <p><code>146 /* ...но не выводить для него итог, поскольку без размера(-ов)</code></p>
     <p><code>147    потенциальных элементов, это может сильно запутывать. */</code></p>
     <p><code>148 if (file_type == FTW_DNR || file_type == FTW_DCH)</code></p>
     <p><code>149  return 0;</code></p>
     <p><code>150</code></p>
     <p><code>151 /* Если мы не считаем элемент, например, потому что это прямая</code></p>
     <p><code>152    ссылка на файл, который уже посчитан (и --count-links), не</code></p>
     <p><code>153    выводить для него строку. */</code></p>
     <p><code>154 if (!print)</code></p>
     <p><code>155  return 0;</code></p>
     <p>Строки 134–135 устанавливают статические переменные <code>prev_level</code> и <code>first_call</code> таким образом, что они содержат правильные значения для последующего вызова <code>process_file()</code>, гарантируя, что весь предыдущий код работает правильно.</p>
     <p>Строки 137–144 выверяют статистику на основе опций и типа файла. Комментарии и код достаточно просты. Строки 146–155 сразу завершают функцию, если сведения не должны выводиться.</p>
     <p><code>157  /* FIXME: Это выглядит подозрительно годным для упрощения. */</code></p>
     <p><code>158  if ((IS_FTW_DIR_TYPE(file_type) &amp;&amp;</code></p>
     <p><code>159   (info-&gt;level &lt;= max_depth || info-&gt;level == 0))</code></p>
     <p><code>160   || &lt;(opt_all &amp;&amp; info-&gt;level &lt;= max_depth) || info-&gt;level == 0))</code></p>
     <p><code>161  {</code></p>
     <p><code>162   print_only_size(size_to_print);</code></p>
     <p><code>163   fputc('\t', stdout);</code></p>
     <p><code>164   if (arg_length)</code></p>
     <p><code>165   {</code></p>
     <p><code>166    /* Вывести имя файла, но без суффикса каталога '.' или '/.'</code></p>
     <p><code>167       который мы, возможно, добавили в main. */</code></p>
     <p><code>168    /* Вывести все до добавленной нами части. */</code></p>
     <p><code>169    fwrite(file, arg_length, 1, stdout);</code></p>
     <p><code>170    /* Вывести все после добавленного нами. */</code></p>
     <p><code>171    fputs(file + arg_length + suffix_length</code></p>
     <p><code>172     + (file[arg_length + suffix_length] == '/'), stdout);</code></p>
     <p><code>173   }</code></p>
     <p><code>174   else</code></p>
     <p><code>175   {</code></p>
     <p><code>176    fputs(file, stdout);</code></p>
     <p><code>177   }</code></p>
     <p><code>178   fputc('\n', stdout);</code></p>
     <p><code>179   fflush(stdout);</code></p>
     <p><code>180  }</code></p>
     <p><code>181</code></p>
     <p><code>182  return 0;</code></p>
     <p><code>183 }</code></p>
     <p>Условие в строках 158–160 сбивает с толку, и комментарий в строке 157 указывает на это. Условие утверждает: «Если (1a) файл является каталогом и (1b) уровень меньше максимального для вывода (переменные — <code>-max-depth</code> и <code>max_depth</code>) или нулевой, <emphasis>или</emphasis> (2a) должны быть выведены все файлы и уровень меньше, чем максимальный для вывода, или (2b) уровень нулевой», тогда вывести файл. (Версия <code>du</code> после 5.0 использует в этом случае несколько менее запутанное условие.)</p>
     <p>Строки 162–179 осуществляют вывод. Строки 162–163 выводят размер и символ TAB Строки 164–173 обрабатывают специальный случай. Это объяснено далее в <code>du.c</code>, в строках файла 524–529:</p>
     <p><code>524 /* При разыменовании лишь аргументов командной строки мы</code></p>
     <p><code>525    используем флаг nftw FTW_PHYS, поэтому символическая ссылка</code></p>
     <p><code>526    на каталог, указанная в командной строке, в норме не</code></p>
     <p><code>527    разыменовывается. Для решения этого мы идем на издержки,</code></p>
     <p><code>528    сначала добавляя '/.' (или '.'), а затем удаляем их каждый раз</code></p>
     <p><code>529    при выводе имени производного файла или каталога. */</code></p>
     <p>В этом случае <code>arg_length</code> равен true, поэтому строки 164–173 должны вывести первоначальное имя, а не измененное В противном случае строки 174–177 могут вывести имя как есть.</p>
     <p>Фу! Куча кода. Мы находим, что это верхний уровень спектра сложности, по крайней мере, насколько это может быть просто представлено в книге данного содержания. Однако, он демонстрирует, что код из реальной жизни часто бывает сложным. Лучшим способом справиться с этой сложностью является ясное именование переменных и подробные комментарии <code>du.с</code> в этом отношении хорош; мы довольно легко смогли извлечь и изучить код без необходимости показывать все 735 строк программы!</p>
    </section>
    <section>
     <title>
      <p>8.6. Изменение корневого каталога: <code>chroot()</code></p>
     </title>
     <p>Текущий рабочий каталог, установленный с помощью <code>chdir(</code>) (см. раздел 8.4.1 «Изменение каталога — <code>chdir()</code> и <code>fchdir()</code>»), является атрибутом процесса, таким же, как набор открытых файлов. Он также наследуется новыми процессами.</p>
     <p>Менее известным является то, что у каждого процесса есть также <emphasis>текущий корневой каталог</emphasis>. Это именно на этот каталог ссылается имя пути <code>/</code>. В большинстве случаев корневые каталоги процесса и системы идентичны. Однако, суперпользователь может изменить корневой каталог с помощью (как вы догадались) системного вызова <code>chroot()</code>:</p>
     <p><code>#include &lt;unistd.h&gt; /* Обычный */</code></p>
     <empty-line/>
     <p><code>int chroot(const char *path);</code></p>
     <p>Возвращаемое значение равно 0 при успешном завершении и -1 при ошибке.</p>
     <p>Как указывает справочная страница GNU/Linux <emphasis>chroot</emphasis>(2), изменение корневого каталога не изменяет текущий каталог: программы, которые должны обеспечить нахождение под новым корневым каталогом, должны также вызвать затем <code>chdir()</code>: </p>
     <p><code>if (chroot("/new/root") &lt; 0) /* Установить новый корневой каталог */</code></p>
     <p><code> /* обработать ошибку */</code></p>
     <p><code>if (chdir("/some/dir") &lt; 0) /* Пути даны не относительно нового корневого каталога */</code></p>
     <p><code> /* обработать ошибку */</code></p>
     <p>Системный вызов <code>chroot()</code> чаще всего используется для <emphasis>демонов</emphasis> — фоновых программ, которые должны работать в специальном ограниченном окружении. Например, рассмотрите демон Интернета FTP, допускающий анонимный FTP (соединение любого клиента из любого места, без обычных имени пользователя и пароля). Очевидно, такое соединение не должно быть способным видеть все файлы целой системы. Вместо этого демон FTP выполняет <code>chroot()</code> в специальный каталог со структурой, достаточной лишь чтобы позволить ему функционировать. (Например, со своим собственным <code>/bin/ls</code> для перечисления файлов, со своей копией библиотеки С времени исполнения, если она разделяется, и, возможно, со своей копией <code>/etc/passwd</code> и <code>/etc/group</code> для отображения ограниченного набора имен пользователей и групп.)</p>
     <p>POSIX не стандартизует этот системный вызов, хотя GNU/Linux и все системы Unix его поддерживают. (Он популярен с V7.) Он специализирован, но при необходимости очень удобен.</p>
    </section>
    <section>
     <title>
      <p>8.7. Резюме</p>
     </title>
     <p>• Файловые системы являются коллекциями блоков индексов, данных, вспомогательных данных и свободных блоков, организованных особым способом. Файловые системы один к одному соответствуют (физическим или логическим) разделам, на которых они создаются. У каждой файловой системы есть свой корневой каталог; по соглашению, у корневого каталога номер индекса всегда равен 2.</p>
     <p>• Команда <code>mount</code> монтирует файловую систему, наращивая логическое иерархическое пространство имен файлов. Команда <code>umount</code> отсоединяет файловую систему. Ядро делает <code>/.</code> и <code>/..</code> одним и тем же; корневой каталог всего пространства имен является своим собственным родителем. Во всех остальных случаях ядро устанавливает в корневом каталоге смонтированной файловой системы указывающим на родительский каталог точки монтирования.</p>
     <p>• Современные Unix-системы поддерживают множество типов файловых систем. В частности, повсеместно поддерживается сетевая файловая система (NFS) Sun, также, как ISO 9660 является стандартным форматом для CD-ROM, а разделы FAT MS- DOS поддерживаются на всех Unix-системах, работающих на платформе Intel x86. Насколько мы знаем, Linux поддерживает наибольшее число различных файловых систем — свыше 30! Многие из них специализированные, но многие из оставшихся предназначены для общего использования, включая по крайней мере четыре различные журналируемые файловые системы.</p>
     <p>• Файл <code>/etc/fstab</code> перечисляет разделы каждой системы, их точки монтирования и относящиеся к монтированию опции, <code>/etc/mtab</code> перечисляет те файловые системы, которые смонтированы в настоящее время, то же делает <code>/proc/mounts</code> на системах GNU/Linux. Опция <code>loop</code> функции <code>mount</code> особенно полезна под GNU/Linux для монтирования образов файловых систем, содержащихся в обычных файлах, таких, как образы CD-ROM. Другие опции полезны для безопасности и монтирования внешних файловых систем, таких, как файловые системы vfat Windows.</p>
     <p>• Файлы формата <code>/etc/fstab</code> можно читать с помощью набора процедур <code>getmntent()</code>. Формат GNU/Linux общий с рядом других коммерческих вариантов Unix, особенно Sun Solaris.</p>
     <p>• Функции <code>statvfs()</code> и <code>fstatvfs()</code> стандартизованы POSIX для получения сведений о файловой системе, таких, как число свободных и используемых дисковых блоков, число свободных и используемых индексов и т.д. В Linux есть свой собственный системный вызов для получения подобной информации: <code>statfs()</code> и <code>fstatfs()</code>.</p>
     <p>• <code>chdir()</code> и <code>fchdir()</code> дают процессу возможность изменить его текущий каталог, <code>getcwd()</code> получает абсолютное имя пути текущего каталога. Эти три функции просты в использовании.</p>
     <p>• Функция <code>nftw()</code> централизует задачу «обхода дерева файлов», т.е. посещения каждого объекта файловой системы (файла, устройства, символической ссылки, каталога) во всей иерархии каталогов. Ее поведением управляют различные флаги. Программист должен предоставить функцию обратного вызова, которая получает имя каждого файла, <code>struct stat</code> для файла, тип файла и сведения об имени файла и уровне в иерархии. Эта функция может делать для каждого файла все что нужно. Версия функции <code>du</code> из Coreutils 5.0 GNU использует для выполнения этой работы расширенную версию <code>nftw()</code>.</p>
     <p>• Наконец, системный вызов <code>chroot()</code> изменяет текущий корневой каталог процесса. Это специализированная, но важная возможность, которая особенно полезна для определенных программ в стиле демонов.</p>
    </section>
    <section>
     <title>
      <p>Упражнения</p>
     </title>
     <p>1. Изучите справочную страницу <emphasis>mount</emphasis>(2) под GNU/Linux и на всех различных системах Unix, к которым у вас есть доступ. Как отличаются системные вызовы?</p>
     <p>2. Усовершенствуйте программу <code>ch08-statvfs.c</code>, чтобы она принимала опцию, предоставляющую открытый целый дескриптор файла; для получения сведений о файловой системе она должна использовать <code>fstatvfs()</code>.</p>
     <p>3. Усовершенствуйте <code>ch08-statvfs.c</code>, чтобы она не игнорировала смонтированные файловые системы NFS. Такие файловые системы имеют устройство в форме <code>server.example.com:/big/disk</code>.</p>
     <p>4. Измените <code>ch08-statfs.c</code> (ту, которая использует специфичный для Linux вызов <code>statfs()</code>), чтобы ее вывод был похож на вывод <code>df</code>.</p>
     <p>5. Добавьте опцию <code>-i</code> к программе, которую вы написали для предыдущего упражнения, чтобы ее вывод был такой же, как у '<code>df -i</code>'.</p>
     <p>6. Используя <code>opendir()</code>, <code>readdir()</code>, <code>stat()</code> или <code>fstat()</code>, <code>dirfd()</code> и <code>fchdir()</code>, напишите собственную версию <code>getcwd()</code>. Как вы вычислите общий размер, который должен иметь буфер? Как вы будете перемещаться по иерархии каталогов?</p>
     <p>7. Усовершенствуйте свою версию <code>getcwd()</code>, чтобы она выделяла буфер для вызывающего, если первый аргумент равен NULL.</p>
     <p>8. Можете ли вы использовать <code>nftw()</code> для написания <code>getcwd()</code>? Если нет, почему?</p>
     <p>9. Используя <code>nftw()</code>, напишите свою собственную версию <code>chown</code>, которая принимает опцию <code>-R</code> для рекурсивной обработки целых деревьев каталогов. Убедитесь, что без <code>-R</code>, '<code>chown <emphasis>пользователь каталог</emphasis></code>' <emphasis>не</emphasis> является рекурсивной. Как вы это проверите?</p>
     <p>10. Набор процедур BSD <code>fts()</code> («file tree stream» — «поток дерева файлов») предоставляет другой способ для обработки иерархии каталогов. У него несколько более тяжелый API как в смысле числа функций, так и структур, которые доступны для вызывающих функций уровня пользователя. Эти функции доступны как стандартная часть GLIBC.</p>
     <p>Прочтите справочную страницу <emphasis>fts</emphasis>(3). (Для удобства ее можно распечатать.) Перепишите свою частную версию chown для использования <code>fts()</code>.</p>
     <p>11. Посмотрите справочную страницу <emphasis>find</emphasis>(1). Если бы вы пытались написать <code>find</code> с самого начала, какой набор деревьев файлов вы бы предпочли, <code>nftw()</code> или <code>fts()</code>? Почему?</p>
    </section>
   </section>
  </section>
  <section>
   <title>
    <p>Часть 2</p>
    <p>Процессы, IPC и интернационализация</p>
   </title>
   <section>
    <title>
     <p>Глава 9</p>
     <p>Управление процессами и каналы</p>
    </title>
    <section>
     <p>Как мы говорили в главе 1 «Введение», если бы нужно было резюмировать Unix (а следовательно, и Linux) в трёх словах, это были бы «файлы и процессы». Теперь, когда мы увидели, как работать с файлами и каталогами, время взглянуть на оставшуюся часть утверждения: процессы. В частности, мы исследуем, как создаются и управляются процессы, как они взаимодействуют с открытыми файлами и как они могут взаимодействовать друге другом. Последующие главы исследуют сигналы — грубый способ дать возможность одному процессу (или ядру) сообщить другому о том, что произошло некоторое событие — и проверку прав доступа.</p>
     <p>В данной главе картина начинает усложняться. В частности, для полноты мы должны упомянуть о вещах, которые не будут рассматриваться до конца главы или до конца книги В таких случаях мы предусмотрели ссылки вперед, но вы должны быть способны без подготовки уловить суть каждого раздела.</p>
    </section>
    <section>
     <title>
      <p>9.1. Создание и управление процессами</p>
     </title>
     <section>
      <p>В отличие от многих предшествующих и последующих операционных систем, создание процессов в Unix задумывалось (и было сделано) дешевым. Более того, Unix разделяет идеи «создания нового процесса» и «запуска данной программы в процессе». Это было элегантное проектное решение, которое упрощает многие операции.</p>
     </section>
     <section>
      <title>
       <p>9.1.1. Создание процесса: <code>fork()</code></p>
      </title>
      <section>
       <p>Первым шагом в запуске новой программы является вызов <code>fork()</code>:</p>
       <p><code>#include &lt;sys/types.h&gt; /* POSIX */</code></p>
       <p><code>#include &lt;unistd.h&gt;</code></p>
       <empty-line/>
       <p><code>pid_t fork(void);</code></p>
       <p>Использование <code>fork()</code> просто. Перед вызовом один процесс, который мы называем <emphasis>родительским</emphasis>, является запущенным. Когда <code>fork()</code> возвращается, имеется уже два процесса: родительский и <emphasis>порожденный (child)</emphasis>.</p>
       <p>Вот ключ: <emphasis>оба процесса выполняют одну и ту же программу</emphasis>. Два процесса могут различить себя, основываясь на возвращённом <code>fork()</code> значении:</p>
       <p><emphasis>Отрицательное</emphasis></p>
       <p>Если была ошибка, <code>fork()</code> возвращает -1, а новый процесс не создается. Работу продолжает первоначальный процесс.</p>
       <p><emphasis>Нулевое</emphasis></p>
       <p>В порожденном процессе <code>fork()</code> возвращает 0.</p>
       <p><emphasis>Положительное</emphasis></p>
       <p>В родительском процессе <code>fork()</code> возвращает положительный идентификационный номер (PID) порожденного процесса.</p>
       <p>Код шаблона для создания порожденного процесса выглядит следующим образом:</p>
       <p><code>pid_t child;</code></p>
       <p><code>if ((child = fork()) &lt; 0)</code></p>
       <p><code> /* обработать ошибку */</code></p>
       <p><code>else if (child == 0)</code></p>
       <p><code> /* это новый процесс */</code></p>
       <p><code>else</code></p>
       <p><code> /* это первоначальный родительский процесс */</code></p>
       <p><code>pid_t</code> является знаковым целым типом для хранения значений PID. Скорее всего, это просто <code>int</code>, но специальный тип делает код более понятным, поэтому он должен использоваться вместо <code>int</code>.</p>
       <p>На языке Unix, помимо названия системного вызова, слово «fork» является и глаголом, и существительным<a l:href="#n88" type="note">[88]</a>. Мы можем сказать, что «один процесс ответвляет другой», и что «после разветвления работают два процесса». (Думайте «развилка (fork) на дороге», а не «вилка (fork), нож и ложка».)</p>
      </section>
      <section>
       <title>
        <p>9.1.1.1. После <code>fork()</code>: общие и различные атрибуты</p>
       </title>
       <p>Порожденный процесс «наследует» идентичные копии большого числа атрибутов от родителя. Многие из этих атрибутов специализированы и здесь неуместны. Поэтому следующий список намеренно неполон. Существенны следующие:</p>
       <p>• Окружение, см. раздел 2.4 «Окружение».</p>
       <p>• Все открытые файлы и открытые каталоги; см. раздел 4.4.1 «Понятие о дескрипторах файлов» и раздел 5.3.1 «Базовое чтение каталогов».</p>
       <p>• Установки umask; см. раздел 4.6 «Создание файлов».</p>
       <p>• Текущий рабочий каталог; см раздел 8.4.1 «Смена каталога: <code>chdir()</code> и <code>fchdir()</code>.</p>
       <p>• Корневой каталог; см. раздел 8.6 «Изменение корневого каталога: <code>chroot()</code>».</p>
       <p>• Текущий приоритет (иначе называемый «значение nice»; вскоре мы это обсудим; см раздел 9.1.3 «Установка приоритета процесса: <code>nice()</code>»).</p>
       <p>• Управляющие терминалы. Это устройство терминала (физическая консоль или окно эмулятора терминала), которому разрешено посылать процессу сигналы (такие, как CTRL-Z для прекращения выполняющихся работ). Это обсуждается далее в разделе 9.2.1 «Обзор управления работой».</p>
       <p>• Маска сигналов процесса и расположение всех текущих сигналов (еще не обсуждалось; см. главу 10 «Сигналы»).</p>
       <p>• Реальный, эффективный и сохраненный ID пользователя, группы и набора дополнительных групп (еще не обсуждалось; см. главу 11 «Права доступа и ID пользователя и группы»).</p>
       <p>Помимо возвращаемого значения <code>fork()</code> два процесса различаются следующим образом:</p>
       <p>• У каждого есть уникальный ID процесса и ID родительского процесса (PID и PPID) Они описаны в разделе 9.1.2 «Идентификация процесса: <code>getpid()</code> и <code>getppid()</code>».</p>
       <p>• PID порожденного процесса не будет равняться ID любой существующей группы процессов (см. раздел 9.2 «Группы процессов»).</p>
       <p>• Аккумулированное время использования процессора для порожденного процесса и его будущих потомков инициализируется нулем. (Это имеет смысл; в конце концов, это совершенно новый процесс.)</p>
       <p>• Любые сигналы, которые были ожидающими в родительском процессе, в порожденном сбрасываются, также как ожидающие аварийные сигналы и таймеры. (Мы еще не рассматривали эти темы; см. главу 10 «Сигналы» и раздел 14.3.3 «Интервальные таймеры: <code>setitimer()</code> и <code>getitimer()</code>».)</p>
       <p>• Блокировки файлов в родительском процессе не дублируются в порожденном (также еще не обсуждалось; см. раздел 14.2 «Блокировка файлов»).</p>
      </section>
      <section>
       <title>
        <p>9.1.1.2. Разделение дескрипторов файлов</p>
       </title>
       <p>Атрибуты, которые порожденный процесс наследует от родителя, устанавливаются в те же значения, которые были в родительском процессе в момент выполнения <code>fork()</code>. Однако, с этого момента два процесса продолжают идти собственными путями (большей частью) независимо один от другого. Например, если порожденный процесс изменяет каталог, каталог родительского процесса не затрагивается. Сходным образом, если порожденный изменяет среду, среда родителя <emphasis>не</emphasis> меняется.</p>
       <p>Открытые файлы являются важным исключением из этого правила. Дескрипторы открытых файлов являются <emphasis>разделяемыми</emphasis>, и действия одного процесса с разделяемым дескриптором файла затрагивает состояние файла также и для другого процесса. Это лучше всего понять, изучив рис. 9.1.</p>
       <image l:href="#img_14.jpeg"/>
       <p><strong>Рис. 9.1</strong>. Разделение дескрипторов файлов</p>
       <p>Рисунок отображает внутренние структуры данных ядра. Ключевой структурой данных является <emphasis>таблица файлов</emphasis>. Каждый элемент ссылается на открытый файл. Помимо других учетных данных, таблица файлов содержит текущее положение (смещение чтения/записи) в файле. Оно устанавливается либо автоматически каждый раз при чтении или записи файла, либо непосредственно через <code>lseek()</code> (см. раздел 4.5 «Произвольный доступ: перемещения внутри файла»).</p>
       <p>Дескриптор файла, возвращенный функциями <code>open()</code> или <code>creat()</code>, действует как индекс имеющегося в каждом процессе массива указателей на таблицу файлов. Размер этого массива не превышает значение, возвращенное <code>getdtablesize()</code> (см. раздел 4.4.1 «Понятие о дескрипторах файлов»).</p>
       <p>На рис. 9.1 показаны два процесса, разделяющие стандартный ввод и стандартный вывод; для каждого из процессов указаны одни и те же элементы в таблице файлов. Поэтому, когда процесс 45 (порожденный) осуществляет <code>read()</code>, общее смещение обновляется; следующий раз, когда процесс 42 (родитель) осуществляет <code>read()</code>, он начинает с позиции, в которой закончила чтение <code>read()</code> процесса 45.</p>
       <p>Это легко можно видеть на уровне оболочки:</p>
       <p><code>$ <strong>cat data</strong> /* Показать содержание демонстрационного файла */</code></p>
       <p><code>line 1</code></p>
       <p><code>line 2</code></p>
       <p><code>line 3</code></p>
       <p><code>line 4</code></p>
       <p><code>$ <strong>ls -l test1 ; cat test1</strong> /* Режим и содержание тестовой программы */</code></p>
       <p><code>-rwxr-xr-x 1 arnold devel 93 Oct 20 22:11 test1</code></p>
       <p><code>#! /bin/sh</code></p>
       <p><code>read line ; echo p: $line /* Прочесть строку в родительской оболочке,</code></p>
       <p><code>                             вывести ее */</code></p>
       <p><code>( read line ; echo с: $line ) /* Прочесть строку в порожденной оболочке,</code></p>
       <p><code>                                 вывести ее */</code></p>
       <p><code>read line ; echo p: $line /* Прочесть строку в родительской оболочке,</code></p>
       <p><code>                             вывести ее */</code></p>
       <p><code>$ <strong>test1 &lt; data</strong> /* Запустить программу */</code></p>
       <p><code>p: line 1 /* Родитель начинает сначала */</code></p>
       <p><code>c: line 2 /* Порожденный продолжает оттуда, где остановился родитель */</code></p>
       <p><code>p: line 3 /* Родитель продолжает оттуда, где остановился порожденный */</code></p>
       <p>Первая исполняемая строка <code>test1</code> читает из стандартного ввода строку, изменяя смещение файла. Следующая строка <code>test1</code> запускает команды, заключенные между скобками, в подоболочке (subshell). Это отдельный процесс оболочки, созданный — как вы догадались — с помощью <code>fork()</code>. Порожденная подоболочка наследует от родителя стандартный ввод, включая текущее смещение. Этот процесс читает строку и обновляет разделяемое смещение в файле. Когда третья строка, снова в родительской оболочке, читает файл, она начинает там, где остановился порожденный.</p>
       <p>Хотя команда <code>read</code> встроена в оболочку, все работает таким же образом и для внешних команд. В некоторых ранних Unix-системах была команда <code>line</code>, которая читала одну строку ввода (по одному символу за раз!) для использования в сценариях оболочки; если бы смещение файла не было разделяемым, было бы невозможно использовать такую команду в цикле.</p>
       <p>Разделение дескрипторов файлов и наследование играют центральную роль в перенаправлении ввода/вывода оболочки; системные вызовы и их семантика делают примитивы уровня оболочки простыми для реализации на С, как мы позже увидим в данной главе.</p>
      </section>
      <section>
       <title>
        <p>9.1.1.3. Разделение дескрипторов файлов и <code>close()</code></p>
       </title>
       <p>Тот факт, что несколько дескрипторов файлов могут указывать на один и тот же открытый файл, имеет важное следствие: <emphasis>файл не закрывается до тех пор, пока не будут закрыты все дескрипторы файла</emphasis>.</p>
       <p>Позже в главе мы увидим, что несколько дескрипторов для одного файла могут существовать не только для разных процессов, но даже и внутри одного и того же процесса; это правило особенно важно для работы с каналами (pipes).</p>
       <p>Если вам нужно узнать, открыты ли два дескриптора для одного и того же файла, можете использовать <code>fstat()</code> (см. раздел 5.4.2 «Получение сведений о файле») для двух дескрипторов с двумя различными структурами <code>struct stat</code>. Если соответствующие поля <code>st_dev</code> и <code>st_ino</code> равны, это один и тот же файл.</p>
       <p>Позже в главе мы завершим обсуждение манипуляций с дескрипторами файлов и таблицей дескрипторов файлов.</p>
      </section>
     </section>
     <section>
      <title>
       <p>9.1.2. Идентификация процесса: <code>getpid()</code> и <code>getppid()</code></p>
      </title>
      <p>У каждого процесса есть уникальный ID номер процесса (PID). Два системных вызова предоставляют текущий PID и PID родительского процесса:</p>
      <p><code>#include &lt;sys/types.h&gt; /* POSIX */</code></p>
      <p><code>#include &lt;unistd.h&gt;</code></p>
      <empty-line/>
      <p><code>pid_t getpid(void);</code></p>
      <p><code>pid_t getppid(void);</code></p>
      <p>Функции так просты, как выглядят:</p>
      <p><code>pid_t getpid(void) </code>Возвращает PID текущего процесса</p>
      <p><code>pid_t getppid(void)</code>Возвращает PID родителя.</p>
      <p>Значения PID уникальны; по определению, не может быть двух запущенных процессов с одним и тем же PID. PID обычно возрастают в значении, так что порожденный процесс имеет обычно больший PID, чем его родитель. Однако, на многих системах значения PID <emphasis>переполняются</emphasis>; когда достигается значение системного максимума для PID, следующий процесс создается с наименьшим не используемым номером PID. (Ничто в POSIX не требует такого поведения, и некоторые системы назначают неиспользуемые номера PID случайным образом.)</p>
      <p>Если родительский процесс завершается, порожденный получает нового родителя, <code>init</code>. В этом случае PID родителя будет 1, что является PID <code>init</code>. Такой порожденный процесс называется <emphasis>висячим (orphan)</emphasis>. Следующая программа, <code>ch09-reparent.с</code>, демонстрирует это. Это также первый пример <code>fork()</code> в действии:</p>
      <p><code>1  /* ch09-reparent.c --- показывает, что getppid() может менять значения */</code></p>
      <p><code>2</code></p>
      <p><code>3  #include &lt;stdio.h&gt;</code></p>
      <p><code>4  #include &lt;errno.h&gt;</code></p>
      <p><code>5  #include &lt;sys/types.h&gt;</code></p>
      <p><code>6  #include &lt;unistd.h&gt;</code></p>
      <p><code>7</code></p>
      <p><code>8  /* main --- осуществляет работу */</code></p>
      <p><code>9</code></p>
      <p><code>10 int main(int argc, char **argv)</code></p>
      <p><code>11 {</code></p>
      <p><code>12  pid_t pid, old_ppid, new_ppid;</code></p>
      <p><code>13  pid_t child, parent;</code></p>
      <p><code>14</code></p>
      <p><code>15  parent = getpid(); /* перед fork() */</code></p>
      <p><code>16</code></p>
      <p><code>17  if ((child = fork()) &lt; 0) {</code></p>
      <p><code>18   fprintf(stderr, "%s: fork of child failed: %s\n",</code></p>
      <p><code>19    argv[0], strerror(errno));</code></p>
      <p><code>20   exit(1);</code></p>
      <p><code>21  } else if (child == 0) {</code></p>
      <p><code>22   old_ppid = getppid();</code></p>
      <p><code>23   sleep(2); /* см. главу 10 */</code></p>
      <p><code>24   new_ppid = getppid();</code></p>
      <p><code>25  } else {</code></p>
      <p><code>26   sleep(1);</code></p>
      <p><code>27   exit(0); /* родитель завершается после fork() */</code></p>
      <p><code>28  }</code></p>
      <p><code>29</code></p>
      <p><code>30  /* это выполняет только порожденный процесс */</code></p>
      <p><code>31  printf("Original parent: %d\n", parent);</code></p>
      <p><code>32  printf("Child: %d\n", getpid());</code></p>
      <p><code>33  printf("Child's old ppid: %d\n", old_ppid);</code></p>
      <p><code>34  printf("Child's new ppid: %d\n", new_ppid);</code></p>
      <p><code>35</code></p>
      <p><code>36  exit(0);</code></p>
      <p><code>37 }</code></p>
      <p>Строка 15 получает PID начального процесса, используя <code>getpid()</code>. Строки 17–20 создают порожденный процесс, проверяя по возвращении ошибки.</p>
      <p>Строки 21–24 выполняются порожденным процессом: строка 22 получает PPID. Строка 23 приостанавливает процесс на две секунды (сведения о <code>sleep()</code> см в разделе 10.8.1 «Аварийные часы: <code>sleep()</code>, <code>alarm()</code> и <code>SIGALRM</code>»), а строка 24 снова получает PPID.</p>
      <p>Строки 25–27 исполняются в родительском процессе. Строка 26 задерживает родителя на одну секунду, давая порожденному процессу достаточно времени для осуществления первого вызова <code>getppid()</code>. Строка 27 завершает родителя.</p>
      <p>Строки 31–34 выводят значения. Обратите внимание, что переменная <code>parent</code>, которая была установлена до разветвления, сохраняет свое значение в порожденном процессе. После порождения у двух процессов идентичные, но независимые копии адресного пространства. Вот что происходит при запуске программы:</p>
      <p><code>$ <strong>ch09-reparent</strong> /* Запуск программы */</code></p>
      <p><code>$ Original parent: 6582 /* Программа завершается: приглашение оболочки</code></p>
      <p><code>                           и вывод порожденного процесса */</code></p>
      <p><code>Child: 6583</code></p>
      <p><code>Child's old ppid: 6582</code></p>
      <p><code>Child's new ppid: 1</code></p>
      <p>Помните, что обе программы выполняются <emphasis>параллельно</emphasis>. Графически это изображено на рис. 9.2.</p>
      <image l:href="#img_15.png"/>
      <p><strong>Рис. 9.2</strong>. Два параллельно исполняющихся процесса после разветвления</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Использование <code>sleep()</code>, чтобы заставить один процесс пережить другой, работает в большинстве случаев. Однако, иногда случаются ошибки, которые трудно воспроизвести и трудно обнаружить. Единственным способом гарантировать правильное поведение является явная синхронизация с помощью <code>wait()</code> или <code>waitpid()</code>, которые описываются далее в главе (см. раздел 9.1.6.1 «Использование функций POSIX: <code>wait()</code> и <code>waitpid()</code>»).</p>
      </cite>
     </section>
     <section>
      <title>
       <p>9.1.3. Установка приоритетов процесса: <code>nice()</code></p>
      </title>
      <section>
       <p>Когда процессы запущены, ядро динамически меняет <emphasis>приоритет</emphasis> каждого процесса. Как и в жизни, элементы с большим приоритетом получают внимание до элементов с меньшим приоритетом. Короче говоря, каждому процессу выделяется небольшая порция времени для исполнения, которая называется <emphasis>квантом времени (time slice)</emphasis>. Когда квант истекает, если текущий процесс все еще является процессом с наивысшим приоритетом, ему разрешается продолжать.</p>
       <p>Linux, как и Unix, обеспечивает <emphasis>вытесняющую многозадачность</emphasis>. Это означает, что ядро может вытеснить процесс (приостановить его), если настало время дать возможность поработать другому процессу. Приоритет длительное время работающих процессов (например, процессов, выполняющих интенсивные вычисления), снижается в конце их кванта времени, поэтому они дают шанс другим процессам получить время процессора. Сходным образом, процессам, длительное время бездействовавшим в ожидании завершения ввода/вывода (таким, как интерактивный текстовый редактор), приоритет повышается, так что они могут ответить на ввод/вывод, когда он происходит. Короче, ядро гарантирует, что все процессы, усредненные по времени, получают свою «справедливую долю» времени процессора. Повышение и понижение приоритетов является частью этого процесса.</p>
       <p>Проектирование хорошего планировщика процессов для ядра является искусством; практические подробности выходят за рамки данной книги. Однако, процесс может влиять на назначения приоритетов ядром посредством своего значения <emphasis>относительного приоритета (nice)</emphasis>.</p>
       <p>Значение относительного приоритета является указанием того, насколько «приятным» хочет быть процесс в отношении других процессов. В соответствии с этим большие значения означают во все большей степени терпеливые процессы; т.е. те, которые все более приятны другим, снижая свой приоритет по отношению к ним.</p>
       <p>Отрицательное значение относительного приоритета, с другой стороны, означает, что процесс желает быть «менее приятным» по отношению к другим. Такой процесс более эгоистичный, требуя себе большего количества времени процессора<a l:href="#n89" type="note">[89]</a>. К счастью, в то время как пользователи могут повышать значение относительного приоритета (быть более приятными), лишь <code>root</code> может снижать значение относительного приоритета (быть менее приятным).</p>
       <p>Значение относительного приоритета является лишь одним фактором в уравнении, используемом ядром для вычисления приоритета; это не значение самого приоритета, которое изменяется с течением времени на основе поведения процесса и состояния других процессов системы. Для изменения значения относительного приоритета используется системный вызов <code>nice()</code>:</p>
       <p><code>#include &lt;unistd.h&gt; /* XSI */</code></p>
       <empty-line/>
       <p><code>int nice(int inc);</code></p>
       <p>Значение относительного приоритета по умолчанию равно 0. Разрешен диапазон значений от -20 до 19. Это требует некоторой привычки. Чем более отрицательное значение, тем выше приоритет процесса: -20 является наивысшим приоритетом (наименьшая приятность), а 19 — наинизшим приоритетом (наибольшая приятность)</p>
       <p>Аргумент <code>inc</code> является приращением, на который надо изменить значение приоритета. Для получения текущего значения, не изменяя его, используйте '<code>nice(0)</code>'. Если результат '<code>текущий_относительный_приоритет + inc</code>' выйдет за пределы от -20 до 19, система принудительно включит его в этот диапазон.</p>
       <p>Возвращаемое значение является новым значением относительного приоритета или -1, если возникла ошибка. Поскольку -1 также является действительным значением относительного приоритета, при вызове <code>nice()</code> следует сначала явным образом установить <code>errno</code> в ноль, а затем проверить его насчет имевшихся проблем:</p>
       <p><code>int niceval;</code></p>
       <p><code>int inc = /* любое значение */;</code></p>
       <p><code>errno = 0;</code></p>
       <p><code>if ((niceval = nice(inc)) &lt; 0 &amp;&amp; errno != 0) {</code></p>
       <p><code> fprintf(stderr, "nice(%d) failed: %s\n", inc, strerror(errno));</code></p>
       <p><code> /* другое восстановление */</code></p>
       <p><code>}</code></p>
       <p>Этот пример может завершиться неудачей, если в <code>inc</code> отрицательное значение, а процесс не запущен как <code>root</code>.</p>
      </section>
      <section>
       <title>
        <p>9.1.3.1. POSIX против действительности</p>
       </title>
       <p>Диапазон значений относительного приоритета от -20 до 19, которые использует Linux, имеет исторические корни; он ведет начало по крайней мерее V7. POSIX выражает состояние менее прямым языком, что дает возможность большей гибкости, сохраняя в то же время историческую совместимость. Это также затрудняет чтение и понимание стандарта, вот почему вы и читаете эту книгу. Итак, вот как описывает это POSIX</p>
       <p>Во-первых, <emphasis>значение относительного приоритета</emphasis> процесса, поддерживаемое системой, колеблется от 0 до '<code>(2 * NZERO) - 1</code>'. Константа <code>NZERO</code> определена в <code>&lt;limits.h&gt;</code> и должна равняться по крайней мере 20. Это дает диапазон 0–39.</p>
       <p>Во-вторых, как мы описывали, сумма текущего значения относительного приоритета и приращение <code>incr</code> загоняются в этот диапазон.</p>
       <p>В заключение, возвращаемое <code>nice()</code> значение является значением относительного приоритета процесса минус <code>NZERO</code>. При значении <code>NZERO</code> 20 это дает первоначальный диапазон от -20 до 19, который мы описали вначале.</p>
       <p>Результатом является то, что возвращаемое nice() значение в действительности изменяется от '<code>-NZERO</code>' до '<code>NZERO-1</code>', и лучше всего писать свой код в терминах этой именованной константы. Однако, на практике трудно найти систему, в которой <code>NZERO</code> не было бы равно 20.</p>
      </section>
     </section>
     <section>
      <title>
       <p>9.1.4. Запуск новой программы: семейство <code>exec()</code></p>
      </title>
      <section>
       <p>После запуска нового процесса (посредством <code>fork()</code>) следующим шагом является запуск в процессе другой программы. Имеется несколько функций, которые служат различным целям:</p>
       <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
       <empty-line/>
       <p><code>int execve(const char *filename, /* Системный вызов */</code></p>
       <p><code>char *const argv[], char *const envp[]);</code></p>
       <p><code>int execl(const char *path, const char *arg, ...); /* Оболочки */</code></p>
       <p><code>int execlp(const char *file, const char *arg, ...);</code></p>
       <p><code>int execle(const char *path, const char *arg, ..., char *const envp[]);</code></p>
       <p><code>int execv(const char *path, char *const argv[]);</code></p>
       <p><code>int execvp(const char *file, char *const argv[]);</code></p>
       <p>Мы ссылаемся на эти функции как на «семейство <code>exec()</code>». Функции с именем <code>exec()</code> нет; вместо этого мы используем это имя для обозначения любой из перечисленных выше функций. Как и в случае с <code>fork()</code>, «<code>exec</code>» используется на языке Unix и в качестве глагола, означающего исполнение (запуск) программы, и в качестве существительного.</p>
      </section>
      <section>
       <title>
        <p>9.1.4.1. Системный вызов <code>execve()</code></p>
       </title>
       <p>Простейшей для объяснения функцией является <code>execve()</code>. Она является также лежащим в основе системным вызовом. Другие являются функциями-оболочками, как вскоре будет объяснено.</p>
       <p><code>int execve(const char *filename, char *const argv[],</code></p>
       <p><code> char* const envp[]);</code></p>
       <p><code>filename</code> является именем программы для исполнения. Это может быть именем полного или относительного пути. Файл должен иметь формат исполняемого файла, который понимает ядро. Современные системы используют формат исполняемого файла ELF (Extensible Linking Format — открытый формат компоновки). GNU/Linux распознает ELF и несколько других форматов. С помощью <code>execve()</code> можно исполнять интерпретируемые сценарии, если они используют особую первую строку с именем интерпретатора, начинающуюся с '<code>#!</code>'. (Сценарии, которые не начинаются с '<code>#!</code>', потерпят неудачу.) В разделе 1.1.3 «Исполняемые файлы» представлен пример использования '#!'. argv является стандартным списком аргументов С — массив символьных указателей на строки аргументов, <emphasis>включая значение для использования с</emphasis> <code>argv[0]</code><a l:href="#n90" type="note">[90]</a>, завершающийся указателем <code>NULL</code>.</p>
       <p><code>envp</code> является окружением для использования новым процессом, с таким же форматом, как глобальная переменная <code>environ</code> (см. раздел 2.4 «Переменные окружения»). В новой программе это окружение становится начальным значением <code>environ</code>.</p>
       <p>Программа не должна возвращаться из вызова <code>exec()</code>. Если она возвращается, возникла проблема. Чаще всего либо не существует затребованная программа, либо она существует, но не является исполняемой (значения для <code>errno ENOENT</code> и <code>EACCESS</code> соответственно). Может быть множество других ошибок; см. справочную страницу <emphasis>execve</emphasis>(2).</p>
       <p>В предположении, что вызов был успешным, текущее содержимое адресного пространства процесса сбрасывается. (Ядро сначала сохраняет в безопасном месте данные <code>argv</code> и <code>envp</code>.) Ядро загружает для новой программы исполняемый код вместе со всеми глобальными и статическими переменными. Затем ядро инициализирует переменные окружения переданными <code>execve()</code> данными, а далее вызывает процедуру <code>main()</code> новой программы с переданным функции <code>execve()</code> массивом <code>argv</code>. Подсчитывается число аргументов и это значение передается <code>main()</code> в <code>argc</code>.</p>
       <p>К этому моменту новая программа запущена. Она не знает (и не может определить), какая программа была в процессе до нее. Обратите внимание, что ID процесса <emphasis>не меняется</emphasis>. Многие другие атрибуты при вызове <code>exec</code> сохраняются; вскоре мы рассмотрим это более подробно.</p>
       <p><code>exec()</code> для процесса можно сравнить с ролями, которые играют в жизни люди. В различное время в течение дня один человек может быть родителем, супругом, другом, студентом или рабочим, покупателем в магазине и т.д. Это одна и та же личность, исполняющая различные роли. Также и процесс — его PID, открытые файлы, текущий каталог и т.п. — не изменяются, тогда как выполняемая работа - запущенная с помощью <code>exec()</code> программа — может измениться.</p>
      </section>
      <section>
       <title>
        <p>9.1.4.2. Функции-оболочки: <code>execl()</code> и др.</p>
       </title>
       <p>Пять дополнительных функций, действующих в качестве оболочек, предоставляют более удобные интерфейсы для <code>execve()</code>. В первой группе все принимают список аргументов, каждый из которых передается в виде явного параметра функции:</p>
       <p><code>int execl(const char *path, const char *arg, ...)</code></p>
       <p>Первый аргумент, <code>path</code>, является путем к исполняемому файлу. Последующие аргументы, начиная с <code>arg</code>, являются отдельными элементами, которые должны быть помещены в <code>argv</code>. Как и ранее, явным образом должен быть включен <code>argv[0]</code>. Вы должны в качестве последнего аргумента передать завершающий указатель <code>NULL</code>, чтобы <code>execl()</code> смогла определить, где заканчивается список аргументов. Новая программа наследует любые переменные окружения, которые находятся в переменной <code>environ</code>.</p>
       <p><code>int execlp(const char *file, const char *arg, ...)</code></p>
       <p>Эта функция подобна <code>execl()</code>, но она имитирует механизм поиска команд оболочки, разыскивая <code>file</code> в каждом каталоге, указанном в переменной окружения <code>PATH</code>. Если <code>file</code> содержит символ <code>/</code>, этот поиск не осуществляется. Если <code>PATH</code> в окружении не присутствует, <code>execlp()</code> использует путь по умолчанию. В GNU/Linux по умолчанию используется "<code>:/bin:/usr/bin</code>", но в других системах может быть другое значение. (Обратите внимание, что ведущее двоеточие в <code>PATH</code> означает, что <emphasis>сначала</emphasis> поиск осуществляется в текущем каталоге.)</p>
       <p>Более того, если файл найден и имеет право доступа на исполнение, но не может быть исполнен из-за того, что неизвестен его формат, <code>execlp()</code> считает, что это сценарий оболочки и запускает оболочку с именем файла в качестве аргумента.</p>
       <p><code>int execle(const char *path, const char *arg, ...,</code></p>
       <p><code> char *const envp[])</code></p>
       <p>Эта функция также подобна <code>execl()</code>, но принимает дополнительный аргумент, <code>envp</code>, который становится окружением новой программы. Как и в случае с <code>execl()</code>, вы должны для завершения списка аргументов поместить перед <code>envp</code> указатель <code>NULL</code>.</p>
       <p>Вторая группа функций-оболочек принимает массив в стиле <code>argv</code>:</p>
       <p><code>int execv(const char *path, char *const argv[])</code></p>
       <p>Эта функция подобна <code>execve()</code>, но новая программа наследует любое окружение, которое находится в переменной environ текущей программы.</p>
       <p><code>int execvp(const char *file, char *const argv[])</code></p>
       <p>Эта функция подобна <code>execv()</code>, но она осуществляет такой же поиск в <code>PATH</code>, как и функция <code>execlp()</code>. Она также переходит на исполнение сценария оболочки, если найденный файл не может быть исполнен непосредственно.</p>
       <p>В табл. 9.1 подведены итоги для шести функций <code>exec()</code>.</p>
       <empty-line/>
       <p><strong>Таблица 9.1</strong>. Сводка семейства функций <code>exec()</code> по алфавиту</p>
       <table>
        <tr align="left">
         <th align="left" valign="top">Функция</th>
         <th align="left" valign="top">Поиск пути</th>
         <th align="left" valign="top">Окружение пользователя</th>
         <th align="left" valign="top">Назначение</th>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>execl()</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">Исполняет список аргументов.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>execle()</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Исполняет список аргументов с окружением.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>execlp()</code></td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">Исполняет список аргументов с поиском пути</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>execv()</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">Исполняет с <code>argv</code></td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>execve()</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Исполняет с <code>argv</code> и окружением (системный вызов).</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>execvp()</code></td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">Исполняет с <code>argv</code> и с поиском пути</td>
        </tr>
       </table>
       <p>Функций <code>execlp()</code> и <code>execvp()</code> лучше избегать, если вы не знаете, что переменная окружения <code>PATH</code> содержит приемлемый список каталогов.</p>
      </section>
      <section>
       <title>
        <p>9.1.4.3. Имена программ и <code>argv[0]</code></p>
       </title>
       <p>До сих пор мы все время считали <code>argv[0]</code> именем программы. Мы знаем, что оно может содержать, а может и не содержать символ <code>/</code>, в зависимости от способа вызова программы, если этот символ содержится, это хорошая подсказка к тому, что для вызова программы использовалось имя пути.</p>
       <p>Однако, как должно быть ясно к этому времени, то, что <code>argv[0]</code> содержит имя файла, является <emphasis>лишь соглашением</emphasis>. Ничто не может воспрепятствовать передаче вами вызываемой программе в качестве <code>argv[0]</code> произвольной строки. Следующая программа, <code>ch09-run.c</code>, демонстрирует передачу произвольной строки:</p>
       <p><code>1  /* ch09-run.c --- запуск программы с другим именем и любыми аргументами */</code></p>
       <p><code>2</code></p>
       <p><code>3  #include &lt;stdio.h&gt;</code></p>
       <p><code>4  #include &lt;errno.h&gt;</code></p>
       <p><code>5  #include &lt;unistd.h&gt;</code></p>
       <p><code>6</code></p>
       <p><code>7  /* main --- настроить argv и запустить указанную программу */</code></p>
       <p><code>8</code></p>
       <p><code>9  int main(int argc, char **argv)</code></p>
       <p><code>10 {</code></p>
       <p><code>11  char *path;</code></p>
       <p><code>12</code></p>
       <p><code>13  if (argc &lt; 3) {</code></p>
       <p><code>14   fprintf(stderr, "usage: %s path arg0 [ arg ... ]\n", argv[0]);</code></p>
       <p><code>15   exit(1);</code></p>
       <p><code>16  }</code></p>
       <p><code>17</code></p>
       <p><code>18  path = argv[1];</code></p>
       <p><code>19</code></p>
       <p><code>20  execv(path, argv + 2); /* skip argv[0] and argv[1] */</code></p>
       <p><code>21</code></p>
       <p><code>22  fprintf(stderr, "%s: execv() failed: %s\n", argv[0],</code></p>
       <p><code>23   strerror(errno));</code></p>
       <p><code>24  exit(1);</code></p>
       <p><code>25 }</code></p>
       <p>Первый аргумент является путем к запускаемой программе, а второй аргумент является новым именем для программы (которое большинство утилит игнорируют, кроме сообщений об ошибках); все остальные аргументы передаются вызываемой программе.</p>
       <p>Строки 13–16 осуществляют проверку ошибок. Строка 18 сохраняет путь в <code>path</code> Строка 20 осуществляет <code>exec</code>; если программа доходит до строк 22–23, это указывает на ошибку. Вот что происходит при запуске программы:</p>
       <p><code>$ <strong>ch09-run /bin/grep whoami foo</strong> /* Запустить grep */</code></p>
       <p><code><strong>a line</strong> /* Входная строка не подходит */</code></p>
       <p><code><strong>a line with foo in it</strong> /* Входная строка подходит */</code></p>
       <p><code><strong>a line with foo in it</strong> /* Это выводится */</code></p>
       <p><code><strong>^D</strong> /* EOF */</code></p>
       <p><code>$ <strong>ch09-run nonexistent-program foo bar</strong> /* Демонстрация неудачи */</code></p>
       <p><code>ch09-run: execv() failed: No such file or directory</code></p>
       <p>Следующий пример несколько неестественен: мы заставили <code>ch09-run</code> запустить <emphasis>себя</emphasis>, передав в качестве имени программы '<code>foo</code>'. Поскольку аргументов для второго запуска недостаточно, она выводит сообщение об использовании и завершается:</p>
       <p><code>$ <strong>ch09-run ./ch09-run foo</strong></code></p>
       <p><code>usage: foo path arg() [ arg ... ]</code></p>
       <p>Хотя она и не очень полезна, <code>ch09-run</code> ясно показывает, что <code>argv[0]</code> не обязательно должен иметь какое-нибудь отношение к файлу, который в действительности запускается.</p>
       <p>В System III (примерно в 1980-м) команды <code>cp</code>, <code>ln</code> и <code>mv</code> представляли один исполняемый файл с тремя ссылками с этими именами в <code>/bin</code>. Программа проверяла <code>argv[0]</code> и решала, что она должна делать. Это сохраняло некоторое количество дискового пространства за счет усложнения исходного кода и форсирования выполнения программой действия по умолчанию при запуске с неизвестным именем. (Некоторые современные коммерческие системы Unix продолжают эту практику!) Без явной формулировки причин <emphasis>GNU Coding Standards</emphasis> рекомендует, чтобы программы не основывали свое поведение на своем имени. Одна причина, которую мы видели, состоит в том, что администраторы часто устанавливают GNU версию утилиты наряду со стандартной версией коммерческих систем Unix, используя префикс g: <code>gmake</code>, <code>gawk</code> и т.д. Если такие программы ожидают лишь стандартные имена, они при запуске с другим именем потерпят неудачу.</p>
       <p>Сегодня также дисковое пространство дешево; если из одного и того же исходного кода можно построить две почти идентичные программы, лучше это сделать, использовав <code>#ifdef</code>, что у вас есть. Например, <code>grep</code> и <code>egrep</code> имеют значительную часть общего кода, но GNU версия строит два отдельных исполняемых файла.</p>
      </section>
      <section>
       <title>
        <p>9.1.4.4. Атрибуты, наследуемые <code>exec()</code></p>
       </title>
       <p>Как и в случае с <code>fork()</code>, после вызова программой <code>exec</code> сохраняется ряд атрибутов:</p>
       <p>• Все открытые файлы и открытые каталоги; см. раздел 4.4.1 «Понятие о дескрипторах файлов» и раздел 3.3.1 «Базовое чтение каталогов». (Сюда не входят файлы, помеченные для закрытия при исполнении (close-on-exec), как описано далее в этой главе; см. раздел 9.4.3.1 «Флаг close-on-exec».)</p>
       <p>• Установки umask; см. раздел 4.6 «Создание файлов».</p>
       <p>• Текущий рабочий каталог, см. раздел 8.4.1 «Изменение каталога: <code>chdir()</code> и <code>fchdir()</code>»</p>
       <p>• Корневой каталог; см. раздел 8.6 «Изменение корневого каталога: <code>chroot()</code>».</p>
       <p>• Текущее значение относительного приоритета.</p>
       <p>• ID процесса и ID родительского процесса.</p>
       <p>• ID группы процесса и контролирующий терминал; см. раздел 9.2.1 «Обзор управления работами».</p>
       <p>• Маску сигналов процесса и любые ожидающие сигналы, а также любые не истекшие аварийные сигналы или таймеры (здесь не обсуждается; см. главу 10 «Сигналы»).</p>
       <p>• Действительные ID пользователя и ID группы, а также дополнительный набор групп. Эффективные ID пользователя и группы (а следовательно, и сохраненные ID set-user и set-group) могут быть установлены с помощью битов setuid и setgid исполняемого файла. (Ничто из этого пока не обсуждалось; см. главу 11 «Права доступа и ID пользователя и группы».)</p>
       <p>• Блокировки файлов сохраняются (также пока не обсуждалось; см. раздел 14.2 «Блокировка файлов»).</p>
       <p>• Суммарное использованное время процессора для процесса и его потомков не меняется.</p>
       <p>После <code>exec</code> размещение сигналов изменяется; дополнительные сведения см. в разделе 10.9 «Сигналы для <code>fork()</code> и <code>exec()</code>».</p>
       <p>После <code>exec</code> все открытые файлы и каталоги остаются открытыми и доступными для использования. Вот как программы наследуют стандартные ввод, вывод и ошибку: они на месте, когда программа запускается.</p>
       <p>В большинстве случаев при исполнении <code>fork</code> и <code>exec</code> для отдельной программы не нужно ничего наследовать, кроме дескрипторов файлов 0, 1 и 2. В этом случае можно вручную закрыть все другие открытые файлы в порожденном процессе после выполнения <code>fork</code> и до выполнения <code>exec</code>. В качестве альтернативы можно пометить дескриптор файла для автоматического закрытия системой при исполнении exec; эта последняя возможность обсуждается далее в главе (см раздел 9.4.3.1 «Флаг close-on-exec».)</p>
      </section>
     </section>
     <section>
      <title>
       <p>9.1.5. Завершение процесса</p>
      </title>
      <section>
       <p>Завершение процесса включает два шага: окончание процесса с передачей системе статуса завершения и восстановление информации родительским процессом.</p>
      </section>
      <section>
       <title>
        <p>9.1.5.1. Определение статуса завершения процесса</p>
       </title>
       <p><emphasis>Статус завершения (exit status)</emphasis> (известный также под другими именами <emphasis>значения завершения (exit value)</emphasis>, <emphasis>кода возврата (return code)</emphasis> и <emphasis>возвращаемого значения (return value)</emphasis>) представляет собой 8-битовое значение, которое родитель может использовать при завершении порожденного процесса (на языке Unix, «когда порожденный кончается (dies)»). По соглашению статус завершения 0 означает, что программа отработала без проблем. Любое ненулевое значение указывает на какую-нибудь разновидность ошибки; программа определяет используемые числа и их значения, если они есть. (Например, <code>grep</code> использует 0 для указания, что образец был встречен по крайней мере один раз, 1 означает, что образец вообще не встретился, а 2 означает, что возникла ошибка.) Этот статус завершения доступен на уровне оболочки (для оболочек в стиле оболочки Борна) через специальную переменную <code>$?</code>.</p>
       <p>Стандарт С определяет две константы, которые следует использовать для полной переносимости на не-POSIX системы:</p>
       <p><code>EXIT_SUCCESS</code></p>
       <p>Программа завершилась без проблем. Для обозначения успеха может также использоваться ноль.</p>
       <p><code>EXIT</code>_FAILURE</p>
       <p>В программе была какая-нибудь проблема.</p>
       <p>На практике использование лишь этих значений довольно ограничивает. Вместо этого следует выбрать небольшой набор кодов возврата, документировать их значения и использовать. (Например, 1 для ошибок опций командной строки и аргументов, 2 для ошибок ввода/вывода, 3 для ошибок данных и т.д.) Для удобочитаемости стоит использовать константы <code>#define</code> или значения <code>enum</code>. Слишком большой список ошибок делает их использование обременительным; в большинстве случаев вызывающая программа (или пользователь) интересуется лишь нулевым или ненулевым значением.</p>
       <p>Когда достаточно двоичного разделения успех/неудача, педантичный программист использует <code>EXIT_SUCCESS</code> и <code>EXIT_FAILURE</code>. Наш собственный стиль более естественный, используя с <code>return</code> и <code>exit()</code> явные константы 0 или 1. Это настолько обычно, что рано заучивается и быстро становится второй натурой. Однако для своих проектов вы сами должны принять решение.</p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. Для родительского процесса доступны лишь восемь наименее значимых битов значения. Поэтому следует использовать значения в диапазоне 0–255. Как мы вскоре увидим, у чисел 126 и 127 есть традиционные значения (помимо простого «неуспешно»), которых ваши программы должны придерживаться.</p>
        <p>Поскольку имеют значение лишь восемь наименее значимых битов, вы никогда не должны использовать отрицательные статусы завершения. Когда из небольших отрицательных чисел выделяются восемь последних битов, они превращаются в большие положительные значения! (Например. -1 становится 255, а -5 становится 251.) Мы видели книги по программированию на С, в которых это понималось неправильно — не дайте сбить себя с толку</p>
       </cite>
      </section>
      <section>
       <title>
        <p>9.1.5.2. Возвращение из <code>main()</code></p>
       </title>
       <p>Программа может естественно завершиться одним из двух способов: посредством использования одной из описанных далее функций или возвратившись из <code>main()</code>. (Третий, более радикальный способ описан далее в разделе 12.4 «Совершение самоубийства: <code>abort()</code>».) В последнем случае следует использовать явное возвращаемое значение вместо выпадения в конце функции:</p>
       <p><code>/* Правильно */                  /* Неправильно */</code></p>
       <p><code>int main(int argc, char **argv)  int main(int argc, char **argv)</code></p>
       <p><code>{                                {</code></p>
       <p><code> /* здесь код */                  /* здесь код */</code></p>
       <p><code> return 0;                        /* ?? Что возвращает main()? */</code></p>
       <p><code>}                                }</code></p>
       <p>Стандарт С 1999 г. указывает, что при выпадении в конце, поведение функции <code>main()</code> должно быть таким, как если бы она возвращала 0. (Это верно также для С++; однако, стандарт С 1989 г. намеренно оставляет этот случай неопределенным.) Во всех случаях плохо полагаться на это поведение; однажды вы можете программировать для системы со скудной поддержкой С времени исполнения, или для внедренной системы, или где-то еще, где это будет по-другому. (В общем, выпадение в конце любой функции, не являющейся <code>void</code> — плохая мысль, которая может вести лишь к ошибочному коду.)</p>
       <p>Возвращенное из <code>main()</code> значение автоматически передается обратно системе, от которой родительский процесс может его впоследствии получить. Мы опишем, как это делается, в разделе 9.1.6.1 «Использование функций POSIX: <code>wait()</code> и <code>waitpid()</code>».</p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. На системах GNU/Linux управляемая компилятором команда c99 запускает компилятор с соответствующими опциями, так что возвращаемое значение при выпадении из конца функции равно 0. Простой gcc этого не делает.</p>
       </cite>
      </section>
      <section>
       <title>
        <p>9.1.5.3. Функции завершения</p>
       </title>
       <p>Другим способом естественного завершения программы является вызов функций завершения. Стандарт С определяет следующие функции:</p>
       <p><code>#include &lt;stdlib.h&gt; /* ISO С */</code></p>
       <empty-line/>
       <p><code>void exit(int status);</code></p>
       <p><code>void _Exit(int status);</code></p>
       <p><code>int atexit(void (*function)(void));</code></p>
       <p>Эти функции работают следующим образом:</p>
       <p><code>void exit(int status)</code></p>
       <p>Эта функция завершает программу, <code>status</code> передается системе для использования родителем. Перед завершением программы <code>exit()</code> вызывает все функции, зарегистрированные с помощью <code>atexit()</code>, сбрасывает на диск и закрывает все открытые потоки &lt;<code>stdio.h&gt; FILE</code>* и удаляет все временные файлы, созданные <code>tmpfile()</code> (см. раздел 12.3.2 «Создание и открытие временных файлов»). Когда процесс завершается, ядро закрывает любые оставшиеся открытыми файлы (которые были открыты посредством <code>open()</code>, <code>creat()</code> или через наследование дескрипторов), освобождает его адресное пространство и освобождает любые другие ресурсы, которые он мог использовать. <code>exit()</code> никогда не возвращается.</p>
       <p><code>void _Exit(int status)</code></p>
       <p>Эта функция в сущности идентична функции POSIX <code>_exit()</code>; мы на короткое время отложим ее обсуждение,</p>
       <p><code>int atexit(void (*function)(void))</code></p>
       <p><code>function</code> является указателем на функцию обратного вызова, которая должна вызываться при завершении программы, <code>exit()</code> запускает функцию обратного вызова перед закрытием файлов и завершением. Идея в том, что приложение может предоставить одну или более функций очистки, которые должны быть запущены перед окончательным завершением работы. Предоставление функции называется ее <emphasis>регистрацией</emphasis>. (Функции обратного вызова для <code>nftw()</code> обсуждались в разделе 8.4.3.2 «Функция обратного вызова <code>nftw()</code>»; здесь та же идея, хотя <code>atexit()</code> вызывает каждую зарегистрированную функцию лишь однажды.)</p>
       <p><code>atexit()</code> возвращает 0 при успехе или -1 при неудаче и соответствующим образом устанавливает <code>errno</code>.</p>
       <p>Следующая программа не делает полезной работы, но демонстрирует, как работает <code>atexit()</code>:</p>
       <p><code>/* ch09-atexit.c --- демонстрация atexit().</code></p>
       <p><code>   Проверка ошибок для краткости опущена. */</code></p>
       <p><code>/*</code></p>
       <p><code> * Функции обратного вызова здесь просто отвечают на вызов.</code></p>
       <p><code> * В настоящем приложении они делали бы больше. */</code></p>
       <p><code>void callback1(void) { printf("callback1 called\n"); }</code></p>
       <p><code>void callback2(void) { printf("callback2 called\n"); }</code></p>
       <p><code>void callback3(void) { printf("callback3 called\n"); }</code></p>
       <empty-line/>
       <p><code>/* main --- регистрация функций и завершение */</code></p>
       <p><code>int main(int argc, char **argv) {</code></p>
       <p><code> printf("registering callback1\n"); atexit(callback1);</code></p>
       <p><code> printf("registering callback2\n"); atexit(callback2);</code></p>
       <p><code> printf("registering callback3\n"); atexit(callback3);</code></p>
       <p><code> printf("exiting now\n");</code></p>
       <p><code> exit(0);</code></p>
       <p><code>}</code></p>
       <p>Вот что происходит при запуске:</p>
       <p><code>$ <strong>ch09-atexit</strong></code></p>
       <p><code>registering callback1 /* Запуск главной программы */</code></p>
       <p><code>registering callback2</code></p>
       <p><code>registering callback3</code></p>
       <p><code>exiting now</code></p>
       <p><code>callback3 called /* Функции обратного вызова запускаются в обратном</code></p>
       <p><code>                    порядке */</code></p>
       <p><code>callback2 called</code></p>
       <p><code>callback1 called</code></p>
       <p>Как показывает пример, функции, зарегистрированные с помощью <code>atexit()</code>, запускаются в порядке, обратном порядку их регистрации: последние первыми. (Это обозначается также LIFO — <emphasis>last-in-first-out — вошедший последним выходит первым</emphasis>).</p>
       <p>POSIX определяет функцию <code>_exit()</code>. В отличие от <code>exit()</code>, которая вызывает функции обратного вызова и выполняет <code>&lt;stdio.h&gt;</code>-очистку, <code>_exit()</code> является «сразу заканчивающейся» функцией:</p>
       <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
       <empty-line/>
       <p><code>void _exit(int status);</code></p>
       <p>Системе передается <code>status</code>, как и для <code>exit()</code>, но процесс завершается немедленно. Ядро все еще делает обычную очистку: все открытые файлы закрываются, использованная адресным пространством память освобождается, любые другие ресурсы, использованные процессом, также освобождаются.</p>
       <p>На практике функция <code>_Exit()</code> ISO С идентична <code>_exit()</code>. Стандарт С говорит, что от реализации функции зависит, вызывает ли <code>_Exit()</code> зарегистрированные <code>atexit()</code> функции и закрывает ли открытые файлы. Для систем GLIBC это не так, и функция ведет себя подобно <code>_exit()</code>.</p>
       <p>Время использовать <code>_exit()</code> наступает, когда <code>exec</code> в порожденном процессе завершается неудачей. В этом случае вам <emphasis>не</emphasis> нужно использовать обычный <code>exit()</code>, поскольку это сбрасывает на диск данные буферов, хранящиеся в потоках <code>FILE*</code>. Когда позже родительский процесс сбрасывает на диск свои копии буферов, данные буфера оказываются записанными <emphasis>дважды</emphasis>; это очевидно нехорошо.</p>
       <p>Например, предположим, что вы хотите запустить команду оболочки и хотите сами выполнить <code>fork</code> и <code>exec</code>. Такой код выглядел бы следующим образом:</p>
       <p><code>char *shellcommand = "...";</code></p>
       <p><code>pid_t child;</code></p>
       <p><code>if ((child = fork()) == 0) { /* порожденный процесс */</code></p>
       <p><code> execl("/bin/sh", "sh", "-c", shellcommand, NULL);</code></p>
       <p><code> _exit(errno == ENOENT ? 127 : 126);</code></p>
       <p><code>}</code></p>
       <p><code>/* родитель продолжает */</code></p>
       <p>Проверка значения <code>errno</code> и завершающего значения следуют соглашениям, используемым оболочкой POSIX. Если запрошенная программа не существует (<code>ENOENT</code> — нет для неё элемента в каталоге), завершающее значение равно 127. В противном случае, файл существует, но <code>exec</code> не могла быть выполнена по какой-то другой причине, поэтому статус завершения равен 126. Хорошая мысль следовать этим соглашениям также и в ваших программах. Вкратце, чтобы хорошо использовать <code>exit()</code> и <code>atexit()</code>, следует делать следующее:</p>
       <p>• Определить небольшой набор значений статуса завершения, которые ваша программа будет использовать для сообщения этой информации вызывающему. Используйте для них в своем коде константы <code>#define</code> или <code>enum</code>.</p>
       <p>• Решить, имеет ли смысл наличие функций обратного вызова для использования с <code>atexit()</code>. Если имеет, зарегистрировать их в <code>main()</code> в соответствующий момент; например, после анализа опций и инициализации всех структур данных, которые функция обратного вызова должна очищать. Помните, что функции должны вызываться в порядке LIFO (последняя вызывается первой).</p>
       <p>• Использовать <code>exit()</code> для выхода из программы во всех местах, когда что-то идет не так и когда выход является правильным действием. Используйте коды ошибок, которые определили.</p>
       <p>• Исключением является <code>main()</code>, для которой можно использовать при желании <code>return</code>. Наш собственный стиль заключается обычно в использовании <code>exit()</code> при наличии проблем и '<code>return 0</code>' в конце <code>main()</code>, если все прошло хорошо.</p>
       <p>• Использовать <code>_exit()</code> или <code>_Exit()</code> в порожденном процессе, если exec() завершается неудачей.</p>
      </section>
     </section>
     <section>
      <title>
       <p>9.1.6. Использование статуса завершения порожденного процесса</p>
      </title>
      <section>
       <p>Когда процесс заканчивается, нормальным ходом событий для ядра является освобождение всех его ресурсов. Ядро сохраняет статус завершения законченного процесса, также, как сведения о ресурсах, которые он использовал в своей работе, a PID продолжает считаться используемым. Такой завершившийся процесс называется <emphasis>зомби</emphasis>.</p>
       <p>Родительский процесс, будь то первоначальный родитель или <code>init</code>, может получить статус завершения порожденного процесса. Или, посредством использования функций BDS, которые не стандартизованы POSIX, можно получить статус завершения вместе со сведениями об использовании ресурсов. Использование статуса осуществляется ожиданием окончания процесса: это известно также как <emphasis>пожинание (reaping)</emphasis> процесса<a l:href="#n91" type="note">[91]</a>.</p>
       <p>Между механизмами, которые ожидают завершения потомков, и сигнальными механизмами, которые мы еще не обсуждали, есть значительное взаимодействие. Что из них описать вначале представляет собой нечто вроде проблемы курицы и яйца; мы решили сначала поговорить сначала о механизмах ожидания порожденного процесса, а глава 10 «Сигналы» дает полный рассказ о сигналах.</p>
       <p>Пока достаточно понять, что сигнал является способом уведомления процесса о том, что произошло некоторое событие. Процессы могут генерировать сигналы, которые посылаются самим себе, или сигналы могут посылаться извне другими процессами или пользователем за терминалом. Например, CTRL-C посылает сигнал «прерывания», a CTRL-Z посылает сигнал управления работой «стоп».</p>
       <p>По умолчанию, многие сигналы, такие, как сигнал прерывания, заставляют получающий процесс закончиться. Другие, такие, как сигналы управления работами, вызывают изменение его состояния. Механизмы ожидания порожденного процесса могут определить, претерпел ли процесс сигнал завершения, и если да, какой это был сигнал. То же верно и для остановки процесса и, на некоторых системах возобновления процесса.</p>
      </section>
      <section>
       <title>
        <p>9.1.6.1. Использование функций POSIX: <code>wait()</code> и <code>waitpid()</code></p>
       </title>
       <p>Первоначальным системным вызовом V7 был <code>wait()</code>. Более новым вызовом POSIX, основанным на возможностях BSD, является <code>waitpid()</code>. Объявления функций следующие:</p>
       <p><code>#include &lt;sys/types.h&gt; /* POSIX */</code></p>
       <p><code>#include &lt;sys/wait.h&gt;</code></p>
       <empty-line/>
       <p><code>pid_t wait(int *status);</code></p>
       <p><code>pid_t waitpid(pid_t pid, int *status, int options);</code></p>
       <p><code>wait()</code> ждет завершения <emphasis>любого</emphasis> порожденного процесса; сведения о том, как он завершился, возвращаются в <code>*status</code>. (Вскоре мы обсудим, как интерпретировать <code>*status</code>.) Возвращаемое значение является PID завершившегося процесса или -1, если возникла ошибка.</p>
       <p>Если порожденных процессов нет, <code>wait()</code> возвращает -1 с <code>errno</code>, установленным в <code>ECHILD</code> (отсутствует порожденный процесс). В противном случае, функция ждет завершения первого порожденного процесса или поступления сигнала.</p>
       <p>Функция <code>waitpid()</code> дает возможность ждать завершения определенного порожденного процесса. Она предоставляет значительную гибкость и является предпочтительной для использования функцией. Она также возвращает PID закончившегося процесса или -1 при возникновении ошибки. Аргументы следующие:</p>
       <p><code>pid_t pid</code></p>
       <p>Значение указывает, завершения какого порожденного процесса ждать как по-настоящему <code>pid</code>, так и по группе процесса. Смысл значения <code>pid</code> следующий:</p>
       <p><code>pid &lt; -1 </code>Ждать завершения любого порожденного процесса с ID группы процесса, равной абсолютному значению <code>pid</code>.</p>
       <p><code>pid = -1 </code>Ждать завершения любого порожденного процесса. Таким способом работает <code>wait()</code>.</p>
       <p><code>pid = 0  </code>Ждать завершения любого порожденного процесса с ID группы процесса, равной ID группе родительского процесса.</p>
       <p><code>pid &gt; 0  </code>Ждать завершения конкретного процесса с PID, равным <code>pid</code>.</p>
       <p><code>int *status</code></p>
       <p>То же, что и для <code>wait()</code>. <code>&lt;sys/wait.h&gt;</code> определяет различные макросы, которые интерпретируют значение в <code>*status</code>, которые мы вскоре опишем</p>
       <p><code>int options</code></p>
       <p>Этот параметр должен быть равен либо 0, либо побитовым ИЛИ одного или более из следующих флагов:</p>
       <p><code> WNOHANG</code></p>
       <p> Если ни один порожденный процесс не завершился, вернуться немедленно. Таким способом можно периодически проверять, не закончился ли какой- нибудь порожденный процесс. (Такая периодическая проверка известна как <emphasis>опрашивание</emphasis> события.)</p>
       <p><code> WUNTRACED</code></p>
       <p> Вернуть сведения о порожденном процессе, который остановился, но еще не завершился. (Например, для управления работой.)</p>
       <p><code> WCONTINUED</code></p>
       <p> (XSI.) Вернуть сведения о порожденном процессе, который продолжился, если его статус не сообщался с момента изменения. Это также для управления работой. Этот флаг является расширением XSI и не доступен под GNU/Linux.</p>
       <p>С заполненным значением <code>*status</code> работают несколько макросов, определяющие, что случилось. Они имеют тенденцию образовывать пары: один макрос для определения, что что-то случилось, и если этот макрос истинен, еще один макрос позволяет получить подробности. Макросы следующие:</p>
       <p><code>WIFEXITED(status)</code></p>
       <p>Этот макрос не равен нулю (true), если процесс завершился (в противоположность изменению состояния).</p>
       <p><code>WEXITSTATUS(status)</code></p>
       <p>Этот макрос дает статус завершения; он равен восьми наименее значимым битам значения, переданного <code>exit()</code> или возвращенного из <code>main()</code>. Этот макрос следует использовать лишь если <code>WIFEXIDED(status)</code> равен true.</p>
       <p><code>WIFSIGNALED(status)</code></p>
       <p>Этот макрос не равен нулю, если процесс подвергся действию завершающего сигнала death-by-signal.</p>
       <p><code>WTERMSIG(status)</code></p>
       <p>Этот макрос предоставляет номер сигнала, который завершил процесс. Этот макрос следует использовать, лишь когда <code>WIFSIGNALED(status)</code> равен true.</p>
       <p><code>WIFSTOPPED(status)</code></p>
       <p>Этот макрос не равен нулю, если процесс был остановлен.</p>
       <p><code>WSTOPSIG(status)</code></p>
       <p>Этот макрос предоставляет номер сигнала, который остановил процесс. (Процесс остановить могут несколько сигналов.) Этот макрос следует использовать лишь когда <code>WIFSTOPPED(status)</code> равен true. Сигналы управления работами обсуждаются в разделе 10.8.2 «Сигналы управления работой».</p>
       <p><code>WIFCONTINUED(status)</code></p>
       <p>(XSI.) Этот макрос не равен нулю, если процесс был продолжен. Соответствующего макроса <code>WCONTSIG()</code> нет, поскольку лишь один сигнал может вызвать продолжение процесса.</p>
       <p>Обратите внимание, что этот макрос является расширением XSI и в частности, он недоступен в GNU/Linux. Следовательно, если вы хотите его использовать, заключите код внутри '<code>#ifdef WIFCONTINUED ... #endif</code>'.</p>
       <p><code>WCOREDUMP(status)</code></p>
       <p>(Общий.) Этот макрос не равен нулю, если процесс создал снимок. <emphasis>Снимок процесса (core dump)</emphasis> является образом запущенного процесса в памяти, созданном при завершении процесса. Он предназначен для использования впоследствии при отладке. Системы Unix называют файл <code>core</code>, тогда как системы GNU/Linux используют <code>corе.<emphasis>pid</emphasis></code>, где <code><emphasis>pid</emphasis></code> является ID завершившегося процесса. Определенные сигналы завершают процесс и автоматически создают снимок процесса.</p>
       <p>Обратите внимание, что этот макрос не стандартный. Системы GNU/Linux, Solaris и BSD его поддерживают, однако некоторые другие системы Unix нет. Поэтому и здесь, если нужно его использовать, заключите код внутрь '<code>#ifdef WCOREDUMP ... #endif</code>'.</p>
       <p>Большинство программ не интересуются, почему завершился порожденный процесс; им просто нужно, <emphasis>что</emphasis> он завершился, возможно, отметив, было завершение успешным или нет. Программа GNU Coreutils <code>install</code> демонстрирует такое простое использование <code>fork()</code>, <code>execlp()</code> и <code>wait()</code>. Опция <code>-s</code> заставляет <code>install</code> запустить для устанавливаемого двоичного исполняемого файла программу <code>strip</code>. <code>(strip</code> удаляет из исполняемого файла отладочную и прочую информацию. Это может сохранить значительное пространство. На современных системах с многогигабайтными жесткими дисками при установке редко бывает необходимо использовать <code>strip</code> для исполняемых файлов.) Вот функция <code>strip()</code> из <code>install.с</code>:</p>
       <p><code>513 /* Вырезать таблицу имен из файла PATH.</code></p>
       <p><code>514    Мы могли бы сначала вытащить из файла магическое число</code></p>
       <p><code>515    для определения, нужно ли вырезать, но заголовочные файлы и</code></p>
       <p><code>516    магические числа варьируют от системы к системе так сильно, что</code></p>
       <p><code>517    сделать его переносимым было бы очень трудно. Не стоит усилий. */</code></p>
       <p><code>518</code></p>
       <p><code>519 static void</code></p>
       <p><code>520 strip (const char *path)</code></p>
       <p><code>521 {</code></p>
       <p><code>522  int status;</code></p>
       <p><code>523  pid_t pid = fork();</code></p>
       <p><code>524</code></p>
       <p><code>525  switch (pid)</code></p>
       <p><code>526  {</code></p>
       <p><code>527  case -1:</code></p>
       <p><code>528   error(EXIT_FAILURE, errno, _("fork system call failed"));</code></p>
       <p><code>529   break;</code></p>
       <p><code>530  case 0: /* Порожденный. */</code></p>
       <p><code>531   execlp("strip", "strip", path, NULL);</code></p>
       <p><code>532   error(EXIT_FAILURE, errno, _("cannot run strip"));</code></p>
       <p><code>533   break;</code></p>
       <p><code>534  default: /* Родитель. */</code></p>
       <p><code>535   /* Родительский процесс. */</code></p>
       <p><code>536   while (pid != wait(&amp;status)) /* Ждать завершения потомка. */</code></p>
       <p><code>537    /* Ничего не делать. */ ;</code></p>
       <p><code>538   if (status)</code></p>
       <p><code>539    error(EXIT_FAILURE, 0, _("strip failed"));</code></p>
       <p><code>540   break;</code></p>
       <p><code>541  }</code></p>
       <p><code>542 }</code></p>
       <p>Строка 523 вызывает <code>fork()</code>. Затем оператор <code>switch</code> предпринимает нужное действие для возвращения ошибки (строки 527–529), порожденного процесса (строки 530–533) и родительского процесса (строки 534–539).</p>
       <p>Стиль строк 536–537 типичен; они ожидают завершения нужного порожденного процесса. Возвращаемое значение wa<code>it()</code> является PID этого потомка. Оно сравнивается с PID порожденного процесса, <code>status</code> проверяется лишь на предмет равенства нулю (строка 538), в случае ненулевого результата потомок завершился неудачно. (Тест, хотя и правильный, грубый, но простой. Более правильным был бы тест наподобие '<code>if (WIFEXITED(status) &amp;&amp; WEXITSTATUS(status) != 0)</code>'.)</p>
       <p>Из описаний и кода, представленных до сих пор, может показаться, что родительские программы должны выбрать определенный момент, чтобы ожидать завершения любого порожденного процесса, возможно, с опросом в цикле (как делает <code>install.c</code>), ожидая всех потомков. В разделе 10.8.3 «Родительский надзор: три различные стратегии» мы увидим, что это необязательно. Скорее, сигналы предоставляют ряд механизмов для использования уведомлениями родителей о завершении порожденных процессов.</p>
      </section>
      <section>
       <title>
        <p>9.1.6.2. Использование функций BSD: <code>wait3()</code> и <code>wait4()</code></p>
       </title>
       <p>Системные вызовы BSD <code>wait3()</code> и <code>wait4()</code> полезны, если вы интересуетесь ресурсами, использованными порожденным процессом. Функции нестандартны (что означает, что они не являются частью POSIX), но широко доступны, в том числе на GNU/Linux. Объявления следующие:</p>
       <p><code>#include &lt;sys/types.h&gt; /* Обычный */</code></p>
       <p><code>#include &lt;sys/time.h&gt;</code></p>
       <p><code> /* Под GNU/Linux не нужно, но улучшает переносимость */</code></p>
       <p><code>#include &lt;sys/resource.h&gt;</code></p>
       <p><code>#include &lt;sys/wait.h&gt;</code></p>
       <empty-line/>
       <p><code>pid_t wait3(int *status, int options, struct rusage *rusage);</code></p>
       <p><code>pid_t wait4(pid_t pid, int *status, int options, struct rusage *rusage);</code></p>
       <p>Переменная <code>status</code> та же, что и для <code>wait()</code> и <code>waitpid()</code>. Все описанные ранее макросы (<code>WIFEXITED()</code> и т.д.) могут использоваться и с ними.</p>
       <p>Значение <code>options</code> также то же самое, что и для <code>waitpid()</code>: либо 0, либо побитовое ИЛИ с одним или обоими флагами <code>WNOHANG</code> и <code>WUNTRACED</code>.</p>
       <p><code>wait3()</code> ведет себя подобно <code>wait()</code>, получая сведения о первом доступном порожденном зомби, a <code>wait4()</code> подобна <code>waitpid()</code>, получая сведения об определенном процессе. Обе функции возвращают PID потомка, -1 при ошибке или 0, если нет доступных процессов и был использован флаг <code>WNOHANG</code>. Аргумент <code>pid</code> может принимать те же значения, что и аргумент <code>pid</code> для <code>waitpid()</code>.</p>
       <p>Ключевым отличием является указатель <code>struct rusage</code>. Если он не равен <code>NULL</code>, система заполняет ее сведениями о процессе. Эта структура описана в POSIX и в справочной странице <emphasis>getrusage</emphasis>(2):</p>
       <p><code>struct rusage {</code></p>
       <p><code> struct timeval ru_utime; /* используемое время пользователя */</code></p>
       <p><code> struct timeval ru_stime; /* используемое системное время */</code></p>
       <p><code> long ru_maxrss;   /* максимальный размер резидентного набора */</code></p>
       <p><code> long ru_ixrss;    /* общий размер разделяемой памяти */</code></p>
       <p><code> long ru_idrss;    /* общий размер не разделяемых данных */</code></p>
       <p><code> long ru_isrss;    /* общий размер не разделяемого стека */</code></p>
       <p><code> long ru_minflt;   /* использование страниц */</code></p>
       <p><code> long ru_majflt;   /* ошибок страниц */</code></p>
       <p><code> long ru_nswap;    /* подкачек */</code></p>
       <p><code> long ru_inblock;  /* блочных операций ввода */</code></p>
       <p><code> long ru_oublock;  /* блочных операций вывода */</code></p>
       <p><code> long ru_msgsnd;   /* посланных сообщений */</code></p>
       <p><code> long ru_msgrcv;   /* полученных сообщений */</code></p>
       <p><code> long ru_nsignals; /* полученных сигналов */</code></p>
       <p><code> long ru_nvcsw;    /* добровольных переключений контекста */</code></p>
       <p><code> long ru_nivcsw;   /* принудительных переключений контекста */</code></p>
       <p><code>};</code></p>
       <p>Чисто BSD системы (4.3 Reno и более поздние) поддерживают все поля. В табл. 9.2 описаны доступность различных полей <code>struct rusage</code> для POSIX и Linux.</p>
       <empty-line/>
       <p><strong>Таблица 9.2</strong>. Доступность полей <code>struct rusage</code></p>
       <table>
        <tr align="left">
         <th align="left" valign="top">Поле</th>
         <th align="left" valign="top">POSIX</th>
         <th align="left" valign="top">Linux</th>
         <th align="left" valign="top">Поле</th>
         <th align="left" valign="top">POSIX</th>
         <th align="left" valign="top">Linux</th>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>ru_utime</code></td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">&#8805; 2.4</td>
         <td align="left" valign="top"><code>ru_nswap</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">&#8805;2.4</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>ru_stime</code></td>
         <td align="left" valign="top">&#8730;</td>
         <td align="left" valign="top">&#8805;2.4</td>
         <td align="left" valign="top"><code>ru_nvcsw</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">&#8805;2.6</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>ru_minflt</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">&#8805;2.4</td>
         <td align="left" valign="top"><code>ru_nivcsw</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">&#8805;2.6</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>ru_majflt</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">&#8805;2.4</td>
         <td align="left" valign="top"/>
         <td align="left" valign="top"/>
         <td align="left" valign="top"/>
        </tr>
       </table>
       <p>Стандартом определены лишь поля, помеченные «POSIX». Хотя Linux определяет полную структуру, ядро 2.4 поддерживает лишь поля времени пользователя и системного времени. Ядро 2.6 поддерживает также поля, связанные с переключением контекста.<a l:href="#n92" type="note">[92]</a></p>
       <p>Наиболее интересными полями являются <code>ru_utime</code> и <code>ru_stime</code>, использование времени процессора в режиме пользователя и ядра соответственно. (Время процессора в режиме пользователя является временем, потраченным на исполнение кода уровня пользователя. Время процессора в режиме ядра является временем, потраченным в ядре в пользу процесса.)</p>
       <p>Эти два поля используют <code>struct timeval</code>, которая содержит значения времени с точностью до микросекунд. Дополнительные сведения по этой структуре см. в разделе 14.3.1 «Время в микросекундах: <code>gettimeofday()</code>».</p>
       <p>В BSD 4.2 и 4.3 аргумент <code>status</code> функций <code>wait()</code> и <code>wait3()</code> был <code>union wait</code>. Он умещался в <code>int</code> и предоставлял доступ к тем же сведениям, которые выдают современные макросы <code>WIFEXITED()</code> и др., но через членов объединения. Не все члены были действительными во всех случаях. Эти члены и их использование описаны в табл. 9.3.</p>
       <empty-line/>
       <p><strong>Таблица 9.3</strong>. <code>union wait</code> 4.2 и 4.3 BSD</p>
       <table>
        <tr align="left">
         <th align="left" valign="top">Макрос POSIX</th>
         <th align="left" valign="top">Член объединения</th>
         <th align="left" valign="top">Использование</th>
         <th align="left" valign="top">Значение</th>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>WIFEXITED()</code></td>
         <td align="left" valign="top"><code>w_termsig</code></td>
         <td align="left" valign="top"><code>w.w_termsig == 0</code></td>
         <td align="left" valign="top">True при нормальном завершении</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>WEXITSTATUS()</code></td>
         <td align="left" valign="top"><code>w_retcode</code></td>
         <td align="left" valign="top"><code>code = w.w_retcode</code></td>
         <td align="left" valign="top">Статус завершения, если не по сигналу</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>WIFSIGNALED()</code></td>
         <td align="left" valign="top"><code>w_termsig</code></td>
         <td align="left" valign="top"><code>w.w_temsig != 0</code></td>
         <td align="left" valign="top">True, если завершен по сигналу</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>WTERMSIG()</code></td>
         <td align="left" valign="top"><code>w_termsig</code></td>
         <td align="left" valign="top"><code>sig = w.w_termsig</code></td>
         <td align="left" valign="top">Сигнал, вызвавший завершение</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>WIFSTOPPED()</code></td>
         <td align="left" valign="top"><code>w_stopval</code></td>
         <td align="left" valign="top"><code>w.w_stopval == WSTOPPED</code></td>
         <td align="left" valign="top">True, если остановлен</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>WSTOPSIG()</code></td>
         <td align="left" valign="top"><code>w_stopsig</code></td>
         <td align="left" valign="top"><code>sig = w.w_stopsig</code></td>
         <td align="left" valign="top">Сигнал, вызвавший остановку</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>WCOREDUMP()</code></td>
         <td align="left" valign="top"><code>w_coredump</code></td>
         <td align="left" valign="top"><code>w.w_coredump != 0</code></td>
         <td align="left" valign="top">True, если потомок сделал снимок образа</td>
        </tr>
       </table>
       <p>POSIX не стандартизует <code>union wait</code>, a BSD 4.4 не документирует его, используя вместо этого макросы POSIX. GLIBC делает несколько бросков, чтобы заставить использующий его старый код продолжать работать. Мы опишем его здесь главным образом для того, чтобы вы увидев его — узнали; новый код должен использовать макросы, описанные в разделе 9.1.6.1 «Использование функций POSIX: <code>wait()</code> и <code>waitpid()</code>».</p>
      </section>
     </section>
    </section>
    <section>
     <title>
      <p>9.2. Группы процессов</p>
     </title>
     <section>
      <p><emphasis>Группа процесса</emphasis> является группой связанных процессов, которые в целях управления заданием (job) рассматриваются вместе. Процессы с одним и тем же ID группы процессов являются членами группы процессов, а процесс, PID которого равен ID группы процессов, является <emphasis>лидеров группы процессов</emphasis>. Новые процессы наследуют ID группы процессов своих родительских процессов.</p>
      <p>Мы уже видели, что <code>waitpid()</code> позволяет вам ждать любой процесс в данной группе процессов. В разделе 10.6.7 «Отправка сигналов: <code>kill()</code> и <code>killpg()</code>» мы увидим также, что вы можете отправить сигнал всем процессам в определенной группе процессов. (Всегда применяется проверка прав доступа; вы не можете послать сигнал процессу, которым не владеете.)</p>
     </section>
     <section>
      <title>
       <p>9.2.1. Обзор управления заданиями</p>
      </title>
      <p>Управление заданиями является сложной темой, той, в которую мы решили не погружаться в данной книге. Однако, здесь приведен краткий концептуальной обзор.</p>
      <p>Устройство терминала (физическое или другое) с работающим на нем пользователем называется <emphasis>управляющим терминалом</emphasis>.</p>
      <p><emphasis>Сеанс (session)</emphasis> является коллекцией групп процессов, связанных с управляющим терминалом. На одном терминале имеется лишь один сеанс, с несколькими группами процессов в сеансе. Один процесс назначен <emphasis>лидером сеанса</emphasis>; обычно это оболочка, такая, как Bash, <code>pdksh</code>, <code>zsh</code> или <code>ksh93</code><a l:href="#n93" type="note">[93]</a>, которая может осуществлять управление заданиями. Мы называем такую оболочку <emphasis>оболочкой, управляющей заданиями</emphasis>.</p>
      <p>Каждое задание, запущенное управляющей заданиями оболочкой, будь то простая программа или конвейер, получает отдельный идентификатор группы процессов. Таким способом оболочка может манипулировать заданием как отдельной сущностью, хотя в нем может быть несколько процессов.</p>
      <p>Управляющий терминал также имеет связанный с ним идентификатор группы процессов. Когда пользователь набирает специальный символ, такой, как CTRL-C для «прерывания» или CTRL-Z для «остановки», ядро посылает данный сигнал процессам в группе процессов терминала.</p>
      <p>Группе процессов, ID которой совпадает с ID управляющего терминала, разрешено записывать в терминал и читать с него. Эта группа называется <emphasis>приоритетной (foreground) группой процессов</emphasis>. (Она получает также генерируемые клавиатурой сигналы.) Любые другие группы процессов в сеансе являются <emphasis>фоновыми (background) группами процессов</emphasis> и не могут читать или записывать в терминал; они получают специальные сигналы, которые их останавливают, если они пытаются это делать.</p>
      <p>Задания переходят из приоритетного режима в фоновый и обратно <emphasis>не</emphasis> путем изменения атрибута задания, но посредством изменения группы процессов управляющего терминала. Это изменение осуществляет именно контролирующая задания оболочка, и если новая группа процессов останавливается, оболочка вновь запускает ее, посылая сигнал «продолжить» всем членам группы процессов.</p>
      <p>В былые времена пользователи часто использовали последовательные терминалы, соединенные с модемами, для подключения к централизованным Unix-системам на мини-компьютерах. Когда пользователь закрывал соединение (вешал трубку), линия последовательной передачи обнаруживала отсоединение, и ядро посылало сигнал «отсоединение» всем подключенным к терминалу процессам.</p>
      <p>Эта концепция остается: если возникает отключение (оборудование последовательной связи все еще существует и все еще используется), ядро посылает сигнал отсоединения приоритетной группе процессов. Если существует лидер сеанса, происходит то же самое.</p>
      <p><emphasis>Висячая (orphaned) группа процессов</emphasis> — это такая группа, в которой для каждого процесса родительский процесс находится в той же группе или в другом сеансе. (Это может случиться, если управляющая заданиями оболочка завершается при все еще работающих фоновых заданиях.) Запущенным процессам в висячей группе процессов разрешается работать до завершения. Если в такой группе на момент, когда она становится висячей, уже имеются остановленные процессы, ядро посылает этим процессам сигнал отсоединения, а затем сигнал продолжения. Это заставляет их пробудиться, чтобы они могли завершиться, вместо того, чтобы остаться остановленными навечно.</p>
     </section>
     <section>
      <title>
       <p>9.2.2. Идентификация группы процессов: <code>getpgrp()</code> и <code>getpgid()</code></p>
      </title>
      <p>Для совместимости с более старыми системами POSIX предоставляет множество способов получения сведений о группе процессов:</p>
      <p><code>#include &lt;unistd.h&gt;</code></p>
      <empty-line/>
      <p><code>pid_t getpgrp(void);      /* POSIX */</code></p>
      <p><code>pid_t getpgid(pid_t pid); /* XSI */</code></p>
      <p>Функция <code>getpgrp()</code> возвращает ID группы процессов текущего процесса. <code>getpgid()</code> является расширением XSI. Она возвращает ID группы процессов для данного <code>pid</code> группы процессов. <code>pid</code>, равный 0, означает «группа процессов текущего процесса». Таким образом, '<code>getpgid(0)</code>' является тем же самым, что и '<code>getpgrp()</code>'. При обычном программировании следует использовать <code>getpgrp()</code>.</p>
      <p>В BSD 4.2 и 4.3 также есть функция <code>getpgrp()</code>, но она действует как функция POSIX <code>getpgid()</code>, требуя аргумент <code>pid</code>. Поскольку современные системы поддерживают POSIX, в новом коде следует использовать версию POSIX. (Если вы думаете, что это сбивает с толку, вы правы. Несколько способов для получения одного и того же результата является обычным итогом проектирования комитетом, поскольку комитет считает, что он должен удовлетворить каждого.)</p>
     </section>
     <section>
      <title>
       <p>9.2.3. Установка группы процесса: <code>setpgid()</code> и <code>setpgrp()</code></p>
      </title>
      <p>Две функции устанавливают группу процесса:</p>
      <p><code>#include &lt;unistd.h&gt;</code></p>
      <empty-line/>
      <p><code>int setpgid(pid_t pid, pid_t pgid); /* POSIX */</code></p>
      <p><code>int setpgrp(void);                  /* XSI */</code></p>
      <p>Функция <code>setpgrp()</code> проста: она устанавливает ID группы процесса равной ID процесса. Это создает новую группу процессов в том же сеансе, а вызывающий функцию процесс становится лидером группы процессов.</p>
      <p>Функция <code>setpgid()</code> предназначена для использования управления заданиями. Она позволяет одному процессу устанавливать группу процесса для другого. Процесс может изменить лишь свой собственный ID группы процессов или ID группы процессов порожденного процесса, лишь если этот порожденный процесс не выполнил еще <code>exec</code>. Управляющая заданиями оболочка делает этот вызов после <code>fork</code> <emphasis>как</emphasis> в родительском, <emphasis>так</emphasis> и в порожденном процессах. Для одного из них вызов завершается успехом, и ID группы процессов изменяется. (В противном случае нет способа гарантировать упорядочение, когда родитель может изменить ID группы процессов порожденного процесса до того, как последний выполнит <code>exec</code>. Если сначала успешно завершится вызов родителя, он может перейти на следующую задачу, такую, как обработка других заданий или управление терминалом.)</p>
      <p>При использовании <code>setpgid() pgid</code> должна быть группой существующего процесса, которая является частью текущего сеанса, фактически подключая <code>pid</code> к этой группе процессов. В противном случае <code>pgid</code> должна равняться <code>pid</code>, создавая новую группу процессов.</p>
      <p>Имеется несколько значений для особых случаев как для <code>pid</code>, так и для <code>pgid</code>:</p>
      <p><code>pid = 0 </code>В данном случае <code>setpgid()</code> изменяет группу процессов вызывающего процесса на <code>pgid</code>. Это эквивалентно '<code>setpgid(getpid(), pgid)</code>'.</p>
      <p><code>pgid = 0 </code>Это устанавливает ID группы процессов для данного процесса равным его PID. Таким образом, '<code>setpgid(pid, 0)</code>' является тем же самым, что и '<code>setpgid(pid, pid)</code>'. Это делает процесс с PID, равным <code>pid</code>, лидером группы процессов.</p>
      <p>Во всех случаях лидеры сеанса являются особыми; их PID, ID группы процессов и ID сеанса идентичны, a ID группы процессов лидера не может быть изменена. (ID сеанса устанавливаются посредством <code>setsid()</code>, а получаются посредством <code>getsid()</code>. Это особые вызовы: см. справочные страницы <emphasis>setsid</emphasis>(2) и <emphasis>getsid</emphasis>(2)).</p>
     </section>
    </section>
    <section>
     <title>
      <p>9.3. Базовое межпроцессное взаимодействие: каналы и очереди FIFO</p>
     </title>
     <section>
      <p><emphasis>Межпроцессное взаимодействие (Interprocess communication — IPC)</emphasis> соответствует своему названию: это способ взаимодействия для двух отдельных процессов. Самым старым способом IPC на системах Unix является <emphasis>канал (pipe)</emphasis>: односторонняя линия связи. Данные, записанные в один конец канала, выходят из другого конца.</p>
     </section>
     <section>
      <title>
       <p>9.3.1. Каналы</p>
      </title>
      <section>
       <p>Каналы проявляют себя как обычные дескрипторы файлов. Без особого разбирательства вы не можете сказать, представляет ли дескриптор файла сам файл или канал. Это особенность; программы, которые читают из стандартного ввода и записывают в стандартный вывод, не должны знать или заботиться о том, что они могут взаимодействовать с другим процессом. Если хотите знать, каноническим способом проверки этого является попытка выполнить с дескриптором '<code>lseek(fd, 0L, SEEK_CUR)</code>'; этот вызов пытается отсчитать 0 байтов от текущего положения, т е. операция, которая ничего не делает<a l:href="#n94" type="note">[94]</a>. Эта операция завершается неудачей для каналов и не наносит никакого вреда другим файлам.</p>
      </section>
      <section>
       <title>
        <p>9.3.1.1. Создание каналов</p>
       </title>
       <p>Системный вызов <code>pipe()</code> создает канал:</p>
       <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
       <empty-line/>
       <p><code>int pipe(int filedes[2]);</code></p>
       <p>Значение аргумента является адресом массива из двух элементов целого типа, <code>pipe()</code> возвращает 0 при успешном возвращении и -1, если была ошибка.</p>
       <p>Если вызов был успешным, у процесса теперь есть два дополнительных открытых дескриптора файла. Значение <code>filedes[0]</code> является <emphasis>читаемым концом</emphasis> канала, a <code>filedes [1]</code> — <emphasis>записываемым концом</emphasis>. (Удобным мнемоническим способом запоминания является то, что читаемый конец использует индекс 0, аналогичный дескриптору стандартного ввода 0, а записываемый конец использует индекс 1, аналогичный дескриптору стандартного вывода 1.)</p>
       <p>Как упоминалось, данные, записанные в записываемый конец, считываются из читаемого конца. После завершения работы с каналом оба конца закрываются с помощью вызова <code>close()</code>. Следующая простая программа, <code>ch09-pipedemo.c</code>, демонстрирует каналы путем создания канала, записи в него данных, а затем чтения этих данных из него:</p>
       <p><code>1  /* ch09-pipedemo.c --- демонстрация ввода/вывода с каналом. */</code></p>
       <p><code>2</code></p>
       <p><code>3  #include &lt;stdio.h&gt;</code></p>
       <p><code>4  #include &lt;errno.h&gt;</code></p>
       <p><code>5  #include &lt;unistd.h&gt;</code></p>
       <p><code>6</code></p>
       <p><code>7  /* main --- создание канала, запись в него и чтение из него. */</code></p>
       <p><code>8</code></p>
       <p><code>9  int main(int argc, char **argv)</code></p>
       <p><code>10 {</code></p>
       <p><code>11  static const char mesg[] = "Don't Panic!"; /* известное сообщение */</code></p>
       <p><code>12  char buf[BUFSIZ];</code></p>
       <p><code>13  ssize_t rcount, wcount;</code></p>
       <p><code>14  int pipefd[2];</code></p>
       <p><code>15  size_t l;</code></p>
       <p><code>16</code></p>
       <p><code>17  if (pipe(pipefd) &lt; 0) {</code></p>
       <p><code>18   fprintf(stderr, "%s: pipe failed: %s\n", argv[0],</code></p>
       <p><code>19    strerror(errno));</code></p>
       <p><code>20   exit(1);</code></p>
       <p><code>21  }</code></p>
       <p><code>22</code></p>
       <p><code>23  printf("Read end = fd %d, write end = fd %d\n",</code></p>
       <p><code>24   pipefd[0], pipefd[1]);</code></p>
       <p><code>25</code></p>
       <p><code>26  l = strlen(mesg);</code></p>
       <p><code>27  if ((wcount = write(pipefd[1], mesg, 1)) != 1) {</code></p>
       <p><code>28   fprintf(stderr, "%s: write failed: %s\n", argv[0],</code></p>
       <p><code>29    strerror(errno));</code></p>
       <p><code>30   exit(1);</code></p>
       <p><code>31  }</code></p>
       <p><code>32</code></p>
       <p><code>33  if ((rcount = read(pipefd[0], buf, BUFSIZ)) != wcount) {</code></p>
       <p><code>34   fprintf(stderr, "%s: read failed: %s\n", argv[0],</code></p>
       <p><code>35    strerror(errno));</code></p>
       <p><code>36   exit(1);</code></p>
       <p><code>37  }</code></p>
       <p><code>38</code></p>
       <p><code>39  buf[rcount] = '\0';</code></p>
       <p><code>40</code></p>
       <p><code>41  printf("Read &lt;%s&gt; from pipe\n", buf);</code></p>
       <p><code>42  (void)close(pipefd[0]);</code></p>
       <p><code>43  (void)close(pipefd[1]);</code></p>
       <p><code>44</code></p>
       <p><code>45  return 0;</code></p>
       <p><code>46 }</code></p>
       <p>Строки 11–15 объявляют локальные переменные; наибольший интерес представляет <code>mesg</code>, который представляет текст, проходящий по каналу.</p>
       <p>Строки 17–21 создают канал с проверкой ошибок; строки 23–24 выводят значения новых дескрипторов файлов (просто для подтверждения, что они не равны 0, 1 или 2)</p>
       <p>В строке 26 получают длину сообщения для использования с <code>write()</code>. Строки 27–31 записывают сообщение в канал, снова с проверкой ошибок.</p>
       <p>Строки 33–37 считывают содержимое канала, опять с проверкой ошибок. Строка 39 предоставляет завершающий нулевой байт, так что прочитанные данные могут использоваться в качестве обычной строки. Строка 41 выводит данные, а строки 42–43 закрывают оба конца канала. Вот что происходит при запуске программы:</p>
       <p><code>$ <strong>ch09-pipedemo</strong></code></p>
       <p><code>Read end = fd 3, write end = fd 4</code></p>
       <p><code>Read &lt;Don't Panic!&gt; from pipe</code></p>
       <p>Эта программа не делает ничего полезного, но она демонстрирует основы. Обратите внимание, что нет вызовов <code>open()</code> или <code>creat()</code> и что программа не использует три своих унаследованных дескриптора. Тем не менее, <code>write()</code> и <code>read()</code> завершаются успешно, показывая, что дескрипторы файлов действительны и что данные, поступающие в канал, действительно выходят из него.<a l:href="#n95" type="note">[95]</a> Конечно, будь сообщение слишком большим, наша программа не работала бы. Это происходит из-за того, что размер (памяти) каналов ограничен, факт, который мы обсудим в следующем разделе.</p>
       <p>Подобно другим дескрипторам файлов, дескрипторы для каналов наследуются порожденным процессом после <code>fork</code>, и если они не закрываются, все еще доступны после <code>exec</code>. Вскоре мы увидим, как использовать это обстоятельство и сделать с каналами что-то интересное.</p>
      </section>
      <section>
       <title>
        <p>9.3.1.2. Буферирование каналов</p>
       </title>
       <p>Каналы <emphasis>буферируют</emphasis> свои данные, что означает, что записанные в канал данные хранятся ядром до тех пор, пока не будут прочитаны. Однако, канал может содержать лишь такое-то количество записанных, но еще не прочитанных данных. Мы можем называть записывающий процесс <emphasis>производителем</emphasis>, а читающий процесс <emphasis>потребителем</emphasis>. Как система управляет полными и пустыми каналами?</p>
       <p>Когда канал полон, система автоматически <emphasis>блокирует</emphasis> производителя в следующий раз, когда он пытается осуществить запись данных в канал с помощью <code>write()</code>. Когда канал освобождается, система копирует данные в канал, а затем позволяет системному вызову <code>write()</code> вернуться к производителю.</p>
       <p>Подобным же образом, если канал пустой, потребитель блокируется в <code>read()</code> до тех пор, пока в канале не появятся данные для чтения. (Блокирующее поведение можно отключить; это обсуждается в разделе 9.4.3.4 «Неблокирующий ввод/вывод для каналов и очередей FIFO».)</p>
       <p>Когда производитель вызывает на записывающем конце канала <code>close()</code>, потребитель может успешно прочесть любые данные, все еще находящиеся в канале. После этого дальнейшие вызовы <code>read()</code> возвращают 0, указывая на конец файла.</p>
       <p>Напротив, если потребитель закрывает читаемый конец, <code>write()</code> на записываемом конце завершается неудачей. В частности, ядро посылает производителю сигнал «нарушенный канал», действием по умолчанию для которого является завершение процесса.</p>
       <p>Нашей любимой аналогией для каналов является то, как муж и жена вместе моют и сушат тарелки. Один супруг моет тарелки, помещая чистые, но влажные тарелки в сушилку на раковине. Другой супруг вынимает тарелки из сушилки и вытирает их. Моющий тарелки является производителем, сушилка является каналом, а вытирающий является потребителем.<a l:href="#n96" type="note">[96]</a></p>
       <p>Если вытирающий супруг оказывается быстрее моющего, сушилка становится пустой, и вытирающему приходится ждать, пока не будут готовы новые тарелки. Напротив, если быстрее вытирающий супруг, сушилка наполняется, и моющему приходится ждать, пока она не опустеет, прежде чем помещать в нее тарелки. Это изображено на рис. 9.3.</p>
       <image l:href="#img_16.jpeg"/>
       <p><strong>Рис. 9.3</strong>. Синхронизация процессов канала</p>
      </section>
     </section>
     <section>
      <title>
       <p>9.3.2. Очереди FIFO</p>
      </title>
      <p>Для традиционных каналов единственным способом для двух различных программ получить доступ к одному и тому же каналу является наследование дескрипторов файлов. Это означает, что процессы должны быть порожденными от общего родителя или один должен быть предком другого.</p>
      <p>Это может быть серьезным ограничением. Многие системные службы запускаются как <emphasis>демоны</emphasis>, отсоединенные долгоживущие процессы. Должен быть способ отправки данных таким процессам (и, возможно, получения данных от них). Файлы для этого не подходят; синхронизация трудна или невозможна, а каналы для выполнения задания не могут быть созданы, поскольку нет общих предков.</p>
      <p>Для решения этой проблемы System III предложила идею о FIFO. <emphasis>FIFO</emphasis>,<a l:href="#n97" type="note">[97]</a> или <emphasis>именованный канал</emphasis>, является файлом в файловой системе, который действует подобно каналу. Другими словами, один процесс открывает FIFO для записи, тогда как другой открывает его для чтения. Затем данные, записанные; в FIFO, читаются читателем. Данные буферируются ядром, а не хранятся на диске.</p>
      <p>Рассмотрите спулер печати. Демон спулера управляет физическими принтерами, создавая задания для печати и печатая по одному заданию за раз. Для добавления в очередь задания программное обеспечение принтера на уровне пользователя должно сообщаться с демоном спулера. Одним способом для осуществления этого является создание спулером FIFO с хорошо известным именем файла. Программа пользователя может затем открыть FIFO, записать в него запрос и снова закрыть. Спулер находится в цикле, читая запросы из FIFO и обрабатывая их.</p>
      <p>Функция mkfifo() создает файлы FIFO:</p>
      <p><code>#include &lt;sys/types.h&gt; /* POSIX */</code></p>
      <p><code>#include &lt;sys/stat.h&gt;</code></p>
      <empty-line/>
      <p><code>int mkfifo(const char *pathname, mode_t mode);</code></p>
      <p>Аргумент <code>pathname</code> является именем создаваемого FIFO, a <code>mode</code> является данными ему правами доступа, аналогичными второму аргументу функции <code>creat()</code> или третьему аргументу функции <code>open()</code> (см. раздел 4.6 «Создание файлов»). Файлы FIFO удаляются, как любые другие, с помощью <code>remove()</code> или <code>unlink()</code> (см. раздел 5.1.5.1 «Удаление открытых файлов»).</p>
      <p>Справочная страница GNU/Linux <emphasis>mkfifo</emphasis>(3) указывает, что FIFO должен быть открыт как для чтения, так и для записи в одно и то же время, до того, как может быть осуществлен ввод/вывод: «Открытие FIFO для чтения обычно блокирует до тех пор, пока какой-нибудь другой процесс не откроет тот же FIFO для записи, и наоборот». После открытия файла FIFO он действует подобно обычному каналу; т.е. это просто еще один дескриптор файла.</p>
      <p>Команда <code>mkfifo</code> доставляет этот системный вызов на командный уровень. Это упрощает показ файла FIFO в действии:</p>
      <p><code>$ <strong>mkfifo afifo</strong> /* Создание файла FIFO */</code></p>
      <p><code>$ ls -l afifo</code></p>
      <p><code> /* Показать тип и права доступа, обратите внимание на 'p' впереди */</code></p>
      <p><code>prw-r--r-- 1 arnold devel 0 Oct 23 15:49 afifo</code></p>
      <p><code>$ <strong>cat &lt; afifo &amp;</strong> /* Запустить читателя в фоновом режиме */</code></p>
      <p><code>[1] 22100</code></p>
      <p><code>$ <strong>echo It was a Blustery Day &gt; afifo</strong> /* Послать данные в FIFO */</code></p>
      <p><code>$ It was a Blustery Day /* Приглашение оболочки, cat выводит данные */</code></p>
      <p><code> /* Нажмите ENTER, чтобы увидеть статус завершения задания */</code></p>
      <p><code>[1]+ Done cat &lt;afifo /* cat завершился */</code></p>
     </section>
    </section>
    <section>
     <title>
      <p>9.4. Управление дескрипторами файлов</p>
     </title>
     <section>
      <p>На данный момент части загадки почти полностью составлены, <code>fork()</code> и <code>exec()</code> создают процессы и запускают в них программы, <code>pipe()</code> создает канал, который может использоваться для IPC. Чего до сих пор не хватает, так это способа помещения дескрипторов канала на место стандартных ввода и вывода для производителя и потребителя канала.</p>
      <p>Системные вызовы <code>dup()</code> и <code>dup2()</code>, совместно с <code>close()</code> дают вам возможность поместить (скопировать) открытый дескриптор файла на другой номер. Системный вызов <code>fcntl()</code> дает вам возможность то же самое и управлять несколькими важными атрибутами открытых файлов.</p>
     </section>
     <section>
      <title>
       <p>9.4.1. Дублирование открытых файлов: <code>dup()</code> и <code>dup2()</code></p>
      </title>
      <p>Два системных вызова создают копию открытого дескриптора файла:</p>
      <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
      <empty-line/>
      <p><code>int dup(int oldfd);</code></p>
      <p><code>int dup2(int oldfd, int newfd);</code></p>
      <p>Функции следующие:</p>
      <p><code>int dup(int oldfd)</code></p>
      <p>Возвращает наименьшее значение неиспользуемого дескриптора файла; это копия <code>oldfd</code>. <code>dup()</code> возвращает неотрицательное целое в случае успеха и -1 при неудаче.</p>
      <p><code>int dup2(int oldfd, int newfd)</code></p>
      <p>Делает <code>newfd</code> копией <code>oldfd</code>; если <code>newfd</code> открыт, он сначала закрывается, как при использовании <code>close()</code>. <code>dup2()</code> возвращает новый дескриптор или -1, если была проблема. Помните рис. 9.1, в котором два процесса разделяли общие указатели на один и тот же элемент файла в таблице файлов ядра? <code>dup()</code> и <code>dup2()</code> создают ту же ситуацию внутри одного процесса. См. рис. 9.4.</p>
      <image l:href="#img_17.jpeg"/>
      <p><strong>Рис. 9.4</strong>. Разделение дескриптора файла как результат '<code>dup2(1, 3)</code>'</p>
      <p>На этом рисунке процесс выполнил '<code>dup2(1, 3)</code>', чтобы сделать дескриптор файла 3-й копией стандартного вывода, дескриптора файла 1. Точно как описано ранее, эти два дескриптора разделяют общее смещение открытого файла.</p>
      <p>В разделе 4.4.2 «Открытие и закрытие файлов» мы упомянули, что <code>open()</code> (и <code>creat()</code>) <emphasis>всегда</emphasis> возвращают наименьшее целое значение неиспользуемого дескриптора для открываемого файла. Этому правилу следуют почти все системные вызовы, которые возвращают новые дескрипторы файлов, а не только <code>open()</code> и <code>creat()</code>. (<code>dup2()</code> является исключением, поскольку он предусматривает способ получения конкретного нового дескриптора файла, даже если он не является наименьшим неиспользуемым дескриптором.)</p>
      <p>При наличии правила «возвращения наименьшего неиспользуемого номера» в сочетании с функцией <code>dup()</code> теперь легко поместить дескрипторы файла канала на место стандартного ввода и вывода. В предположении, что текущим процессом является оболочка и что ей необходимо создать два порожденных процесса для образования двухступенчатого канала, вот эти шаги:</p>
      <p>1. Создать канал с помощью <code>pipe()</code>. Это должно быть сделано сначала, чтобы два порожденных процесса могли унаследовать дескрипторы открытых файлов.</p>
      <p>2. Создать то, что мы называем «левым потомком». Это процесс, стандартный вывод которого идет в канал. В данном процессе сделать следующее:</p>
      <p> a. Использовать '<code>close(pipefd[0])</code>', поскольку читаемый конец канала в левом потомке не нужен.</p>
      <p> b. Использовать '<code>close(1)</code>', чтобы закрыть первоначальный стандартный вывод.</p>
      <p> c. Использовать '<code>dup(pipefd[1])</code>' для копирования записываемого конца канала в дескриптор файла 1.</p>
      <p> d. Использовать '<code>close(pipefd[1])</code>', поскольку нам не нужны две копии открытого дескриптора.</p>
      <p> e. Выполнить <code>exec</code> для запускаемой программы.</p>
      <p>3. Создать то, что мы называем «правым потомком». Это процесс, стандартный ввод которого поступает из канала. Шаги для этого потомка являются зеркальным отражением шагов для левого потомка:</p>
      <p> a. Использовать '<code>close(pipefd[1])</code>', поскольку записываемый конец канала в правом потомке не нужен.</p>
      <p> b. Использовать '<code>close(0)</code>', чтобы закрыть первоначальный стандартный ввод.</p>
      <p> c. Использовать '<code>dup(pipefd[0])</code>' для копирования читаемого конца канала в дескриптор файла 0.</p>
      <p> d. Использовать '<code>close(pipefd[0])</code>', поскольку нам не нужны две копии открытого дескриптора.</p>
      <p> e. Выполнить <code>exec</code> для запускаемой программы.</p>
      <p>4. В родителе закрыть оба конца канала — '<code>close(pipefd[0]); close(pipefd[1])</code>'.</p>
      <p>5. Наконец, использовать в родителе <code>wait()</code> для ожидания завершения обоих порожденных процессов.</p>
      <p>Обратите внимание, как важно закрыть неиспользуемые копии дескрипторов файлов каналов. Как мы отмечали ранее, файл не закрывается до тех пор, пока не будет закрыт последний открытый для него дескриптор. Это верно, даже если дескрипторы файлов разделяют несколько процессов. Закрытие не использующихся дескрипторов файлов имеет значение, поскольку процесс, читающий из канала, не получит указания конца файла, пока <emphasis>все</emphasis> копии записываемого конца не будут закрыты.</p>
      <p>В нашем случае после порождения двух потомков имеются три процесса, у каждого из которых есть копии двух дескрипторов файлов каналов: родительский и два порожденных. Родительский процесс закрывает оба конца, поскольку ему не нужен канал. Левый потомок записывает в канал, поэтому ему нужно закрыть читаемый конец. Правый потомок читает из канала, поэтому ему нужно закрыть записываемый конец. Это оставляет открытым ровно по одной копии дескриптора файла.</p>
      <p>Когда левый потомок завершает работу, он заканчивается. Система после этого закрывает все его дескрипторы файлов. Когда это случается, правый потомок получает в конечном счете уведомление конца файла и тоже может завершить работу и выйти.</p>
      <p>Следующая программа, <code>ch09-pipeline.c</code>, создает эквивалент следующего конвейера оболочки:</p>
      <p><code>$ <strong>echo hi there | sed s/hi/hello/g</strong></code></p>
      <p><code>hello there</code></p>
      <p>Вот программа:</p>
      <p><code>1  /* ch09-pipeline.c --- ответвляет два процесса в их собственный конвейер.</code></p>
      <p><code>2     Для краткости проверка ошибок сведена к минимуму. */</code></p>
      <p><code>3</code></p>
      <p><code>4  #include &lt;stdio.h&gt;</code></p>
      <p><code>5  #include &lt;errno.h&gt;</code></p>
      <p><code>6  #include &lt;sys/types.h&gt;</code></p>
      <p><code>7  #include &lt;sys/wait.h&gt;</code></p>
      <p><code>8  #include &lt;unistd.h&gt;</code></p>
      <p><code>9</code></p>
      <p><code>10 int pipefd[2];</code></p>
      <p><code>11</code></p>
      <p><code>12 extern void left_child(void), right_child(void);</code></p>
      <p><code>13</code></p>
      <p><code>14 /* main --- порождение процессов и ожидание их завершения */</code></p>
      <p><code>15</code></p>
      <p><code>16 int main(int argc, char **argv)</code></p>
      <p><code>17 {</code></p>
      <p><code>18  pid_t left_pid, right_pid;</code></p>
      <p><code>19  pid_t ret;</code></p>
      <p><code>20  int status;</code></p>
      <p><code>21</code></p>
      <p><code>22  if (pipe(pipefd) &lt; 0) { /* создать канал в самом начале */</code></p>
      <p><code>23   perror("pipe");</code></p>
      <p><code>24   exit(1);</code></p>
      <p><code>25  }</code></p>
      <p><code>26</code></p>
      <p><code>27  if ((left_pid = fork()) &lt; 0) { /* порождение левого потомка */</code></p>
      <p><code>28   perror("fork");</code></p>
      <p><code>29   exit(1);</code></p>
      <p><code>30  } else if (left_pid == 0)</code></p>
      <p><code>31  left_child();</code></p>
      <p><code>32</code></p>
      <p><code>33  if ((right_pid = fork()) &lt; 0) { /* порождение правого потомка */</code></p>
      <p><code>34   perror("fork");</code></p>
      <p><code>35   exit(1);</code></p>
      <p><code>36  } else if (right_pid == 0)</code></p>
      <p><code>37  right_child();</code></p>
      <p><code>38</code></p>
      <p><code>39  close(pipefd[0])); /* закрыть родительские копии канала */</code></p>
      <p><code>40  close(pipefd[1]);</code></p>
      <p><code>41</code></p>
      <p><code>42  while ((ret = wait(&amp;status)) &gt; 0) { /* wait for children */</code></p>
      <p><code>43   if (ret == left_pid)</code></p>
      <p><code>44    printf("left child terminated, status: %x\n", status);</code></p>
      <p><code>45   else if (ret == right_pid)</code></p>
      <p><code>46    printf("right child terminated, status: %x\n", status);</code></p>
      <p><code>47   else</code></p>
      <p><code>48    printf("yow! unknown child %d terminated, status %x\n",</code></p>
      <p><code>49     ret, status);</code></p>
      <p><code>50  }</code></p>
      <p><code>51</code></p>
      <p><code>52  return 0;</code></p>
      <p><code>53 }</code></p>
      <p>Строки 22–25 создают канал. Это должно быть сделано в самом начале.</p>
      <p>Строки 27–31 создают левого потомка, а строки 33–37 создают правого потомка. В обоих случаях родитель продолжает линейное исполнение ветви <code>main()</code> до тех пор, пока порожденный процесс не вызовет соответствующую функцию для манипулирования дескрипторами файла и осуществления <code>exec</code>.</p>
      <p>Строки 39–40 закрывают родительскую копию канала.</p>
      <p>Строки 42–50 в цикле ожидают потомков, пока <code>wait()</code> не вернет ошибку.</p>
      <p><code>55 /* left_child --- осуществляет работу левого потомка */</code></p>
      <p><code>56</code></p>
      <p><code>57 void left_child(void)</code></p>
      <p><code>58 {</code></p>
      <p><code>59  static char *left_argv[] = { "echo", "hi", "there", NULL };</code></p>
      <p><code>60</code></p>
      <p><code>61  close(pipefd[0]);</code></p>
      <p><code>62  close(1);</code></p>
      <p><code>63  dup(pipefd[1]);</code></p>
      <p><code>64  close(pipefd[1]);</code></p>
      <p><code>65</code></p>
      <p><code>66  execvp("echo", left_argv);</code></p>
      <p><code>67  _exit(errno == ENOENT ? 127 : 126);</code></p>
      <p><code>68 }</code></p>
      <p><code>69</code></p>
      <p><code>70 /* right_child --- осуществляет работу правого потомка */</code></p>
      <p><code>71</code></p>
      <p><code>72 void right_child(void)</code></p>
      <p><code>73 {</code></p>
      <p><code>74  static char *right_argv[] = { "sed", "s/hi/hello/g", NULL };</code></p>
      <p><code>75</code></p>
      <p><code>76  close(pipefd[1]);</code></p>
      <p><code>77  close(0);</code></p>
      <p><code>78  dup(pipefd[0]);</code></p>
      <p><code>79  close(pipefd[0]));</code></p>
      <p><code>80</code></p>
      <p><code>81  execvp("sed", right_argv);</code></p>
      <p><code>82  _exit(errno == ENOENT ? 127 : 126);</code></p>
      <p><code>83 }</code></p>
      <p>Строки 57–68 являются кодом для левого потомка. Процедура следует приведенным выше шагам, закрывая ненужный конец канала, закрывая первоначальный стандартный вывод, помещая с помощью <code>dup()</code> записываемый конец канала на номер 1 и закрывая затем первоначальный записываемый конец. В этот момент строка 66 вызывает <code>execvp()</code>, и если она завершается неудачей, строка 67 вызывает <code>_exit()</code>. (Помните, что строка 67 никогда не выполняется, если <code>execvp()</code> завершается удачно.)</p>
      <p>Строки 72–83 делают подобные же шаги для правого потомка. Вот что происходит при запуске:</p>
      <p><code>$ <strong>ch09-pipeline</strong> /* Запуск программы */</code></p>
      <p><code>left child terminated, status: 0 /* Левый потомок завершается до вывода (!) */</code></p>
      <p><code>hello there /* Вывод от правого потомка */</code></p>
      <p><code>right child terminated, status: 0</code></p>
      <p><code>$ <strong>ch09-pipeline</strong> /* Повторный запуск программы */</code></p>
      <p><code>hello there /* Вывод от правого потомка и ... */</code></p>
      <p><code>right child terminated, status: 0 /* Правый потомок завершается до левого */</code></p>
      <p><code>left child terminated, status: 0</code></p>
      <p>Обратите внимание, что порядок, в котором завершаются потомки, не является детерминированным. Он зависит от загрузки системы и многих других факторов, которые могут повлиять на планирование процессов. Вам следует проявить осторожность, чтобы избежать предположений о порядке действий при написании кода, создающего несколько процессов, в особенности для кода, который вызывает семейство функций <code>wait()</code>.</p>
      <p>Весь процесс показан на рис. 9.5.</p>
      <image l:href="#img_18.jpeg"/>
      <empty-line/>
      <image l:href="#img_19.jpeg"/>
      <empty-line/>
      <image l:href="#img_20.jpeg"/>
      <p><strong>Рис. 9.5</strong>. Создание конвейера родителем</p>
      <p>На рис. 9.5 (а) изображена ситуация после создания родителем канала (строки 22–25) и двух порожденных процессов (строки 27–37).</p>
      <p>На рис. 9.5 (b) показана ситуация после закрытия родителем канала (строки 39–40) и начала ожидания порожденных процессов (строки 42–50). Каждый порожденный процесс поместил канал на место стандартного вывода (левый потомок, строки 61–63) и стандартного ввода (строки 76–78).</p>
      <p>Наконец, рис. 9.5 (с) изображает ситуацию после закрытия потомками первоначального канала (строки 64 и 79) и вызова <code>execvp()</code> (строки 66 и 81).</p>
     </section>
     <section>
      <title>
       <p>9.4.2. Создание нелинейных конвейеров: <code>/dev/fd/XX</code></p>
      </title>
      <p>Многие современные системы Unix, включая GNU/Linux, поддерживают в каталоге <code>/dev/fd</code><a l:href="#n98" type="note">[98]</a> специальные файлы. Эти файлы представляют дескрипторы открытых файлов с именами <code>/dev/fd/0</code>, <code>/dev/fd/1</code> и т.д. Передача такого имени функции <code>open()</code> возвращает новый дескриптор файла, что в сущности является тем же самым, что и вызов <code>dup()</code> для данного номера дескриптора.</p>
      <p>Эти специальные файлы находят свое применение на уровне оболочки: Bash, <code>ksh88</code> (некоторые версии) и <code>ksh93</code> предоставляют возможность <emphasis>замещения процесса (process substitution)</emphasis>, что позволяет создавать нелинейные конвейеры. На уровне оболочки для входного конвейера используется запись '<code>&lt;(...)</code>', а для выходного конвейера запись '<code>&gt;(...)</code>'. Например, предположим, вам нужно применить команду <code>diff</code> к выводу двух команд. Обычно вам пришлось бы использовать временные файлы:</p>
      <p><code>command1 &gt; /tmp/out.$$.1</code></p>
      <p><code>command2 &gt; /tmp/out.$$.2</code></p>
      <p><code>diff /tmp/out.$$.1 /tmp/out.$$.2</code></p>
      <p><code>rm /tmp/out.$$.1 /tmp/out.$$.2</code></p>
      <p>С замещением процессов это выглядит следующим образом:</p>
      <p><code>diff &lt;(command1) &lt;(command2)</code></p>
      <p>Не надо никаких беспорядочных файлов для временного запоминания и удаления. Например, следующая команда показывает, что наш домашний каталог является ссылкой на другой каталог:</p>
      <p><code>$ <strong>diff &lt;(pwd) &lt;(/bin/pwd)</strong></code></p>
      <p><code>1c1</code></p>
      <p><code>&lt; /home/arnold/work/prenhall/progex</code></p>
      <p><code>---</code></p>
      <p><code>&gt; /d/home/arnold/work/prenhall/progex</code></p>
      <p>Незамысловатая команда <code>pwd</code> является встроенной в оболочку: она выводит текущий логический путь, который управляется оболочкой с помощью команды <code>cd</code>. Программа <code>/bin/pwd</code> осуществляет обход физической файловой системы для вывода имени пути.</p>
      <p>Как выглядит замещение процессов? Оболочка создает вспомогательные команды<a l:href="#n99" type="note">[99]</a> ('<code>pwd</code>' и '<code>/bin/pwd</code>'). Выход каждой из них подсоединяется к каналу, причем читаемый конец открыт в дескрипторе нового файла для главного процесса ('<code>diff</code>'). Затем оболочка передает главному процессу <emphasis>имена файлов в</emphasis> <code><emphasis>/dev/fd</emphasis></code> в качестве аргументов командной строки. Мы можем увидеть это, включив в оболочке трассировку исполнения.</p>
      <p><code>$ <strong>set -х</strong> /* Включить трассировку исполнения */</code></p>
      <p><code>$ <strong>diff &lt;(pwd) &lt;(/bin/pwd)</strong> /* Запустить команду */</code></p>
      <p><code>+ diff /dev/fd/63 /dev/fd/62 /* Трассировка оболочки: главная,</code></p>
      <p><code> программа, обратите внимание на аргументы */</code></p>
      <p><code>++ pwd /* Трассировка оболочки: вспомогательные программы */</code></p>
      <p><code>++ /bin/pwd</code></p>
      <p><code>1c1 /* Вывод diff */</code></p>
      <p><code>&lt; /home/arnold/work/prenhall/progex</code></p>
      <p><code>---</code></p>
      <p><code>&gt; /d/home/arnold/work/prenhall/progex</code></p>
      <p>Это показано на рис. 9.6.</p>
      <image l:href="#img_21.jpeg"/>
      <p><strong>Рис. 9.6</strong>. Замещение процесса</p>
      <p>Если на вашей системе есть <code>/dev/fd</code>, вы также можете использовать преимущества этой возможности. Однако, будьте осторожны и задокументируйте то, что вы делаете. Манипуляции с дескриптором файла на уровне С значительно менее прозрачны, чем соответствующие записи оболочки!</p>
     </section>
     <section>
      <title>
       <p>9.4.3. Управление атрибутами файла: <code>fcntl()</code></p>
      </title>
      <section>
       <p>Системный вызов <code>fcntl()</code> («управление файлом») предоставляет контроль над различными атрибутами либо самого дескриптора файла, либо лежащего в его основе открытого файла. Справочная страница GNU/Linux <emphasis>fcntl</emphasis>(2) описывает это таким способом:</p>
       <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
       <p><code>#include &lt;fcntl.h&gt;</code></p>
       <empty-line/>
       <p><code>int fcntl (int fd, int cmd);</code></p>
       <p><code>int fcntl(int fd, int cmd, long arg);</code></p>
       <p><code>int fcntl(int fd, int cmd, struct flock *lock);</code></p>
       <p>Другими словами, функция принимает по крайней мере два аргумента; в зависимости от второго аргумента, она может принимать и третий аргумент.</p>
       <p>Последняя форма, в которой третий аргумент является указателем на <code>struct flock</code>, предназначена для блокировки файла. Блокировка файлов сама по себе представляет большую тему; мы отложим обсуждение до раздела 14.2 «Блокировка файлов».</p>
      </section>
      <section>
       <title>
        <p>9.4.3.1. Флаг close-on-exec</p>
       </title>
       <p>После вызова <code>fork()</code> и перед вызовом <code>exec()</code> следует убедиться, что новая программа наследует лишь те открытые файлы, которые ей нужны. Вы не захотите, чтобы порожденный процесс мешался в открытых файлах родителя, если только это так не задумано. С другой стороны, если у родителя множество открытых файлов, это будет искусственно ограничивать число новых файлов, которые может открыть порожденный процесс. (См. сопроводительную врезку.)</p>
       <p>Организационно такое поведение может представлять проблему. Часть вашей программы, порождающая новый процесс, не должна особенно нуждаться в других частях программы, манипулирующей открытыми файлами. И цикл наподобие следующего неприятный, поскольку может не быть открытых файлов:</p>
       <p><code>int j;</code></p>
       <p><code>for (j = getdtablesize(); j &gt;= 3; j--) /* закрыть все, кроме 0, 1, 2 */</code></p>
       <p><code> (void)close(j);</code></p>
       <p>Решением является флаг <emphasis>close-on-exec (закрытие при исполнении exec)</emphasis>. Он является атрибутом <emphasis>самого дескриптора файла</emphasis>, а не лежащего в его основе открытого файла. Когда этот флаг установлен, система автоматически закрывает файл, когда процесс осуществляет <code>exec</code>. Установив этот флаг сразу после открытия файла, вам не нужно беспокоиться о том, что какой-нибудь порожденный процесс случайно его унаследует. (Оболочка автоматически устанавливает этот флаг для всех дескрипторов файлов, которые она открывает, начиная с номера 3 и выше.)</p>
       <p>Аргумент <code>cmd</code> имеет два значения, относящиеся к флагу close-on-exec:</p>
       <p><code>F_GETFD</code></p>
       <p>Получает флаги дескриптора файла. Возвращаемое значение является значением всех установленных флагов дескриптора или -1 при ошибке.</p>
       <p><code>F_SETFD</code></p>
       <p>Устанавливает флаги дескриптора файла в содержащееся в <code>arg</code> (третий аргумент) значение. Возвращаемое значение равно 0 при успехе или -1 при ошибке.</p>
       <p>В настоящий момент определен лишь один «флаг дескриптора файла»: <code>FD_CLOEXEC</code>. Эта именованная константа является нововведением POSIX<a l:href="#n100" type="note">[100]</a>, а большая часть кода использует просто 1 или 0:</p>
       <p><code>if (fcntl(fd, F_SETFD, 1) &lt; 0) ...</code></p>
       <p><code> /* установить close-on-exec, обработать ошибки */</code></p>
       <p><code>if (fcntl(fd, F_GETFD) == 1) ...</code></p>
       <p><code> /* бит close-on-exec уже установлен */</code></p>
       <p>Однако, определение POSIX допускает дальнейшее расширение, поэтому правильный способ написания такого кода больше соответствует этим строкам:</p>
       <p><code>int fd;</code></p>
       <p><code>long fd_flags;</code></p>
       <p><code>if ((fd_flags = fcntl(fd, F_GETFD)) &lt; 0) /* Получить флаги */</code></p>
       <p><code> /* обработать ошибки */</code></p>
       <p><code>fd_flags |= FD_CLOEXEC; /* Add close-on-exec flag */</code></p>
       <p><code>if (fcntl(fd, F_SETFD, fd_flags) &lt; 0) /* Установить флаги */</code></p>
       <p><code> /* обработать ошибки */</code></p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. Флаг close-on-exec является собственностью дескриптора, а не лежащего в его основе файла. Поэтому новый дескриптор, возвращенный функциями <code>dup()</code> или <code>dup2()</code> (или <code>fcntl()</code> с <code>F_DUPD</code>, которую мы намереваемся посмотреть), не наследует установки флага close-on-exec первоначального дескриптора. Если вам нужно установить его также и для нового дескриптора файла, вы должны не забыть сделать это сами. Такое поведение имеет смысл: если вы просто вызвали <code>dup()</code>, копируя один конец канала в 0 или 1, вы не захотите, чтобы система закрыла его вместо вас, как только процесс осуществит exec!</p>
       </cite>
       <cite>
        <subtitle>История борьбы close-on-exec от <code>gawk</code></subtitle>
        <p>В языке awk операторы ввода/вывода используют обозначение перенаправления, сходное с обозначением для оболочки. Это включает односторонние каналы к и от подпроцесса:</p>
        <p><code>print "something brilliant" &gt; "/some/file" /* Вывод в файл */</code></p>
        <p><code>getline my_record &lt; "/some/other/file" /* Ввод из файла */</code></p>
        <p><code>print "more words of wisdom" | "a_reader process" /* Вывод в подпроцесс */</code></p>
        <p><code>"a_write_process" | getline some_input /* Ввод из подпроцесса */</code></p>
        <p>У интерпретатора <code>awk</code> есть дескрипторы открытых файлов для всех перенаправлений файлов, а для обозначений каналов, создающих подпроцессы, интерпретатор <code>awk</code> создает канал, а затем осуществляет <code>fork</code> и <code>exec</code> оболочки для запуска команды, приведенной в строке.</p>
        <p>Теперь на современных системах часть стартового кода библиотеки С времени исполнения (который запускается до вызова <code>main()</code>) нуждается для управления использованием разделяемых библиотек во временно открытых файлах. Это означает, что для новой программы после исполнения <code>exec</code> должны быть по крайней мере один или два неиспользуемых дескриптора файла, иначе программа просто не будет работать</p>
        <p>Однажды один пользователь сообщил, что когда в программе было максимальное количество открытых файлов, ни один процесс, для которого она пыталась использовать для конвейера <code>fork</code> и <code>exec</code>, не мог успешно начаться!</p>
        <p>Вы, возможно, можете догадаться, что произошло. Порожденная оболочка унаследовала дескрипторы открытых файлов, которые <code>gawk</code> сама использовала для своих перенаправлений. Мы модифицировали <code>gawk</code> так, чтобы установить флаг close-on-exec для всех перенаправлений файлов и каналов, что и решило проблему.</p>
       </cite>
      </section>
      <section>
       <title>
        <p>9.4.3.2. Дублирование дескриптора файла</p>
       </title>
       <p>Когда аргумент <code>cmd</code> функции <code>fcntl()</code> равен <code>F_DUPFD</code>, ее поведение похоже, но не идентично поведению <code>dup2()</code>. В этом случае <code>arg</code> является дескриптором файла, представляющим наименьшее приемлемое значение для нового дескриптора файла:</p>
       <p><code>int new_fd = fcntl(old_fd, F_DUPFD, 7);</code></p>
       <p><code> /* Возвращаемое значение между 7 и максимумом или неудача */</code></p>
       <p><code>int new_fd = dup2(old_fd, 7);</code></p>
       <p><code> /* Возвращаемое значение 7 или неудача */</code></p>
       <p>Вы можете имитировать поведение <code>dup()</code>, которая возвращает наименьший свободный дескриптор файла, использовав '<code>fcntl(old_fd, F_DUPED, 0)</code>'.</p>
       <p>Если вы помните, что дескрипторы файлов являются просто индексами внутренней таблицы, работа этой функции должна быть ясна. Третий аргумент просто предоставляет индекс, с которого ядро должно начать поиск неиспользуемого дескриптора файла.</p>
       <p>Использовать ли в собственном коде <code>fcntl()</code> с <code>F_DUPED</code> или <code>dup()</code> или <code>dup2()</code>, в значительной степени является делом вкуса. Все три функции API являются частью POSIX и широко поддерживаются. У нас легкое пристрастие к <code>dup()</code> и <code>dup2()</code>, поскольку они более специфичны в своих действиях, поэтому являются самодокументирующимися. Но поскольку все они довольно просты, эта аргументация может вас не убедить.</p>
      </section>
      <section>
       <title>
        <p>9.4.3.3. Работа с флагами статуса файла и режимами доступа</p>
       </title>
       <p>В разделе 4.6.3 «Возвращаясь к <code>open()</code>» мы предоставили полный список флагов O_<emphasis>xx</emphasis>, которые принимает <code>open()</code>. POSIX разбивает их по функциям, классифицируя в соответствии с табл. 9.4.</p>
       <empty-line/>
       <p><strong>Таблица 9.4</strong>. Флаги O_<emphasis>xx</emphasis> для <code>open()</code>, <code>creat()</code> и <code>fcntl()</code></p>
       <table>
        <tr align="left">
         <th align="left" valign="top">Категория</th>
         <th align="left" valign="top">Функции</th>
         <th align="left" valign="top">Флаги</th>
        </tr>
        <tr align="left">
         <td align="left" valign="top">Доступ к файлу</td>
         <td align="left" valign="top"><code>open()</code>, <code>fcntl()</code></td>
         <td align="left" valign="top"><code>O_RDONLY</code>, <code>O_RDWR</code>, <code>O_WRONLY</code></td>
        </tr>
        <tr align="left">
         <td align="left" valign="top">Создание файла</td>
         <td align="left" valign="top"><code>open()</code></td>
         <td align="left" valign="top"><code>O_CREAT</code>, <code>O_EXCL</code>, <code>O_NOCTTY</code>, <code>O_TRUNC</code></td>
        </tr>
        <tr align="left">
         <td align="left" valign="top">Статус файла</td>
         <td align="left" valign="top"><code>open()</code>, <code>fcntl()</code></td>
         <td align="left" valign="top"><code>O_APPEND</code>, <code>O_DSYNC</code>, <code>O_NONBLOCK</code>, <code>O_RSYNC</code>, <code>O_SYNC</code></td>
        </tr>
       </table>
       <p>Помимо первоначальной установки различных флагов с помощью <code>open()</code>, вы можете использовать <code>fcntl()</code> для получения текущих установок, а также их изменения. Это осуществляется с помощью значений <code>cmd</code> <code>F_GETFL</code> и <code>F_SETFL</code> соответственно. Например, вы можете использовать эти команды для изменения установки неблокирующего флага, <code>O_NONBLOCK</code>, подобным образом:</p>
       <p><code>int fd_flags;</code></p>
       <p><code>if ((fd_flags = fcntl(fd, F_GETFL)) &lt; 0)</code></p>
       <p><code> /* обработать ошибку */</code></p>
       <p><code>if ((fd_flags &amp; O_NONBLOCK) != 0) { /* Установлен неблокирующий флаг */</code></p>
       <p><code> fd_flags &amp;= ~O_NONBLOCK; /* Сбросить его */</code></p>
       <p><code> if (fcntl(fd, F_SETFL, fd_flags) != 0) /* Дать ядру новое значение */</code></p>
       <p><code>  /* обработать ошибку */</code></p>
       <p><code>}</code></p>
       <p>Помимо самих режимов именованная константа <code>O_ACCMODE</code> является маской, которую вы можете использовать для выделения из возвращаемого значения режимов прав доступа.</p>
       <p><code>fd_flags = fcntl(fd, F_GETFL);</code></p>
       <p><code>switch (fd_flags &amp; O_ACCESS) {</code></p>
       <p><code>case O_RDONLY:</code></p>
       <p><code> /* ...действия только для чтения... */</code></p>
       <p><code> break;</code></p>
       <p><code>case O_WRONLY:</code></p>
       <p><code> /* ...действия только для записи... */</code></p>
       <p><code> break;</code></p>
       <p><code>case O_RDWR:</code></p>
       <p><code> /* ...действия для чтения и записи... */</code></p>
       <p><code> break;</code></p>
       <p><code>}</code></p>
       <p>POSIX требует, чтобы <code>O_RDONLY</code>, <code>O_RDWR</code> и <code>O_WRONLY</code> были побитово различными, таким образом, гарантируется, что код, подобный только что показанному, будет работать и является простым способом определения того, как был открыт произвольный дескриптор файла.</p>
       <p>Используя <code>F_SETFL</code> вы можете также изменить эти режимы, хотя по-прежнему применяется проверка прав доступа. Согласно справочной странице GNU/Linux <emphasis>fcnlt</emphasis>(2) флаг <code>O_APPEND</code> не может быть сброшен, если он использовался при открытии файла.</p>
      </section>
      <section>
       <title>
        <p>9.4.3.4. Неблокирующий ввод/вывод для каналов и FIFO</p>
       </title>
       <p>Ранее для описания способа работы каналов мы использовали сравнение с двумя людьми, моющими и вытирающими тарелки с использованием сушилки; когда сушилка заполняется, останавливается моющий, а когда она пустеет, останавливается вытирающий. Это <emphasis>блокирующее</emphasis> поведение: производитель или потребитель блокируются в вызове <code>write()</code> или <code>read()</code>, ожидая либо освобождения канала, либо появления в нем данных.</p>
       <p>В действительности человек, ожидающий опустения или заполнения сушилки, не должен просто неподвижно стоять.<a l:href="#n101" type="note">[101]</a> Вместо этого незанятый супруг мог бы пойти и найти другую работу по кухне (такую, как подметание всех крошек за детьми на полу), пока сушилка снова не будет готова.</p>
       <p>На языке Unix/POSIX эта концепция обозначается термином <emphasis>неблокирующий ввод/вывод</emphasis>, т.е. запрошенный ввод/вывод либо завершается, либо возвращает значение ошибки, указывающее на отсутствие данных (для читающего) или отсутствие места (для записывающего). Неблокирующий ввод/вывод применяется к каналам и FIFO, а не к обычным файлам на диске. Он может применяться также и к определенным устройствам, таким как терминалы, и к сетевым соединениям, обе эти темы выходят за рамки данной книги.</p>
       <p>С функцией <code>open()</code> может использоваться флаг <code>O_NONBLOCK</code> для указания неблокирующего ввода/вывода, он может быть установлен и сброшен с помощью <code>fcntl()</code>. Для <code>open()</code> и <code>read()</code> неблокирующий ввод/вывод прост.</p>
       <p>Открытие FIFO с установленным или сброшенным <code>O_NONBLOCK</code> демонстрирует следующее поведение:</p>
       <p><code>open("/fifо/file", O_RDONLY, mode)</code></p>
       <p>Блокируется до открытия FIFO для записи.</p>
       <p><code>open("/fifo/file", O_RDONLY | O_NONBLOCK, mode)</code></p>
       <p>Открывает файл, возвращаясь немедленно.</p>
       <p><code>open("/fifo/file", O_WRONLY, mode)</code></p>
       <p>Блокирует до открытия FIFO для чтения.</p>
       <p><code>open("/fifo/file", O_WRONLY | O_NONBLOCK, mode)</code></p>
       <p>Если FIFO был открыт для чтения, открывает FIFO и немедленно возвращается. В противном случае возвращает ошибку (возвращаемое значение -1 и <code>errno</code> установлен в <code>ENXIO</code>).</p>
       <p>Как описано для обычных каналов, вызов <code>read()</code> для FIFO, который больше не открыт для чтения, возвращает конец файла (возвращаемое значение 0). Флаг <code>O_NONBLOCK</code> в данном случае неуместен. Для <emphasis>пустого</emphasis> канала или FIFO (все еще открытых для записи, но не содержащих данных) все становится интереснее:</p>
       <p><code>read(fd, buf, count) и сброшенный O_NONBLOCK</code></p>
       <p>Функция <code>read()</code> блокируется до тех пор, пока в канал или FIFO не поступят данные.</p>
       <p><code>read(fd, buf, count) и установленный O_NONBLOCK</code></p>
       <p>Функция <code>read()</code> немедленно возвращает -1 с установленным в <code>errno EAGAIN</code>.</p>
       <p>В заключение, поведение <code>write()</code> более сложно. Для обсуждения этого нам нужно сначала представить концепцию <emphasis>атомарной записи</emphasis>. Атомарная запись — это такая запись, при которой все данные записываются целиком, не чередуясь с данными от других записей. POSIX определяет в <code>&lt;unistd.h&gt;</code> константу <code>PIPE_BUF</code>. Запись в канал или FIFO данных размером менее или равным <code>PIPE_BUF</code> байтов либо успешно завершается, либо блокируется в соответствии с подробностями, которые мы скоро приведем. Минимальным значением для <code>PIPE_BUF</code> является <code>_POSIX_PIPE_BUF</code>, что равняется 512. Само значение <code>PIPE_BUF</code> может быть больше; современные системы GLIBC определяют ее размер в 4096, но в любом случае следует использовать эту именованную константу и не ожидать, что <code>PIPE_BUF</code> будет иметь то же значение на разных системах.</p>
       <p>Во всех случаях для каналов и FIFO <code>write()</code> добавляет данные в конец канала. Это происходит от того факта, что у каналов нет файловых смещений: в них нельзя осуществлять поиск.</p>
       <p>Также во всех случаях, как упоминалось, записи размером вплоть до <code>PIPE_BUF</code> являются атомарными: данные не перемежаются с данными от других записей. Данные записи размером более <code>PIPE_BUF</code> байтов могут перемежаться с данными других записей <emphasis>в произвольных границах</emphasis>. Это последнее означает, что вы <emphasis>не можете</emphasis> ожидать, что каждая порция размером <code>PIPE_BUF</code> большого набора данных будет записана атомарно. Установка <code>O_NONBLOCK</code> не влияет на это правило.</p>
       <p>Как и в случае с <code>read()</code>, когда <code>O_NONBLOCK</code> не установлен, <code>write()</code> блокируется до тех пор, пока все данные не будут записаны.</p>
       <p>Наиболее все усложняется, когда установлен <code>O_NONBLOCK</code>. Канал или FIFO ведут себя следующим образом:</p>
       <table>
        <tr align="left">
         <th align="left" valign="top"/>
         <th align="left" valign="top">размер &#8805; nbytes</th>
         <th align="left" valign="top">размер &lt; abytes</th>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>nbytes &#8804; PIPE_BUF</code></td>
         <td align="left" valign="top"><code>write()</code> успешна</td>
         <td align="left" valign="top"><code>write()</code> возвращает <code>(-1)/EAGAIN</code></td>
        </tr>
        <tr align="left">
         <th align="left" valign="top"/>
         <th align="left" valign="top">размер &gt; 0</th>
         <th align="left" valign="top">размер = 0</th>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>nbytes &gt; PIPE_BUF</code></td>
         <td align="left" valign="top"><code>write()</code> записывает, что может</td>
         <td align="left" valign="top"><code>write()</code> возвращает <code>(-1)/EAGAIN</code></td>
        </tr>
       </table>
       <p>Для файлов, не являющихся каналами и FIFO и к которым может быть применен <code>O_NONBLOCK</code>, поведение следующее:</p>
       <p>размер &gt; 0 <code>write()</code> записывает, что может</p>
       <p>размер = 0 <code>write()</code> возвращает <code>-1/EAGAIN</code></p>
       <p>Хотя есть ряд сбивающих с толку изменений поведения в зависимости от того, канал это или не канал, установлен <code>O_NONBLOCK</code> или сброшен, есть в канале место для записи или нет, а также в зависимости от размера предполагаемой записи, эти правила предназначены для упрощения программирования:</p>
       <p>• Всегда можно отличить конец файла: <code>read()</code> возвращает 0 байтов.</p>
       <p>• Если нет доступных для чтения данных, <code>read()</code> либо завершается успешно, либо возвращает указание «нет данных для чтения»: <code>EAGAIN</code>, что означает «попытайтесь снова позже».</p>
       <p>• Если для записи нет места, <code>write()</code> либо блокируется до успешного завершения (<code>O_NONBLOCK</code> сброшен), либо завершается неудачей с ошибкой «в данный момент нет места для записи»: <code>EAGAIN</code>.</p>
       <p>• Когда место есть, будет записано столько данных, сколько возможно, так что в конечном счете все данные будут переписаны.</p>
       <p>Подводя итог, если вы собираетесь использовать неблокирующий ввод/вывод, любой код, который использует <code>write()</code>, должен быть способен обработать укороченную запись, когда успешно записан меньший объем данных, чем было затребовано. Устойчивый код в любом случае должен быть написан таким способом: даже в случае обычного файла диск может оказаться заполненным и <code>write()</code> сможет записать лишь часть данных.</p>
       <p>Более того, вы должны быть готовы обработать <code>EAGAIN</code>, понимая, что в этом случае неудача <code>write()</code> не обязательно означает фатальную ошибку. То же верно для кода, использующего для чтения неблокирующий ввод/вывод: признайте, что и здесь <code>EAGAIN</code> не является фатальным. (Однако, может стоит подсчитывать число таких отказов, оставив попытки, когда их слишком много.)</p>
       <p>Неблокирующий ввод/вывод действительно усложняет вашу жизнь, в этом нет никакого сомнения. Но для многих приложений он является необходимостью, позволяющей выполнить задание. Снова рассмотрите спулер печати. Демон спулера не может позволить себе находиться в блокирующем <code>read()</code> для файла FIFO, которому представлены входящие задания. Он должен иметь также возможность отслеживать запущенные задания и, возможно, периодически проверять состояние печатающих устройств (например, убедиться, что не заело бумагу).</p>
      </section>
      <section>
       <title>
        <p>9.4.3.5. Сводка fcntl()</p>
       </title>
       <p>Сводка для системного вызова <code>fcntl()</code> приведена в табл. 9.5.</p>
       <empty-line/>
       <p><strong>Таблица 9.5</strong>. Сводка <code>fcntl()</code></p>
       <table>
        <tr align="left">
         <th align="left" valign="top">Значение <code>cmd</code></th>
         <th align="left" valign="top">Значение <code>arg</code></th>
         <th align="left" valign="top">Возвращает</th>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>F_DUPFD</code></td>
         <td align="left" valign="top">Наименьший новый дескриптор</td>
         <td align="left" valign="top">Дублирует аргумент <code>fd</code></td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>F_GETFD</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Получает флаги дескриптора файла (close-on-exec)</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>F_SETFD</code></td>
         <td align="left" valign="top">Новое значение флага</td>
         <td align="left" valign="top">Устанавливает флаги дескриптора файла (close-on-exec)</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>F_GETFL</code></td>
         <td align="left" valign="top"/>
         <td align="left" valign="top">Получает флаги основного файла</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>F_SETFL</code></td>
         <td align="left" valign="top">Новое значение флага</td>
         <td align="left" valign="top">Устанавливает флаги основного файла</td>
        </tr>
       </table>
       <p>Флаги создания, статуса и прав доступа файла копируются, когда дескриптор файла дублируется. Флаг close-on-exec не копируется.</p>
      </section>
     </section>
    </section>
    <section>
     <title>
      <p>9.5. Пример: двусторонние каналы в <code>gawk</code></p>
     </title>
     <p><emphasis>Двусторонний канал</emphasis> соединяет два процесса двунаправленным образом. Обычно, по крайней мере для одного из процессов, на канал с другим процессом настраиваются как стандартный ввод, так и стандартный вывод. Оболочка Корна (<code>ksh</code>) ввела двусторонние каналы на уровне языка, обозначив термином <emphasis>сопроцесса (coprocess)</emphasis>:</p>
     <p><code><emphasis>команды и аргументы движка базы данных</emphasis> |&amp; /* Запустить сопроцесс в фоновом режиме */</code></p>
     <p><code>print -p "команда базы данных" /* Записать в сопроцесс */</code></p>
     <p><code>read -p db_response /* Прочесть из сопроцесса */</code></p>
     <p>Здесь <emphasis>движок базы данных</emphasis> представляет любую серверную программу, которая может управляться интерфейсной частью, в данном случае, сценарием <code>ksh</code>. У <emphasis>движка базы данных</emphasis> стандартный ввод и стандартный вывод подсоединены к оболочке посредством двух отдельных односторонних каналов.<a l:href="#n102" type="note">[102]</a> Это показано на рис. 9.7.</p>
     <image l:href="#img_22.jpeg"/>
     <p><strong>Рис. 9.7</strong>. Сопроцессы оболочки Корна</p>
     <p>В обычном <code>awk</code> каналы к или от подпроцесса являются односторонними: нет способа послать данные в программу и прочесть посланные от нее в ответ данные — нужно использовать временный файл. GNU <code>awk</code> (<code>gawk</code>) заимствует обозначение '<code>|&amp;</code>' от <code>ksh</code> для расширения языка <code>awk</code>:</p>
     <p><code>print "<emphasis>команда</emphasis>" |&amp; "<emphasis>движок базы данных</emphasis>" /* Запустить сопроцесс, записать в него */</code></p>
     <p><code>"<emphasis>движок базы данных</emphasis>" |&amp; getline db_response /* Прочесть из сопроцесса */</code></p>
     <p><code>gawk</code> использует запись '<code>|&amp;</code>' также для сокетов TCP/IP и порталов BSD, которые не рассматриваются в данной книге. Следующий код из <code>io.c</code> в дистрибутиве <code>gawk</code> 3.1.3 является частью функции <code>two_way_open()</code>, которая устанавливает простой сопроцесс: она создает два канала, порождает новый процесс и осуществляет все манипуляции с дескриптором файла. Мы опустили ряд не относящихся к делу частей кода (эта функция занимает больше места, чем следовало бы):</p>
     <p><code>1561 static int</code></p>
     <p><code>1562 two_way_open(const char *str, struct redirect *rp)</code></p>
     <p><code>1563 {</code></p>
     <p><code>      ...</code></p>
     <empty-line/>
     <p><code>1827 /* случай 3: двусторонний канал с порожденным процессом */</code></p>
     <p><code>1828 {</code></p>
     <p><code>1829  int ptoc[2], сtop[2];</code></p>
     <p><code>1830  int pid;</code></p>
     <p><code>1831  int save_errno;</code></p>
     <p><code>1835</code></p>
     <p><code>1836  if (pipe(ptoc) &lt; 0)</code></p>
     <p><code>1837   return FALSE; /* установлен errno, диагностика от вызывающего */</code></p>
     <p><code>1838</code></p>
     <p><code>1839  if (pipe(ctop) &lt; 0) {</code></p>
     <p><code>1840   save_errno = errno;</code></p>
     <p><code>1841   close(ptoc[0]);</code></p>
     <p><code>1842   close(ptoc[1]);</code></p>
     <p><code>1843   errno = save_errno;</code></p>
     <p><code>1844   return FALSE;</code></p>
     <p><code>1845  }</code></p>
     <p>Первым шагом является создание двух каналов, <code>ptoc</code> является каналом «от родителя к потомку», а <code>ctop</code> — «от потомка к родителю». Во время чтения держите в уме, что индекс 0 является читаемым концом, а 1 — записываемым.</p>
     <p>Строки 1836–1837 создают первый канал, <code>ptoc</code>. Строки 1839–1845 создают второй канал, закрывая при неудачном создании и первый. Это важно. Небрежность в закрытии открытых, но не используемых каналов ведет к <emphasis>утечкам дескрипторов файлов</emphasis>. Как и память, дескрипторы файлов являются конечным ресурсом, и когда они иссякают, то теряются.<a l:href="#n103" type="note">[103]</a> То же верно и для открытых файлов: убедитесь, что ваш обрабатывающий ошибки код всегда закрывает все открытые файлы и каналы, которые не нужны, когда происходит ошибка.</p>
     <p><code>save_errno</code> сохраняет значения <code>errno</code>, установленные <code>pipe()</code>, на тот редкий случай, когда <code>close()</code> может завершиться неудачей (строка 1840). Затем <code>errno</code> восстанавливается в строке 1843.</p>
     <p><code>1906 if ((pid = fork()) &lt; 0) {</code></p>
     <p><code>1907  save_errno = errno;</code></p>
     <p><code>1908  close(ptoc[0]); close(ptoc[1]);</code></p>
     <p><code>1909  close(ctop[0]); close(ctop[1]);</code></p>
     <p><code>1910  errno = save_errno;</code></p>
     <p><code>1911  return FALSE;</code></p>
     <p><code>1912 }</code></p>
     <p>Строки 1906–1912 порождают процесс, на этот раз закрывая оба канала, если <code>fork()</code> потерпит неудачу. Здесь также первоначальное значение <code>errno</code> сохраняется и восстанавливается для последующего использования при диагностике.</p>
     <p><code>1914 if (pid == 0) { /* порожденный процесс */</code></p>
     <p><code>1915  if (close(1) == -1)</code></p>
     <p><code>1916   fatal(_("close of stdout in child failed (%s)"),</code></p>
     <p><code>1917    strerror(errno));</code></p>
     <p><code>1918  if (dup(ctop[1]) != 1)</code></p>
     <p><code>1919   fatal(_{"moving pipe to stdout in child failed (dup: %s)"), strerror(errno));</code></p>
     <p><code>1920  if (close(0) == -1)</code></p>
     <p><code>1921   fatal(_("close of stdin in child failed (%s)"),</code></p>
     <p><code>1922    strerror(errno));</code></p>
     <p><code>1923  if (dup(ptoc[0]) != 0)</code></p>
     <p><code>1924   fatal(_("moving pipe to stdin in child failed (dup: %s)"), strerror(errno));</code></p>
     <p><code>1925  if (close(ptoc[0]) == -1 || close(ptoc[1]) == -1</code></p>
     <p><code>1926   || close(ctop[0]) == -1 || close(ctop[1]) == -1)</code></p>
     <p><code>1927   fatal(_("close of pipe failed (%s)"), strerror(errno));</code></p>
     <p><code>1928  /* stderr HE дублируется в stdout потомка */</code></p>
     <p><code>1929  execl("/bin/sh", "sh", "-c", str, NULL);</code></p>
     <p><code>1930  _exit(errno == ENOENT ? 127 : 126);</code></p>
     <p><code>1931 }</code></p>
     <p>Строки 1914–1931 обрабатывают код потомка, с соответствующей проверкой ошибок и сообщениями на каждом шагу. Строка 1915 закрывает стандартный вывод. Строка 1918 копирует записываемый конец канала от потомка к родителю на 1. Строка 1920 закрывает стандартный ввод, а строка 1923 копирует читаемый конец канала от родителя к потомку на 0. Если это все работает, стандартные ввод и вывод теперь на месте и подключены к родителю.</p>
     <p>Строки 1925–1926 закрывают все четыре первоначальные дескрипторы файлов каналов, поскольку они больше не нужны. Строка 1928 напоминает нам, что стандартная ошибка остается на месте. Это лучшее решение, поскольку пользователь увидит ошибки от сопроцесса. Программа <code>awk</code>, которая должна перехватить стандартную ошибку, может использовать в команде обозначение '<code>2&gt;&amp;1</code>' для перенаправления стандартной ошибки сопроцесса или записи в отдельный файл.</p>
     <p>Наконец, строки 1929–1930 пытаются запустить для оболочки <code>execl()</code> и соответственно выходят, если это не удается.</p>
     <p><code>1934 /* родитель */</code></p>
     <p><code>1935 rp-&gt;pid = pid;</code></p>
     <p><code>1936 rp-&gt;iop = iop_alloc(ctop[0], str, NULL);</code></p>
     <p><code>1937 if (rp-&gt;iop == NULL) {</code></p>
     <p><code>1938  (void)close(ctop[0]);</code></p>
     <p><code>1939  (void)close(ctop[1]);</code></p>
     <p><code>1940  (void)close(ptoc[0]);</code></p>
     <p><code>1941  (void)close(ptoc[1]);</code></p>
     <p><code>1942  (void)kill(pid, SIGKILL); /* overkill? (pardon pun) */</code></p>
     <p><code>1943</code></p>
     <p><code>1944  return FALSE;</code></p>
     <p><code>1945 }</code></p>
     <p>Первым шагом родителя является настройка входного конца от сопроцесса. Указатель <code>rp</code> указывает на <code>struct redirect</code>, которая содержит поле для сохранения PID порожденного процесса, <code>FILE*</code> для вывода и указатель <code>IOBUF*</code> с именем <code>iop</code>. <code>IOBUF</code> является внутренней структурой данных <code>gawk</code> для осуществления ввода. Она, в свою очередь, хранит копию нижележащего дескриптора файла.</p>
     <p>Строка 1935 сохраняет значение ID процесса. Строка 1936 выделяет память для новой <code>IOBUF</code> для данных дескриптора файла и командной строки. Третий аргумент здесь равен <code>NULL</code>: он позволяет при необходимости использовать предварительно выделенный <code>IOBUF</code>.</p>
     <p>Если выделение памяти потерпело неудачу, строки 1937–1942 производят очистку, закрывая каналы и посылая сигнал «kill» порожденным процессам, чтобы заставить их завершить работу. (Функция <code>kill()</code> описана в разделе 10.6.7 «Отправка сигналов <code>kill()</code> и <code>killpg()</code>».)</p>
     <p><code>1946 rp-&gt;fp = fdopen(ptoc[1], "w");</code></p>
     <p><code>1947 if (rp-&gt;fp == NULL) {</code></p>
     <p><code>1948  iop_close(rp-&gt;iop);</code></p>
     <p><code>1949  rp-&gt;iop = NULL;</code></p>
     <p><code>1950  (void)close(ctop[0]);</code></p>
     <p><code>1951  (void)close(ctop[1]);</code></p>
     <p><code>1952  (void)close(ptoc[0]);</code></p>
     <p><code>1953  (void)close(ptoc[1]);</code></p>
     <p><code>1954  (void)kill(pid, SIGKILL); /* избыточно? (пардон, каламбур)</code><a l:href="#n104" type="note">[104]</a> <code>*/</code></p>
     <p><code>1955</code></p>
     <p><code>1956  return FALSE;</code></p>
     <p><code>1957 }</code></p>
     <p>Строки 1946–1957 аналогичны. Они устанавливают вывод родителя на потомка, сохраняя дескриптор файла для записывающего конца канала от родителя к потомку в <code>FILE*</code>, используя функцию <code>fdopen()</code>. Если это завершается неудачей, строки 1947–1957 предпринимают те же действия, что и ранее: закрывают все дескрипторы каналов и посылают сигнал порожденным процессам.</p>
     <p>С этого момента записываемый конец канала от родителя к потомку и читаемый конец канала от потомка к родителю хранятся в более крупных структурах: <code>FILE*</code> и <code>IOBUF</code> соответственно. Они автоматически закрываются обычными процедурами, которые закрывают эти структуры. Однако, остаются две задачи:</p>
     <p><code>1960   os_close_on_exec(ctop[0], str, "pipe", "from");</code></p>
     <p><code>1961   os_close_on_exec(ptoc[1], str, "pipe", "from");</code></p>
     <p><code>1962</code></p>
     <p><code>1963   (void)close(ptoc[0]);</code></p>
     <p><code>1964   (void)close(ctop[1]);</code></p>
     <p><code>1966</code></p>
     <p><code>1967   return TRUE;</code></p>
     <p><code>1968  }</code></p>
     <p><code>      ...</code></p>
     <p><code>1977 }</code></p>
     <p>Строки 1960–1961 устанавливают флаг close-on-exec для двух дескрипторов, которые остались открытыми. <code>os_close_on_exec()</code> является простой функцией-оболочкой, которая выполняет эту работу на Unix- и POSIX-совместимых системах, но ничего не делает на системах, в которых нет флага close-on-exec. Это скрывает проблему переносимости в одном месте и позволяет избежать в коде множества запутывающих <code>#ifdef</code> здесь и в других местах <code>io.c</code>.</p>
     <p>Наконец, строки 1963–1964 закрывают концы каналов, которые не нужны родителю, а строка 1967 возвращает TRUE для обозначения успеха.</p>
    </section>
    <section>
     <title>
      <p>9.6. Рекомендуемая литература</p>
     </title>
     <p>Управление заданиями сложно, включает группы процессов, сеансы, механизмы ожидания, сигналы и манипулирование группой процессов терминала. По существу, мы решили не вдаваться в детали. Однако, вы можете захотеть взглянуть на следующие книги:</p>
     <p>1. <emphasis>Advanced Programming in the UNIX Environment</emphasis>, 2nd edition, by W. Richard Stevens and Stephen Rago. Addison-Wesley, Reading Massachusetts, USA, 2004. ISBN: 0-201-43307-9.</p>
     <p>Эта книга и полна, и основательна, охватывая элементарное и продвинутое программирование под Unix. Она превосходно освещает группы процессов, сеансы, управление заданиями и сигналы</p>
     <p>2. <emphasis>The Design and Implementation of the 4.4 BSD Operating System</emphasis>, by Marshall Kirk McKusick, Keith Bostic, Michael J. Karels, and John S. Quarterman. Addison-Wesley, Reading, Massachusetts, USA, 1996. ISBN: 0-201-54979-4.</p>
     <p>Эта книга дает хороший обзор того же материала, включая обсуждение структур данных ядра, которое можно найти в разделе 4.8 этой книги.</p>
    </section>
    <section>
     <title>
      <p>9.7. Резюме</p>
     </title>
     <p>• Новые процессы создаются с помощью <code>fork()</code>. После этого оба процесса исполняют один и тот же код, причем единственным различием является возвращаемое значение: 0 в порожденном процессе и положительный номер PID в родительском. Порожденный процесс наследует копии почти всех атрибутов родителя, наиболее важными из которых являются, пожалуй, открытые файлы.</p>
     <p>• Унаследованные разделяемые дескрипторы файлов делают возможным многое из высокоуровневой семантики Unix и элегантные управляющие структуры оболочки. Это одна из наиболее фундаментальных частей оригинального дизайна Unix. Из-за разделения дескрипторов файл на самом деле не закрывается до тех пор, пока не будет закрыт последний открытый дескриптор файла. Это в особенности касается каналов, но затрагивает также освобождение дисковых блоков для удаленных, но все еще открытых файлов.</p>
     <p>• Вызовы <code>getpid()</code> и <code>getppid()</code> возвращают ID текущего и родительского процессов соответственно. Родителем процесса, первоначальный родитель которого завершается, становится специальный процесс <code>init</code> с PID 1. Таким образом, PPID может меняться, и приложения должны быть готовы к этому.</p>
     <p>• Системный вызов <code>nice()</code> дает возможность настраивать приоритет вашего процесса. Чем приятнее вы по отношению к другим процессам, тем меньше ваш относительный приоритет, и наоборот. Лишь суперпользователь может иметь больший приоритет по сравнению с другими процессами. На современных системах, особенно однопользовательских, нет действительных причин для изменения знамения относительного приоритета.</p>
     <p>• Системный вызов <code>exec()</code> начинает исполнение новой программы в существующем процессе. Шесть различных версий вызова предоставляют гибкость в установке списков аргументов и окружения ценой первоначальной путаницы по поводу того, какую из них лучше всего использовать. Два варианта имитируют механизм поиска оболочки и отступают к использованию оболочки для интерпретации файла в случае, если он не является двоичным исполняемым файлом; эти варианты должны использоваться с предусмотрительностью.</p>
     <p>• Значение <code>argv[0]</code> для новой программы обычно происходит от имени исполняемого файла, но это лишь соглашение. Как и в случае с <code>fork()</code>, значительный, но не идентичный набор атрибутов наследуется через <code>exec</code>. Другие атрибуты сбрасываются для использования подходящих значений по умолчанию.</p>
     <p>• Функция <code>atexit()</code> регистрирует функции обратного вызова для вызова в порядке LIFO при завершении программы. Функции <code>exit()</code>, <code>_exit()</code> и <code>_Exit()</code> все завершают программу, передавая статус завершения обратно родителю, <code>exit()</code> очищает открытые потоки <code>FILE*</code> и запускает функции, зарегистрированные с помощью <code>atexit()</code>. Две другие функции завершаются немедленно и должны использоваться, лишь когда <code>exec</code> в порожденном процессе завершилась неудачей. Возвращение из <code>main()</code> подобно вызову <code>exit()</code> с данным возвращаемым значением. В C99 и C++ выпадение из <code>main()</code> в конце функции дает тот же результат, что и '<code>exit(0)</code>', но является плохой практикой.</p>
     <p>• <code>wait()</code> и <code>waitpid()</code> являются функциями POSIX для получения статуса завершения порожденного процесса. Различные макросы позволяют определить, завершился ли порожденный процесс нормально, и в таком случае определить статус его завершения, или же порожденный процесс претерпел сигнал завершения, и в этом случае определить совершивший этот проступок сигнал. Со специальными опциями <code>waitpid()</code> предоставляет также сведения о потомках, которые не завершились, но изменили состояние.</p>
     <p>• Системы GNU/Linux и большинство Unix-систем поддерживают также функции BSD <code>wait3()</code> и <code>wait4()</code>. GNU/Linux поддерживает также выходящий из употребления <code>union wait</code>. Функции BSD предоставляют <code>struct rusage</code>, давая доступ к сведениям об использовании времени процессора, что может быть удобным. Хотя если <code>waitpid()</code> будет достаточной, то это наиболее переносимый способ выполнения.</p>
     <p>• Группы процессов являются частью более крупного механизма управления заданиями, который включает сигналы, сеансы и манипулирование состоянием терминала, <code>getpgrp()</code> возвращает ID группы процессов текущего процесса, a <code>getpgid()</code> возвращает PGID определенного процесса. Сходным образом, <code>setpgrp()</code> устанавливает PGID текущего процесса равным его PID, делая его лидером группы процессов; <code>setpgid()</code> дает возможность родительскому процессу установить PGID порожденного, который еще не выполнил <code>exec</code>.</p>
     <p>• Каналы и FIFO предоставляют односторонний коммуникационный канал между двумя процессами. Каналы должны быть установлены общим предком, тогда как FIFO могут использоваться любыми двумя процессами. Каналы создаются с помощью <code>pipe()</code>, а файлы FIFO создаются с помощью <code>mkfifo()</code>. Каналы и FIFO буферируют свои данные, останавливая производителя или потребителя, когда канал заполняется или пустеет.</p>
     <p>• <code>dup()</code> и <code>dup2()</code> создают копии дескрипторов открытых файлов. В сочетании с <code>close()</code> они дают возможность поместить дескрипторы файлов на место стандартного ввода и вывода для каналов. Чтобы каналы работали правильно, все копии неиспользуемых концов каналов до исполнения программой назначения exec должны быть закрыты. Для создания нелинейных каналов может быть использован <code>/dev/fd</code>, что демонстрируется возможностью замещения процессов оболочками Bash и Korn.</p>
     <p>• <code>fcntl()</code> является функцией для выполнения различных работ. Она управляет атрибутами как самого дескриптора файла, так и лежащего в его основе файла. В данной главе мы видели, что <code>fcntl()</code> используется для следующего:</p>
     <p> • Дублирования дескриптора файла, имитирования <code>dup()</code> и почти имитирования <code>dup2()</code>.</p>
     <p> • Получения и установки флага close-on-exec. Флаг close-on-exec является в настоящее время единственным атрибутом дескриптора файла, но он важен. Он не копируется в результате действия <code>dup()</code>, но должен явным образом устанавливаться для дескрипторов файлов, которые не должны оставаться открытыми после выполнения exec. На практике, это должно быть сделано для большинства дескрипторов файла.</p>
     <p> • Получение и установка флагов, управляющих нижележащим файлом. Из них <code>O_NONBLOCK</code> является, пожалуй, наиболее полезным, по крайней мере, для FIFO и каналов. Это определенно самый сложный флаг.</p>
    </section>
    <section>
     <title>
      <p>Упражнения</p>
     </title>
     <p>1. Напишите программу, которая выводит как можно больше сведений о текущем процессе: PID, PPID, открытые файлы, текущий каталог, значение относительного приоритета и т.д. Как вы можете сказать, какие файлы открыты? Если несколько дескрипторов файлов ссылаются на один и тот же файл, укажите это. (Опять-таки, как вы можете это узнать?)</p>
     <p>2. Как вы думаете, <code>atexit()</code> хранит указатели на функции обратного вызова? Реализуйте <code>atexit()</code>, держа в уме принцип GNU «никаких произвольных ограничений». Набросайте схему (псевдокод) для <code>exit()</code>. Каких сведений (внутренностей библиотеки <code>&lt;stdio.h&gt;</code>) вам не хватает, чтобы написать <code>exit()</code>?</p>
     <p>3. Программа <code>xargs</code> предназначена для многократных запусков команды и аргументов, когда аргументов слишком много для непосредственного набора в командной строке. Программа работает, считывая строки из стандартного ввода, рассматривая каждую строку в качестве отдельного аргумента для указанной команды, и упаковывая аргументы до тех пор, пока они остаются в пределах максимально допустимого для системы. Например:</p>
     <p><code>$ <strong>grep ARG_MAX /usr/include/*.h /usr/include/*/*.h</strong> /* Командная строка */</code></p>
     <p><code>bash: /bin/grep: Argument list too long /* Сообщение оболочки об ошибке */</code></p>
     <p><code>$ <strong>find /usr/include -name '*.h' | xargs grep ARG_MAX</strong> /* find b xargs работают */</code></p>
     <p><code>/usr/include/sys/param.h:#define NCARGS ARG_MAX</code></p>
     <p><code>...</code></p>
     <p>Константа <code>ARG_MAX</code> в <code>&lt;limits.h&gt;</code> представляет сочетание общей памяти, используемой средой, и аргументов командной строки. Стандарт POSIX не говорит, включает ли это массивы указателей или просто сами строки.</p>
     <p>Напишите простую версию <code>xargs</code>, которая работает указанным способом. Не забудьте об окружении при вычислении размера необходимого пространства. Убедитесь, что тщательно управляете памятью.</p>
     <p>4. Компоновка значения status, заполняемого функциями <code>wait()</code> и <code>waitpid()</code>, стандартом POSIX не определяется. Хотя и историческое, это 16-разрядное значение, которое выглядит, как показано на рис. 9.8.</p>
     <image l:href="#img_23.jpeg"/>
     <p><strong>Рис. 9.8</strong>. Компоновка значения status функции <code>wait()</code></p>
     <p> • Ненулевое значение в битах 0–7 указывает на завершение по сигналу.</p>
     <p> • Все единичные биты в поле сигнала указывает, что порожденный процесс остановлен. В этом случае биты 9-15 содержат номер сигнала.</p>
     <p> • Единичное значение бита 8 указывает завершение со снимком процесса.</p>
     <p> • Если биты 0–7 равны нулю, процесс завершился нормально. В этом случае биты 9–15 являются статусом завершения.</p>
     <p>Напишите с данными сведениями макросы POSIX <code>WIFEXITED()</code> и др.</p>
     <p>5. Помня, что <code>dup2()</code> сначала закрывает запрошенный дескриптор файла, реализуйте <code>dup2()</code>, используя <code>close()</code> и <code>fcntl()</code>. Как вы обработаете случай, когда <code>fcntl()</code> возвращает значение меньше запрошенного?</p>
     <p>6. Есть ли на вашей системе каталог <code>/dev/fd</code>? Если есть, как он реализован?</p>
     <p>7. Напишите новую версию <code>ch09-pipeline.c</code>, которая порождает лишь один процесс. После порождения родитель должен поменять дескрипторы своих файлов и сам выполнить exec для одной из новых программ.</p>
     <p>8. (Трудное) Как вы можете узнать, вызывал ли ваш процесс когда-нибудь <code>chroot()</code>? Напишите программу, которая проверяет это и выводит сообщение с ответом да или нет. Можно ли обмануть вашу программу? Если да, как?</p>
     <p>9. Есть ли на вашей системе каталог <code>/proc</code>? Если да, доступ к какой информации о процессе он обеспечивает?</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 10</p>
     <p>Сигналы</p>
    </title>
    <section>
     <p>Данная глава освещает все подробности сигналов, важную, но сложную часть GNU/Linux API.</p>
    </section>
    <section>
     <title>
      <p>10.1. Введение</p>
     </title>
     <p><emphasis>Сигнал</emphasis> является указанием, что случилось какое-то событие, например, попытка сослаться на адрес памяти, который не является частью адресного пространства вашей программы, или когда пользователь нажимает CTRL-C для выхода из программы (называется <emphasis>генерированием прерывания</emphasis>).</p>
     <p>Программа может узнать лишь, что определенный сигнал был по крайней мере однажды. Обычно вы не можете сказать, случился ли один и тот же сигнал несколько раз. Вы можете отличить один сигнал от другого и управлять способом реагирования программы на различные сигналы.</p>
     <p>Механизмы обработки сигналов развились с течением времени. Как бывает почти со всеми такими механизмами, стандартизованы и доступны как первоначальные, так и более новые API. Однако, из фундаментальных API обработка сигналов обнаруживает, возможно, самые широкие изменения; имеется множество возможностей обработки, чтобы преуспеть в использовании наиболее подходящего API. В результате, возможно, это самая трудная глава в книге. Мы сделаем всевозможное, чтобы сделать изложение более ясным, но если вы проработаете эту главу более тщательно, чем обычно, это поможет.</p>
     <p>В отличие от большинства глав в данной книге, наше представление здесь историческое, связанное с освещением развития API, <emphasis>включая API, которые никогда не следует использовать в новом коде</emphasis>. Мы делаем это, потому что это упрощает изложение, делая понятным, почему функция POSIX API <code>sigaction()</code> поддерживает все те возможности, которые поддерживает.</p>
    </section>
    <section>
     <title>
      <p>10.2. Действия сигналов</p>
     </title>
     <p>Каждый сигнал (вскоре мы представим полный список) имеет связанное с ним <emphasis>действие</emphasis> по умолчанию. POSIX обозначает это как <emphasis>диспозицию (disposition)</emphasis> сигнала. Это то действие, которое ядро осуществляет для процесса, когда поступает определенный сигнал. Действие по умолчанию варьирует:</p>
     <p><emphasis>Завершение</emphasis></p>
     <p>Процесс завершается.</p>
     <p><emphasis>Игнорирование</emphasis></p>
     <p>Сигнал игнорируется. Программа никогда не узнает, что что-то случилось.</p>
     <p><emphasis>Снимок образа процесса</emphasis></p>
     <p>Процесс завершается, и ядро создает файл core (в текущем каталоге процесса), содержащий образ работавшей на момент поступления сигнала программы. Снимок процесса может впоследствии использоваться с отладчиком для исследования состояния программы (см. главу 15 «Отладка»).</p>
     <p>По умолчанию системы GNU/Linux создают файлы с именем <code>core.<emphasis>pid</emphasis></code>, где <code><emphasis>pid</emphasis></code> является ID завершаемого процесса. (Это можно изменить; см. <emphasis>sysctl</emphasis>(8).) Такое именование позволяет хранить в одном и том же каталоге несколько файлов <code>core</code>, за счет использования большего дискового пространства.<a l:href="#n105" type="note">[105]</a> Традиционные системы Unix называют файл <code>core</code>, и это ваше дело сохранить какие-нибудь файлы <code>core</code> для последующего изучения, если есть шанс создания других таких же файлов в том же каталоге.</p>
     <p><emphasis>Остановка</emphasis></p>
     <p>Процесс останавливается. Впоследствии он может быть возобновлен. (Если вы использовали управление заданиями оболочки с помощью CTRL-Z, <code>fg</code> и <code>bg</code>, вы понимаете остановку процесса.)</p>
    </section>
    <section>
     <title>
      <p>10.3. Стандартные сигналы С: <code>signal()</code> и <code>raise()</code></p>
     </title>
     <section>
      <p>Стандарт ISO С определяет первоначальный API управления сигналами V7 и новый API для посылки сигналов. Вы должны использовать их для программ, которым придется работать на не-POSIX системах, или в случаях, когда предоставляемые ISO С API возможности являются достаточными.</p>
     </section>
     <section>
      <title>
       <p>10.3.1. Функция <code>signal()</code></p>
      </title>
      <p>Действие сигнала изменяется с помощью функции <code>signal()</code>. Вы можете изменить действие на «игнорировать сигнал», «восстановить для сигнала действие системы по умолчанию» или «вызвать при появлении сигнала мою функцию с номером сигнала в качестве параметра».</p>
      <p>Функция, которую вы предоставляете для распоряжения сигналом, называется <emphasis>обработчиком сигнала</emphasis> (или просто <emphasis>обработчиком</emphasis>), а установка ее в соответствующем месте осуществляет <emphasis>перехват (catch) сигнала</emphasis>.</p>
      <p>Получив эти сведения, давайте перейдем к API. В заголовочном файле <code>&lt;signal.h&gt;</code> представлены определения макросов для поддерживаемых сигналов и объявления функций управления сигналами, предоставляемыми стандартом С:</p>
      <p><code>#include &lt;signal.h&gt; /* ISO С */</code></p>
      <empty-line/>
      <p><code>void (*signal(int signum, void (*func)(int)))(int);</code></p>
      <p>Это объявление для функции signal() почти невозможно прочесть. Поэтому справочная страница GNU/Linux <emphasis>signal</emphasis>(2) определяет ее таким способом:</p>
      <p><code>typedef void (*sighandler_t)(int);</code></p>
      <empty-line/>
      <p><code>sighandler_t signal(int signum, sighandler_t handler);</code></p>
      <p>Теперь это более вразумительно. Тип <code>sighandler_t</code> является указателем на функцию с возвращаемым типом <code>void</code>, которая принимает один целый аргумент. Это целое является номером поступающего сигнала.</p>
      <p>Функция <code>signal()</code> принимает номер сигнала в качестве своего первого параметра, а указатель функции (новый обработчик) в качестве своего второго аргумента. Если последний не является указателем функции, он может быть лишь <code>SIG_DEF,</code> что означает «восстановить действие по умолчанию», либо <code>SIG_IGN</code>, что означает «игнорировать сигнал».</p>
      <p><code>signal()</code> изменяет действие для <code>signum</code> и возвращает предыдущее действие. (Это дает вам возможность восстановить при желании предыдущее действие.) Возвращаемое значение может равняться также <code>SIG_ERR</code>, что указывает на произошедшую ошибку. (Некоторые сигналы невозможно перехватить или игнорировать; предоставление для них обработчика сигнала или неверный <code>signum</code> создают эту ошибку.) В табл. 10.1 перечислены сигналы, доступные под GNU/Linux, их числовые значения, действия по умолчанию для каждого, формальный стандарт или современная операционная система, которые их определяют, и смысл каждого.</p>
      <empty-line/>
      <p><strong>Таблица 10.1</strong>. Сигналы GNU/Linux</p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Имя</th>
        <th align="left" valign="top">Значение</th>
        <th align="left" valign="top">По умолчанию</th>
        <th align="left" valign="top">Источник</th>
        <th align="left" valign="top">Смысл</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGHUP</code></td>
        <td align="left" valign="top">1</td>
        <td align="left" valign="top">Term</td>
        <td align="left" valign="top">POSIX</td>
        <td align="left" valign="top">Отсоединение</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGINT</code></td>
        <td align="left" valign="top">2</td>
        <td align="left" valign="top">Term</td>
        <td align="left" valign="top">ISO C</td>
        <td align="left" valign="top">Прерывание</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGQUIT</code></td>
        <td align="left" valign="top">3</td>
        <td align="left" valign="top">Core</td>
        <td align="left" valign="top">POSIX</td>
        <td align="left" valign="top">Выход</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGILL</code></td>
        <td align="left" valign="top">4</td>
        <td align="left" valign="top">Core</td>
        <td align="left" valign="top">ISO C</td>
        <td align="left" valign="top">Недействительная инструкция</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGTRAP</code></td>
        <td align="left" valign="top">5</td>
        <td align="left" valign="top">Core</td>
        <td align="left" valign="top">POSIX</td>
        <td align="left" valign="top">Трассировочная ловушка</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGABRT</code></td>
        <td align="left" valign="top">6</td>
        <td align="left" valign="top">Core</td>
        <td align="left" valign="top">ISO C</td>
        <td align="left" valign="top">Прекращение</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGIOT</code></td>
        <td align="left" valign="top">6</td>
        <td align="left" valign="top">Core</td>
        <td align="left" valign="top">BSD</td>
        <td align="left" valign="top">Ловушка IOT</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGBUS</code></td>
        <td align="left" valign="top">7</td>
        <td align="left" valign="top">Core</td>
        <td align="left" valign="top">BSD</td>
        <td align="left" valign="top">Ошибка шины</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGFPE</code></td>
        <td align="left" valign="top">8</td>
        <td align="left" valign="top">Core</td>
        <td align="left" valign="top">ISO C</td>
        <td align="left" valign="top">Исключение с плавающей точкой</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGKILL</code></td>
        <td align="left" valign="top">9</td>
        <td align="left" valign="top">Term</td>
        <td align="left" valign="top">POSIX</td>
        <td align="left" valign="top">Завершение, неблокируемый</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGUSR1</code></td>
        <td align="left" valign="top">10</td>
        <td align="left" valign="top">Term</td>
        <td align="left" valign="top">POSIX</td>
        <td align="left" valign="top">Сигнал 1 пользователя</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGSEGV</code></td>
        <td align="left" valign="top">11</td>
        <td align="left" valign="top">Core</td>
        <td align="left" valign="top">ISO C</td>
        <td align="left" valign="top">Нарушение сегмента</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGUSR2</code></td>
        <td align="left" valign="top">12</td>
        <td align="left" valign="top">Term</td>
        <td align="left" valign="top">POSIX</td>
        <td align="left" valign="top">Сигнал 2 пользователя</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGPIPE</code></td>
        <td align="left" valign="top">13</td>
        <td align="left" valign="top">Term</td>
        <td align="left" valign="top">POSIX</td>
        <td align="left" valign="top">Нарушенный канал</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGALRM</code></td>
        <td align="left" valign="top">14</td>
        <td align="left" valign="top">Term</td>
        <td align="left" valign="top">POSIX</td>
        <td align="left" valign="top">Аварийные часы</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGTERM</code></td>
        <td align="left" valign="top">15</td>
        <td align="left" valign="top">Term</td>
        <td align="left" valign="top">ISO C</td>
        <td align="left" valign="top">Завершение</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGSTKFLT</code></td>
        <td align="left" valign="top">16</td>
        <td align="left" valign="top">Term</td>
        <td align="left" valign="top">Linux</td>
        <td align="left" valign="top">Ошибка стека в процессоре (не используется)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGCHLD</code></td>
        <td align="left" valign="top">17</td>
        <td align="left" valign="top">Ignr</td>
        <td align="left" valign="top">POSIX</td>
        <td align="left" valign="top">Изменение статуса порожденного процесса</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGCLD</code></td>
        <td align="left" valign="top">17</td>
        <td align="left" valign="top">Ignr</td>
        <td align="left" valign="top">System V</td>
        <td align="left" valign="top">То же, что и SIGCHLD (для совместимости)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGCONT</code></td>
        <td align="left" valign="top">18</td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">POSIX</td>
        <td align="left" valign="top">Продолжить при остановке</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGSTOP</code></td>
        <td align="left" valign="top">19</td>
        <td align="left" valign="top">Stop</td>
        <td align="left" valign="top">POSIX</td>
        <td align="left" valign="top">Стоп, неблокируемый</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGTSTP</code></td>
        <td align="left" valign="top">20</td>
        <td align="left" valign="top">Stop</td>
        <td align="left" valign="top">POSIX</td>
        <td align="left" valign="top">Стоп от клавиатуры</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGTTIN</code></td>
        <td align="left" valign="top">21</td>
        <td align="left" valign="top">Slop</td>
        <td align="left" valign="top">POSIX</td>
        <td align="left" valign="top">Фоновое чтение от tty</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGTTOU</code></td>
        <td align="left" valign="top">22</td>
        <td align="left" valign="top">Stop</td>
        <td align="left" valign="top">POSIX</td>
        <td align="left" valign="top">Фоновая запись в tty</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGURG</code></td>
        <td align="left" valign="top">23</td>
        <td align="left" valign="top">Ignr</td>
        <td align="left" valign="top">BSD</td>
        <td align="left" valign="top">Срочный сигнал сокета</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGXCPU</code></td>
        <td align="left" valign="top">24</td>
        <td align="left" valign="top">Core</td>
        <td align="left" valign="top">BSD</td>
        <td align="left" valign="top">Превышение предела процессора</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGXFSZ</code></td>
        <td align="left" valign="top">25</td>
        <td align="left" valign="top">Core</td>
        <td align="left" valign="top">BSD</td>
        <td align="left" valign="top">Превышение предела размера файла</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGVTALRM</code></td>
        <td align="left" valign="top">26</td>
        <td align="left" valign="top">Term</td>
        <td align="left" valign="top">BSD</td>
        <td align="left" valign="top">Виртуальные аварийные часы</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGPROF</code></td>
        <td align="left" valign="top">27</td>
        <td align="left" valign="top">Term</td>
        <td align="left" valign="top">BSD</td>
        <td align="left" valign="top">Профилирующие аварийные часы</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGWINCH</code></td>
        <td align="left" valign="top">28</td>
        <td align="left" valign="top">Ignr</td>
        <td align="left" valign="top">BSD</td>
        <td align="left" valign="top">Изменение размера окна</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGIO</code></td>
        <td align="left" valign="top">29</td>
        <td align="left" valign="top">Term</td>
        <td align="left" valign="top">BSD</td>
        <td align="left" valign="top">Возможен ввод/вывод</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGPOLL</code></td>
        <td align="left" valign="top">29</td>
        <td align="left" valign="top">Term</td>
        <td align="left" valign="top">System V</td>
        <td align="left" valign="top">Опрашиваемое событие, то же, что и SIGIO (для совместимости)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGPWR</code></td>
        <td align="left" valign="top">30</td>
        <td align="left" valign="top">Term</td>
        <td align="left" valign="top">System V</td>
        <td align="left" valign="top">Повторный запуск из-за сбоя питания</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SIGSYS</code></td>
        <td align="left" valign="top">31</td>
        <td align="left" valign="top">Core</td>
        <td align="left" valign="top">POSIX</td>
        <td align="left" valign="top">Неверный системный вызов</td>
       </tr>
      </table>
      <p>Обозначения: <strong>Core</strong>: Завершить процесс и создать снимок образа процесса <strong>Ignr</strong>: Игнорировать сигнал <strong>Stop</strong>: Остановить процесс. <strong>Term</strong>: Завершить процесс. </p>
      <p>Более старые версии оболочки Борна (<code>/bin/sh</code>) непосредственно связывали с номерами сигналов <emphasis>ловушки (traps)</emphasis>, которые являются обработчиками сигналов на уровне оболочки. Таким образом, всесторонне образованному Unix-программисту нужно было знать не только имена сигналов для использования в коде С, но также и соответствующие номера сигналов! POSIX требует, чтобы команда <code>trap</code> понимала символические имена сигналов (без префикса '<code>SIG</code>'), поэтому этого больше не требуется. Однако (главным образом для лучшего разбирательства), мы предоставили эти номера в интересах полноты из-за того, что однажды вам может понадобиться иметь дело со сценарием оболочки, созданным до POSIX, или с древним кодом на С, которые непосредственно используют номера сигналов.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Для некоторых более новых сигналов, от 16 и выше, соответствующие номера сигнала и их имена на различных платформах не обязательно совпадают! Проверьте заголовочные файлы и справочные страницы на своей системе. Табл. 10.1 верна для GNU/Linux</p>
      </cite>
      <p>Некоторые системы определяют также и другие сигналы, такие, как <code>SIGEMT</code>, <code>SIGLOST</code> и <code>SIGINFO</code>. Справочная страница GNU/Linux <emphasis>signal</emphasis>(7) предоставляет полный список; если ваша программа должна обработать сигналы, не поддерживаемые GNU/Linux, это можно сделать с помощью <code>#ifdef</code>:</p>
      <p><code>#ifdef SIGLOST</code></p>
      <p><code>/* ...обработать здесь SIGLOST... */</code></p>
      <p><code>#endif</code></p>
      <p>За исключением <code>SIGSTKFLT</code>, сигналы, перечисленные в табл. 10.1, широкодоступны и не нуждаются в заключении в <code>#ifdef</code>.</p>
      <p>Сигналы <code>SIGKILL</code> и <code>SIGSTOP</code> нельзя перехватить или игнорировать (или блокировать, как описано далее в главе). Они всегда выполняют действие по умолчанию, указанное в табл. 10.1.</p>
      <p>Чтобы увидеть список поддерживаемых сигналов, вы можете использовать '<code>kill -l</code>'. На одной из наших систем GNU/Linux:</p>
      <p><code>$ <strong>kill -l</strong></code></p>
      <p><code> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL</code></p>
      <p><code> 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE</code></p>
      <p><code> 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2</code></p>
      <p><code>13) SIGPIPE     14) SIGALRM     15) SIGTERM     17) SIGCHLD</code></p>
      <p><code>18) SIGCONT     19) SIGSTOP     20) SIGTSTP     21) SIGTTIN</code></p>
      <p><code>22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</code></p>
      <p><code>26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO</code></p>
      <p><code>30) SIGPWR      31) SIGSYS      32) SIGRTMIN    33) SIGRTMIN+1</code></p>
      <p><code>34) SIGRTMIN+2  35) SIGRTMIN+3  36) SIGRTMIN+4  37) SIGRTMIN+5</code></p>
      <p><code>38) SIGRTMIN+6  39) SIGRTMIN+7  40) SIGRTMIN+8  41) SIGRTMIN+9</code></p>
      <p><code>42) SIGRTMIN+10 43) SIGRTMIN+11 44) SIGRTMIN+12 45) SIGRTMIN+13</code></p>
      <p><code>46) SIGRTMIN+14 47) SIGRTMIN+15 48) SIGRTMAX-15 49) SIGRTMAX-14</code></p>
      <p><code>50) SIGRTMAX-13 51) SIGRTMAX-12 52) SIGRTMAX-11 53) SIGRTMAX-10</code></p>
      <p><code>54) SIGRTMAX-9  55) SIGRTMAX-8  56) SIGRTMAX-7  57) SIGRTMAX-6</code></p>
      <p><code>58) SIGRTMAX-5  59) SIGRTMAX-4  60) SIGRTMAX-3  61) SIGRTMAX-2</code></p>
      <p><code>62) SIGRTMAX-1  63) SIGRTMAX</code></p>
      <p>Сигналы <code>SIGRT<emphasis>XXX</emphasis></code> являются сигналами реального времени, сложная тема, которую мы не будем рассматривать.</p>
     </section>
     <section>
      <title>
       <p>10.3.2. Программная отправка сигналов: <code>raise()</code></p>
      </title>
      <p>Помимо внешнего генерирования, сигнал может быть отправлен непосредственно самой программой с использованием стандартной функции С <code>raise()</code>:</p>
      <p><code>#include &lt;signal.h&gt; /* ISO С */</code></p>
      <empty-line/>
      <p><code>int raise(int sig);</code></p>
      <p>Эта функция посылает сигнал <code>sig</code> вызывающему процессу. (Это действие имеет свое применение; вскоре мы увидим пример.)</p>
      <p>Поскольку <code>raise()</code> определена стандартом С, для процесса это наиболее переносимый способ отправить себе сигнал. Есть другие способы, которые мы обсудим далее в главе.</p>
     </section>
    </section>
    <section>
     <title>
      <p>10.4. Обработчики сигналов в действии</p>
     </title>
     <section>
      <p>Множество осложнений и отклонений обнаруживается после установки на место обработчика, после его вызова и впоследствии возвращения.</p>
     </section>
     <section>
      <title>
       <p>10.4.1. Традиционные системы</p>
      </title>
      <p>После помещения на место обработчика сигнала ваша программа развивается своим путем. Интересные вещи возникают лишь с появлением сигнала (например, пользователь нажал CTRL-C для прерывания вашей программы, или был сделан вызов <code>raise()</code>).</p>
      <p>По получении сигнала ядро останавливает процесс, где бы он ни был. Затем оно имитирует вызов процедуры обработчика сигнала, передавая ему номер сигнала в качестве ее единственного аргумента. Ядро устраивает все таким образом, что нормальный возврат из функции обработчика сигнала (либо посредством <code>return</code>, либо в результате выпадения из конца функции) передает управление в ту точку программы, в которой она находилась в момент появления сигнала.</p>
      <p>Что происходит после обработки сигнала, когда тот же самый сигнал появится в следующий раз снова? Остается ли обработчик на том же месте? Или же он сбрасывается, и для сигнала используется действие по умолчанию? Ответ, по историческим причинам, «зависит от». В частности, стандарт С оставляет это на усмотрение реализации.</p>
      <p>На практике V7 и традиционные системы System V, такие, как Solaris, устанавливают для сигнала действие по умолчанию.</p>
      <p>Давайте рассмотрим простой обработчик сигнала в действии под Solaris. Следующая программа, <code>ch10-catchint.c</code>, перехватывает <code>SIGINT</code>. Обычно вы генерируете этот сигнал, набирая на клавиатуре CTRL-C.</p>
      <p><code>1  /* ch10-catchint.c - перехват SIGINT, по крайней мере, однажды. */</code></p>
      <p><code>2</code></p>
      <p><code>3  #include &lt;signal.h&gt;</code></p>
      <p><code>4  #include &lt;string.h&gt;</code></p>
      <p><code>5  #include &lt;unistd.h&gt;</code></p>
      <p><code>6</code></p>
      <p><code>7  /* handler --- простой обработчик сигнала. */</code></p>
      <p><code>8</code></p>
      <p><code>9  void handler(int signum)</code></p>
      <p><code>10 {</code></p>
      <p><code>11  char buf[200], *cp;</code></p>
      <p><code>12  int offset;</code></p>
      <p><code>13</code></p>
      <p><code>14  /* Пройти через это испытание , чтобы избежать fprintf(). */</code></p>
      <p><code>15  strcpy(buf, "handler: caught signal ");</code></p>
      <p><code>16  cp = buf + strlen(buf); /* cp указывает на завершающий '\0' */</code></p>
      <p><code>17  if (signum &gt; 100) /* маловероятно */</code></p>
      <p><code>18   offset = 3;</code></p>
      <p><code>19  else if (signum &gt; 10)</code></p>
      <p><code>20   offset = 2;</code></p>
      <p><code>21  else</code></p>
      <p><code>22   offset = 1;</code></p>
      <p><code>23  cp += offset;</code></p>
      <p><code>24</code></p>
      <p><code>25  *cp-- = '\0'; /* завершить строку */</code></p>
      <p><code>26  while (signum &gt;0) { /* work backwards, filling in digits */</code></p>
      <p><code>27   *cp-- = (signum % 10) + '0';</code></p>
      <p><code>28   signum /= 10;</code></p>
      <p><code>29  }</code></p>
      <p><code>30  strcat(buf, "\n");</code></p>
      <p><code>31  (void)write(2, buf, strlen(buf));</code></p>
      <p><code>32 }</code></p>
      <p><code>33</code></p>
      <p><code>34 /* main --- установить обработку сигнала и войти в бесконечный цикл */</code></p>
      <p><code>35</code></p>
      <p><code>36 int main(void)</code></p>
      <p><code>37 {</code></p>
      <p><code>38  (void)signal(SIGINT, handler);</code></p>
      <p><code>39</code></p>
      <p><code>40  for(;;)</code></p>
      <p><code>41   pause(); /* ждать сигнал, см. далее в главе */</code></p>
      <p><code>42</code></p>
      <p><code>43  return 0;</code></p>
      <p><code>44 }</code></p>
      <p>Строки 9–22 определяют функцию обработки сигнала (остроумно названную <code>handler()</code><a l:href="#n106" type="note">[106]</a>). Все, что эта функция делает, — выводит номер перехваченного сигнала и возвращается. Для вывода этого сообщения она выполняет множество ручной работы, поскольку <code>fprintf()</code> не является «безопасной» для вызова из обработчика сигнала. (Вскоре это будет описано в разделе 10.4.6 «Дополнительные предостережения».)</p>
      <p>Функция <code>main()</code> устанавливает обработчик сигнала (строка 38), а затем входит в бесконечный цикл (строки 40–41). Вот что происходит при запуске:</p>
      <p><code>$ <strong>ssh solaris.example.com</strong></code></p>
      <p><code> /* Зарегистрироваться на доступной системе Solaris */</code></p>
      <p><code>Last login: Fri Sep 19 04:33:25 2003 from 4.3.2.1.</code></p>
      <p><code>Sun Microsystems Inc. SunOS 5.9 Generic May 2002</code></p>
      <p><code>$ <strong>gcc ch10-catchint.c</strong> /* Откомпилировать программу */</code></p>
      <p><code>$ <strong>a.out</strong> /* Запустить ее */</code></p>
      <p><code><strong>^C </strong>handler: caught signal 2 /* Набрать ^C, вызывается обработчик */</code></p>
      <p><code><strong>^C</strong> /* Попробовать снова, но на этот раз... */</code></p>
      <p><code>$ /* Программа завершается */</code></p>
      <p>Поскольку V7 и другие традиционные системы восстанавливают действие сигнала по умолчанию, поэтому когда вы хотите снова получить сигнал в будущем, функция обработчика должна немедленно переустановить саму себя:</p>
      <p><code>void handler(int signum) {</code></p>
      <p><code> char buf[200], *cp;</code></p>
      <p><code> int offset;</code></p>
      <p><code> (void)signal(signum, handler); /* переустановить обработчик */</code></p>
      <p><code> /* ...оставшаяся часть функции как прежде... */</code></p>
      <p><code>}</code></p>
     </section>
     <section>
      <title>
       <p>10.4.2. BSD и GNU/Linux</p>
      </title>
      <p>BSD 4.2 изменила способ работы <code>signal()</code>.<a l:href="#n107" type="note">[107]</a> На системах BSD обработчик сигнала после его возвращения остается на месте. Системы GNU/Linux следуют поведению BSD. Вот что происходит под GNU/Linux:</p>
      <p><code>$ <strong>ch10-catchint</strong>          /* Запустить программу */</code></p>
      <p><code>handler: caught signal 2 /* Набираем ^C, вызывается обработчик */</code></p>
      <p><code>handler: caught signal 2 /* И снова... */</code></p>
      <p><code>handler: caught signal 2 /* И снова! */</code></p>
      <p><code>handler: caught signal 2 /* Помогите! */</code></p>
      <p><code>handler: caught signal 2 /* Как нам это остановить?! */</code></p>
      <p><code>Quit (core dumped)       /* ^\, генерирует SIGQUIT. Bay */</code></p>
      <p>На системе BSD или GNU/Linux обработчик сигнала не должен дополнительно использовать '<code>signal(signum, handler)</code>' для переустановки обработчика. Однако, лишний вызов не причиняет никакого вреда, поэтому сохраняется статус-кво.</p>
      <p>В действительности, POSIX предоставляет функцию <code>bsd_signal()</code>, которая идентична <code>signal()</code> за тем исключением, что она гарантирует, что обработчик сигнала останется установленным:</p>
      <p><code>#include &lt;signal.h&gt; /* XSI, устаревает */</code></p>
      <empty-line/>
      <p><code>void (*bsd_signal(int sig, void (*func)(int)))(int);</code></p>
      <p>Это устраняет проблемы переносимости. Если вы знаете, что ваша программа будет работать лишь на системах POSIX, вы можете воспользоваться <code>bsd_signal()</code> вместо <code>signal()</code>.</p>
      <p>Одно предостережение — эта функция также помечена как «устаревающая», что означает возможность отказа от нее в будущем стандарте. На практике, даже если от нее откажутся, поставщики скорее всего долгое время будут ее поддерживать. (Как мы увидим, функция API POSIX <code>sigaction()</code> предоставляет достаточно возможностей для написания рабочей версии, если это вам нужно.)</p>
     </section>
     <section>
      <title>
       <p>10.4.3. Игнорирование сигналов</p>
      </title>
      <p>Более практично, когда вызывается обработчик сигнала, это означает, что программа должна завершиться и выйти. Было бы раздражающим, если бы большинство программ по получении <code>SIGINT</code> выводили бы сообщение и продолжали работу; смысл сигнала в том, что они должны остановиться!</p>
      <p>Например, рассмотрите программу <code>sort</code>. <code>sort</code>, возможно, создала любое число временных файлов для использования на промежуточных этапах процесса сортировки. По получении <code>SIGINT</code>, <code>sort</code> должна удалить временные файлы и выйти. Вот упрощенная версия обработчика сигнала из GNU Coreutils <code>sort.c</code>:</p>
      <p><code>/* Обработка прерываний и отсоединений. Упрощена для представления */</code></p>
      <p><code>static void sighandler(int sig) {</code></p>
      <p><code> signal(sig, SIG_IGN); /* Отныне этот сигнал игнорировать */</code></p>
      <p><code> cleanup();            /* Очистка после себя */</code></p>
      <p><code> signal(sig, SIG_DFL); /* Восстановление действия по умолчанию */</code></p>
      <p><code> raise(sig);           /* Повторно отправить сигнал */</code></p>
      <p><code>}</code></p>
      <p>Установка действия <code>SIG_IGN</code> гарантирует, что все последующие появляющиеся сигналы <code>SIGINT</code> не повлияют на продолжающийся процесс очистки. Когда функция <code>cleanup()</code> завершит работу, восстановление действия <code>SIG_DFL</code> позволяет системе сделать снимок образа процесса, если это нужно возникшему сигналу. Вызов <code>raise()</code> восстанавливает сигнал. Затем восстановленный сигнал вызывает действие по умолчанию, которое, скорее всего, завершит программу. (Далее в этой главе мы полностью покажем обработчик сигнала <code>sort.c</code>.)</p>
     </section>
     <section>
      <title>
       <p>10.4.4. Системные вызовы, допускающие повторный запуск</p>
      </title>
      <section>
       <p>Значение <code>EINTR</code> для <code>errno</code> (см. раздел 4.3 «Определение ошибок») указывает, что системный вызов был прерван. Хотя с этим значением ошибки может завершаться большое количество системных вызовов, двумя наиболее значительными являются <code>read()</code> и <code>write()</code>. Рассмотрите следующий код:</p>
       <p><code>void handler(int signal) { /* обработка сигналов */ }</code></p>
       <empty-line/>
       <p><code>int main(int argc, char **argv) {</code></p>
       <p><code> signal(SIGINT, handler);</code></p>
       <p><code> ...</code></p>
       <p><code> while ((count = read(fd, buf, sizeof buf)) &gt; 0) {</code></p>
       <p><code>  /* Обработка буфера */</code></p>
       <p><code> }</code></p>
       <p><code> if (count == 0)</code></p>
       <p><code>  /* конец файла, очистка и т.п. */</code></p>
       <p><code> else if (count == -1)</code></p>
       <p><code>  /* ошибка */</code></p>
       <p><code> ...</code></p>
       <p><code>}</code></p>
       <p>Предположим, что система успешно прочла (и заполнила) часть буфера, когда возник <code>SIGINT</code>. Системный вызов <code>read()</code> еще не вернулся из ядра в программу, но ядро решает, что оно может доставить сигнал. Вызывается <code>handler()</code>, запускается и возвращается в середину <code>read()</code>. Что возвратит <code>read()</code>?</p>
       <p>В былые времена (V7, более ранние системы System V) <code>read()</code> возвратила бы -1 и установила бы <code>errno</code> равным <code>EINTR</code>. <emphasis>Не было способа сообщить</emphasis>, что данные были переданы. В данном случае V7 и System V действуют, как если бы ничего не случилось: не было перемещений данных в и из буфера пользователя, и смещение файла не было изменено. BSD 4.2 изменила это. Были два случая:</p>
       <p><emphasis>Медленные устройства</emphasis></p>
       <p>«Медленное устройство» является в сущности терминалом или почти всяким другим устройством, кроме обычного файла. В этом случае <code>read()</code> могла завершиться с ошибкой <code>EINTR</code>, <emphasis>лишь</emphasis> если не было передано никаких данных, когда появился сигнал. В противном случае системный вызов был бы <emphasis>запущен повторно</emphasis>, и <code>read()</code> возвратилась бы нормально.</p>
       <p><emphasis>Обычные файлы</emphasis></p>
       <p>Системный вызов был бы запущен повторно В этом случае <code>read()</code> вернулась бы нормально; возвращенное значение могло быть либо числом запрошенных байтов, либо числом действительно прочитанных байтов (как в случае чтения вблизи конца файла).</p>
       <p>Поведение BSD несомненно полезно; вы всегда можете сказать, сколько данных было прочитано.</p>
       <p>Поведение POSIX сходно, но не идентично первоначальному поведению BSD. POSIX указывает, что <code>read()</code><a l:href="#n108" type="note">[108]</a> завершается с ошибкой <code>EINTR</code> лишь в случае появления сигнала до начала перемещения данных. Хотя POSIX ничего не говорит о «медленных устройствах», на практике это условие проявляется именно на них.</p>
       <p>В противном случае, если сигнал прерывает частично выполненную <code>read()</code>, возвращенное значение является числом уже прочитанных байтов. По этой причине (а также для возможности обработки коротких файлов) всегда следует проверять возвращаемое <code>read()</code> значение и никогда не предполагать, что прочитано все запрошенное количество байтов. (Функция POSIX API <code>sigaction()</code>, описанная позже, позволяет при желании получить поведение повторно вызываемых системных вызовов BSD.)</p>
      </section>
      <section>
       <title>
        <p>10.4.4.1. Пример: GNU Coreutils <code>safe_read()</code> и <code>safe_write()</code></p>
       </title>
       <p>Для обработки случая EINTR в традиционных системах GNU Coreutils использует две функции, <code>safe_read()</code> и <code>safe_write()</code>. Код несколько запутан из-за того, что один и тот же файл за счет включения #include и макросов реализует обе функции. Из файла <code>lib/safe-read.c</code> в дистрибутиве Coreutils:</p>
       <p><code>1  /* Интерфейс read и write для .повторных запусков после прерываний.</code></p>
       <p><code>2     Copyright (С) 1993, 1994, 1998, 2002 Free Software Foundation, Inc.</code></p>
       <p><code>   /* ... куча шаблонного материала опущена... */</code></p>
       <p><code>56</code></p>
       <p><code>57 #ifdef SAFE_WRITE</code></p>
       <p><code>58 # include "safe-write.h"</code></p>
       <p><code>59 # define safe_rw safe_write /* Создание safe_write() */</code></p>
       <p><code>60 # define rw write /* Использование системного вызова write() */</code></p>
       <p><code>61 #else</code></p>
       <p><code>62 # include "safe-read.h"</code></p>
       <p><code>63 # define safe_rw safe_read /* Создание safe_read() */</code></p>
       <p><code>64 # define rw read /* Использование системного вызова read() */</code></p>
       <p><code>65 # undef const</code></p>
       <p><code>66 # define const /* пусто */</code></p>
       <p><code>67 #endif</code></p>
       <p><code>68</code></p>
       <p><code>69 /* Прочесть (записать) вплоть до COUNT байтов в BUF из(в) дескриптора FD, повторно запуская вызов при</code></p>
       <p><code>70 прерывании. Вернуть число действительно прочитанных (записанных) байтов, 0 для EOF</code></p>
       <p><code>71 или в случае ошибки SAFE_READ_ERROR(SAFE_WRITE_ERROR). */</code></p>
       <p><code>72 size_t</code></p>
       <p><code>73 safe_rw(int fd, void const *buf, size_t count)</code></p>
       <p><code>74 {</code></p>
       <p><code>75  ssize_t result;</code></p>
       <p><code>76</code></p>
       <p><code>77  /* POSIX ограничивает COUNT значением SSIZE_MAX, но мы еще больше ограничиваем его, требуя,</code></p>
       <p><code>78  чтобы COUNT &lt;= INT_MAX, для избежания ошибки в Tru64 5.1.</code></p>
       <p><code>79  При уменьшении COUNT сохраняйте указатель файла выровненным по размеру блока.</code></p>
       <p><code>80  Обратите внимание, что read (write) может быть успешным в любом случае, даже если прочитано (записано)</code></p>
       <p><code>81  менее COUNT байтов, поэтому вызывающий должен быть готов обработать</code></p>
       <p><code>82  частичные результаты. */</code></p>
       <p><code>83  if (count &gt; INT_MAX)</code></p>
       <p><code>84   count = INT_MAX &amp; -8191;</code></p>
       <p><code>85</code></p>
       <p><code>86  do</code></p>
       <p><code>87  {</code></p>
       <p><code>88   result = rw(fd, buf, count);</code></p>
       <p><code>89  }</code></p>
       <p><code>90  while (result &lt; 0 &amp;&amp; IS_EINTR(errno));</code></p>
       <p><code>91</code></p>
       <p><code>92  return (size_t) result;</code></p>
       <p><code>93 }</code></p>
       <p>Строки 57–67 обрабатывают определения, создавая соответствующим образом <code>safe_read()</code> и <code>safe_write()</code> (см. ниже <code>safe_write.c</code>).</p>
       <p>Строки 77–84 указывают на разновидность осложнений, возникающих при чтении. Здесь один особый вариант Unix не может обработать значения, превышающие <code>INT_MAX</code>, поэтому строки 83–84 выполняют сразу две операции: уменьшают значение числа, чтобы оно не превышало <code>INT_MAX</code>, и сохраняют его кратным 8192. Последняя операция служит эффективности дисковых операций: выполнение ввода/вывода с кратным основному размеру дискового блока объемом данных более эффективно, чем со случайными размерами данных. Как отмечено в комментарии, код сохраняет семантику <code>read()</code> и <code>write()</code>, где возвращенное число байтов может быть меньше затребованного.</p>
       <p>Обратите внимание, что параметр <code>count</code> может и в самом деле быть больше <code>INT_MAX</code>, поскольку count представляет тип <code>size_t</code>, который является беззнаковым (unsigned). <code>INT_MAX</code> является чистым <code>int</code>, который на всех современных системах является знаковым.</p>
       <p>Строки 86–90 представляют действительный цикл, повторно осуществляющий операцию, пока она завершается ошибкой <code>EINTR</code>. Макрос <code>IS_EINTR()</code> не показан, но он обрабатывает случай в системах, на которых <code>EINTR</code> не определен. (Должен быть по крайней мере один такой случай, иначе код не будет возиться с установкой макроса; возможно, это было сделано для эмуляции Unix или POSIX в не-Unix системе.) Вот <code>safe_write.c</code>:</p>
       <p><code>1  /* Интерфейс write для повторного запуска после прерываний.</code></p>
       <p><code>2     Copyright (С) 2002 Free Software Foundation, Inc.</code></p>
       <p><code>   /* ...куча шаблонного материала опущена... */</code></p>
       <p><code>17</code></p>
       <p><code>18 #define SAFE_WRITE</code></p>
       <p><code>19 #include "safe-read.с"</code></p>
       <p>В строке 18 <code>#define</code> определяет <code>SAFE_WRITE</code>; это связано со строками 57–60 в <code>safe_read.с</code>.</p>
      </section>
      <section>
       <title>
        <p>10.4.4.2. Только GLIBC: <code>TEMP_FAILURE_RETRY()</code></p>
       </title>
       <p>Файл &lt;unistd.h&gt; GLIBC определяет макрос TEMP_FAILURE_RETRY(), который вы можете использовать для инкапсулирования любого системного вызова, который может при неудачном вызове установить errno в EINTR. Его «объявление» следующее:</p>
       <p><code>#include &lt;unistd.h&gt; /* GLIBC */</code></p>
       <empty-line/>
       <p><code>long int TEMP_FAILURE_RETRY(expression);</code></p>
       <p>Вот определение макроса:</p>
       <p><code>/* Оценить EXPRESSION и повторять, пока оно возвращает -1 с 'errno',</code></p>
       <p><code>    установленным в EINTR. */</code></p>
       <p><code># define TEMP_FAILURE_RETRY(expression) \</code></p>
       <p><code> (__extension__ \</code></p>
       <p><code>  ({ long int __result; \</code></p>
       <p><code>   do __result = (long int)(expression); \</code></p>
       <p><code>   while (__result == -1L &amp;&amp; errno == EINTR); \</code></p>
       <p><code>   __result; }))</code></p>
       <p>Макрос использует расширение GCC к языку С (как обозначено ключевым словом <code>__extension__</code>), которое допускает заключенным в фигурные скобки внутри обычных скобок выражениям возвращать значение, действуя таким образом подобно простому выражению.</p>
       <p>Используя этот макрос, мы могли бы переписать <code>safe_read()</code> следующим образом:</p>
       <p><code>size_t safe_read(int fd, void const *buf, size_t count) {</code></p>
       <p><code> ssize_t result;</code></p>
       <p><code> /* Ограничить count, как в ранее приведенном комментарии. */</code></p>
       <p><code> if (count &gt; INT_MAX)</code></p>
       <p><code>  count = INT_MAX &amp; ~8191;</code></p>
       <p><code> result = TEMP_FAILURE_RETRY(read(fd, buf, count));</code></p>
       <p><code> return (size_t)result;</code></p>
       <p><code>}</code></p>
      </section>
     </section>
     <section>
      <title>
       <p>10.4.5. Состояния гонок и <code>sig_atomic_t</code> (ISO C)</p>
      </title>
      <p>Пока обработка одного сигнала за раз выглядит просто: установка обработчика сигнала в <code>main()</code> и (не обязательная) переустановка самого себя обработчиком сигнала (или установка действия <code>SIG_IGN</code>) в качестве первого действия обработчика.</p>
      <p>Но что произойдет, если возникнут <emphasis>два</emphasis> идентичных сигнала, один за другим? В частности, что, если ваша система восстановит действие по умолчанию для вашего сигнала, а второй сигнал появится <emphasis>после</emphasis> вызова обработчика, но <emphasis>до</emphasis> того, как он себя восстановит?</p>
      <p>Или предположим, что вы используете <code>bsd_signal()</code>, так что обработчик остается установленным, но второй сигнал отличается от первого? Обычно обработчику первого сигнала нужно завершить свою работу до того, как запускается второй, а каждый обработчик сигнала не должен временно игнорировать все прочие возможные сигналы!</p>
      <p>Оба случая относятся к состоянию гонки. Одним решением для этих проблем является как можно большее упрощение обработчиков сигналов. Это можно сделать, создав флаговые переменные, указывающие на появление сигнала. Обработчик сигнала устанавливает переменную в true и возвращается. Затем основная логика проверяет флаговую переменную в стратегических местах:</p>
      <p><code>int sig_int_flag = 0; /* обработчик сигнала устанавливает в true */</code></p>
      <empty-line/>
      <p><code>void int_handler(int signum) {</code></p>
      <p><code> sig_int_flag = 1;</code></p>
      <p><code>}</code></p>
      <empty-line/>
      <p><code>int main(int argc, char **argv) {</code></p>
      <p><code> bsd_signal(SIGINT, int_handler);</code></p>
      <p><code> /* ...программа продолжается... */</code></p>
      <p><code> if (sig_int_flag) {</code></p>
      <p><code>  /* возник SIGINT, обработать его */</code></p>
      <p><code> }</code></p>
      <p><code> /* ...оставшаяся логика... */</code></p>
      <p><code>}</code></p>
      <p>(Обратите внимание, что эта стратегия <emphasis>уменьшает</emphasis> окно уязвимости, но не устраняет его).</p>
      <p>Стандарт С вводит специальный тип — <code>sig_atomic_t</code> — для использования с такими флаговыми переменными. Идея, скрывающаяся за этим именем, в том, что присвоение значений переменным этого типа является <emphasis>атомарной</emphasis> операцией: т.е. они совершаются как одно делимое действие. Например, на большинстве машин присвоение значения <code>int</code> осуществляется атомарно, тогда как инициализация значений в структуре осуществляется либо путем копирования всех байтов в (сгенерированном компилятором) цикле, либо с помощью инструкции «блочного копирования», которая может быть прервана. Поскольку присвоение значения <code>sig_atomic_t</code> является атомарным, раз начавшись, оно завершается до того, как может появиться другой сигнал и прервать его.</p>
      <p>Наличие особого типа является лишь частью истории. Переменные <code>sig_atomic_t</code> должны быть также объявлены как <code>volatile</code>:</p>
      <p><code>volatile sig_atomic_t sig_int_flag = 0; /* обработчик сигнала устанавливает в true */</code></p>
      <p><code>/* ...оставшаяся часть кода как раньше... */</code></p>
      <p>Ключевое слово <code>volatile</code> сообщает компилятору, что переменная может быть изменена извне, за спиной компилятора, так сказать. Это не позволяет компилятору применить оптимизацию, которая могла бы в противном случае повлиять на правильность кода</p>
      <p>Структурирование приложения исключительно вокруг переменных <code>sig_atomic_t</code> ненадежно. Правильный способ обращения с сигналами показан далее, в разделе 10.7 «Сигналы для межпроцессного взаимодействия».</p>
     </section>
     <section>
      <title>
       <p>10.4.6. Дополнительные предостережения</p>
      </title>
      <p>Стандарт POSIX предусматривает для обработчиков сигналов несколько предостережений:</p>
      <p>• Что случается, когда возвращаются обработчики для <code>SIGFPE</code>, <code>SIGILL</code>, <code>SIGSEGV</code> или любых других сигналов, представляющих «вычислительные исключения», не определено.</p>
      <p>• Если обработчик был вызван в результате вызова <code>abort()</code>, <code>raise()</code> или <code>kill()</code>, он не может вызвать <code>raise()</code>. <code>abort()</code> описана в разделе 12.4 «Совершение самоубийства: <code>abort()</code>», a <code>kill()</code> описана далее в этой главе. (Описанная далее функция API <code>sigaction()</code> с обработчиком сигнала, принимающая три аргумента, дает возможность сообщить об этом, если это имеет место.)</p>
      <p>• Обработчики сигналов могут вызвать лишь функции из табл. 10.2. В частности, они должны избегать функций <code>&lt;stdio.h&gt;</code>. Проблема в том, что во время работы функции <code>&lt;stdio.h&gt;</code> может возникнуть прерывание, когда внутреннее состояние библиотечной функции находится в середине процесса обновления. Дальнейшие вызовы функций <code>&lt;stdio.h&gt;</code> могут повредить это внутреннее состояние.</p>
      <p>Список в табл. 10.2 происходит из раздела 2.4 тома <emphasis>System Interfaces (Системные интерфейсы)</emphasis> стандарта POSIX 2001. Многие из этих функций относятся к сложному API и больше не рассматриваются в данной книге.</p>
      <empty-line/>
      <p><strong>Таблица 10.2</strong>. Функции, которые могут быть вызваны из обработчика сигнала</p>
      <table>
       <tr align="left">
        <td align="left" valign="top"><code>_Exit()</code></td>
        <td align="left" valign="top"><code>fpathconf()</code></td>
        <td align="left" valign="top"><code>raise()</code></td>
        <td align="left" valign="top"><code>sigqueue()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>_exit()</code></td>
        <td align="left" valign="top"><code>fstat()</code></td>
        <td align="left" valign="top"><code>read()</code></td>
        <td align="left" valign="top"><code>sigset()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>accept()</code></td>
        <td align="left" valign="top"><code>fsync()</code></td>
        <td align="left" valign="top"><code>readlink()</code></td>
        <td align="left" valign="top"><code>sigsuspend()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>access()</code></td>
        <td align="left" valign="top"><code>ftruncate()</code></td>
        <td align="left" valign="top"><code>recv()</code></td>
        <td align="left" valign="top"><code>sleep()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>aio_error()</code></td>
        <td align="left" valign="top"><code>getegid()</code></td>
        <td align="left" valign="top"><code>recvfrom()</code></td>
        <td align="left" valign="top"><code>socket()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>aio_return()</code></td>
        <td align="left" valign="top"><code>geteuid()</code></td>
        <td align="left" valign="top"><code>recvmsg()</code></td>
        <td align="left" valign="top"><code>socketpair()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>aio_suspend()</code></td>
        <td align="left" valign="top"><code>getgid()</code></td>
        <td align="left" valign="top"><code>rename()</code></td>
        <td align="left" valign="top"><code>stat()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>alarm()</code></td>
        <td align="left" valign="top"><code>getgroups()</code></td>
        <td align="left" valign="top"><code>rmdir()</code></td>
        <td align="left" valign="top"><code>sysmlink()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>bind()</code></td>
        <td align="left" valign="top"><code>getpeername()</code></td>
        <td align="left" valign="top"><code>select()</code></td>
        <td align="left" valign="top"><code>sysconf()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>cfgetispeed()</code></td>
        <td align="left" valign="top"><code>getpgrp()</code></td>
        <td align="left" valign="top"><code>sem_post()</code></td>
        <td align="left" valign="top"><code>tcdrain()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>cfgetospeed()</code></td>
        <td align="left" valign="top"><code>getpid()</code></td>
        <td align="left" valign="top"><code>send()</code></td>
        <td align="left" valign="top"><code>tcflow()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>cfsetispeed()</code></td>
        <td align="left" valign="top"><code>getppid()</code></td>
        <td align="left" valign="top"><code>sendmsg()</code></td>
        <td align="left" valign="top"><code>tcflush()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>cfsetospeed()</code></td>
        <td align="left" valign="top"><code>getsockname()</code></td>
        <td align="left" valign="top"><code>sendto()</code></td>
        <td align="left" valign="top"><code>tcgetattr()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>chdir()</code></td>
        <td align="left" valign="top"><code>getsockopt()</code></td>
        <td align="left" valign="top"><code>setgid()</code></td>
        <td align="left" valign="top"><code>tcgetpgrp()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>chmod()</code></td>
        <td align="left" valign="top"><code>getuid()</code></td>
        <td align="left" valign="top"><code>setpgid()</code></td>
        <td align="left" valign="top"><code>tcsendbreak()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>chown()</code></td>
        <td align="left" valign="top"><code>kill()</code></td>
        <td align="left" valign="top"><code>setsid()</code></td>
        <td align="left" valign="top"><code>tcsetattr()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>clock_gettime()</code></td>
        <td align="left" valign="top"><code>link()</code></td>
        <td align="left" valign="top"><code>setsockopt()</code></td>
        <td align="left" valign="top"><code>tcsetpgrp()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>close()</code></td>
        <td align="left" valign="top"><code>listen()</code></td>
        <td align="left" valign="top"><code>setuid()</code></td>
        <td align="left" valign="top"><code>time()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>connect()</code></td>
        <td align="left" valign="top"><code>lseek()</code></td>
        <td align="left" valign="top"><code>shutdown()</code></td>
        <td align="left" valign="top"><code>timer_getoverrun()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>creat()</code></td>
        <td align="left" valign="top"><code>lstat()</code></td>
        <td align="left" valign="top"><code>sigaction()</code></td>
        <td align="left" valign="top"><code>timer_gettime()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>dup()</code></td>
        <td align="left" valign="top"><code>mkdir()</code></td>
        <td align="left" valign="top"><code>sigaddset()</code></td>
        <td align="left" valign="top"><code>timer_settime()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>dup2()</code></td>
        <td align="left" valign="top"><code>mkfifo()</code></td>
        <td align="left" valign="top"><code>sigdelset()</code></td>
        <td align="left" valign="top"><code>times()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>execle()</code></td>
        <td align="left" valign="top"><code>open()</code></td>
        <td align="left" valign="top"><code>sigemptyset()</code></td>
        <td align="left" valign="top"><code>umask()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>execve()</code></td>
        <td align="left" valign="top"><code>pathconf()</code></td>
        <td align="left" valign="top"><code>sigfillset()</code></td>
        <td align="left" valign="top"><code>uname()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>fchmod()</code></td>
        <td align="left" valign="top"><code>pause()</code></td>
        <td align="left" valign="top"><code>sigismember()</code></td>
        <td align="left" valign="top"><code>unlink()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>fchown()</code></td>
        <td align="left" valign="top"><code>pipe()</code></td>
        <td align="left" valign="top"><code>signal()</code></td>
        <td align="left" valign="top"><code>utime()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>fcntl()</code></td>
        <td align="left" valign="top"><code>poll()</code></td>
        <td align="left" valign="top"><code>sigpause()</code></td>
        <td align="left" valign="top"><code>wait()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>fdatasync()</code></td>
        <td align="left" valign="top"><code>posix_trace_event()</code></td>
        <td align="left" valign="top"><code>sigpending()</code></td>
        <td align="left" valign="top"><code>waitpid()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>fork()</code></td>
        <td align="left" valign="top"><code>pselect()</code></td>
        <td align="left" valign="top"><code>sigprocmask()</code></td>
        <td align="left" valign="top"><code>write()</code></td>
       </tr>
      </table>
     </section>
     <section>
      <title>
       <p>10.4.7. Наша история до настоящего времени, эпизод 1</p>
      </title>
      <p>Сигналы являются сложной темой, и она становится еще более сбивающей с толку. Поэтому давайте на время сделаем остановку, сделаем шаг назад и подведем итог обсужденному до сих пор:</p>
      <p>• Сигналы являются указанием того, что произошло некоторое внешнее событие.</p>
      <p>• <code>raise()</code> является функцией ISO С для отправки сигнала <emphasis>текущему процессу</emphasis>. Как отправлять сигналы другим процессам, нам еще предстоит описать.</p>
      <p>• <code>signal()</code> контролирует диспозицию сигнала, т.е. реакцию процесса на сигнал, когда он появляется. Сигнал можно оставить системе для обработки по умолчанию, проигнорировать или перехватить.</p>
      <p>• Когда сигнал перехватывается, вызывается функция-обработчик. Вот где сложность начинает поднимать свою безобразную голову:</p>
      <p> • ISO С не определяет, восстанавливается ли диспозиция сигнала по умолчанию до вызова обработчика или она остается на месте. Первое является поведением V7 и современных систем System V, таких, как Solaris. Последнее является поведением BSD, используемым также в GNU/Linux. (Для форсирования поведения BSD может использоваться функция POSIX <code>bsd_signal()</code>.)</p>
      <p>• То, что случается при прерывании сигналом системного вызова, также различается в традиционной и BSD линейках. Традиционные системы возвращают -1 с errno, установленным в <code>EINTR</code>. BSD системы повторно запускают системный вызов после возвращения из обработчика. Макрос GLIBC <code>TEMP_FAILURE_RETRY()</code> может помочь вам написать код для обработки системных вызовов, возвращающих -1 с <code>errno</code>, установленным в <code>EINTR</code>.</p>
      <p>POSIX требует, чтобы частично выполненный системный вызов возвращал успешное завершение, указав, сколько работы было выполнено. Системный вызов, который еще не начал выполняться, вызывается повторно.</p>
      <p>• Механизм <code>signal()</code> предоставляет плодотворную почву для появления условий гонки. В этой ситуации помогает тип данных ISO С <code>sig_atomic_t</code>, но он не решает проблему, и определенный таким способом механизм не может обезопасить от проявления условий гонки.</p>
      <p>• Применяется ряд дополнительных предостережений, и в частности, из обработчика сигнала <emphasis>безопасно</emphasis> может вызываться лишь часть стандартных библиотечных функций.</p>
      <p>Несмотря на эти проблемы интерфейса <code>signal()</code> для простых программ достаточно, и он все еще широко используется.</p>
     </section>
    </section>
    <section>
     <title>
      <p>10.5. API сигналов System V Release 3: <code>sigset()</code> и др.</p>
     </title>
     <p>BSD 4.0 (примерно с 1980 г.) ввел дополнительные функции API для предоставления «надежных» сигналов.<a l:href="#n109" type="note">[109]</a> В частности, стало возможным <emphasis>блокировать</emphasis> сигналы. Другими словами, программа могла сообщить ядру: «Зависни на этих конкретных сигналах в течении следующего небольшого промежутка времени, затем доставь их мне, когда я буду готов их принять». Большим преимуществом является то, что эта особенность упрощает обработчики сигналов, которые автоматически запускаются со своим заблокированным сигналом (чтобы избежать проблемы одновременной обработки двух сигналов) и, возможно, также и с другими заблокированными сигналами.</p>
     <p>System V Release 3 (примерно с 1984 г.) приняла эти API и популяризовала их, в большинстве связанных с Unix документации и книгах вы, возможно, увидите, что на эти API ссылаются, как ведущие начало от System V Release 3. Эти функции следующие:</p>
     <p><code>#include &lt;signal.h&gt; /* XSI */</code></p>
     <empty-line/>
     <p><code>int sighold(int sig); /* Добавить sig к маске сигналов процесса */</code></p>
     <p><code>int sigrelse(int sig); /* Удалить sig из маски сигналов процесса */</code></p>
     <p><code>int sigignore(int sig); /* Сокращение для sigset(sig, SIG_IGN) */</code></p>
     <p><code>int sigpause(int sig);</code></p>
     <p><code> /* Приостановить процесс, позволить появиться sig */</code></p>
     <p><code>void (*sigset(int sig, void (*disp)(int)))(int);</code></p>
     <p><code> /* sighandler_t sigset(int sig, sighandler_t disp); */</code></p>
     <p>Стандарт POSIX для этих функций описывает их поведение в терминах <emphasis>маски сигналов процесса</emphasis>. Маска сигналов процесса отслеживает, какие сигналы (если они вообще есть) процесс заблокировал в настоящее время. Более подробно это описывается в разделе 10.6.2 «Наборы сигналов: <code>sigset_t</code> и связанные функции». В API System V Release 3 нет способа получить или изменить маску сигналов процесса в целом. Функции работают следующим образом:</p>
     <p><code>int sighold(int sig)</code></p>
     <p>Добавляет <code>sig</code> к списку заблокированных процессов (маска сигналов процесса).</p>
     <p><code>int sigrelse(int sig)</code></p>
     <p>Удаляет <code>sig</code> из маски сигналов процесса.</p>
     <p><code>int sigignore(int sig)</code></p>
     <p>Игнорирует <code>sig</code>. Это вспомогательная функция.</p>
     <p><code>int sigpause(int sig)</code></p>
     <p>Удаляет <code>sig</code> из маски сигналов процесса, а затем приостанавливает процесс до появления сигнала (см. раздел 10.7 «Сигналы для межпроцессного взаимодействия»).</p>
     <p><code>sighandler_t sigset(int sig, sighandler_t disp)</code></p>
     <p>Это замена для signal(). (Здесь мы использовали обозначение из справочной страницы GNU/Linux, чтобы упростить восприятие объявления функции.)</p>
     <p>Для <code>sigset()</code> аргумент <code>handler</code> может быть <code>SIG_DFL</code>, <code>SIG_IGN</code> или указатель функции, как и для <code>signal()</code>. Однако, он может равняться также и <code>SIG_HOLD</code>. В этом случае <code>sig</code> добавляется к маске сигналов процесса, но связанное с ним действие никак не изменяется. (Другими словами, если бы у него был обработчик, он остается тем же; если было действие по умолчанию, оно не изменяется.)</p>
     <p>Когда для установки обработчика сигнала используется <code>sigset()</code> и появляется сигнал, ядро сначала добавляет сигнал к маске процессов сигнала, блокируя любой дальнейший прием этого сигнала. Запускается обработчик, а когда он возвращается, ядро восстанавливает маску сигналов процесса в то состояние, какое было до запуска обработчика. (В модели POSIX если обработчик сигнала изменяет маску сигнала, это изменение переписывается в процессе восстановления предыдущей маски, когда обработчик возвращается.)</p>
     <p><code>sighold()</code> и <code>sigrelse()</code> могут использоваться совместно для выделения так называемых критических секций кода: участков кода, который не должен прерываться определенным сигналом, чтобы структуры данных не повреждались кодом обработчика сигнала.</p>
     <cite>
      <p><strong>ЗАМЕЧАНИЕ</strong>. POSIX стандартизует эти API, поскольку главной целью POSIX является формализация существующей практики, где это возможно. Однако, функции <code>sigaction()</code>, которые вскоре будут описаны, дают вам все, что делают эти API, и даже больше. В новых программах вам не следует использовать эти API Вместо этого используйте <code>sigaction()</code>. (Мы заметили, что в справочной системе GNU/Linux нет даже страницы для <emphasis>sigset</emphasis>(2)!)</p>
     </cite>
    </section>
    <section>
     <title>
      <p>10.6. Сигналы POSIX</p>
     </title>
     <section>
      <p>API POSIX основан на API <code>sigvec()</code> из BSD 4.2 и 4.3. С небольшими изменениями этот API можно было отнести к возможностям API как V7, так и System V Release 3. POSIX сделал эти изменения и переименовал API <code>sigaction()</code>. Поскольку интерфейс <code>sigvec()</code> широко не использовался, мы не будем его описывать. Вместо этого в данном разделе описывается только <code>sigaction()</code>, который вы и должны так или иначе использовать. (На самом деле руководства BSD 4.4 от 1994 г. помечают <code>sigvec()</code> как устаревшую, указывая читателю на <code>sigaction()</code>.)</p>
     </section>
     <section>
      <title>
       <p>10.6.1. Обнажение проблемы</p>
      </title>
      <p>Что неладно с API System V Release 3? В конце концов, они предоставляют блокирование сигналов, так, что сигналы не теряются, и любой данный сигнал может быть надежно обработан.</p>
      <p>Ответ в том, что этот API работает лишь <emphasis>с одним сигналом в одно и то же время</emphasis>. Программы обычно обрабатывают больше одного сигнала. И когда вы находитесь в середине процесса обработки одного сигнала, вы не хотите беспокоиться по поводу обработки еще и второго. (Предположим, вы только что начали отвечать по офисному телефону, когда зазвонил ваш мобильный телефон: вы бы предпочли, чтобы телефонная система ответила вызывающему, что в данный момент вы находитесь на другой линии и что скоро освободитесь, вместо того, чтобы проделывать все это самому.)</p>
      <p>С API <code>sigset()</code> каждый обработчик сигнала должен был бы временно блокировать все другие сигналы, сделать свою работу, а затем разблокировать их. Проблема в том, что в промежутке между любыми двумя вызовами <code>sighold()</code> может появиться еще не заблокированный сигнал. Сценарий, еще раз, распространенный, создающий условия гонки.</p>
      <p>Решением является обеспечение возможности автоматической работы с группами сигналов, т.е. с помощью одного системного вызова. Вы достигаете этого, работая с наборами сигналов и маской сигналов процесса.</p>
     </section>
     <section>
      <title>
       <p>10.6.2. Наборы сигналов: <code>sigset_t</code> и связанные функции</p>
      </title>
      <p>Маска сигналов процесса является списком сигналов, которые процесс в настоящее время заблокировал. Сила POSIX API в том, что маской сигналов процесса можно манипулировать атомарно, как единым целым.</p>
      <p>Маска сигналов процесса программно представляется с помощью <emphasis>набора сигналов</emphasis>. Это тип <code>sigset_t</code>. Концептуально он представляет собой просто битовую маску, причем значения 0 и 1 представляют отсутствие или наличие определенного сигнала в маске.</p>
      <p><code>/* Непосредственное манипулирование маской сигналов. НЕ ДЕЛАЙТЕ ЭТОГО! */</code></p>
      <p><code>int mask = (1 &lt;&lt; SIGHUP) | (1 &lt;&lt; SIGINT);</code></p>
      <p><code> /* битовая маска для SIGHUP и SIGINT */</code></p>
      <p>Однако, поскольку в системе может быть больше сигналов, чем может содержаться в одной <code>int</code> или <code>long</code> и поскольку интенсивное использование побитовых операций тяжело для восприятия, для управления наборами сигналов существует несколько функций API.</p>
      <p><code>#include &lt;signal.h&gt; /* POSIX */</code></p>
      <empty-line/>
      <p><code>int sigemptyset(sigset_t *set);</code></p>
      <p><code>int sigfillset(sigset_t *set);</code></p>
      <p><code>int sigaddset(sigset_t *set, int signum);</code></p>
      <p><code>int sigdelset(sigset_t *set, int signum);</code></p>
      <p><code>int sigismember(const sigset_t *set, int signum);</code></p>
      <p>Эти функции следующие:</p>
      <p><code>int sigemptyset(sigset_t *set)</code></p>
      <p>Освобождает набор сигналов. По возвращении <code>*set</code> не содержит сигналов. Возвращает 0 в случае успеха и -1 при ошибке.</p>
      <p><code>int sigfillset(sigset_t *set)</code></p>
      <p>Полностью заполняет набор сигналов. По возвращении <code>*set</code> содержит все сигналы, определенные системой. Возвращает 0 в случае успеха и -1 при ошибке.</p>
      <p><code>int sigaddset(sigset_t *set, int signum)</code></p>
      <p>Добавляет <code>signum</code> к маске сигналов процесса в <code>*set</code>. Возвращает 0 в случае успеха и -1 при ошибке.</p>
      <p><code>int sigdelset(sigset_t *set, int signum)</code></p>
      <p>Удаляет <code>signum</code> из маски сигналов процесса в <code>*set</code>. Возвращает 0 в случае успеха и -1 при ошибке.</p>
      <p><code>int sigismember(const sigset_t *set, int signum)</code></p>
      <p>Возвращает true/false, если <code>signum</code> присутствует или не присутствует в <code>*set</code>.</p>
      <p>Перед выполнением с переменной <code>sigset_t</code> каких-то действий всегда следует вызывать одну из функций <code>sigemptyset()</code> или <code>sigfillset()</code>. Существуют оба интерфейса, поскольку иногда бывает нужно начать с пустого набора и работать потом лишь с одним или двумя сигналами, а в другое время бывает нужно работать со всеми сигналами, возможно, убирая один или два сигнала.</p>
     </section>
     <section>
      <title>
       <p>10.6.3. Управление маской сигналов: <code>sigprocmask()</code> и др.</p>
      </title>
      <p>Маска сигналов процесса вначале пуста - заблокированных сигналов нет. (Это упрощение; см. раздел 10.9 «Сигналы, передающиеся через <code>fork()</code> и <code>exec()</code>.) Три функции позволяют работать непосредственно с маской сигналов процесса:</p>
      <p><code>#include &lt;signal.h&gt; /* POSIX */</code></p>
      <empty-line/>
      <p><code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</code></p>
      <p><code>int sigpending(sigset_t *set);</code></p>
      <p><code>int sigsuspend(const sigset_t *set);</code></p>
      <p>Функции следующие:</p>
      <p><code>int sigprocmask(int how, const sigset_t *set, sigset_t *oldset)</code></p>
      <p>Если <code>oldset</code> не равен <code>NULL</code>, получается маска сигналов текущего процесса и помещается в <code>*oldset</code>. Затем маска сигналов процесса обновляется в соответствии с содержимым <code>set</code> и значением <code>how</code>, который должен иметь одно из следующих значений:</p>
      <p><code>SIG_BLOCK  </code>Объединить сигналы в <code>*set</code> с маской сигналов текущего процесса. Новая маска является объединением текущей маски и <code>*set</code>.</p>
      <p><code>SIG_UNBLOCK  </code>Удалить сигналы в <code>*set</code> из маски сигналов процесса. Это не представляет проблемы, если <code>*set</code> содержит сигнал, который не содержится в текущей маске сигналов процесса.</p>
      <p><code>SIG_SETMASK  </code>Заменить маску сигналов процесса содержимым <code>*set</code>.</p>
      <p>Если <code>set</code> равен <code>NULL</code>, a <code>oldset</code> — нет, значение <code>how</code> неважно. Эта комбинация получает маску сигналов текущего процесса, не меняя ее. (Это явно выражено в стандарте POSIX, но не ясно из справочной страницы GNU/Linux.)</p>
      <p><code>int sigpending(sigset_t *set)</code></p>
      <p>Эта функция позволяет увидеть, какие сигналы <emphasis>ожидают решения</emphasis>; т.е. <code>*set</code> заполнен этими сигналами, которые были посланы, но они еще не доставлены, поскольку заблокированы.</p>
      <p><code>int sigsuspend(const sigset_t *set)</code></p>
      <p>Эта функция <emphasis>временно</emphasis> заменяет маску сигналов процесса содержимым <code>*set</code>, а затем приостанавливает процесс, пока сигнал не будет получен. По определению, заставить функцию вернуться может только сигнал, не находящийся в <code>*set</code> (см. раздел 10.7 «Сигналы для межпроцессного взаимодействия).</p>
     </section>
     <section>
      <title>
       <p>10.6.4. Перехват сигналов: <code>sigaction()</code></p>
      </title>
      <p>Наконец мы готовы взглянуть на функцию <code>sigaction()</code>. Эта функция сложна, и мы намеренно опускаем множество деталей, которые предназначены для специального использования. Стандарт POSIX и справочная страница <emphasis>sigaction</emphasis>(2) предоставляют все подробности, хотя вы должны тщательно прочесть и то, и другое, чтобы полностью все усвоить.</p>
      <p><code>#include &lt;signal.h&gt; /* POSIX */</code></p>
      <empty-line/>
      <p><code>int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</code></p>
      <p>Аргументы следующие:</p>
      <p><code>int signum</code></p>
      <p>Интересующий сигнал, как в случае с другими функциями обработки сигналов.</p>
      <p><code>const struct sigaction *act</code></p>
      <p>Определение нового обработчика для сигнала <code>signum</code>.</p>
      <p><code>struct sigaction *oldact</code></p>
      <p>Определение текущего обработчика. Если не <code>NULL</code>, система до установки <code>*act</code> заполняет <code>*oldact</code>. <code>*act</code> может быть <code>NULL</code>, в этом случае <code>*oldact</code> заполняется, но больше ничего не меняется.</p>
      <p>Таким образом, <code>sigaction()</code> и устанавливает новый обработчик, и получает старый за одно действие. <code>struct sigaction</code> выглядит следующим образом.</p>
      <p><code>/* ПРИМЕЧАНИЕ: Порядок в структуре может варьировать. Могут быть</code></p>
      <p><code>   также и другие поля! */</code></p>
      <p><code>struct sigaction {</code></p>
      <p><code> sigset_t sa_mask; /* Дополнительные сигналы для блокирования */</code></p>
      <p><code> int sa_flags;     /* Контролирует поведение */</code></p>
      <p><code> void (*sa_handler)(int);</code></p>
      <p><code>  /* Может образовать объединение с sa_sigaction */</code></p>
      <p><code> void (*sa_sigaction)(int, siginfo_t*, void*);</code></p>
      <p><code>  /* Может образовать объединение с sa_handler */</code></p>
      <p><code>}</code></p>
      <p>Поля следующие:</p>
      <p><code>sigset_t sa_mask</code></p>
      <p>Набор <emphasis>дополнительных</emphasis> сигналов для блокирования при запуске функции обработчика. Таким образом, когда вызывается обработчик, общий набор заблокированных сигналов является объединением сигналов в маске процесса, сигналов в <code>act-&gt;mask</code> и, если <code>SA_NODEFER</code> сброшен, <code>signum</code>.</p>
      <p><code>int sa_flags</code></p>
      <p>Флаги, контролирующие обработку сигнала ядром. См. обсуждение далее.</p>
      <p><code>void (*sa_handler)(int)</code></p>
      <p>Указатель на «традиционную» функцию обработчика. У нее такой же <emphasis>прототип</emphasis> (возвращаемый тип и список параметров), как у функции обработчика для <code>signal()</code>, <code>bsd_signal()</code> и <code>sigset()</code>.</p>
      <p><code>void (*sa_sigaction)(int, siginfo_t*, void*)</code></p>
      <p>Указатель на функцию обработчика «нового стиля». Функция принимает три аргумента, которые вскоре будут описаны.</p>
      <p>Которая из функций <code>act-&gt;sa_handler</code> и <code>act-&gt;sa_sigaction</code> используется, зависит от флага <code>SA_SIGINFO</code> в <code>act-&gt;sa_flags</code>. Когда имеется, используется <code>act-&gt;sa_sigaction</code>; в противном случае используется <code>act-&gt;sa_handler</code>. Как POSIX, так и справочная страница GNU/Linux указывают, что эти два поля могут перекрываться в памяти (т. е. быть частью <code>union</code>). Таким образом, <emphasis>никогда</emphasis> не следует использовать оба поля в одной и той же <code>struct sigaction</code>.</p>
      <p>Поле <code>sa_flags</code> составляется с помощью побитового ИЛИ значений одного или более флагов, перечисленных в табл. 10.3.</p>
      <empty-line/>
      <p><strong>Таблица 10.3.</strong> Значения флагов для <code>sa_flags</code></p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Флаг</th>
        <th align="left" valign="top">Значение</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SA_NOCLDSTOP</code></td>
        <td align="left" valign="top">Этот флаг имеет смысл лишь для <code>SIGCHLD</code>. Когда он установлен, родитель не получает сигнал при остановке порожденною процесса сигналами <code>SIGSTOP</code>, <code>SIGTSTP</code>, <code>SIGTTIN</code> или <code>SIGTTOU</code>. Эти сигналы обсуждаются позже, в разделе 10.8.2</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SA_NOCLDWAIТ</code></td>
        <td align="left" valign="top">Этот флаг имеет смысл лишь для <code>SIGCHLD</code>. Его поведение сложно. Мы отложим объяснение на потом, см. раздел 10.8.3</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SA_NODEFER</code></td>
        <td align="left" valign="top">Обычно данный сигнал блокируется, когда вызывается обработчик сигнала. Когда установлен один из этих флагов, данный сигнал не блокируется при запуске обработчика <code>SA_NODEFER</code> является официальным именем POSIX данного флага (которое и следует использовать)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SA_NOMASK</code></td>
        <td align="left" valign="top">Альтернативное имя для <code>SA_NODEFER</code><a l:href="#n110" type="note">[110]</a></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SA_SIGINFO</code></td>
        <td align="left" valign="top">Обработчик сигнала принимает три аргумента. Как упоминалось, при данном установленном флаге должно использоваться поле <code>sa_sigaction</code> вместо <code>sa_handler</code>.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SA_ONSTACK</code></td>
        <td align="left" valign="top">Это продвинутая возможность. Обработчики сигналов могут вызываться с использованием предоставленной пользователем памяти в качестве «альтернативного стека сигнала». Эта память даётся ядру для подобного использования посредством <code>sigaltstack()</code> (см. <emphasis>sigaltstack</emphasis>(2)). Эта особенность больше не описывается в данной книге</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SA_RESETHAND</code></td>
        <td align="left" valign="top">Этот флаг обеспечивает поведение V7: после вызова обработчика восстанавливается действие сигнала по умолчанию. Официальным именем POSIX флага (которое следует использовать) является <code>SA_RESETHAND</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SA_ONESHOT</code></td>
        <td align="left" valign="top">Альтернативное имя для <code>SA_RESETHAND.</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SA_RESTART</code></td>
        <td align="left" valign="top">Этот флаг предоставляет семантику BSD: системные вызовы, которые могут завершиться с ошибкой <code>EINTR</code> и которые получают этот сигнал, запускаются повторно.</td>
       </tr>
      </table>
      <p>Когда в <code>act-&gt;sa_flags</code> установлен флаг <code>SA_SIGINFO</code>, поле <code>act-&gt;sa_sigaction</code> является указателем на функцию, объявленную следующим образом:</p>
      <p><code>void action_handler(int sig, siginfo_t *info, void *context) {</code></p>
      <p><code> /* Здесь тело обработчика */</code></p>
      <p><code>}</code></p>
      <p>Структура <code>siginfo</code>_t предоставляет изобилие сведений о сигнале:</p>
      <p><code>/* Определение POSIX 2001. Действительное содержание может на разных системах быть разным. */</code></p>
      <p><code>typedef struct {</code></p>
      <p><code> int si_signo;  /* номер сигнала */</code></p>
      <p><code> int si_errno;  /* значение &lt;errno.h&gt; при ошибке */</code></p>
      <p><code> int si_code;   /* код сигнала; см. текст */</code></p>
      <p><code> pid_t si_pid;  /* ID процесса, пославшего сигнал */</code></p>
      <p><code> uid_t si_uid;  /* настоящий UID посылающего процесса */</code></p>
      <p><code> void *si_addr; /* адрес вызвавшей ошибку инструкции */</code></p>
      <p><code> int si_status; /* значение завершения, может включать death-by-signal */</code></p>
      <p><code> long si_band;  /* связывающее событие для SIGPOLL/SIGIO */</code></p>
      <p><code> union sigval si_value; /* значение сигнала (расширенное) */</code></p>
      <p><code>} siginfo_t;</code></p>
      <p>Поля <code>si_signo</code>, <code>si_code</code> и <code>si_value</code> доступны для всех сигналов. Другие поля могут быть членами объединения, поэтому должны использоваться лишь для тех сигналов, для которых они определены. В структуре <code>siginfo_t</code> могут быть также и другие поля.</p>
      <p>Почти все поля предназначены для расширенного использования. Все подробности содержатся в стандарте POSIX и справочной странице <emphasis>sigaction</emphasis>(2). Однако, мы можем описать простое использование поля <code>si_code</code>.</p>
      <p>Для <code>SIGBUS</code>, <code>SIGCHLD</code>, <code>SIGFPE</code>, <code>SIGILL</code>, <code>SIGPOLL</code>, <code>SIGSEGV</code> и <code>SIGTRAP</code> поле si_code может принимать любое из набора предопределенных значений, специфичных для каждого сигнала, указывая на причину появления сигнала. Откровенно говоря, детали несколько чрезмерны; повседневному коду на самом деле нет необходимости иметь с ними дела (хотя позже мы рассмотрим значения для <code>SIGCHLD</code>). Для всех остальных сигналов член <code>si_code</code> имеет одно из значений из табл. 10.4.</p>
      <empty-line/>
      <p><strong>Таблица 10.4</strong>. Значения происхождения сигнала для <code>si_code</code></p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Значение</th>
        <th align="left" valign="top">Только GLIBC</th>
        <th align="left" valign="top">Смысл</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SI_ASYNCIO</code></td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">Асинхронный ввод/вывод завершен (расширенный).</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SI_KERNEL</code></td>
        <td align="left" valign="top">&#8730;</td>
        <td align="left" valign="top">Сигнал послан ядром.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SI_MESGQ</code></td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">Состояние очереди сообщений изменилось (расширенный.)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SI_QUEUE</code></td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">Сигнал послан из <code>sigqueue()</code> (расширенный).</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SI_SIGIO</code></td>
        <td align="left" valign="top">&#8730;</td>
        <td align="left" valign="top"><code>SIGIO</code> поставлен в очередь (расширенный).</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SI_TIMER</code></td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">Время таймера истекло</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>SI_USER</code></td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">Сигнал послан функцией <code>kill()</code>. <code>raise()</code> и <code>abort()</code> также могут его вызвать, но это не обязательно.</td>
       </tr>
      </table>
      <p>В особенности полезно значение <code>SI_USER</code>; оно позволяет обработчику сигнала сообщить, был ли сигнал послан функциями <code>raise()</code> или <code>kill()</code> (описываются далее). Вы можете использовать эту информацию, чтобы избежать повторного вызова <code>raise()</code> или <code>kill()</code>.</p>
      <p>Третий аргумент обработчика сигнала с тремя аргументами, <code>void *contex</code>t, является расширенной возможностью, которая больше не обсуждается в данной книге.</p>
      <p>Наконец, чтобы увидеть <code>sigaction()</code> в действии, исследуйте полный исходный код обработчика сигнала для <code>sort.c</code>:</p>
      <p><code>2074 static void</code></p>
      <p><code>2075 sighandler(int sig)</code></p>
      <p><code>2076 {</code></p>
      <p><code>2077 #ifndef SA_NOCLDSTOP /* В системе старого стиля... */</code></p>
      <p><code>2078  signal(sig, SIG_IGN); /* - для игнорирования sig используйте signal()*/</code></p>
      <p><code>2079 #endif - /* В противном случае sig автоматически блокируется */</code></p>
      <p><code>2080</code></p>
      <p><code>2081  cleanup(); /* Запуск кода очистки */</code></p>
      <p><code>2082</code></p>
      <p><code>2083 #ifdef SA_NOCLDSTOP /* В системе в стиле POSIX... */</code></p>
      <p><code>2084  {</code></p>
      <p><code>2085   struct sigaction sigact;</code></p>
      <p><code>2086</code></p>
      <p><code>2087   sigact.sa_handler = SIG_DFL; /* - Установить действие по умолчанию */</code></p>
      <p><code>2088   sigemptyset(&amp;sigact.sa_mask); /* - Нет дополнительных сигналов для блокирования */</code></p>
      <p><code>2089   sigact.sa_flags = 0; /* - Специальные действия не предпринимаются */</code></p>
      <p><code>2090   sigaction(sig, &amp;sigact, NULL); /* - Поместить на место */</code></p>
      <p><code>2091  }</code></p>
      <p><code>2092 #else /* На системе в старом стиле... */</code></p>
      <p><code>2093  signal(sig, SIG_DFL); /* - Установить действие по умолчанию */</code></p>
      <p><code>2094 #endif</code></p>
      <p><code>2095</code></p>
      <p><code>2096  raise(sig); /* Повторно послать сигнал */</code></p>
      <p><code>2097 }</code></p>
      <p>Вот код в <code>main()</code>, который помещает обработчик на свое место:</p>
      <p><code>2214 #ifdef SA_NOCLDSTOP /* На системе POSIX... */</code></p>
      <p><code>2215 {</code></p>
      <p><code>2216  unsigned i;</code></p>
      <p><code>2217  sigemptyset(&amp;caught_signals);</code></p>
      <p><code>2218  for (i = 0; i &lt; nsigs; i++) /* - Блокировать все сигналы */</code></p>
      <p><code>2219   sigaddset(&amp;caught_signals, sigs[i]);</code></p>
      <p><code>2220  newact.sa_handler = sighandler; /* - Функция обработки сигнала */</code></p>
      <p><code>2221  newact.sa_mask = caught_signals; /* - Установить для обработчика маску сигналов процесса */</code></p>
      <p><code>2222  newact.sa_flags =0; /* - Особых флагов нет */</code></p>
      <p><code>2223 }</code></p>
      <p><code>2224 #endif</code></p>
      <p><code>2225</code></p>
      <p><code>2226 {</code></p>
      <p><code>2227  unsigned i;</code></p>
      <p><code>2228  for (i = 0; i &lt; nsigs; i++) /* Для всех сигналов... */</code></p>
      <p><code>2229  {</code></p>
      <p><code>2230   int sig = sigs[i];</code></p>
      <p><code>2231 #ifdef SA_NOCLDSTOP</code></p>
      <p><code>2232   sigaction(sig, NULL, &amp;oldact); /* - Получить старый обработчик */</code></p>
      <p><code>2233   if (oldact.sa_handler != SIG_IGN) /* - Если этот сигнал не игнорируется */</code></p>
      <p><code>2234    sigaction(sig, &amp;newact, NULL); /* - Установить наш обработчик */</code></p>
      <p><code>2235 #else</code></p>
      <p><code>2236   if (signal(sig, SIG_IGN) != SIG_IGN)</code></p>
      <p><code>2237    signal(sig, sighandler); /* - Та же логика со старым API */</code></p>
      <p><code>2238 #endif</code></p>
      <p><code>2239  }</code></p>
      <p><code>2240 }</code></p>
      <p>Мы заметили, что строки 2216–2219 и 2221 могут быть замещены одним вызовом: <code>sigfillset(&amp;newact.sa_mask)</code>;</p>
      <p>Мы не знаем, почему код написан именно таким способом.</p>
      <p>Интерес представляют также строки 2233–2234 и 2236–2237, которые показывают правильный способ проверки того, игнорируется ли сигнал, и для установки обработчика лишь в том случае, если сигнал не игнорируется.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Функции API <code>sigaction()</code> и <code>signal()</code> не должны использоваться вместе для одного и того же сигнала. Хотя POSIX идет на большие длинноты, чтобы сначала сделать возможным использование <code>signal()</code>, получить <code>struct sigaction</code>, представляющую диспозицию <code>signal()</code>, и восстановить ее, все равно это плохая мысль. Код будет гораздо проще читать, писать и понимать, если вы используете одну функцию или другую взаимоисключающим образам</p>
      </cite>
     </section>
     <section>
      <title>
       <p>10.6.5. Извлечение ожидающих сигналов: <code>sigpending()</code></p>
      </title>
      <p>Описанный ранее системный вызов <code>sigpending()</code> позволяет получить набор ожидающих сигналов, т.е тех сигналов, которые появились, но еще не доставлены из-за блокировки:</p>
      <p><code>#include &lt;signal.h&gt; /* POSIX */</code></p>
      <empty-line/>
      <p><code>int sigpending(sigset_t *set);</code></p>
      <p>Помимо разблокировки ожидающих сигналов, чтобы они могли быть доставлены, вы можете решить их игнорировать. Установка действия сигнала <code>SIG_IGN</code> вызывает сбрасывание сигнала (даже если он был заблокирован). Сходным образом для тех сигналов, действием по умолчанию для которых является их игнорирование, установка действия в <code>SIG_DFL</code> также вызывает сбрасывание таких ожидающих сигналов.</p>
     </section>
     <section>
      <title>
       <p>10.6.6. Создание возможности для прерывания функций: <code>siginterrupt()</code></p>
      </title>
      <p>Чтобы сделать определенную функцию прерываемой или повторно запускаемой в зависимости от значения второго аргумента, в качестве удобного средства может использоваться функция <code>siginterrupt()</code>. Объявление следующее:</p>
      <p><code>#include &lt;signal.h&gt; /* XSI */</code></p>
      <empty-line/>
      <p><code>int siginterrupt(int sig, int flag);</code></p>
      <p>В соответствии со стандартом POSIX поведение <code>siginterrupt()</code> эквивалентно следующему коду:</p>
      <p><code>int siginterrupt(int sig, int flag) {</code></p>
      <p><code> int ret;</code></p>
      <p><code> struct sigaction act;</code></p>
      <p><code> (void)sigaction(sig, NULL, &amp;act); /* Получить старые установки */</code></p>
      <p><code> if (flag) /* Если flag равен true... */</code></p>
      <p><code>  act.sa_flags &amp;= ~SA_RESTART; /* Запретить повторный запуск */</code></p>
      <p><code> else /* В противном случае... */</code></p>
      <p><code>  act.sa_flags |= SA_RESTART; /* Разрешить повторный запуск */</code></p>
      <p><code> ret = sigaction(sig, &amp;act, NULL);</code></p>
      <p><code>  /* Поместить новые установки на место */</code></p>
      <p><code> return ret; /* Вернуть результат */</code></p>
      <p><code>}</code></p>
      <p>В случае успеха возвращаемое значение равно 0 и -1 при ошибке.</p>
     </section>
     <section>
      <title>
       <p>10.6.7. Передача сигналов: <code>kill()</code> и <code>killpg()</code></p>
      </title>
      <p>Традиционная функция Unix для передачи сигналов называется <code>kill()</code>. Имя несколько неправильное; все, что она делает — отправляет сигнал. (Результатом этого часто является завершение получателя сигнала, но это не обязательно верно. Однако, теперь слишком поздно менять имя.) Функция <code>killpg()</code> посылает сигнал определенной группе процессов. Объявления следующие:</p>
      <p><code>#include &lt;sys/types.h&gt; /* POSIX */</code></p>
      <p><code>#include &lt;signal.h&gt;</code></p>
      <empty-line/>
      <p><code>int kill(pid_t pid, int sig);</code></p>
      <p><code>int killpg(int pgrp, int sig); /* XSI */</code></p>
      <p>Аргумент <code>sig</code> является либо именем сигнала, либо 0. В последнем случае сигнал не посылается, но ядро все равно осуществляет проверку ошибок. В частности, это правильный способ проверки существования данного процесса или группы, а также проверки того, что у вас есть разрешение на передачу сигналов процессу или группе процессов <code>kill()</code> возвращает 0 в случае успеха и -1 при ошибке; <code>errno</code> указывает на проблему.</p>
      <p>Правила для значения <code>pid</code> несколько запутаны:</p>
      <p><code>pid &gt; 0   </code><code>pid</code> является номером процесса, и сигнал посылается этому процессу</p>
      <p><code>pid = 0   </code>Сигнал посылается каждому процессу в группе посылающего процесса.</p>
      <p><code>pid = -1  </code>Сигнал посылается каждому процессу в системе, за исключением специальных системных процессов. Применяется проверка прав доступа. На системах GNU/Linux исключается лишь процесс <code>init</code> (PID 1), но у других систем могут быть другие специальные процессы.</p>
      <p><code>pid &lt; -1  </code>Сигнал посылается группе процессов, представленной абсолютным значением <code>pid</code>. Таким образом, вы можете отправить сигнал всей группе процессов, дублируя возможности <code>killpg()</code>. Эта неортогональность обеспечивает историческую совместимость.</p>
      <p>Значение <code>pid</code> для <code>kill()</code> сходно со значением для <code>waitpid()</code> (см. раздел 9.1.6.1 «Использование функций POSIX: <code>wait()</code> и <code>waitpid()</code>»).</p>
      <p>Стандартная функция С <code>raise()</code> в сущности эквивалентна</p>
      <p><code>int raise(int sig) {</code></p>
      <p><code> return kill(getpid(), sig);</code></p>
      <p><code>}</code></p>
      <p>Комитет по стандартизации С выбрал имя <code>raise()</code>, поскольку С должен работать также в окружениях, не относящихся к Unix, a <code>kill()</code> была сочтена специфичной для Unix функцией. Представилась также возможность дать этой функции более описательное имя.</p>
      <p><code>killpg()</code> посылает сигнал группе процессов. Пока значение <code>pgrp</code> превышает 1, эта функция эквивалентна '<code>kill(-pgrp, sig)</code>'. Справочная страница GNU/Linux <emphasis>killpg</emphasis>(2) утверждает, что если <code>pgrp</code> равно 0, сигнал посылается группе отправляющего процесса (Это то же самое, что и <code>kill()</code>.)</p>
      <p>Как вы могли представить, нельзя послать сигнал произвольному процессу (если вы не являетесь суперпользователем, <code>root</code>). Для обычных пользователей действительный или эффективный UID отправляющего процесса должен соответствовать действительному или сохраненному set-user-ID получающего процесса. (Различные UID описаны в разделе 11.1.1 «Действительные и эффективные ID».)</p>
      <p>Однако <code>SIGCONT</code> является особым случаем: пока получающий процесс является членом того же сеанса, что и отправляющий, сигнал пройдет. (Сеансы были кратко описаны в разделе 9.2.1 «Обзор управления заданиями».) Это особое правило позволяет управляющей заданиями оболочке продолжать остановленные процессы-потомки, даже если этот остановленный процесс имеет другой ID пользователя.</p>
     </section>
     <section>
      <title>
       <p>10.6.8. Наша история до настоящего времени, эпизод II</p>
      </title>
      <p>System V Release 3 API был предназначен для исправления различных проблем, представленных первоначальным API сигналов V7. В частности, важной дополнительной концепцией является понятие о блокировке сигналов.</p>
      <p>Однако, этот API оказался недостаточным, поскольку он работал лишь с одним сигналом за раз, оставляя множество широко открытых окон, через которые могли поступать нежелательные сигналы. POSIX API, работая <emphasis>атомарно</emphasis> с множеством сигналов (маской сигналов процесса, программно представленной типом <code>sigset_t</code>), решает эту проблему, закрывая окна.</p>
      <p>Первый набор функций, который мы исследовали, манипулирует значениями <code>sigset_t</code>: <code>sigfillset()</code>, <code>sigemptyset()</code>, <code>sigaddset()</code>, <code>sigdelset()</code> и <code>sigismember()</code>.</p>
      <p>Следующий набор работает с маской сигналов процесса: <code>sigprocmask()</code> устанавливает и получает маску сигналов процесса, <code>sigpending()</code> получает набор ожидающих сигналов, a <code>sigsuspend()</code> помещает процесс в состояние сна, временно заменяя маску сигналов процесса одним из своих параметров.</p>
      <p>Функция POSIX API <code>sigaction()</code> (весьма) запутана из-за необходимости обеспечить:</p>
      <p>• обратную совместимость: <code>SA_RESETHAND</code> и <code>SA_RESTART</code> в поле <code>sa_flags</code>;</p>
      <p>• выбор, блокировать также полученный сигнал или нет: <code>SA_NODEFER</code> для sa<code>_flags</code>;</p>
      <p>• возможность иметь два различных вида обработчиков сигналов: с одним или с тремя аргументами;</p>
      <p>• выбор поведения для управления <code>SIGCHLD</code>: <code>SA_NOCLDSTOP</code> и <code>SA_NOCLDWAIT</code> для <code>sa_flags</code>.</p>
      <p>Функция <code>siginterrupt()</code> является удобной для разрешения или запрещения повторного запуска системных вызовов для данного сигнала.</p>
      <p>Наконец, для посылки сигналов не только текущему, но также и другим процессам могут использоваться <code>kill()</code> и <code>killpg()</code> (конечно, с проверкой прав доступа).</p>
     </section>
    </section>
    <section>
     <title>
      <p>10.7. Сигналы для межпроцессного взаимодействия</p>
     </title>
     <epigraph>
      <p>«ЭТО УЖАСНАЯ МЫСЛЬ! СИГНАЛЫ НЕ ПРЕДНАЗНАЧЕНЫ ДЛЯ ЭТОГО! Просто скажите НЕТ».</p>
      <text-author>- Джефф Колье (Geoff Collyer) -</text-author>
     </epigraph>
     <p>Одним из главных механизмов межпроцессного взаимодействия (IPC) являются каналы, которые описаны в разделе 9.3 «Базовая межпроцессная коммуникация каналы и FIFO». Сигналы также можно использовать для очень простого IPC<a l:href="#n111" type="note">[111]</a>. Это довольно грубо; получатель может лишь сказать, что поступил определенный сигнал. Хотя функция <code>sigaction()</code> позволяет получателю узнать PID и владельца процесса, пославшего сигнал, эти сведения обычно не очень помогают.</p>
     <cite>
      <p><strong>ЗАМЕЧАНИЕ</strong>. Как указывает цитата в начале, использование сигналов для IPC почти всегда является плохой мыслью. Мы рекомендуем по возможности избегать этого. Но нашей целью является научить вас, как использовать возможности Linux/Unix, включая их отрицательные моменты, оставляя за вами принятие информированного решения, что именно использовать.</p>
     </cite>
     <p>Сигналы в качестве IPC для многих программ могут быть иногда единственным выбором. В частности, каналы не являются альтернативой, если две взаимодействующие программы не запущены общим родителем, а файлы FIFO могут не быть вариантом, если одна из взаимодействующих программ работает лишь со стандартными вводом и выводом. (Примером обычного использования сигналов являются определенные системные программы демонов, таких, как <code>xinetd</code>, которые принимают несколько сигналов, уведомляющих, что нужно повторно прочесть файл настроек, осуществить проверку непротиворечивости и т.д. См. <emphasis>xinetd</emphasis>(8) в системе GNU/Linux и <emphasis>inetd</emphasis>(8) в системе Unix.)</p>
     <p>Типичная высокоуровневая структура основанного на сигналах приложения выглядит таким образом:</p>
     <p><code>for(;;){</code></p>
     <p><code> /* <emphasis>Ожидание сигнала</emphasis> */</code></p>
     <p><code> /* <emphasis>Обработка сигнала</emphasis> */</code></p>
     <p><code>}</code></p>
     <p>Оригинальным интерфейсом V7 для ожидания сигнала является <code>pause()</code>:</p>
     <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
     <empty-line/>
     <p><code>int pause(void);</code></p>
     <p><code>pause()</code> приостанавливает процесс; она возвращается лишь после того, как сигнал будет доставлен и его обработчик вернется из вызова. По определению, <code>pause()</code> полезна лишь с перехваченными сигналами — игнорируемые сигналы при их появлении игнорируются, а сигналы с действием по умолчанию, завершающим процесс (с созданием файла образа или без него), продолжают действовать так же.</p>
     <p>Проблема в только что описанной высокоуровневой структуре приложения кроется в части «Обработка сигнала». Когда этот код запускается, вы не захотите обрабатывать другой сигнал; вы хотите завершить обработку текущего сигнала до перехода к следующему. Одним из возможных решений является структурирование обработчика сигнала таким образом, что он устанавливает флаг и проверяет его в главном цикле: <code>volatile sig_atomic_t signal_waiting = 0; /* true, если не обрабатываются сигналы */</code></p>
     <empty-line/>
     <p><code>void handler(int sig) {</code></p>
     <p><code> signal_waiting = 1;</code></p>
     <p><code> /* Установка других данных, указывающих вид сигнала */</code></p>
     <p>В основном коде флаг проверяется:</p>
     <p><code>for (;;) {</code></p>
     <p><code> if (!signal_waiting) { /* Если возник другой сигнал, */</code></p>
     <p><code>  pause(); /* этот код пропускается */</code></p>
     <p><code>  signal_waiting = 1;</code></p>
     <p><code> }</code></p>
     <p><code> /* Определение поступившего сигнала */</code></p>
     <p><code> signal_waiting = 0;</code></p>
     <p><code> /* Обработка сигнала */</code></p>
     <p><code>}</code></p>
     <p>К сожалению, этот код изобилует условиями гонки:</p>
     <p><code>for (;;) {</code></p>
     <p><code> if (!signal_waiting) {</code></p>
     <p><code>  /* &lt;--- Сигнал может появиться здесь, после проверки условия! */</code></p>
     <p><code>  pause(); /* pause() будет вызвана в любом случае */</code></p>
     <p><code>  signal_waiting = 1;</code></p>
     <p><code> }</code></p>
     <empty-line/>
     <p><code> /* Определение поступившего сигнала</code></p>
     <p><code>    &lt;--- Сигнал может переписать здесь глобальные данные */</code></p>
     <p><code> signal_waiting = 0;</code></p>
     <p><code> /* Обработка сигнала</code></p>
     <p><code>    &lt;--- То же и здесь, особенно для нескольких сигналов */</code></p>
     <p><code>}</code></p>
     <p>Решением является блокирование интересующего сигнала в любое время, кроме ожидания его появления. Например, предположим, что интересующим нас сигналом является <code>SIGINT</code>:</p>
     <p><code>void handler(int sig) {</code></p>
     <p><code> /* sig автоматически блокируется функцией sigaction() */</code></p>
     <p><code> /* Установить глобальные данные, касающиеся этого сигнала */</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>int main(int argc, char **argv) {</code></p>
     <p><code> sigset_t set;</code></p>
     <p><code> struct sigaction act;</code></p>
     <empty-line/>
     <p><code> /* ...обычная настройка, опции процесса и т.д. ... */</code></p>
     <empty-line/>
     <p><code> sigemptyset(&amp;set); /* Создать пустой набор */</code></p>
     <p><code> sigaddset(&amp;set, SIGINT); /* Добавить в набор SIGINT */</code></p>
     <p><code> sigprocmask(SIG_BLOCK, &amp;set, NULL); /* Заблокировать его */</code></p>
     <empty-line/>
     <p><code> act.sa_mask = set; /* Настроить обработчик */</code></p>
     <p><code> act.sa_handler = handler;</code></p>
     <p><code> act.sa_flags = 0;</code></p>
     <p><code> sigaction(sig, &amp;act, NULL); /* Установить его */</code></p>
     <empty-line/>
     <p><code> ... /* Возможно, установить отдельные обработчики */</code></p>
     <p><code> ... /* для других сигналов */</code></p>
     <empty-line/>
     <p><code> sigemptyset(&amp;set); /* Восстановить пустой, допускает SIGINT */</code></p>
     <empty-line/>
     <p><code> for (;;) {</code></p>
     <p><code>  sigsuspend(&amp;set); /* Ждать появления SIGINT */</code></p>
     <p><code>  /* Обработка сигнала. SIGINT здесь снова блокируется */</code></p>
     <p><code> }</code></p>
     <p><code> /* ...любой другой код... */</code></p>
     <p><code> return 0;</code></p>
     <p><code>}</code></p>
     <p>Ключом к использованию этого является то, что <code>sigsuspend()</code> <emphasis>временно</emphasis> заменяет маску сигналов процесса маской, переданной в аргументе. Это дает <code>SIGINT</code> возможность появиться. При появлении он обрабатывается; обработчик сигнала возвращается, а вслед за ним возвращается также <code>sigsuspend()</code>. Ко времени возвращения <code>sigsuspend()</code> первоначальная маска процесса снова на месте.</p>
     <p>Вы легко можете расширить этот пример для нескольких сигналов, блокируя в <code>main()</code> и в обработчике все интересующие сигналы и разблокируя их лишь в вызове <code>sigsuspended()</code>.</p>
     <p>При наличии всего этого не следует в новом коде использовать <code>pause()</code>. <code>pause()</code> был стандартизован POSIX главным образом для поддержки старого кода. То же самое верно и для функции <code>sigpause()</code> System V Release 3. Вместо этого, если нужно структурировать свое приложение с использованием сигналов для IPC, используйте исключительно функции API <code>sigsuspend()</code> и <code>sigaction()</code>.</p>
     <cite>
      <p><strong>ЗАМЕЧАНИЕ</strong>. Приведенный выше код предполагает, что маска сигналов процесса начинается пустой. Код изделия должен вместо этого работать с любой маской сигналов, имеющейся на момент запуска программы.</p>
     </cite>
    </section>
    <section>
     <title>
      <p>10.8. Важные сигналы специального назначения</p>
     </title>
     <section>
      <p>Некоторые сигналы имеют особое назначение. Здесь мы опишем наиболее важные.</p>
     </section>
     <section>
      <title>
       <p>10.8.1. Сигнальные часы: <code>sleep()</code>, <code>alarm()</code> и <code>SIGALARM</code></p>
      </title>
      <section>
       <p>Часто бывает необходимо написать программу в виде</p>
       <p><code>while (/* <emphasis>некоторое неверное условие</emphasis> */) {</code></p>
       <p><code> /* <emphasis>подождать некоторое время</emphasis> */</code></p>
       <p><code>}</code></p>
       <p>Часто такая потребность возникает в сценариях оболочки, например, в ожидании регистрации определенного пользователя:</p>
       <p><code>until who | grep '^arnold' &gt; /dev/null</code></p>
       <p><code>do</code></p>
       <p><code> sleep 10</code></p>
       <p><code>done</code></p>
       <p>Два механизма, один низкоуровневый, другой высокоуровневый, позволяют работающему процессу узнать, когда истекло заданное количество секунд.</p>
      </section>
      <section>
       <title>
        <p>10.8.1.1. Труднее, но с большим контролем: <code>alarm()</code> и <code>SIGALARM</code></p>
       </title>
       <p>Основным строительным блоком является системный вызов <code>alarm()</code>:</p>
       <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
       <empty-line/>
       <p><code>unsigned int alarm(unsigned int seconds);</code></p>
       <p>После того, как <code>alarm()</code> возвратится, программа продолжает работать. Однако, когда истекают <code>seconds</code> секунд, ядро посылает процессу <code>SIGALARM</code>. Действием по умолчанию является завершение процесса, но вы скорее всего вместо этого установите обработчик сигнала для <code>SIGALARM</code>.</p>
       <p>Возвращаемое значение либо 0, либо, если был установлен предыдущий сигнальный интервал, число секунд, остающихся до его завершения. Однако, для процесса имеется лишь один такой сигнальный интервал; предыдущий отменяется, а новый помещается на его место.</p>
       <p>Преимуществом здесь является то, что со своим установленным обработчиком вы можете делать при поступлении сигнала все, что хотите. Недостаток же в том, что приходится быть готовым к работе в нескольких контекстах: основном контексте и контексте обработчика сигнала.</p>
      </section>
      <section>
       <title>
        <p>10.8.1.2. Простой и легкий: <code>sleep()</code></p>
       </title>
       <p>Более легкий способ ожидания истечения фиксированного промежутка времени заключается в использовании функции <code>sleep()</code>:</p>
       <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
       <empty-line/>
       <p><code>unsigned int sleep(unsigned int seconds);</code></p>
       <p>Возвращаемое значение равно 0, если процесс проспал все отведенное время. В противном случае возвращается оставшееся для сна время. Это последнее значение может возникнуть в случае, если появился сигнал, пока процесс дремал.</p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. Функция <code>sleep()</code> часто реализуется через сочетание <code>signal()</code>, <code>alarm()</code> и <code>pause()</code>. Такой подход делает опасным смешивание <code>sleep()</code> с вашим собственным вызовом <code>alarm()</code> (или расширенной функцией <code>setitimer()</code>, описанной в разделе 14.3.3 «Интервальные таймеры <code>setitimer()</code> и <code>getitimer()</code>») Чтобы теперь узнать о функции <code>nanosleep()</code>, см. раздел 14.3.4 «Более точные паузы: <code>nanosleep()</code>».</p>
       </cite>
      </section>
     </section>
     <section>
      <title>
       <p>10.8.2. Сигналы, управляющие заданиями</p>
      </title>
      <p>Несколько сигналов используются для реализации <emphasis>управления заданиями</emphasis> — возможностью начинать и останавливать задания и перемещать их из фонового режима на передний план и обратно. На уровне пользователя вы, несомненно, проделывали это: использовали CTRL-Z для остановки задания, <code>bg</code> для помещения его в фоновый режим, а иногда использовали <code>fg</code> для перемещения фонового или остановленного задания на передний план.</p>
      <p>Секция 9.2.1 «Обзор управления заданиями» описывает в общем, как осуществляется управление заданиями. Данный раздел завершает обзор, описав сигналы управления заданиями. поскольку иногда может понадобиться перехватить их непосредственно:</p>
      <p><code>SIGTSTP</code></p>
      <p>Этот сигнал осуществляет «остановку терминала». Это сигнал, который ядро посылает процессу, когда пользователь за терминалом (или окном, эмулирующим терминал) набирает определенный ключ. Обычно это CTRL-Z, аналогично тому, как CTRL-C обычно посылает <code>SIGINT</code>.</p>
      <p>Действием по умолчанию для <code>SIGTSTP</code> является остановка (переход в приостановленное состояние) процесса. Однако, вы можете перехватить этот сигнал, как любой другой. Хорошая мысль сделать это, если ваша программа изменяет состояние терминала. Например, рассмотрите экранные редакторы <code>vi</code> или Emacs, которые переводят терминал в посимвольный режим. По получении <code>SIGTSTP</code>, они должны восстановить терминал в его нормальный построчный режим, а затем приостановиться сами.</p>
      <p><code>SIGSTOP</code></p>
      <p>Этот сигнал также останавливает процесс, но он не может быть перехвачен, заблокирован или проигнорирован. Он может быть использован в качестве последнего средства вручную (посредством команды <code>kill</code>) или программным путем. Например, только что обсужденный обработчик <code>SIGTSTP</code> после восстановления состояния терминала мог бы затем использовать для остановки процесса '<code>raise (SIGSTOP)</code>'.</p>
      <p><code>SIGTTIN</code>, <code>SIGTTOU</code></p>
      <p>Ранее эти сигналы были определены как «фоновое чтение из tty» и «фоновая запись в tty». <emphasis>tty</emphasis> является устройством терминала. В системах управления заданиями процессы, работающие в фоновом режиме, заблокированы от попыток чтения с терминала или записи в него. Когда процесс пытается осуществить любую из этих операций, ядро посылает ему соответствующий сигнал. Для обоих действием по умолчанию является остановка процесса. При желании можно перехватить эти сигналы, но для этого редко бывает необходимость.</p>
      <p><code>SIGCONT</code></p>
      <p>Этот сигнал вновь запускает остановленный процесс. Если процесс не остановлен, он игнорируется. При желании его можно перехватить, но опять-таки для большинства программ мало причин для осуществления этого. Продолжая наш пример, обработчик <code>SIGCONT</code> для экранного редактора должен перед возвращением вернуть терминал обратно в посимвольный режим.</p>
      <p>Когда процесс остановлен, любые другие посланные ему сигналы становятся ожидающими. Исключением является <code>SIGKILL</code>, который всегда доставляется процессу и который не может быть перехвачен, заблокирован или проигнорирован. В предположении, что были посланы сигналы кроме <code>SIGKILL</code>, по получении <code>SIGCONT</code> ожидающие сигналы доставляются, а процесс продолжает выполнение после того, как они будут обработаны.</p>
     </section>
     <section>
      <title>
       <p>10.8.3. Родительский надзор: три различные стратегии</p>
      </title>
      <section>
       <p>Как описано в разделе 9.1.1 «Создание процесса: <code>fork()</code>», одним побочным эффектом вызова <code>fork()</code> является создание между процессами отношений родитель-потомок. Родительский процесс может ждать завершения одного или более из своих потомков и получить статус завершения порожденного процесса посредством одного из семейства системных вызовов <code>wait()</code>.</p>
       <p>Завершившиеся порожденные процессы, которых никто не ожидал, называются <emphasis>зомби (zombies)</emphasis>. Обычно каждый раз при завершении порожденного процесса ядро посылает родительскому процессу сигнал <code>SIGCHLD</code><a l:href="#n112" type="note">[112]</a>. Действием по умолчанию является игнорирование этого сигнала. В этом случае процессы зомби накапливаются до тех пор, пока родитель не вызовет <code>wait()</code> или не закончится сам. В последнем случае процессы зомби получают в качестве нового родителя системный процесс <code>init</code> (PID 1), который получает от них результаты как часть своей обычной работы. Сходным образом, активные потомки также получают родителем <code>init</code>, и их результаты будут собраны при их завершении.</p>
       <p><code>SIGCHLD</code> используется для большего, чем уведомление о завершении потомка. Каждый раз при остановке потомка (посредством одного из обсужденных ранее сигналов управления заданиями) родителю также посылается <code>SIGCHLD</code>. Стандарт POSIX указывает, что <code>SIGCHLD</code> «может быть послан» также, когда помок вновь запускается; очевидно, среди оригинальных Unix-систем имеются различия.</p>
       <p>Сочетание флагов для поля <code>sa_flags</code>  в <code>struct sigation</code> и использование <code>SIG_IGN</code> в качестве действия для <code>SIGCHLD</code> позволяет изменить способ обработки ядром остановок, возобновления или завершения потомков.</p>
       <p>Как и с сигналами в общем, описанные здесь интерфейсы и механизмы сложны, поскольку они развивались с течением времени.</p>
      </section>
      <section>
       <title>
        <p>10.8.3.1. Плохие родители: полное игнорирование потомков</p>
       </title>
       <p>Простейшим действием, которое вы можете сделать, является изменение действия для <code>SIGCHLD</code> на <code>SIG_IGN</code>. В этом случае завершившиеся потомки не становятся зомби. Вместо этого статус их завершения отбрасывается, и они полностью удаляются из системы.</p>
       <p>Другой возможностью, дающей такой же результат, является использование флага <code>SA_NOCLDWAIТ</code>. В коде:</p>
       <p><code>/* Старый стиль: */        /* Новый стиль: */</code></p>
       <p><code>signal(SIGCHLD, SIG_IGN);  struct sigaction sa;</code></p>
       <p><code>                           sa.sa_handler = SIG_IGN;</code></p>
       <p><code>                           sa.sa_flags = SA_NOCLDWAIT;</code></p>
       <p><code>                           sigemptyset(&amp;sa.sa_mask);</code></p>
       <p><code>                           sigaction(SIGCHLD, &amp;sa, NULL);</code></p>
      </section>
      <section>
       <title>
        <p>10.8.3.2. Снисходительные родители: минимальный надзор</p>
       </title>
       <p>В качестве альтернативы можно беспокоиться лишь о завершении потомка и не интересоваться простыми изменениями состояния (остановке и возобновлении). В этом случае используйте флаг <code>SA_NOCLDSTOP</code> и установите обработчик сигнала, вызывающий <code>wait()</code> (или родственную ей функцию) для получения данных процесса.</p>
       <p>В общем вы не можете ожидать получать по одному сигналу <code>SIGCHLD</code> на каждого завершающегося потомка. Следует считать, что <code>SIGCHLD</code> означает «завершился по крайней мере один потомок» и быть готовым собрать при обработке <code>SIGCHLD</code> сведения о как можно большем числе потомков.</p>
       <p>Следующая программа, <code>ch10-reap1.с</code>, блокирует <code>SIGCHLD</code> до тех пор, пока не будет готова восстановить потомков.</p>
       <p><code>1  /* ch10-reap1.с --- демонстрирует управление SIGCHLD с использованием цикла */</code></p>
       <p><code>2</code></p>
       <p><code>3  #include &lt;stdio.h&gt;</code></p>
       <p><code>4  #include &lt;errno.h&gt;</code></p>
       <p><code>5  #include &lt;signal.h&gt;</code></p>
       <p><code>6  #include &lt;string.h&gt;</code></p>
       <p><code>7  #include &lt;sys/types.h&gt;</code></p>
       <p><code>8  #include &lt;sys/wait.h&gt;</code></p>
       <p><code>9</code></p>
       <p><code>10 #define MAX_KIDS 42</code></p>
       <p><code>11 #define NOT_USED -1</code></p>
       <p><code>12</code></p>
       <p><code>13 pid_t kids[MAX_KIDS];</code></p>
       <p><code>14 size_t nkids = 0;</code></p>
       <p>Массив потомков отслеживает ID порожденных процессов. Если элемент содержит <code>NOT_USED</code>, он не представляет необработанного потомка. (Его инициализируют строки 89–90 внизу) <code>nkids</code> указывает, сколько значений в <code>kids</code> следует проверить.</p>
       <p><code>16 /* format_num --- вспомогательная функция, поскольку нельзя использовать [sf]printf() */</code></p>
       <p><code>17</code></p>
       <p><code>18 const char *format_num(int num)</code></p>
       <p><code>19 {</code></p>
       <p><code>20 #define NUMSIZ 30</code></p>
       <p><code>21  static char buf[NUMSIZ];</code></p>
       <p><code>22  int i;</code></p>
       <p><code>23</code></p>
       <p><code>24  if (num &lt;= 0) {</code></p>
       <p><code>25   strcpy(buf, "0");</code></p>
       <p><code>26   return buf;</code></p>
       <p><code>27  }</code></p>
       <p><code>28</code></p>
       <p><code>29  i = NUMSIZ - 1;</code></p>
       <p><code>30  buf[i--] = '\0';</code></p>
       <p><code>31</code></p>
       <p><code>32  /* Преобразует цифры обратно в строку. */</code></p>
       <p><code>33  do {</code></p>
       <p><code>34   buf[i--] = (num % 10) + '0';</code></p>
       <p><code>35   num /= 10;</code></p>
       <p><code>36  } while (num &gt; 0);</code></p>
       <p><code>37</code></p>
       <p><code>38  return &amp;buf[i+1];</code></p>
       <p><code>39 }</code></p>
       <p>Поскольку обработчики сигналов не должны вызывать функции семейства <code>printf()</code>, мы предусмотрели для преобразования десятичного сигнала или номера PID в строку простую «вспомогательную» функцию <code>format_num()</code>. Это примитивно, но работает.</p>
       <p><code>41 /* childhandler --- перехват SIGCHLD, сбор сведений со всех доступных потомков */</code></p>
       <p><code>42</code></p>
       <p><code>43 void childhandler(int sig)</code></p>
       <p><code>44 {</code></p>
       <p><code>45  int status, ret;</code></p>
       <p><code>46  int i;</code></p>
       <p><code>47  char buf[100];</code></p>
       <p><code>48  static const char entered[] = "Entered childhandler\n" ;</code></p>
       <p><code>49  static const char exited[] = "Exited childhandler\n";</code></p>
       <p><code>50</code></p>
       <p><code>51  writed, entered, strlen(entered));</code></p>
       <p><code>52  for (i =0; i &lt; nkids; i++) {</code></p>
       <p><code>53   if (kids[i] == NOT_USED)</code></p>
       <p><code>54    continue;</code></p>
       <p><code>55</code></p>
       <p><code>56 retry:</code></p>
       <p><code>57   if ((ret = waitpid(kids[i], &amp;status, WNOHANG)) == kids[i]) {</code></p>
       <p><code>58    strcpy(buf, "\treaped process ");</code></p>
       <p><code>59    strcat(buf, format_num(ret));</code></p>
       <p><code>60    strcat(buf, "\n");</code></p>
       <p><code>61    write(1, buf, strlen(buf));</code></p>
       <p><code>62    kids[i] = NOT_USED;</code></p>
       <p><code>63   } else if (ret == 0) {</code></p>
       <p><code>64    strcpy(buf, "\tpid ");</code></p>
       <p><code>65    strcat(buf, format_num(kids[i]));</code></p>
       <p><code>66    strcat(buf, " not available yet\n");</code></p>
       <p><code>67    write(1, buf, strlen(buf));</code></p>
       <p><code>68   } else if (ret == -1 &amp;&amp; errno == EINTR) {</code></p>
       <p><code>69    write(1, "\tretrying\n", 10);</code></p>
       <p><code>70    goto retry;</code></p>
       <p><code>71   } else {</code></p>
       <p><code>72    strcpy(buf, "\twaitpid() failed: ");</code></p>
       <p><code>73    strcat(buf, strerror(errno));</code></p>
       <p><code>74    strcat(buf, "\n");</code></p>
       <p><code>75    write(1, buf, strlen(buf));</code></p>
       <p><code>76   }</code></p>
       <p><code>77  }</code></p>
       <p><code>78  write(1, exited, strlen(exited));</code></p>
       <p><code>79 }</code></p>
       <p>Строки 51 и 58 выводят «входное» и «завершающее» сообщения, так что мы можем ясно видеть, когда вызывается обработчик сигнала. Другие сообщения начинаются с ведущего символа TAB.</p>
       <p>Главной частью обработчика сигнала является большой цикл, строки 52–77. Строки 53–54 проверяют на <code>NOT_USED</code> и продолжают цикл, если текущий слот не используется.</p>
       <p>Строка 57 вызывает <code>waitpid()</code> с PID текущего элемента <code>kids</code>. Мы предусмотрели опцию <code>WNOHANG</code>, которая заставляет <code>waitpid()</code> возвращаться немедленно, если затребованный потомок недоступен. Этот вызов необходим, так как возможно, что не все потомки завершились.</p>
       <p>Основываясь на возвращенном значении, код предпринимает соответствующее действие. Строки 57–62 обрабатывают случай обнаружения потомка, выводя сообщение и помещая в соответствующий слот в <code>kids</code> значение <code>NOT_USED</code>.</p>
       <p>Строки 63–67 обрабатывают случай, когда затребованный потомок недоступен. В этом случае возвращается значение 0, поэтому выводится сообщение, и выполнение продолжается.</p>
       <p>Строки 68–70 обрабатывают случай, при котором был прерван системный вызов. В этом случае самым подходящим способом обработки является <code>goto</code> обратно на вызов <code>waitpid()</code>. (Поскольку <code>main()</code> блокирует все сигналы при вызове обработчика сигнала [строка 96], это прерывание не должно случиться. Но этот пример показывает, как обработать все случаи.)</p>
       <p>Строки 71–76 обрабатывают любую другую ошибку, выводя соответствующее сообщение об ошибке.</p>
       <p><code>81  /* main --- установка связанных с порожденными процессами сведений и сигналов, создание порожденных процессов */</code></p>
       <p><code>82</code></p>
       <p><code>83  int main(int argc, char **argv)</code></p>
       <p><code>84  {</code></p>
       <p><code>85   struct sigaction sa;</code></p>
       <p><code>86   sigset_t childset, emptyset;</code></p>
       <p><code>87   int i;</code></p>
       <p><code>88</code></p>
       <p><code>89   for (i = 0; i &lt; nkids; i++)</code></p>
       <p><code>90    kids[i] = NOT_USED;</code></p>
       <p><code>91</code></p>
       <p><code>92   sigemptyset(&amp;emptyset);</code></p>
       <p><code>93</code></p>
       <p><code>94   sa.sa_flags =</code> <code>SA_NOCLDSTOP;</code></p>
       <p><code>95   sa.sa_handler = childhandler;</code></p>
       <p><code>96   sigfillset(&amp;sa.sa_mask); /* блокировать все при вызове обработчика */</code></p>
       <p><code>97   sigaction(SIGCHLD, &amp;sa, NULL);</code></p>
       <p><code>98</code></p>
       <p><code>99   sigemptyset(&amp;childset);</code></p>
       <p><code>100  sigaddset(&amp;childset, SIGCHLD);</code></p>
       <p><code>101</code></p>
       <p><code>102  sigprocmask(SIG_SETMASK, &amp;childset, NULL); /* блокировать его в коде main */</code></p>
       <p><code>103</code></p>
       <p><code>104  for (nkids = 0; nkids &lt; 5; nkids++) {</code></p>
       <p><code>105   if ((kids[nkids] = fdrk()) == 0) {</code></p>
       <p><code>106    sleep(3);</code></p>
       <p><code>107    _exit(0);</code></p>
       <p><code>108   }</code></p>
       <p><code>109  }</code></p>
       <p><code>110</code></p>
       <p><code>111  sleep(5); /* дать потомкам возможность завершения */</code></p>
       <p><code>112</code></p>
       <p><code>113  printf("waiting for signal\n");</code></p>
       <p><code>114  sigsuspend(&amp;emptyset);</code></p>
       <p><code>115 </code></p>
       <p><code>116  return 0;</code></p>
       <p><code>117 }</code></p>
       <p>Строки 89–90 инициализируют <code>kids</code>. Строка 92 инициализирует <code>emptyset</code>. Строки 94–97 настраивают и устанавливают обработчик сигнала для <code>SIGCHLD</code>. Обратите внимание на использование в строке 94 <code>SA_NOCLDSTOP</code>, тогда как строка 96 блокирует все сигналы при вызове обработчика.</p>
       <p>Строки 99–100 создают набор сигналов, представляющих <code>SIGCHLD</code>, а строка 102 устанавливает их в качестве маски сигналов процесса для программы.</p>
       <p>Строки 104–109 создают пять порожденных процессов, каждый из которых засыпает на три секунды. По ходу дела они обновляют массив <code>kids</code> и переменную <code>nkids</code>.</p>
       <p>Строка 111 дает затем потомкам шанс завершиться, заснув на еще больший промежуток времени. (Это не <emphasis>гарантирует</emphasis>, что порожденные процессы завершатся, но шансы довольно велики.)</p>
       <p>Наконец, строки 113–114 выводят сообщение и приостанавливаются, заменив маску сигналов процесса, блокирующую <code>SIGCHLD</code>, пустой маской. Это дает возможность появиться сигналу <code>SIGCHLD</code>, что в свою очередь вызывает запуск обработчика сигнала. Вот что происходит:</p>
       <p><code>$ <strong>ch10-reap1</strong> /* Запуск программы */</code></p>
       <p><code>waiting for signal</code></p>
       <p><code>Entered childhandler</code></p>
       <p><code>  reaped process 23937</code></p>
       <p><code>  reaped process 23938</code></p>
       <p><code>  reaped process 23939</code></p>
       <p><code>  reaped process 23940</code></p>
       <p><code>  reaped process 23941</code></p>
       <p><code>Exited childhandler</code></p>
       <p>Обработчик сигнала собирает сведения о потомках за один проход.</p>
       <p>Следующая программа, <code>ch10-reap2.c</code>, сходна с <code>ch10-reap1.c</code>. Разница в том, что она допускает появление сигнала <code>SIGCHLD</code> в любое время. Такое поведение увеличивает шанс получения более одного <code>SIGCHLD</code>, но <emphasis>не</emphasis> гарантирует это. В результате обработчик сигнала все равно должен быть готов обработать в цикле несколько потомков.</p>
       <p><code>1  /* ch10-reap2.c — демонстрирует управление SIGCHLD, один сигнал на потомка */</code></p>
       <p><code>2</code></p>
       <p><code>   /* ...не изменившийся код пропущен... */</code></p>
       <p><code>12</code></p>
       <p><code>13 pid_t kids[MAX_KIDS];</code></p>
       <p><code>14 size_t nkids = 0;</code></p>
       <p><code>15 size_t kidsleft = 0; /* &lt;&lt;&lt; Добавлено */</code></p>
       <p><code>16</code></p>
       <p><code> /* ...не изменившийся код пропущен... */</code></p>
       <p><code>41</code></p>
       <p><code>42 /* childhandler --- перехват SIGCHLD, опрос всех доступных потомков */</code></p>
       <p><code>43</code></p>
       <p><code>44 void childhandler(int sig)</code></p>
       <p><code>45 {</code></p>
       <p><code>46  int status, ret;</code></p>
       <p><code>47  int i;</code></p>
       <p><code>48  char buf[100];</code></p>
       <p><code>49  static const char entered[] = "Entered childhandler\n";</code></p>
       <p><code>50  static const char exited[] = "Exited childhandler\n";</code></p>
       <p><code>51</code></p>
       <p><code>52  write(1, entered, strlen(entered));</code></p>
       <p><code>53  for (i = 0; i &lt; nkids; i++) {</code></p>
       <p><code>54   if (kids[i] == NOT_USED)</code></p>
       <p><code>55    continue;</code></p>
       <p><code>56</code></p>
       <p><code>57 retry:</code></p>
       <p><code>58  if ((ret = waitpid(kids[i], &amp;status, WNOHANG)) == kids[i]) {</code></p>
       <p><code>59   strcpy(buf, "\treaped process ");</code></p>
       <p><code>60   strcat(buf, format_num(ret));</code></p>
       <p><code>61   strcat(buf, "\n");</code></p>
       <p><code>62   write(1, buf, strlen(buf));</code></p>
       <p><code>63   kids[i] = NOT_USED;</code></p>
       <p><code>64   kidsleft--; /* &lt;&lt;&lt; Добавлено */</code></p>
       <p><code>65  } else if (ret == 0) {</code></p>
       <p><code>    /* ...не изменившийся код пропущен... */</code></p>
       <p><code>80  write(1, exited, strlen(exited));</code></p>
       <p><code>81 }</code></p>
       <p>Это идентично предыдущей версии за тем исключением, что у нас есть новая переменная, <code>kidsleft</code>, указывающая, сколько имеется не опрошенных потомков. Строки 15 и 64 помечают новый код.</p>
       <p><code>83  /* main --- установка относящейся к порожденным процессам сведений</code></p>
       <p><code>       и сигналов, создание порожденных процессов */</code></p>
       <p><code>84</code></p>
       <p><code>85  int main(int argc, char **argv)</code></p>
       <p><code>86  {</code></p>
       <p><code>     /* ...не изменившийся код пропущен... */</code></p>
       <p><code>100</code></p>
       <p><code>101  sigemptyset(&amp;childset);</code></p>
       <p><code>102  sigaddset(&amp;childset, SIGCHLD);</code></p>
       <p><code>103</code></p>
       <p><code>104  /* sigprocmask(SIG_SETMASK, &amp;childset, NULL); /* блокирование в коде main */</code></p>
       <p><code>105</code></p>
       <p><code>106  for (nkids = 0; nkids &lt; 5; nkids++) {</code></p>
       <p><code>107   if ((kids[nkids] = fork()) == 0) {</code></p>
       <p><code>108    sleep(3);</code></p>
       <p><code>109    _exit(0);</code></p>
       <p><code>110   }</code></p>
       <p><code>111   kidsleft++; /* &lt;&lt;&lt; Added */</code></p>
       <p><code>112  }</code></p>
       <p><code>113</code></p>
       <p><code>114  /* sleep(5); /* дать потомкам шанс завершиться */</code></p>
       <p><code>115</code></p>
       <p><code>116  while (kidsleft &gt; 0) { /* &lt;&lt;&lt; Добавлено */</code></p>
       <p><code>117   printf("waiting for signals\n");</code></p>
       <p><code>118   sigsuspend(&amp;emptyset);</code></p>
       <p><code>119  } /* &lt;&lt;&lt; Добавлено */</code></p>
       <p><code>120</code></p>
       <p><code>121  return 0;</code></p>
       <p><code>122 }</code></p>
       <p>Здесь код также почти идентичен. Строки 104 и 114 закомментированы из предыдущей версии, а строки 111, 116 и 119 добавлены. Удивительно, при запуске поведение меняется в зависимости от версии ядра!</p>
       <p><code>$ <strong>uname -a</strong> /* Отобразить версию системы */</code></p>
       <p><code>Linux example1 2.4.20-8 #1 Thu Mar 13 17:54:28 EST 2003 i686 i686 i386 GNU/Linux</code></p>
       <p><code>$ <strong>ch10-reap2</strong> /* Запустить программу */</code></p>
       <p><code>waiting for signals</code></p>
       <p><code>Entered childhandler /* Опрос одного потомка */</code></p>
       <p><code>  reaped process 2702</code></p>
       <p><code>  pid 2703 not available yet</code></p>
       <p><code>  pid 2704 not available yet</code></p>
       <p><code>  pid 2705 not available yet</code></p>
       <p><code>  pid 27 06 not available yet</code></p>
       <p><code>Exited childhandler</code></p>
       <p><code>waiting for signals</code></p>
       <p><code>Entered childhandler /* И следующего */</code></p>
       <p><code>  reaped process 2703</code></p>
       <p><code>  pid 2704 not available yet</code></p>
       <p><code>  pid 2705 not available yet</code></p>
       <p><code>  pid 2706 not available yet</code></p>
       <p><code>Exited childhandler</code></p>
       <p><code>waiting for signals</code></p>
       <p><code>Entered childhandler /* И так далее */</code></p>
       <p><code>  reaped process 2704</code></p>
       <p><code>  pid 2705 not available yet</code></p>
       <p><code>  pid 2706 not available yet</code></p>
       <p><code>Exited childhandler</code></p>
       <p><code>waiting for signals</code></p>
       <p><code>Entered childhandler</code></p>
       <p><code>  reaped process 2705</code></p>
       <p><code>  pid 2706 not available yet</code></p>
       <p><code>Exited childhandler</code></p>
       <p><code>waiting for signals</code></p>
       <p><code>Entered childhandler</code></p>
       <p><code>  reaped process 2706</code></p>
       <p><code>Exited childhandler</code></p>
       <p>В данном примере на каждый процесс поступает ровно один <code>SIGCHLD</code>! Хотя это прекрасно и полностью воспроизводимо на этой системе, это также необычно. Как на более раннем, так и на более позднем ядре и на Solaris программа получает один сигнал для более чем одного потомка:</p>
       <p><code>$ <strong>uname -a</strong> /* Отобразить версию системы */</code></p>
       <p><code>Linux example2 2.4.22-1.2115.npt1 #1 Wed Oct 29 15:42:51 EST 2003 i686 i686 i386 GNU/Linux</code></p>
       <p><code>$ <strong>ch10-reap2</strong> /* Запуск программы */</code></p>
       <p><code>waiting for signals</code></p>
       <p><code>Entered childhandler /* Обработчик сигнала вызван лишь однажды */</code></p>
       <p><code>  reaped process 9564</code></p>
       <p><code>  reaped process 9565</code></p>
       <p><code>  reaped process 9566</code></p>
       <p><code>  reaped process 9567</code></p>
       <p><code>  reaped process 9568</code></p>
       <p><code>Exited childhandler</code></p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ.</strong> В коде для <code>ch10-reap2.c</code> есть один важный дефект — состояние гонки. Взгляните еще раз на строки 106–112 в <code>ch10-reap2.c</code>. Что случится, если <code>SIGCHLD</code> появится при исполнении этого кода? Массив <code>kids</code> и переменные <code>nkids</code> и <code>kidsleft</code> могут оказаться разрушенными: код в <code>main</code> добавляет новый процесс, но обработчик сигнала вычитает один.</p>
        <p>Этот пример кода является отличным примером критического раздела; он не должен прерываться при исполнении. Правильным способом работы с этим кодом является заключение его между вызовами, которые сначала блокируют, а затем разблокируют <code>SIGCHLD</code>.</p>
       </cite>
      </section>
      <section>
       <title>
        <p>10.8.3.3. Строгий родительский контроль</p>
       </title>
       <p>Структура <code>siginfo_t</code> и перехватчик сигнала с тремя аргументами дают возможность узнать, что случилось с потомком. Для SIGCHLD поле <code>si_code</code> структуры <code>siginfo_t</code> указывает причину посылки сигнала (остановка, возобновление, завершение порожденного процесса и т.д.). В табл. 10.5 представлен полный список значений. Все они определены в качестве расширения XSI стандарта POSIX.</p>
       <p>Следующая программа, <code>ch10-status.c</code>, демонстрирует использование структуры <code>siginfo_t</code>.</p>
       <p><code>1  /* ch10-status.c --- демонстрирует управление SIGCHLD, используя обработчик с 3 аргументами */</code></p>
       <p><code>2</code></p>
       <p><code>3  #include &lt;stdio.h&gt;</code></p>
       <p><code>4  #include &lt;errno.h&gt;</code></p>
       <p><code>5  #include &lt;signal.h&gt;</code></p>
       <p><code>6  #include &lt;string.h&gt;</code></p>
       <p><code>7  #include &lt;sys/types.h&gt;</code></p>
       <p><code>8  #include &lt;sys/wait.h&gt;</code></p>
       <p><code>9</code></p>
       <p><code>10 void manage(siginfo_t *si);</code></p>
       <p><code>11</code></p>
       <p><code>/* ...не изменившийся для format_num() код опущен... */</code></p>
       <empty-line/>
       <p><strong>Таблица 10.5</strong>. Значения <code>si_code</code> XSI для <code>SIGCHLD</code></p>
       <table>
        <tr align="left">
         <th align="left" valign="top">Значение</th>
         <th align="left" valign="top">Смысл</th>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>CLD_CONTINUED</code></td>
         <td align="left" valign="top">Остановленный потомок был возобновлен.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>CLD_DUMPED</code></td>
         <td align="left" valign="top">Потомок завершился с ошибкой, создан образ процесса</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>CLD_EXITED</code></td>
         <td align="left" valign="top">Потомок завершился нормально.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>CLD_KILLED</code></td>
         <td align="left" valign="top">Потомок был завершен сигналом</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>CLD_STOPPED</code></td>
         <td align="left" valign="top">Порожденный процесс был остановлен.</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>CLD_TRAPPED</code></td>
         <td align="left" valign="top">Трассируемый потомок остановлен (Это условие возникает, когда программа трассируется — либо из отладчика, либо для мониторинга реального времени В любом случае, вы вряд ли увидите его в обычных ситуациях.)</td>
        </tr>
       </table>
       <p>Строки 3–8 включают стандартные заголовочные файлы, строка 10 объявляет <code>manage()</code>, которая имеет дело с изменениями состояния потомка, а функция <code>format_num()</code> не изменилась по сравнению с предыдущим.</p>
       <p><code>37 /* childhandler --- перехват SIGCHLD, сбор данных лишь об одном потомке */</code></p>
       <p><code>38</code></p>
       <p><code>39 void childhandler(int sig, siginfo_t *si, void *context)</code></p>
       <p><code>40 {</code></p>
       <p><code>41  int status, ret;</code></p>
       <p><code>42  int i;</code></p>
       <p><code>43  char buf[100];</code></p>
       <p><code>44  static const char entered[] = "Entered childhandler\n";</code></p>
       <p><code>45  static const char exited[] = "Exited childhandler\n";</code></p>
       <p><code>46</code></p>
       <p><code>47  write(1, entered, strlen(entered));</code></p>
       <p><code>48 retry:</code></p>
       <p><code>49  if ((ret = waitpid(si-&gt;si_pid, &amp;status, WNOHANG)) == si-&gt;si_pid) {</code></p>
       <p><code>50   strcpy(buf, "\treaped process ");</code></p>
       <p><code>51   strcat(buf, format_num(si-&gt;si_pid));</code></p>
       <p><code>52   strcat(buf, "\n");</code></p>
       <p><code>53   write(1, buf, strlen(buf));</code></p>
       <p><code>54   manage(si); /* обработать то, что произошло */</code></p>
       <p><code>55  } else if (ret &gt; 0) {</code></p>
       <p><code>56   strcpy(buf, "\treaped unexpected pid ");</code></p>
       <p><code>57   strcat(buf, format_num(ret));</code></p>
       <p><code>58   strcat(buf, "\n");</code></p>
       <p><code>59   write(1, buf, strlen(buf));</code></p>
       <p><code>60   goto retry; /* почему бы нет? */</code></p>
       <p><code>61  } else if (ret == 0) {</code></p>
       <p><code>62   strcpy(buf, "\tpid ");</code></p>
       <p><code>63   strcat(buf, format_num(si-&gt;si_pid));</code></p>
       <p><code>64   strcat(buf, " changed status\n");</code></p>
       <p><code>65   write(1, buf, strlen(buf));</code></p>
       <p><code>66   manage(si); /* обработать то, что произошло */</code></p>
       <p><code>67  } else if (ret == -1 &amp;&amp; errno == EINTR) {</code></p>
       <p><code>68   write(1, "\tretrying\n", 10);</code></p>
       <p><code>69   goto retry;</code></p>
       <p><code>70  } else {</code></p>
       <p><code>71   strcpy(buf, "\twaitpid() failed: ");</code></p>
       <p><code>72   strcat(buf, strerror(errno));</code></p>
       <p><code>73   strcat(buf, "\n");</code></p>
       <p><code>74   write(1, buf, strlen(buf));</code></p>
       <p><code>75  }</code></p>
       <p><code>76</code></p>
       <p><code>77  write(1, exited, strlen(exited));</code></p>
       <p><code>78 }</code></p>
       <p>Обработчик сигнала похож на показанные ранее. Обратите внимание на список аргументов (строка 39) и на то, что нет цикла.</p>
       <p>Строки 49–54 обрабатывают завершение процесса, включая вызов <code>manage()</code> для вывода состояния.</p>
       <p>Строки 55–60 обрабатывают случай неожиданного завершения потомка. Этого не должно происходить, поскольку обработчику сигнала передается специфическая для определенного порожденного процесса информация.</p>
       <p>Строки 61–66 представляют для нас интерес: возвращаемое значение для изменений состояния равно 0. <code>manage()</code> имеет дело с деталями (строка 66).</p>
       <p>Строки 67–69 обрабатывают прерывания, а строки 70–75 распоряжаются ошибками</p>
       <p><code>80 /* child --- что сделать в порожденном процессе */</code></p>
       <p><code>81</code></p>
       <p><code>82 void child(void)</code></p>
       <p><code>83 {</code></p>
       <p><code>84  raise(SIGCONT); /* должен быть проигнорирован */</code></p>
       <p><code>85  raise(SIGSTOP); /* заснуть, родитель снова разбудит */</code></p>
       <p><code>86  printf("\t---&gt; child restarted &lt;---\n");</code></p>
       <p><code>87  exit(42); /* нормальное завершение, дать возможность родителю получить значение */</code></p>
       <p><code>88 }</code></p>
       <p>Функция <code>child()</code> обрабатывает поведение порожденного процесса, предпринимая действия для уведомления родителя<a l:href="#n113" type="note">[113]</a>. Строка 84 посылает <code>SIGCONT</code>, что может вызвать получение родителем события <code>CLD_CONTINUED</code>. Строка 85 посылает <code>SIGSTOP</code>, который останавливает процесс (сигнал не может быть перехвачен) и вызывает для родителя событие <code>CLD_STOPPED</code>. Когда родитель возобновляет порожденный процесс, последний выводит сообщение, что он снова активен, а затем завершается с известным статусом завершения.</p>
       <p><code>90  /* main --- установка относящихся к порожденному процессу сведений</code></p>
       <p><code>       и сигналов, создание порожденного процесса */</code></p>
       <p><code>91</code></p>
       <p><code>92  int main(int argc, char **argv)</code></p>
       <p><code>93  {</code></p>
       <p><code>94   pid_t kid;</code></p>
       <p><code>95   struct sigaction sa;</code></p>
       <p><code>96   sigset_t childset, emptyset;</code></p>
       <p><code>97</code></p>
       <p><code>98   sigemptyset(&amp;emptyset);</code></p>
       <p><code>99</code></p>
       <p><code>100  sa.sa_flags = SA_SIGINFO;</code></p>
       <p><code>101  sa.sa_sigaction = childhandler;</code></p>
       <p><code>102  sigfillset(&amp;sa.sa_mask); /* при вызове обработчика все заблокировать */</code></p>
       <p><code>103  sigaction(SIGCHLD, &amp;sa, NULL);</code></p>
       <p><code>104</code></p>
       <p><code>105  sigemptyset(&amp;childset);</code></p>
       <p><code>106  sigaddset(&amp;childset, SIGCHLD);</code></p>
       <p><code>107</code></p>
       <p><code>108  sigprocmask(SIG_SETMASK, &amp;childset, NULL); /* блокировать его в коде main */</code></p>
       <p><code>109</code></p>
       <p><code>110  if ((kid = fork()) == 0)</code></p>
       <p><code>111   child();</code></p>
       <p><code>112</code></p>
       <p><code>113  /* здесь выполняется родитель */</code></p>
       <p><code>114  for (;;) {</code></p>
       <p><code>115   printf("waiting for signals\n");</code></p>
       <p><code>116   sigsuspend(&amp;emptyset);</code></p>
       <p><code>117  }</code></p>
       <p><code>118</code></p>
       <p><code>119  return 0;</code></p>
       <p><code>120 }</code></p>
       <p>Программа <code>main()</code> все устанавливает. Строки 100–103 помещают на место обработчик. Строка 100 устанавливает флаг <code>SA_SIGINFO</code> таким образом, что используется обработчик с тремя аргументами. Строки 105–108 блокируют <code>SIGCHLD</code>.</p>
       <p>Строка 110 создает порожденный процесс. Строки 113–117 продолжаются в родителе, используя для ожидания входящих сигналов <code>sigsuspend()</code>.</p>
       <p><code>123 /* manage --- разрешение различных событий, которые могут случиться с потомком */</code></p>
       <p><code>124</code></p>
       <p><code>125 void manage(siginfo_t *si)</code></p>
       <p><code>126 {</code></p>
       <p><code>127  char buf[100];</code></p>
       <p><code>128</code></p>
       <p><code>129  switch (si-&gt;si_code) {</code></p>
       <p><code>130  case CLD_STOPPED:</code></p>
       <p><code>131   write(1, "\tchild stopped, restarting\n", 27);</code></p>
       <p><code>132   kill(si-&gt;si_pid, SIGCONT);</code></p>
       <p><code>133   break;</code></p>
       <p><code>134</code></p>
       <p><code>135  case CLD_CONTINUED: /* not sent on Linux */</code></p>
       <p><code>136   write(1, "\tchild continued\n", 17);</code></p>
       <p><code>137   break;</code></p>
       <p><code>138</code></p>
       <p><code>139  case CLD_EXITED:</code></p>
       <p><code>140   strcpy(buf, "\tchild exited with status ");</code></p>
       <p><code>141   strcat(buf, format_num(si-&gt;si_status));</code></p>
       <p><code>142   strcat(buf, "\n");</code></p>
       <p><code>143   write(1, buf, strlen(buf));</code></p>
       <p><code>144   exit(0); /* we're done */</code></p>
       <p><code>145   break;</code></p>
       <p><code>146</code></p>
       <p><code>147  case CLD_DUMPED:</code></p>
       <p><code>148   write(1, "\tchild dumped\n", 14);</code></p>
       <p><code>149   break;</code></p>
       <p><code>150</code></p>
       <p><code>151  case CLD_KILLED:</code></p>
       <p><code>152   write(1, " \tchild killed\n", 14);</code></p>
       <p><code>153   break;</code></p>
       <p><code>154</code></p>
       <p><code>155  case CLD_TRAPPED:</code></p>
       <p><code>156   write(1, "\tchild trapped\n", 15);</code></p>
       <p><code>157   break;</code></p>
       <p><code>158  }</code></p>
       <p><code>159 }</code></p>
       <p>Посредством функции <code>manage()</code> родитель обрабатывает изменение состояния в порожденном процессе, <code>manage()</code> вызывается, когда изменяется состояние и когда порожденный процесс завершился.</p>
       <p>Строки 130–133 обрабатывают случай, когда потомок остановился; родитель возобновляет его, посылая <code>SIGCONT</code>.</p>
       <p>Строки 135–137 выводят уведомление о возобновлении потомка. Это событие на системах GNU/Linux не происходит, и стандарт POSIX использует в этом случае невыразительный язык, просто говоря, что это событие <emphasis>может</emphasis> появиться, а не <emphasis>появится</emphasis>.</p>
       <p>Строки 139–145 обрабатывают случай, когда порожденный процесс завершается, выводя статус завершения. Для этой программы родитель также все сделал, поэтому код завершается, хотя в более крупной программе это не то действие, которое должно быть сделано.</p>
       <p>Другие случаи более специализированные. В случае события <code>CLD_KILLED</code> для получения дополнительных сведений было бы полезным значение <code>status</code>, заполненной функцией <code>waitpid()</code>.</p>
       <p>Вот что происходит при запуске:</p>
       <p><code>$ <strong>ch10-status</strong> /* Запуск программы */</code></p>
       <p><code>waiting for signals</code></p>
       <p><code>Entered childhandler /* Вход в обработчик сигнала */</code></p>
       <p><code>  pid 24279 changed status</code></p>
       <p><code>  child stopped, restarting /* Обработчик действует */</code></p>
       <p><code>Exited childhandler</code></p>
       <p><code>waiting for signals</code></p>
       <p><code>  ---&gt; child restarted &lt;--- /* Из потомка */</code></p>
       <p><code>Entered childhandler</code></p>
       <p><code>  reaped process 24279 /* Обработчик родителя опрашивает потомка */</code></p>
       <p><code>  child exited with status 42</code></p>
       <p>К сожалению, поскольку нет способа гарантировать доставку по одному <code>SIGCHLD</code> на каждый процесс, ваша программа должна быть готова восстановить несколько потомков за один проход.</p>
      </section>
     </section>
    </section>
    <section>
     <title>
      <p>10.9. Сигналы, передающиеся через <code>fork()</code> и <code>exec()</code></p>
     </title>
     <p>Когда программа вызывает <code>fork()</code>, ситуация с сигналами в порожденном процессе почти идентична ситуации в родительском процессе. Установленные обработчики остаются на месте, заблокированные сигналы остаются заблокированными и т.д. Однако, любые ожидающие в родителе сигналы в потомке сбрасываются, включая установленный с помощью <code>alarm()</code> временной интервал. Это просто, и это имеет смысл.</p>
     <p>Когда процесс вызывает одну из функций <code>exec()</code>, положение в новой программе следующее:</p>
     <p>• Сигналы с установленным действием по умолчанию остаются с этим действием по умолчанию.</p>
     <p>• Все перехваченные сигналы сбрасываются в состояние с действием по умолчанию.</p>
     <p>• Сигналы, которые игнорируются, продолжают игнорироваться. Особым случаем является <code>SIGCHLD</code>. Если <code>SIGCHLD</code> до вызова <code>exec()</code> игнорировался, он может игнорироваться также и после вызова. В качестве альтернативы для него может быть восстановлено действие по умолчанию. То, что происходит на самом деле, стандартом POSIX намеренно не определяется. (Справочные страницы GNU/Linux не определяют, что делает Linux, и поскольку POSIX оставляет это не определенным, любой код, который вы пишете для использования <code>SIGCHLD</code>, должен быть подготовлен для обработки любого случая.)</p>
     <p>• Сигналы, заблокированные до вызова <code>exec()</code>, остаются заблокированными и после вызова. Другими словами, новая программа наследует маску сигналов существующего процесса.</p>
     <p>• Любые ожидающие сигналы (те, которые появились, но были заблокированы) сбрасываются. Новая программа не может их получить.</p>
     <p>• Временной интервал, остающийся для <code>alarm()</code>, сохраняется на своем месте. (Другими словами, если процесс устанавливает <code>alarm</code>, а затем непосредственно вызывает <code>exec()</code>, новый образ в конечном счете получит <code>SIGALARM</code>. Если он сначала вызывает <code>fork()</code>, родитель сохраняет установки <code>alarm</code>, тогда как потомок, вызывающий <code>exec()</code>, не сохраняет.</p>
     <cite>
      <p><strong>ЗАМЕЧАНИЕ</strong>. Многие, если не все. программы предполагают, что сигналы инициализированы действиями по умолчанию и что заблокированных сигналов нет. Таким образом, особенно если не вы писали программу, запускаемую с помощью <code>exec()</code>, можно разблокировать перед вызовам <code>exec()</code> все сигналы</p>
     </cite>
    </section>
    <section>
     <title>
      <p>10.10. Резюме</p>
     </title>
     <epigraph>
      <p>«Наша история до настоящего времени, эпизод III»</p>
      <text-author>- Арнольд Роббинс (Arnold Robbins) -</text-author>
     </epigraph>
     <p>• Интерфейсы обработки сигналов развились от простых, но подверженных состояниям гонок, до сложных, но надежных. К сожалению, множественность интерфейсов затрудняет их изучение по сравнению с другими API Linux/Unix.</p>
     <p>• У каждого сигнала есть связанное с ним действие. Действие может быть одним из следующих: игнорирование сигнала; выполнение действия системы по умолчанию или вызов предоставленного пользователем обработчика. Действие системы по умолчанию, в свою очередь, является одним из следующих: игнорирование сигнала, завершение процесса; завершение процесса с созданием его образа; остановка процесса или возобновление процесса, если он остановлен.</p>
     <p>• <code>signal()</code> и <code>raise()</code> стандартизованы ISO С. <code>signal()</code> управляет действиями для определенных сигналов; <code>raise()</code> посылает сигнал текущему процессу. Остаются ли обработчики сигналов установленными после вызова или сбрасываются для действия по умолчанию, зависит от реализации, <code>signal()</code> и <code>raise()</code> являются простейшими интерфейсами, для многих приложений их достаточно.</p>
     <p>• POSIX определяет функцию <code>bsd_signal()</code>, которая подобна <code>signal()</code>, но гарантирует, что обработчик остается установленным.</p>
     <p>• Действия, происходящие после возвращения из обработчика, варьируют в зависимости от системы. Традиционные системы (V7, Solaris, возможно, и другие) восстанавливают действие сигнала по умолчанию. На этих системах прерванный системный вызов возвращает -1, устанавливая в <code>errno</code> значение <code>EINTR</code>. Системы BSD оставляют обработчик установленным и возвращают -1 с <code>errno</code>, содержащим <code>EINTR</code>, лишь в случае, когда не было перемещения данных; в противном случае, системный вызов запускается повторно.</p>
     <p>• GNU/Linux придерживается POSIX, который похож, но не идентичен с BSD. Если не было перемещения данных, системный вызов возвращает -1/<code>EINTR</code>. В противном случае он возвращает объем перемещенных данных. Поведение BSD «всегда повторный запуск» доступно через интерфейс <code>sigaction()</code>, но он не является действием по умолчанию.</p>
     <p>• Обработчики сигналов, используемые с <code>signal()</code>, подвержены состояниям гонок. Внутри обработчиков сигналов должны использоваться исключительно переменные типа <code>volatile sig_atomic_t</code>. (В целях упрощения в некоторых из наших примеров мы не всегда следовали этому правилу.) Таким же образом, для вызова из обработчика сигналов безопасными являются лишь функции из табл. 10.2.</p>
     <p>• Первоначальной попыткой создания надежных сигналов был API сигналов System V Release 3 (скопированный из BSD 4.0). Не используйте его в новом коде.</p>
     <p>• POSIX API содержит множество компонентов:</p>
     <p>  • маску сигналов процесса, перечисляющую текущие заблокированные сигналы;</p>
     <p>  • тип <code>sigset_t</code> для представления масок сигналов, и функции <code>sigfillset()</code>, <code>sigemptyset()</code>, <code>sigaddset()</code>, <code>sigdelset()</code> и <code>sigismember()</code> для работы с ними;</p>
     <p>  • функцию <code>sigprocmask()</code> для установки и получения маски сигналов процесса,</p>
     <p>  • функцию <code>sigpending()</code> для получения набора ожидающих сигналов;</p>
     <p>  • API <code>sigaction()</code> и <code>struct sigaction</code> во всем их великолепии.</p>
     <p>Все эти возможности вместе используют блокирование сигналов и маску сигналов процесса для предоставления надежных сигналов. Более того, через различные флаги можно получить повторно запускаемые системные вызовы и более подходящие обработчики сигналов, которые получают большую информацию о причине, вызвавшей определенный сигнал (структура <code>siginfo_t</code>).</p>
     <p>• Механизмами POSIX для посылки сигналов являются <code>kill()</code> и <code>killpg()</code>. Они отличаются от <code>raise()</code> в двух отношениях: (1) одни процесс может послать сигнал другому процессу или целой группе процессов (конечно, с проверкой прав доступа), и (2) посылка сигнала 0 ничего не посылает, но осуществляет проверку. Таким образом, эти функции предоставляют способ проверки наличия определенного процесса или группы процессов и возможность посылки ему (им) сигнала.</p>
     <p>• Сигналы могут использоваться в качестве механизма IPC, хотя такой способ является плохим способом структурирования приложения, подверженным состояниям гонок. Если кто-то держит приставленным к вашей голове ружье, чтобы заставить вас работать таким способом, для правильной работы используйте тщательное блокирование сигналов и интерфейс <code>sigaction()</code>.</p>
     <p>• <code>SIGALARM</code> и системный вызов <code>alarm()</code> предоставляют низкоуровневый механизм для уведомления о прошествии определенного числа секунд, <code>pause()</code> приостанавливает процесс, пока не появятся какие-нибудь сигналы, <code>sleep()</code> использует их для помещения процесса в спящее состояние на заданный период времени: <code>sleep()</code> и <code>alarm()</code> не должны использоваться вместе. Сама <code>pause()</code> создает состояние гонки; вместо этого нужно использовать блокирование сигналов и <code>sigsuspend()</code>.</p>
     <p>• Сигналы управления заданиями реализуют управление заданиями для оболочки. Большую часть времени следует оставлять их с установленными действиями по умолчанию, но полезно понимать, что иногда имеет смысл их перехватывать.</p>
     <p>• Перехват <code>SIGCHLD</code> позволяет родителю узнать, что делает порожденный им процесс. Использование '<code>signal(SIGCHLD, SIG_IGN)</code>' (или <code>sigaction()</code> с <code>SA_NOCLDWAIT</code>) вообще игнорирует потомков. Использование <code>sigaction()</code> с <code>SA_NOCLDSTOP</code> предоставляет уведомления лишь о завершении. В последнем случае, независимо от того, заблокирован <code>SIGCHLD</code> или нет, обработчики сигналов для <code>SIGCHLD</code> должны быть готовы немедленно обработать несколько потомков. Наконец, использование <code>sigaction()</code> без <code>SA_NOCLDSTOP</code> с обработчиком сигналов с тремя аргументами дает вам причину получения сигнала.</p>
     <p>• После <code>fork()</code> положение сигналов в порожденном процессе остается тем же самым, за исключением сброса ожидающих сигналов и установленных интервалов таймера. После <code>exec()</code> положение несколько более сложно — в сущности, все, что может быть оставлено, остается; для всего остального восстанавливаются значения по умолчанию.</p>
    </section>
    <section>
     <title>
      <p>Упражнения</p>
     </title>
     <p>1. Реализуйте <code>bsd_signal()</code> с использованием <code>sigaction()</code>.</p>
     <p>2. Если у вас не установлен GNU/Linux, запустите на своей системе <code>ch10-catchint</code>. Является ли ваша система традиционной или BSD?</p>
     <p>3. Реализуйте функции System V Release 3 <code>sighold()</code>, <code>sigrelse()</code>, <code>sigignore()</code>, <code>sigpause()</code> и <code>sigset()</code>, использовав <code>sigaction()</code> и другие подходящие функции из POSIX API.</p>
     <p>4. Потренируйте свои навыки в жонглировании битами. В предположении, что сигнал 0 отсутствует и что имеется не более 31 сигналов, предусмотрите <code>typedef</code> для <code>sigset_t</code> и напишите <code>sigemptyset()</code>, <code>sigfillset()</code>, <code>sigaddset()</code>, <code>sigdelset()</code> и <code>sigismember()</code>.</p>
     <p>5. Еще немного потренируйте свои навыки жонглирования битами. Повторите предыдущее упражнение, на этот раз предположив, что наибольшим сигналом является 42.</p>
     <p>6. Теперь, когда вы сделали предыдущие два упражнения, найдите <code>sigemptyset()</code> и др. в своем заголовочном файле <code>&lt;signal.h&gt;</code>. (Может потребоваться поискать их; они могут быть в <code>#include</code> файлах, указанных в <code>&lt;signal.h&gt;</code>.) Являются ли они макросами или функциями?</p>
     <p>7. В разделе 10.7 «Сигналы для межпроцессного взаимодействия» мы упомянули, что код изделия должен работать с начальной маской сигналов процесса, добавляя и удаляя блокируемые сигналы в вызове <code>sigsuspend()</code>. Перепишите пример, используя для этого соответствующие вызовы.</p>
     <p>8. Напишите свою собственную версию команды <code>kill</code>. Интерфейс должен быть таким:</p>
     <p><code>kill [-s <emphasis>имя-сигнала</emphasis>] <emphasis>pid</emphasis> ...</code></p>
     <p>Если сигнал не указан, программа должна посылать <code>SIGTERM</code>.</p>
     <p>9. Как вы думаете, почему в современных оболочках, таких, как Bash и ksh93, <code>kill</code> является встроенной командой?</p>
     <p>10. (Трудное) Реализуйте <code>sleep()</code>, используя <code>alarm()</code>, <code>signal()</code> и <code>pause()</code>. Что случится, если обработчик сигнала для <code>SIGALRM</code> уже установлен?</p>
     <p>11. Поэкспериментируйте с <code>ch10-reap.c</code>, изменяя интервал времени, на который засыпает каждый потомок, и организуя достаточное число вызовов <code>sigsuspend()</code> для сбора сведений о всех потомках.</p>
     <p>12. Попробуйте заставить <code>ch10-reap2.c</code> испортить информацию в <code>kids</code>, <code>nkids</code> и <code>kidsleft</code>. Теперь добавьте вокруг критического раздела блокирование/разблокирование и посмотрите, есть ли разница.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 11</p>
     <p>Права доступа и ID пользователей и групп</p>
    </title>
    <section>
     <p>Linux, вслед за Unix, является <emphasis>многопользовательской системой</emphasis>. В отличие от большинства операционных систем для персональных компьютеров,<a l:href="#n114" type="note">[114]</a> в которых имеется лишь один пользователь и в которых, кто бы ни находился перед компьютером, он имеет полный контроль, Linux и Unix различают файлы и процессы по владельцам и группам, которым они принадлежат. В данной главе мы исследуем проверку прав доступа и рассмотрим API для получения и установки идентификаторов владельцев и групп.</p>
    </section>
    <section>
     <title>
      <p>11.1. Проверка прав доступа</p>
     </title>
     <section>
      <p>Как мы видели в разделе 5.4.2 «Получение информации о файлах», файловая система хранит идентификаторы владельца и группы файла в виде числовых значений; это типы <code>uid_t</code> и <code>gid_t</code> соответственно. Для краткости мы используем для «идентификатора владельца (пользователя)» и «идентификатора группы» сокращения UID и GID соответственно.</p>
      <p>У каждого процесса есть несколько связанных с ним идентификаторов пользователя и группы. Для проверки прав доступа в качестве упрощения используется один определенный UID и GID; когда UID процесса совпадает с UID файла, биты прав доступа пользователя файла диктуют, что может сделать процесс с файлом. Если они не совпадают, система проверяет GID процесса с GID файла; при совпадении используются права доступа группы; в противном случае, используются права доступа для «остальных».</p>
      <p>Помимо файлов, UID определяет, как один процесс может повлиять на другой путем посылки сигналов. Сигналы описаны в главе 10 «Сигналы».</p>
      <p>Наконец, особым случаем является суперпользователь, <code>root</code>. <code>root</code> идентифицируется по UID, равным 0. Когда у процесса UID равен 0, ядро позволяет ему делать все, что он захочет: читать, записывать или удалять файлы, посылать сигналы произвольным процессам и т.д. (POSIX в этом отношении более непонятный, ссылаясь на процессы с «соответствующими привилегиями». Этот язык, в свою очередь, просочился в справочные страницы GNU/Linux и справочное руководство GLIBC online Info manual. Некоторые операционные системы действительно разделяют привилегии пользователей, и Linux также движется в этом направлении. Тем не менее, в настоящее время «соответствующие привилегии» означает просто процессы с UID, равным 0.)</p>
     </section>
     <section>
      <title>
       <p>11.1.1. Действительные и эффективные ID</p>
      </title>
      <p>Номера UID и GID подобны персональным удостоверениям личности. Иногда вам может понадобиться более одного удостоверяющего документа. Например, у вас могут быть водительские права или правительственное удостоверение личности<a l:href="#n115" type="note">[115]</a>. Вдобавок, ваш университет или компания могли выдать вам свои удостоверения личности. То же самое относится и к процессам; они имеют при себе множество следующих номеров UID и GID:</p>
      <p><emphasis>Действительный ID пользователя</emphasis></p>
      <p>UID пользователя, породившего процесс.</p>
      <p><emphasis>Эффективный ID пользователя</emphasis></p>
      <p>UID, использующийся при большинстве проверок прав доступа. В большинстве случаев эффективный и действительный UID являются одним и тем же. Эффективный UID может отличаться от действительного при запуске, если установлен бит <emphasis>setuid</emphasis> файла исполняемой программы и файл не принадлежит пользователю, запускающему программу. (Вскоре будут дополнительные сведения.)</p>
      <p><emphasis>Сохраненный set-user ID</emphasis></p>
      <p>Первоначальный эффективный UID при запуске программы (после выполнения exec.) Имеет значение при проверке прав доступа, когда процессу нужно менять действительный и эффективный UID в ходе работы. Эта концепция пришла из System V.</p>
      <p><emphasis>Действительный ID группы</emphasis></p>
      <p>GID пользователя, создавшего процесс, аналогично действительному UID.</p>
      <p><emphasis>Эффективный ID группы</emphasis></p>
      <p>GID, использующийся для проверки прав доступа, аналогично эффективному GID.</p>
      <p><emphasis>Сохраненный set-group ID</emphasis></p>
      <p>Первоначальный эффективный GID при запуске программы, аналогично сохраненному set-user ID.</p>
      <p><emphasis>Набор дополнительных групп</emphasis></p>
      <p>4.2 BSD ввело понятие <emphasis>набора групп</emphasis>. Помимо действительного и эффективного GID. у каждого процесса есть некоторый набор дополнительных групп, которым он принадлежит <emphasis>в одно и то же время</emphasis>. Таким образом, когда проверка прав доступа осуществляется для группы файла, ядро проверяет не только эффективный GID, но также и все GID в наборе групп.</p>
      <p>Каждый процесс может получить все из этих значений. Обычный (не принадлежащий суперпользователю) процесс может переключать свои действительные и эффективные ID пользователя и группы. Процесс <code>root</code> (с эффективным UID, равным 0) может также устанавливать значения таким образом, как ему нужно (хотя это может оказаться односторонней операцией)</p>
     </section>
     <section>
      <title>
       <p>11.1.2. Биты Setuid и Setgid</p>
      </title>
      <p>Биты <emphasis>setuid</emphasis> и <emphasis>setgid</emphasis><a l:href="#n116" type="note">[116]</a> в правах доступа к файлу заставляют процесс принять эффективный UID или GID, который отличается от действительного. Эти биты накладываются на файл вручную с помощью команды <code>chmod</code>:</p>
      <p><code>$ <strong>chmod u+s myprogram</strong> /* Добавить бит setuid */</code></p>
      <p><code>$ <strong>chmod g+s myprogram</strong> /* Добавить бит setgid */</code></p>
      <p><code>$ <strong>ls -l myprogram</strong></code></p>
      <p><code>-rwsr-sr-x 1 arnold devel 4573 Oct 9 18:17 myprogram</code></p>
      <p>Наличие символа s в месте, где обычно находится символ x, указывает на присутствие битов setuid/setgid.</p>
      <p>Как упоминалось в разделе 8.2.1 «Использование опций монтирования», опция <code>nosuid</code> команды mount для файловой системы предотвращает обращение ядра к битам setuid и setgid. Это мера безопасности; например, пользователь с домашней системой GNU/Linux мог бы вручную изготовить гибкий диск с копией исполняемого файла оболочки с setuid, устанавливающей в <code>root</code>. Но если система GNU/Linux в офисе или лаборатории монтирует файловые системы с гибкими дисками с опцией <code>nosuid</code>, запуск этой оболочки не предоставит доступа с правами <code>root</code><a l:href="#n117" type="note">[117]</a>.</p>
      <p>Каноническим (и возможно, злоупотребляемым) примером программы с setuid является игровая программа. Представьте, что вы написали по-настоящему крутую игру и хотите позволить пользователям системы играть в нее. Игра содержит файл счета, в котором перечислены высшие достижения.</p>
      <p>Если вы не являетесь системным администратором, вы не можете создать отдельную группу только для тех пользователей, которым разрешено играть в игру и тем самым записывать в файл счета. Но если вы сделаете файл доступным для записи любому, чтобы каждый смог поиграть в игру, тогда каждый сможет также сжульничать и поместить наверх любое имя.</p>
      <p>Однако, заставив программу устанавливать setuid на вас, пользователи, запускающие игру, получат ваш UID в качестве своего эффективного UID. Игровая программа сможет при этом открывать и обновлять файл счета по мере необходимости, но произвольные пользователи не смогут прийти и отредактировать его. (Вы подвергаете себя также большинству опасностей при программировании setuid; например, если в игровой программе есть дыра, которую можно использовать для запуска оболочки, действующей от вашего имени, <emphasis>все</emphasis> ваши файлы оказываются доступными для удаления или изменения. Это действительно устрашающая мысль.)</p>
      <p>Та же логика применяется к программам setgid, хотя на практике программы с setgid используются гораздо реже, чем с setuid (Это также плохо; многие вещи, которые делаются программами с setuid <code>root</code>, легко могут быть сделаны программами с setgid или программами, которые вместо этого устанавливают setuid на обычного пользователя<a l:href="#n118" type="note">[118]</a>).</p>
     </section>
    </section>
    <section>
     <title>
      <p>11.2. Получение ID пользователя и группы</p>
     </title>
     <p>Получение от системы сведений о UID и GID просто. Функции следующие:</p>
     <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
     <empty-line/>
     <p><code>uid_t getuid(void); /* Действительный и эффективный UID */</code></p>
     <p><code>uid_t geteuid(void);</code></p>
     <p><code>gid_t getgid(void); /* Действительный и эффективный GID */</code></p>
     <p><code>gid_t getegid(void);</code></p>
     <p><code>int getgroups(int size, gid_t list[]); /* Список дополнительных групп*/</code></p>
     <p>Функции:</p>
     <p><code>uid_t getuid(void)</code></p>
     <p>Возвращает действительный UID.</p>
     <p><code>uid_t geteuid(void)</code></p>
     <p>Возвращает эффективный UID.</p>
     <p><code>gid_t getgid(void)</code></p>
     <p>Возвращает действительный GID.</p>
     <p><code>gid_t getegid(void)</code></p>
     <p>Возвращает эффективный GID.</p>
     <p><code>int getgroups(int size, gid_t list[])</code></p>
     <p>Заполняет до <code>size</code> элементов массива <code>list</code> из набора дополнительных групп процесса. Возвращаемое значение является числом заполненных элементов или -1 при ошибке. Включается ли в набор также эффективный GID, зависит от реализации. На системах, совместимых с POSIX, можно передать в size нулевое значение; в этом случае <code>getgroups()</code> возвращает число групп в наборе групп процесса. Затем можно использовать это значение для динамического выделения массива достаточного размера. На не-POSIX системах константа <code>NGROUPS_MAX</code> определяет максимально допустимый размер для массива <code>list</code>. Эту константу можно найти в современных системах в <code>&lt;limits.h&gt;</code>, а в старых системах в <code>&lt;sys/param.h&gt;</code>. Вскоре мы представим пример.</p>
     <p>Возможно, вы заметили, что для получения сохраненных значений set-user ID или set-group ID нет вызовов. Это просто первоначальные значения эффективных UID и GID. Таким образом, для получения шести значений в начале программы вы можете использовать код наподобие этого:</p>
     <p><code>uid_t ruid, euid, saved_uid;</code></p>
     <p><code>gid_t rgid, egid, saved_gid;</code></p>
     <empty-line/>
     <p><code>int main(int argc, char **argv) {</code></p>
     <p><code> ruid = getuid();</code></p>
     <p><code> euid = saved_uid = geteuid();</code></p>
     <p><code> rgid = getgid();</code></p>
     <p><code> egid = saved_gid = getegid();</code></p>
     <p><code> /* ...оставшаяся программа... */</code></p>
     <p><code>}</code></p>
     <p>Вот пример получения набора групп. В качестве расширения <code>gawk</code> предоставляет доступ на уровне <code>awk</code> к значениям действительных и эффективных UID и GID и дополнительному набору групп. Для этого он должен получить набор групп. Следующая функция из <code>main.c</code> в дистрибутиве <code>gawk</code> 3.1.3:</p>
     <p><code>1080 /* init_groupset --- инициализация набора групп */</code></p>
     <p><code>1081</code></p>
     <p><code>1082 static void</code></p>
     <p><code>1083 init_groupset()</code></p>
     <p><code>1084 {</code></p>
     <p><code>1085 #if defined(HAVE_GETGROUPS) &amp;&amp; defined(NGROUPS_MAX) &amp;&amp; NGROUPS_MAX &gt; 0</code></p>
     <p><code>1086 #ifdef GETGROUPS_NOT_STANDARD</code></p>
     <p><code>1087  /* Для систем, которые не отвечают стандарту, используйте старый способ */</code></p>
     <p><code>1088  ngroups = NGROUPS_MAX;</code></p>
     <p><code>1089 #else</code></p>
     <p><code>1090  /*</code></p>
     <p><code>1091   * Если оба аргумента при вызове равны 0, возвращаемое</code></p>
     <p><code>1092   * значение является общим числом групп.</code></p>
     <p><code>1093   */</code></p>
     <p><code>1094  ngroups = getgroups(0, NULL);</code></p>
     <p><code>1095 #endif</code></p>
     <p><code>1096  if (ngroups == -1)</code></p>
     <p><code>1097   fatal(_("could not find groups: %s"), strerror(errno));</code></p>
     <p><code>1098  else if (ngroups == 0)</code></p>
     <p><code>1099   return;</code></p>
     <p><code>1100</code></p>
     <p><code>1101  /* заполнить группы */</code></p>
     <p><code>1102  emalloc(groupset, GETGROUPS_T*, ngroups * sizeof(GETGROUPS_T), "init_groupset");</code></p>
     <p><code>1103</code></p>
     <p><code>1104  ngroups = getgroups(ngroups, groupset);</code></p>
     <p><code>1105  if (ngroups == -1)</code></p>
     <p><code>1106   fatal(_("could not find groups: %s"), strerror(errno));</code></p>
     <p><code>1107 #endif</code></p>
     <p><code>1108 }</code></p>
     <p>Переменные <code>ngroups</code> и <code>groupset</code> глобальные; их объявления не показаны. Макрос <code>GETGROUPS_T</code> (строка 1102) является типом для использования со вторым аргументом: на системе POSIX это <code>gid_t</code>, в противном случае <code>int</code>.</p>
     <p>Строки 1085 и 1107 заключают в скобки все тело функции; на древних системах, в которых вообще нет наборов групп, тело функции пустое.</p>
     <p>Строки 1086–1088 обрабатывают не-POSIX системы; до компиляции программы механизмом конфигурации определяется <code>GETGROUPS_NOT_STANDARD</code>. В этом случае код использует <code>NGROUPS_MAX</code>, как описано выше. (Даже а 2004 г. такие системы все еще существуют и используются; хотя, слава богу, число их уменьшается.)</p>
     <p>Строки 1089–1094 для систем POSIX, причем нулевой параметр <code>size</code> используется для получения числа групп.</p>
     <p>Строки 1096–1099 осуществляют проверку ошибок. Если возвращаемое значение 0, дополнительных групп нет, поэтому <code>init_groupset()</code> просто сразу возвращается.</p>
     <p>Наконец, строка 1102 для выделения массива достаточного размера использует <code>malloc()</code> (посредством проверяющего ошибки макроса-оболочки, см. раздел 3.2.1.8 «Пример: чтение строк произвольной длины»). Затем строка 1104 заполняет этот массив.</p>
    </section>
    <section>
     <title>
      <p>11.3. Проверка для действительного пользователя: <code>access()</code></p>
     </title>
     <p>В большинстве случаев значения эффективного и действительного UID и GID являются одними и теми же. Таким образом, не имеет значения, что проверка прав доступа к файлу осуществляется по эффективному ID, а не по действительному.</p>
     <p>Однако, при написании приложения с setuid или setgid вы можете иногда захотеть проверить, является ли операция, разрешенная для эффективных UID и GID, также разрешенной для <emphasis>действительных</emphasis> UID и GID. В этом заключается задача функции <code>access()</code>:</p>
     <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
     <empty-line/>
     <p><code>int access(const char *path, int amode);</code></p>
     <p>Аргумент <code>path</code> является путем к файлу для проверки действительных UID и GID. <code>amode</code> содержит объединение побитовым ИЛИ одного или нескольких из следующих значений:</p>
     <p><code>R_OK  </code>Действительный UID/GID разрешает чтение файла.</p>
     <p><code>W_OK  </code>Действительный UID/GID разрешает запись в файл.</p>
     <p><code>X_OK  </code>Действительный UID/GID разрешает исполнение файла или, в случае каталога, поиск в каталоге.</p>
     <p><code>F_OK  </code>Проверка существования файла.</p>
     <p>Проверяется каждый компонент в имени пути, а на некоторых реализациях при проверке для <code>root access()</code> может действовать, как если бы был установлен <code>X_OK</code>, даже если в правах доступа к файлу не установлены биты, разрешающие исполнение. (Странно, но верно: в этом случае предупрежденный вооружен.) В Linux нет такой проблемы.</p>
     <p>Если <code>path</code> является символической ссылкой, <code>access()</code> проверяет файл, на который указывает символическая ссылка.</p>
     <p>Возвращаемое значение равно 0, если операция для действительных UID и GID разрешена, и -1 в противном случае. Соответственно, если <code>access()</code> возвращает -1, программа с setuid может запретить доступ к файлу, с которым в противном случае эффективный UID/GID смог бы работать:</p>
     <p><code>if (access("/some/special/file", R_OK|W_OK) &lt; 0) {</code></p>
     <p><code> fprintf(stderr, "Sorry: /some/special/file: %s\n",</code></p>
     <p><code>  strerror(errno));</code></p>
     <p><code> exit(1);</code></p>
     <p><code>}</code></p>
     <p>По крайней мере для серии ядра Linux 2.4, когда тест X_OK применяется к файловой системе, смонтированной с опцией <code>noexec</code> (см. раздел 8.2.1 «Использование опций монтирования»), тест успешно проходится, если права доступа к файлу имеют разрешение на исполнение. Это верно, несмотря на то, что попытка выполнить файл завершилась бы неудачей.</p>
     <cite>
      <p><strong>ЗАМЕЧАНИЕ</strong>. Хотя использование <code>access()</code> перед открытием файла является обычной практикой, существует состояние гонки открываемый файл может быть сброшен при подкачке между проверкой функцией <code>access()</code> и вызовом <code>open()</code>. Необходимо осмотрительное программирование, такое, как проверка владельца и прав доступа с помощью <code>stat()</code> и <code>fstat()</code> до и после вызовов <code>access()</code> и <code>open()</code>.</p>
     </cite>
     <p>Например, программа <code>pathchk</code> проверяет действительность имен путей. GNU версия использует <code>access()</code> для проверки того, что компоненты каталога данного пути действительны. Из Coreutils <code>pathchk.c</code>:</p>
     <p><code>244 /* Возвращает 1, если PATH является годным к использованию</code></p>
     <p><code>245    каталогом, 0 если нет, 2 если он не существует. */</code></p>
     <p><code>246</code></p>
     <p><code>247 static int</code></p>
     <p><code>248 dir_ok(const char *path)</code></p>
     <p><code>249 {</code></p>
     <p><code>250  struct stat stats;</code></p>
     <p><code>251</code></p>
     <p><code>252  if (stat (path, &amp;stats)) /* Nonzero return = failure */</code></p>
     <p><code>253   return 2;</code></p>
     <p><code>254</code></p>
     <p><code>255  if (!S_ISDIR(stats.st_mode))</code></p>
     <p><code>256  {</code></p>
     <p><code>257   error(0, 0, _("'%s" is not a directory"), path);</code></p>
     <p><code>258   return 0;</code></p>
     <p><code>259  }</code></p>
     <p><code>260</code></p>
     <p><code>261  /* Используйте access для проверки прав доступа на поиск,</code></p>
     <p><code>262     поскольку при проверке битов прав доступа st_mode они могут</code></p>
     <p><code>263     потеряться новыми механизмами управления доступом. Конечно,</code></p>
     <p><code>264     доступ теряется, если вы используете setuid. */</code></p>
     <p><code>265  if (access (path, X_OK) != 0)</code></p>
     <p><code>266  {</code></p>
     <p><code>267   if (errno == EACCES)</code></p>
     <p><code>268    error (0, 0, _("directory '%s' is not searchable"), path);</code></p>
     <p><code>269   else</code></p>
     <p><code>270    error(0, errno, "%s", path);</code></p>
     <p><code>271   return 0;</code></p>
     <p><code>272  }</code></p>
     <p><code>273</code></p>
     <p><code>274  return 1;</code></p>
     <p><code>275 }</code></p>
     <p>Код прост. Строки 252–253 проверяют, существует ли файл. Если <code>stat()</code> завершится неудачей, файл не существует. Строки 255–259 удостоверяют, что файл в самом деле является каталогом.</p>
     <p>Комментарий в строках 261–264 объясняет использование <code>access()</code>. Проверки битов <code>st_mode</code> недостаточно: файл может находиться в файловой системе, которая смонтирована только для чтения, в удаленной файловой системе или в файловой системе, не принадлежащей Linux или Unix, или у файла могут быть атрибуты, предотвращающие доступ. Таким образом, лишь ядро может в действительности сказать, будет ли работать <code>access</code>. Строки 265–272 осуществляют проверку, выдавая сообщение об ошибке, определяемое значением <code>errno</code> (строки 267–270).</p>
    </section>
    <section>
     <title>
      <p>11.4. Проверка для эффективного пользователя: <code>euidaccess()</code> (GLIBC)</p>
     </title>
     <p>GLIBC предоставляет дополнительную функцию, которая работает подобно <code>access()</code>, но проверяет в соответствии с эффективными UID, GID и набором групп:</p>
     <p><code>#include &lt;unistd.h&gt; /* CLIBC */</code></p>
     <empty-line/>
     <p><code>int euidaccess(const char *path, int amode);</code></p>
     <p>Аргументы и возвращаемое значение имеют тот же смысл, как для <code>access()</code>. Когда равны эффективный и действительный UID и эффективный и действительный GID, <code>euidaccess()</code> вызывает для осуществления теста <code>access()</code>. Это имеет то преимущество, что ядро может проверить файловую систему только для чтения или другие условия, которые не отражаются в правах доступа и владении файлами.</p>
     <p>В противном случае <code>euidaccess()</code> сравнивает значения владельца и группы файла со значениями эффективных UID и GID и набора групп, используя соответствующие биты прав доступа. Этот тест основан на сведениях о файле от <code>stat()</code>.</p>
     <p>Если вы пишете переносимую программу, но предпочитаете использовать этот интерфейс, достаточно просто извлечь исходный файл из архива GLIBC и приспособить его для общего использования.</p>
    </section>
    <section>
     <title>
      <p>11.5. Установка дополнительных битов доступа для каталогов</p>
     </title>
     <section>
      <p>На современных системах setgid и «липкий» биты имеют особое значение при применении к каталогам.</p>
     </section>
     <section>
      <title>
       <p>11.5.1. Группа по умолчанию для новых файлов и каталогов</p>
      </title>
      <p>В оригинальной системе Unix, когда <code>open()</code> или <code>creat()</code> создавали новый файл, он получал эффективные UID и GID создавшего их процесса.</p>
      <p>V7, BSD вплоть до BSD 4.1 и System V вплоть до Release 3 все трактовали каталоги как файлы. Однако, с добавлением дополнительного набора групп в BSD 4.2 способ создания новых каталогов изменился: новые каталоги наследовали группу родительского каталога. Более того, новые файлы также наследовали ID группы родительского каталога, а <emphasis>не</emphasis> эффективный GID создающего процесса.</p>
      <p>Идея, лежащая в основе множества групп и каталогов, которые работают таким способом, была в усилении группового взаимодействия. У каждого проекта организации, использующего систему, была бы отдельная назначенная ему группа. Для каждой такой группы в группе этого проекта был бы каталог верхнего уровня, и все файлы проекта имели бы доступ на чтение и запись (а при необходимости и на исполнение). Вдобавок, новые файлы автоматически получают группу родительского каталога. Состоя одновременно в нескольких группах (наборе групп), пользователь мог бы как угодно перемещаться между проектами с помощью простой команды <code>cd</code>, а все файлы и каталоги сохраняли бы свою надлежащую группу.</p>
      <p>Что происходит на современных системах? Ну, это еще один из немногих случаев, когда можно поймать двух зайцев. SunOS 4.0 придумал механизм, который был включен в System V Release 4; сегодня он используется по крайней мере в Solaris и GNU/Linux. Эти системы придают биту setgid родительского каталога нового файла или каталога следующее значение:</p>
      <p><emphasis>Бит setgid родительского каталога сброшен</emphasis></p>
      <p>Новые файлы и каталоги получают эффективный GID создающего процесса.</p>
      <p><emphasis>Бит setgid родительского каталога установлен</emphasis></p>
      <p>Новые файлы и каталоги получают GID родительского каталога. Новые каталоги наследуют также установленный бит setgid.</p>
      <p>(До SunOS 4.0 бит setgid для каталогов не имел определенного значения.) Следующий сеанс показывает бит setgid в действии:</p>
      <p><code>$ <strong>cd /tmp</strong> /* Перейти в /tmp */</code></p>
      <p><code>$ <strong>ls -ld .</strong> /* Проверить его права доступа */</code></p>
      <p><code>drwxrwxrwt 8 root root 4096 Oct 16 17:40 .</code></p>
      <p><code>$ <strong>id</strong> /* Отметить текущие группы */</code></p>
      <p><code>uid=2076(arnold) gid=42(devel) groups=19(floppy),42(devel),2076(arnold)</code></p>
      <p><code>$ <strong>mkdir d1 ; ls -ld d1</strong> /* Создать новый каталог */</code></p>
      <p><code>drwxr-xr-x 2 arnold devel 4096 Oct 16 17:40 d1 /* Эффективный ID группы</code></p>
      <p><code>                                                  наследуется */</code></p>
      <p><code>$ <strong>chgrp arnold d1</strong> /* Сменить группу */</code></p>
      <p><code>$ <strong>chmod g+s d1</strong> /* Добавить бит setgid */</code></p>
      <p><code>$ <strong>ls -ld d1</strong> /* Проверить изменение */</code></p>
      <p><code>drwxr-sr-x 2 arnold arnold 4096 Oct 16 17:40 d1</code></p>
      <p><code>$ <strong>cd d1</strong> /* Перейти в него */</code></p>
      <p><code>$ <strong>echo this should have group arnold on it &gt; f1</strong> /* создать новый файл */</code></p>
      <p><code>$ <strong>ls -l f1</strong> /* Проверить права доступа */</code></p>
      <p><code>-rw-r--r-- 1 arnold arnold 36 Oct 16 17:41 f1</code></p>
      <p><code> /* Унаследовано от родителя */</code></p>
      <p><code>$ <strong>mkdir d2</strong> /* Создать каталог */</code></p>
      <p><code>$ <strong>ls -ld d2</strong> /* Проверить права доступа */</code></p>
      <p><code>drwxr-sr-x 2 arnold arnold 4096 Oct 16 17:51 d2</code></p>
      <p><code> /* Группа и setgid унаследованы */</code></p>
      <p>Файловые системы <code>ext2</code> и <code>ext3</code> для GNU/Linux работают указанным способом. Вдобавок они поддерживают специальные опции монтирования <code>grpid</code> и <code>bsdgroups</code>, которые делают «использование группы родительского каталога» семантикой по умолчанию. (Два имени означают одно и то же.) Другими словами, когда используются эти опции монтирования, в родительских каталогах не нужно устанавливать свои биты seigid.</p>
      <p>Противоположными опциями монтирования являются <code>nogrpid</code> и <code>sysvgroups</code>. Это поведение по умолчанию; однако, бит setgid. если он есть, все равно учитывается. (Здесь также оба имени означают одно и то же.)</p>
      <p>POSIX устанавливает, что новые файлы и каталоги наследуют либо эффективный GID создающего процесса, либо группу родительского каталога. Однако, реализации должны предусмотреть способ заставить новые каталоги наследовать группу родительского каталога. Более того, стандарт рекомендует, чтобы приложения не полагались на то или иное поведение, но в случаях, когда это имеет значение, использовали <code>chown()</code> для принудительного назначения желательного GID для группы нового файла или каталога.</p>
     </section>
     <section>
      <title>
       <p>11.5.2. Каталоги и «липкий» бит</p>
      </title>
      <epigraph>
       <p>«Шерман, установите машину времени для 1976 г.»</p>
       <text-author>- М-р Пибоди (Mr. Peabody) -</text-author>
      </epigraph>
      <p>«<emphasis>Липкий</emphasis>» бит ведет начало от версий Unix для PDP-11, он использовался с обычными исполняемыми файлами<a l:href="#n119" type="note">[119]</a>. Этот бит использовался с программами, которые предназначались для интенсивного использования, такими, как оболочка и редактор. Когда у программы был установлен этот бит, ядро хранило копию исполняемого кода программы на устройстве подкачки, из которого ее можно было быстро загрузить в память для повторного использования. (Загрузка из файловой системы занимает больше времени образ на устройстве подкачки хранился в смежных дисковых блоках, тогда как образ в файловой системе мог быть разбросан по всему диску). Исполняемые образы были «приклеены» к устройству подкачки, отсюда и название.</p>
      <p>Таким образом, даже если программа в настоящее время не использовалась, предполагалось, что она вскоре могла быть использована другим пользователем, поэтому она могла быть быстро загружена.</p>
      <p>В современных системах значительно более быстрые дисковое оборудование и память, чем в давнишней PDP-11. Они используют также методику, называемую <emphasis>подкачка по требованию</emphasis>, для загрузки в память лишь тех частей исполняемой программы, которые выполняются. Таким образом, сегодня «липкий» бит обычных исполняемых файлов не служит никаким целям и на самом деле ни на что не влияет.</p>
      <p>Однако, в разделе 1.1.2 «Каталоги и имена файлов» мы упомянули, что «липкий» бит в каталоге, запись в который в других отношениях разрешена, предотвращает удаление файлов из этого каталога и их переименование любым пользователем, кроме владельца файла или <code>root</code>. Вот пример:</p>
      <p><code>$ <strong>ls -ld /tmp</strong> /* Показать права доступа к /tmp */</code></p>
      <p><code>drwxrwxrwt 19 root root 4096 Oct 20 14:04 /tmp</code></p>
      <p><code>$ <strong>cd /tmp</strong> /* Перейти туда */</code></p>
      <p><code>$ <strong>echo this is my file &gt; arnolds-file</strong> /* Создать файл */</code></p>
      <p><code>$ <strong>ls -l arnolds-file</strong> /* Показать его права доступа */</code></p>
      <p><code>-rw-r--r-- 1 arnold devel 16 Oct 20 14:14 arnolds-file</code></p>
      <p><code>$ <strong>su - miriam</strong> /* Смена пользователя */</code></p>
      <p><code>Password:</code></p>
      <p><code>$ <strong>cd /tmp</strong> /* Перейти в /tmp */</code></p>
      <p><code>$ <strong>rm arnolds-file</strong> /* Попытка удаления файла */</code></p>
      <p><code>rm: remove write-protected regular file 'arnolds-file'? y</code></p>
      <p><code> /* rm предупреждает */</code></p>
      <p><code>rm: cannot remove 'arnolds-file': Operation not permitted</code></p>
      <p><code> /* Ядро запрещает удаление */</code></p>
      <p>Основным назначением этой особенности является как раз использование в таких каталогах, как <code>/tmp</code>, куда хотят помещать свои файлы множество пользователей. С одной стороны, каталог должен иметь права записи для всех, чтобы каждый мог создавать там свои файлы. С другой стороны, раз запись разрешена для всех, любой пользователь может удалять файлы всех остальных пользователей! «Липкий» бит каталога красиво решает эту проблему. Для добавления к файлу или каталогу «липкого» бита используйте '<code>chmod +t</code>':</p>
      <p><code>$ <strong>mkdir mytmp</strong> /* Создать каталог */</code></p>
      <p><code>$ <strong>chmod a+wxt mytmp</strong> /* Добавить права записи для всех и «липкий» бит */</code></p>
      <p><code>$ <strong>ls -ld mytmp</strong> /* Проверить результат */</code></p>
      <p><code>drwxrwxrwt 2 arnold devel 4096 Oct 20 14:23 mytmp</code></p>
      <p>В заключение, обратите внимание, что владелец каталога также может удалить файлы, даже если они не принадлежат ему.</p>
     </section>
    </section>
    <section>
     <title>
      <p>11.6. Установка действительных и эффективных ID</p>
     </title>
     <section>
      <p>Все становится интереснее, когда процессу приходится менять значения UID и GID. Установка набора групп проста. Изменение значений действительных и эффективных UID и GID сложнее.</p>
     </section>
     <section>
      <title>
       <p>11.6.1. Изменение набора групп</p>
      </title>
      <p>Функция <code>setgroups()</code> устанавливает новый набор групп:</p>
      <p><code>#include &lt;sys/types.h&gt; /* Common */</code></p>
      <p><code>#include &lt;unistd.h&gt;</code></p>
      <p><code>#include &lt;grp.h&gt;</code></p>
      <empty-line/>
      <p><code>int setgroups(size_t size, const gid_t *list);</code></p>
      <p>Параметр <code>size</code> указывает, сколько элементов в массиве <code>list</code>. Возвращаемое значение равно 0, если все было нормально, и -1 с установленным errno в противном случае.</p>
      <p>В отличие от функций для манипулирования значениями действительных и эффективных UID и GID, эту функцию может вызвать лишь процесс, действующий как <code>root</code>. Это один пример того, что POSIX называет <emphasis>привилегированной операцией</emphasis>; сама она как таковая не стандартизуется POSIX.</p>
      <p><code>setgroups()</code> используется любой программой, которая осуществляет регистрацию в системе, такой как <code>/bin/login</code> для регистрации в консоли и <code>/bin/sshd</code> для удаленной регистрации с помощью <code>ssh</code>.</p>
     </section>
     <section>
      <title>
       <p>11.6.2. Изменение действительного и эффективного ID</p>
      </title>
      <p>Работа с двумя различными ID пользователей представляет для программиста приложения проблему. Могут быть вещи, которые программе нужно сделать, работая с эффективным UID, а другие вещи — работая с действительным UID.</p>
      <p>Например, до того, как в системах Unix появилось управление заданиями, многие программы предоставляли <emphasis>переходы в оболочк</emphasis>у, т.е. способ запуска команды или интерактивной оболочки из текущей программы. Хорошим примером этого является редактор <code>ed</code>: набор командной строки, начинающейся с '<code>!</code>', запускает оставшуюся часть строки в качестве команды оболочки. Набрав '<code>!sh</code>', вы получаете интерактивную оболочку. (Это работает до сих пор — попробуйте!) Предположим, описанная ранее гипотетическая игровая программа также предоставляет переход в оболочку: она должна быть запущена от имени действительного пользователя, а <emphasis>не</emphasis> эффективного. В противном случае, редактирование файла счета или многие гораздо худшие вещи становятся для игрока тривиальной задачей!</p>
      <p>Таким образом, имеется явная потребность в возможности замены эффективного UID действительным UID. Более того, полезна возможность <emphasis>обратного</emphasis> переключения эффективного UID на первоначальный. (В этом причина необходимости наличия сохраненного set-user ID; появляется возможность восстановления первоначальных привилегий, которые были у процесса при его запуске.)</p>
      <p>Как и для множества Unix API, различные системы решили проблему разными способами, иногда с использованием одного и того же API, но с другой семантикой, а иногда введением другого API. Погружение в исторические подробности годится лишь для создания головной боли, поэтому мы не будем с этим беспокоиться. Вместо этого мы рассмотрим, что предоставляет POSIX и как работает каждый API. Более того, наше обсуждение фокусируется на значениях действительных и эффективных UID; значения GID работают аналогичным образом, поэтому мы не будем хлопотать с повторением подробностей для этих системных вызовов. Функции следующие:</p>
      <p><code>#include &lt;sys/types.h&gt; /* POSIX */</code></p>
      <p><code>#include &lt;unistd.h&gt;</code></p>
      <empty-line/>
      <p><code>int seteuid(uid_t euid); /* Установка эффективного ID */</code></p>
      <p><code>int setegid(gid_t egid);</code></p>
      <empty-line/>
      <p><code>int setuid(uid_t uid);</code></p>
      <p><code> /* Установка эффективного ID, root устанавливает все */</code></p>
      <p><code>int setgid(gid_t gid);</code></p>
      <empty-line/>
      <p><code>int setreuid(uid_t ruid, uid_t euid);</code></p>
      <p><code> /* Совместимость с BSD, устанавливаются оба */</code></p>
      <p><code>int setregid(gid_t rgid, gid_t egid);</code></p>
      <p>Есть три набора функций. Первые два были созданы POSIX:</p>
      <p><code>int seteuid(uid_t euid)</code></p>
      <p>Эта функция устанавливает лишь эффективный UID. Обычный пользователь (не <code>root</code>) может установить в качестве ID лишь в значения действительного, эффективного или сохраненного set-user ID. Приложения, которые будут переключать эффективный UID. должны использовать исключительно эту функцию.</p>
      <p>Процесс с эффективным UID, равным нулю, может установить в качестве эффективного UID любое значение. Поскольку в качестве значения эффективного UID можно установить также сохраненный set-user ID, процесс может восстановить свои привилегии root с помощью другого вызова <code>seteuid()</code>.</p>
      <p><code>int setegid(gid_t egid)</code></p>
      <p>Эта функция делает для эффективного ID группы то, что <code>seteuid()</code> делает для эффективного ID пользователя.</p>
      <p>Следующий набор функций предлагает первоначальный API Unix для изменения действительных и эффективных UID и GID. В модели POSIX эти функции являются тем. что должна использовать программа с setuid-root для постоянного изменения действительного или эффективного UID:</p>
      <p><code>int setuid(uid_t uid)</code></p>
      <p>Для обычного пользователя эта функция также устанавливает лишь эффективный UID. Как и для <code>seteuid()</code>, значением эффективного UID может быть любое из текущих значений действительного, эффективного иди сохраненного set-user ID. Изменение не постоянно; эффективный UID может быть изменен последующим вызовом на другое значение (из того же исходного набора).</p>
      <p>Однако, для <code>root</code> эта функция устанавливает в данное значение все три значения для действительного, эффективного и сохраненного set-user ID. Более того, изменение постоянно; прежнее ID нельзя восстановить. (Это имеет смысл: раз изменился сохраненный set-user ID, нет другого ID для восстановления.)</p>
      <p><code>int setgid(gid_t gid)</code></p>
      <p>Эта функция делает для эффективного ID группы то же, что <code>setuid()</code> делает для эффективного ID пользователя. Используется то же разграничение между обычными пользователями и <code>root</code>.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Возможность изменения ID группы зависит от эффективного ID пользователя. Эффективный GID, равный 0, не имеет особых привилегий.</p>
      </cite>
      <p>Наконец, POSIX представляет для исторической совместимости две функции из BSD 4.2. В новом коде их лучше не использовать. Однако, поскольку вы, вероятно, увидите использующий эти функции старый код, мы их здесь опишем.</p>
      <p><code>int setreuid(uid_t ruid, uid_t euid)</code></p>
      <p>Устанавливает данные значения в качестве действительного и эффективного UID. Значение -1 для <code>ruid</code> или <code>euid</code> оставляет соответствующие ID без изменения. (Это похоже на <code>chown()</code>; см. раздел 5.5.1 «Смена владельца файла: <code>chown()</code>, <code>fchown()</code> и <code>lchown()</code>».)</p>
      <p><code>root</code> может устанавливать в качестве действительного и эффективного ID любое значение. В соответствии с POSIX пользователи, не являющиеся <code>root</code>, могут изменять лишь эффективный ID; то, что случится, если обычный пользователь попытается изменить действительный UID, «не определено». Однако, справочная страница GNU/Linux <emphasis>setreuid</emphasis>(2) разъясняет поведение Linux, в качестве действительного UID может быть установлено значение действительного или эффективного UID, а в качестве эффективного UID может быть значение действительного, эффективного или сохраненного set-user ID. (Для других систем см. справочную страницу <emphasis>setreuid</emphasis>(2).)</p>
      <p><code>int setregid(gid_t rgid, gid_t egid)</code></p>
      <p>Делает для действительных и эффективных ID групп то же, что <code>setreuid()</code> делает для действительных и эффективных ID пользователя. Используется то же разграничение между обычными пользователями и <code>root</code>.</p>
      <p>Сохраненный set-user ID в модели BSD не существует, поэтому лежащей в основе <code>setreuid()</code> и <code>setregid()</code> идеей было упростить переключение между действительным и эффективным ID:</p>
      <p><code>setreuid(geteuid(), getuid()); /* обмен действительным и эффективным */</code></p>
      <p>Однако, с принятием POSIX модели сохранения set-user ID и функций <code>seteuid()</code> и <code>setegid()</code> функции BSD не следует использовать в новом коде. Даже документация BSD 4.4 помечает эти функции как устаревшие, рекомендуя вместо них <code>seteuid()</code>/<code>setuid()</code> и <code>setegid()</code>/<code>setgid()</code>.</p>
     </section>
     <section>
      <title>
       <p>11.6.3. Использование битов setuid и setgid</p>
      </title>
      <p>Есть важные случаи, в которых действующая как <code>root</code> программа должна <emphasis>безвозвратно</emphasis> изменить все три значения действительного, эффективного и сохраненного set-user ID на ID обычного пользователя. Наиболее очевидным случаем является программа <code>login</code>, которую вы используете (либо непосредственно, либо удаленно) каждый раз при регистрации в системе GNU/Linux или Unix. Имеется иерархия программ, как очерчено на рис. 11.1.</p>
      <image l:href="#img_24.jpeg"/>
      <p><strong>Рис. 11.1</strong>. От <code>init</code> через <code>getty</code> через <code>login</code> к shell</p>
      <p>Код для <code>login</code> слишком сложен, чтобы показать здесь, поскольку он имеет дело с рядом задач, не имеющих отношения к текущему обсуждению. Но мы можем очертить шаги, которые происходят во время регистрации, следующим образом:</p>
      <p>1. <code>init</code> является самым первым процессом. Его PID равен 1. Все другие процессы являются его потомками. Ядро вручную создает процесс 1 во время загрузки и запускает в нем <code>init</code>. Он действует с действительным и эффективным UID, равными нулю, т.е. как <code>root</code>.</p>
      <p>2. <code>init</code> читает <code>/etc/inittab</code>, который, помимо прочих вещей, сообщает <code>init</code> о том, на каких устройствах он должен запустить процесс <code>getty</code>. Для каждого такого устройства (такого, как консоль, последовательные терминалы или виртуальные консоли в системе GNU/Linux) <code>init</code> порождает новый процесс. Этот новый процесс использует затем <code>exec()</code> для запуска <code>getty</code> (от «get tty» («получить tty», т.е. терминал)). На многих системах GNU/Linux эта команда называется <code>mingetty</code>. Программа открывает устройство, сбрасывает его состояние и выводит приглашение '<code>login:</code>'.</p>
      <p>3. По получении регистрационного имени <code>getty</code> выполняет <code>login</code>. Программа <code>login</code> ищет имя пользователя в файле паролей, запрашивает пароль и проверяет его. Если пароль подходит, процесс <code>login</code> продолжается.</p>
      <p>4. <code>login</code> изменяет домашний каталог пользователя, устанавливает начальное окружение, а затем устанавливает начальный набор открытых файлов. Он закрывает дескрипторы файлов, открывает терминал и использует <code>dup()</code> для копирования дескрипторов файла терминала в 0, 1 и 2. Вот откуда происходят дескрипторы уже открытых файлов стандартного ввода, стандартного вывода и стандартной ошибки.</p>
      <p>5. Затем <code>login</code> использует <code>setgroups()</code> для установки дополнительного набора групп, <code>setgid()</code> для установки значений действительного, эффективного и сохраненного set-group ID в соответствующее значение группы пользователя, и наконец, <code>setuid()</code> для установки всех трех значений действительного, эффективного и сохраненного set-user ID в соответствующие значения для регистрирующегося пользователя. Обратите внимание, что вызов <code>setuid()</code> должен быть <emphasis>последним</emphasis> для того, чтобы другие два вызова завершились успешно.</p>
      <p>6. Наконец, <code>login</code> вызывает зарегистрированную оболочку пользователя. Оболочки в стиле Борна после этого читают файлы <code>/etc/profile</code> и <code>$HOME/.profile</code>, если они существуют. Затем оболочка выводит приглашение.</p>
      <p>Обратите внимание, как один процесс меняет свою сущность от системного процесса до процесса пользователя. Каждый потомок <code>init</code> начинается как копия <code>init</code>. Используя <code>exec()</code>, тот же самый процесс выполняет различные задания. Вызвав <code>setuid()</code> для перехода от <code>root</code> к обычному пользователю, процесс в конечном счете поступает непосредственно для работы пользователя. Когда вы выходите из оболочки (посредством CTRL-D или <code>exit</code>), процесс попросту завершается. Затем <code>init</code> возобновляет цикл, порождая новый <code>getty</code>, который выводит новое приглашение '<code>login:</code>'.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Открытые файлы остаются открытыми и доступными для использования, даже после изменения процессом своих UID или GID. Таким образом, программы с setuid должны заранее открыть все нужные файлы, изменить их ID на ID действительного пользователя и продолжить оставшуюся часть работы без дополнительных привилегий</p>
      </cite>
      <p>В табл. 11.1 приведена сводка шести стандартных функций для манипулирования значениями UID и GID.</p>
      <empty-line/>
      <p><strong>Таблица 11.1</strong>. Сводка API для установки действительных и эффективных ID<a l:href="#n120" type="note">[120]</a></p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Функция</th>
        <th align="left" valign="top">Устанавливает</th>
        <th align="left" valign="top">Постоянно</th>
        <th align="left" valign="top">Обычный пользователь</th>
        <th align="left" valign="top">Root</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>seteuid()</code></td>
        <td align="left" valign="top">E</td>
        <td align="left" valign="top">Нет</td>
        <td align="left" valign="top">Из R, E, S</td>
        <td align="left" valign="top">Любое</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>setegid()</code></td>
        <td align="left" valign="top">E</td>
        <td align="left" valign="top">Нет</td>
        <td align="left" valign="top">Из R, E, S</td>
        <td align="left" valign="top">Любое</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>setuid()</code></td>
        <td align="left" valign="top">Root: R,E,S Другие: E</td>
        <td align="left" valign="top">Root: да Другие: нет</td>
        <td align="left" valign="top">Из R, E</td>
        <td align="left" valign="top">Любое</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>setgid()</code></td>
        <td align="left" valign="top">Root: R,E,S Другие: E</td>
        <td align="left" valign="top">Root: да Другие: нет</td>
        <td align="left" valign="top">Из R, E</td>
        <td align="left" valign="top">Любое</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>setreuid()</code></td>
        <td align="left" valign="top">E, может установить R</td>
        <td align="left" valign="top">Нет</td>
        <td align="left" valign="top">Из R, E</td>
        <td align="left" valign="top">Любое</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>setregid()</code></td>
        <td align="left" valign="top">E, может установить R</td>
        <td align="left" valign="top">Нет</td>
        <td align="left" valign="top">Из R, E</td>
        <td align="left" valign="top">Любое</td>
       </tr>
      </table>
     </section>
    </section>
    <section>
     <title>
      <p>11.7. Работа со всеми тремя ID: <code>getresuid()</code> и <code>setresuid()</code> (Linux)</p>
     </title>
     <p>Linux предоставляет дополнительные системные вызовы, посредством которых вы можете непосредственно работать с действительными, эффективными и сохраненными ID пользователя и группы:</p>
     <p><code>#include &lt;sys/types.h&gt; /* Linux */</code></p>
     <p><code>#include &lt;unistd.h&gt;</code></p>
     <empty-line/>
     <p><code>int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid);</code></p>
     <p><code>int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid);</code></p>
     <empty-line/>
     <p><code>int setresuid(uid_t ruid, uid_t euid, uid_t suid);</code></p>
     <p><code>int setresgid(gid_t rgid, gid_t egid, gid_t sgid);</code></p>
     <p>Функции следующие:</p>
     <p><code>int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid)</code></p>
     <p>Получает значения действительного, эффективного и сохраненного set-user ID. Возвращаемое значение 0 в случае успеха и -1 при ошибке, <code>errno</code> указывает проблему.</p>
     <p><code>int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid)</code></p>
     <p>Получает значения действительного, эффективного и сохраненного set-group ID. Возвращаемое значение 0 в случае успеха и -1 при ошибке, <code>errno</code> обозначает проблему.</p>
     <p><code>int setresuid(uid_t ruid, uid_t euid, uid_t suid)</code></p>
     <p>Устанавливает значения действительного, эффективного и сохраненного set-user ID соответственно. Когда значение параметра равно -1, соответствующий UID остается без изменения.</p>
     <p>Когда процесс действует как <code>root</code>, параметрами могут быть любые произвольные значения. Однако, использование ненулевого значения для <code>euid</code> вызывает постоянную, безвозвратную утерю привилегии <code>root</code>). В противном случае параметры должны быть одним из значений действительного, эффективного или сохраненного set-user ID.</p>
     <p><code>int setresgid(gid_t rgid, gid_t egid, gid_t sgid)</code></p>
     <p>Устанавливает значения действительного, эффективного и сохраненного set-group ID соответственно. Когда значение параметра равно -1, соответствующий GID остается без изменений.</p>
     <p>Эта функция аналогична <code>setresuid()</code>.</p>
     <p>Функции <code>setresuid()</code> и <code>setresgid()</code> особенно ценны, поскольку их семантика ясно определена. Программист точно знает, каким может быть результат их вызова.</p>
     <p>Более того, вызовы являются операциями типа «все или ничего»: они либо полностью успешны в осуществлении нужного изменения, либо терпят полную неудачу, оставляя текущее состояние как есть. Это повышает надежность, поскольку, опять-таки можно быть точно уверенным в том, что случилось.</p>
    </section>
    <section>
     <title>
      <p>11.8. Пересечение минного поля безопасности: setuid <code>root</code></p>
     </title>
     <p>Настоящие минные поля трудно, но не невозможно перейти. Однако, это не является чем-то, что можно сделать легко, без тренировки или опыта</p>
     <p>Точно также написание программ, которые используют setuid <code>root</code>, является трудной задачей. Имеется много, очень много проблем, о которых нужно знать, и почти все может иметь неожиданные последствия в плане безопасности. Такая попытка должна предприниматься очень осторожно.</p>
     <p>В частности, стоит специально изучить проблемы безопасности Linux/Unix и потратить время на обучение написанию программ setuid root. Если вы сразу нырнете в эту проблему, прочитав лишь эту книгу и ничего более, можно быть уверенным, что ваша система будет взломана, <emphasis>легко и сразу</emphasis>. Маловероятно, что вы или ваши клиенты будут довольны.</p>
     <p>Вот несколько руководящих принципов:</p>
     <p>• Как можно меньше действуйте в качестве <code>root</code>. Скупо используйте свои чрезвычайные полномочия, лишь тогда, когда это абсолютно необходимо</p>
     <p>• Соответствующим образом проектируйте свою программу. Разделите программу на составные части таким образом, чтобы все операции <code>root</code> были выполнены заранее, а оставшаяся программа работала в качестве обычного пользователя.</p>
     <p>• При изменении или сбрасывании привилегий используйте <code>setresuid()</code>, если она у вас есть. В противном случае используйте <code>setreuid(),</code> поскольку у этих функций самая чистая семантика. Используйте <code>setuid()</code>, лишь когда вы хотите сделать постоянное изменение.</p>
     <p>• Переходите от <code>root</code> к обычному пользователю в соответствующем порядке: сначала установите набор групп и значения GID, затем значения UID. Будьте особенно осторожны с <code>fork()</code> и <code>exec()</code>; действительные и эффективные UID при их вызове не изменяются, если вы не измените их явным образом.</p>
     <p>• Рассмотрите использование прав доступа setgid и особой группы для вашего приложения. Если это будет работать, это убережет вас от большой головной боли.</p>
     <p>• Рассмотрите отказ от наследуемого окружения. Если вам нужно сохранить некоторые переменные окружения, сохраните как можно меньше. Убедитесь в предоставлении подходящих значений для переменных окружения <code>PATH</code> и <code>IFS</code>.</p>
     <p>• Избегайте <code>execlp()</code> и <code>execvp()</code>, которые зависят от значения переменной окружения <code>PATH</code> (хотя это менее проблематично, если вы сами восстанавливаете <code>PATH</code>).</p>
     <p>Это просто некоторые из множества тактик по пересечению опасной зоны, известной своими подвохами, минами-ловушками и фугасами. Ссылки на другие источники информации см. в следующем разделе.</p>
    </section>
    <section>
     <title>
      <p>11.9. Рекомендуемая литература</p>
     </title>
     <p>Безопасность Unix (а следовательно, и GNU/Linux) является темой, требующей знаний и опыта для того, чтобы справиться с ней должным образом. В Эпоху Интернета она стала лишь труднее, не проще.</p>
     <p>1. <emphasis>Practical UNIX &amp; Internet Security</emphasis>, 3rd edition, by Simson Garfinkel, Gene Spafford, and Alan Schwartz, O'Reilly &amp; Associates, Sebastopol, CA, USA, 2003. ISBN: 0-596-00323-4.</p>
     <p>Это стандартная книга по безопасности Unix.</p>
     <p>2. <emphasis>Building Secure Software. How to Avoid Security Problems the Right Way</emphasis>, by John Viega and Gary McGraw. Addison-Wesley, Reading, Massachusetts, USA, 2001. ISBN: 0-201-72152-X.</p>
     <p>Это хорошая книга по написанию безопасного программного обеспечения, она включает проблемы setuid. Предполагается, что вы знакомы с основными API Linux/Unix; к моменту прочтения данной книги вы должны быть готовы к ее прочтению.</p>
     <p>3. "Setuid Demystified," by Hao Chen, David Wagner, and Drew Dean. Proceedings of the 11th USENIX Security Symposium, August 5–9, 2002 http://www.cs.berkeley.edu/~daw/papers/setuid-usenix02.pdf.</p>
     <p>Гарфинкель, Спаффорд и Шварц (Garfinkel, Spafford, Schwartz) рекомендуют прочтение этого материала «до того, как вы даже подумаете о написании кода, который пытается сохранять и восстанавливать привилегии». Мы всецело согласны с ними.</p>
    </section>
    <section>
     <title>
      <p>11.10. Резюме</p>
     </title>
     <p>• Использование значений ID пользователя и группы (UID и GID) для идентификации файлов и процессов — вот что превращает Linux и Unix в многопользовательские системы. Процессы имеют значения как действительных, так и эффективных UID и GID, а также набор дополнительных групп. Обычно именно эффективный UID определяет, как один процесс может повлиять на другой, и эффективные UID, GID и набор групп проверяются на соответствие с правами доступа к файлу. Пользователи с эффективным UID, равным нулю, известные как <code>root</code> или <emphasis>суперпользователи</emphasis>, могут делать все, что захотят; система не использует для такого пользователя проверку прав доступа.</p>
     <p>• Концепции сохраненных set-user ID и set-group ID пришли из System V и были приняты POSIX с полной поддержкой в GNU/Linux. Наличие этих отдельных значений ID дает возможность легко и безошибочно переключать при необходимости действительные и эффективные UID (и GID).</p>
     <p>• Программы setuid и setgid создают процессы, в которых действительные и эффективные ID различаются. Программы как таковые помечаются дополнительными битами прав доступа к файлу. Биты setuid и setgid должны быть добавлены к файлу после его создания.</p>
     <p>• <code>getuid()</code> и <code>geteuid()</code> получают значения действительного и эффективного UID соответственно, a <code>getgid()</code> и <code>getegid()</code> получают значения действительного и эффективного GID соответственно, <code>getgroups()</code> получает набор дополнительных групп, а в среде POSIX может запросить у системы, сколько членов содержит набор групп.</p>
     <p>• Функция <code>access()</code> осуществляет проверку прав доступа к файлу для <emphasis>действительного</emphasis> пользователя, давая возможность программе setuid проверить полномочия реального пользователя. Обратите внимание, что часто проверка возвращаемых <code>stat()</code> сведений может не представить полной картины при условии, что файл может находиться на не родной или сетевой файловой системе.</p>
     <p>• Функция GLIBC <code>euidaccess()</code> сходна с <code>access()</code>, но осуществляет проверку на основе значений эффективных UID и GID.</p>
     <p>• «Липкий» бит и бит setgid при использовании с каталогами привносят дополнительную семантику. Когда для каталога установлен бит setgid, новые файлы в этом каталоге наследуют группу этого каталога. Новые каталоги делают то же самое, они также автоматически наследуют установку бита setgid. Без установленного бита setgid новые файлы и каталоги получают эффективный GID создающего их процесса. «Липкий» бит, установленный для каталогов, в которые в других отношениях разрешена запись, ограничивает право на удаление файла владельцем файла, владельцем каталога и <code>root</code>.</p>
     <p>• Набор групп изменяется с помощью <code>setgroups()</code>. Эта функция не стандартизована POSIX, но существует на всех современных системах Unix. Ее может использовать лишь <code>root</code>.</p>
     <p>• Изменение UID и GID довольно сложно. Семантика различных системных вызовов с течением времени изменилась. Новые приложения, которые будут изменять лишь свои эффективные UID/GID, должны использовать <code>seteuid()</code> и <code>setegid()</code>. Приложения, не действующие от имени <code>root</code>, могут также устанавливать свои эффективные ID с помощью <code>setuid()</code> и <code>setgid()</code>. Вызовы <code>setreuid()</code> и <code>setregid()</code> от BSD были предназначены для обмена значениями UID и GID; их использование в новых программах не рекомендуется.</p>
     <p>• Приложения, действующие как <code>root</code>, могут перманентно заменить значения действительного, эффективного и сохраненного ID с помощью <code>setuid()</code> и <code>setgid()</code>. Одним из таких примеров является <code>login</code>, которая должна превратиться из программы, выполняющейся как <code>root</code> в не непривилегированную зарегистрированную оболочку, выполняющуюся от имени обычного пользователя.</p>
     <p>• Функции Linux <code>setresuid()</code> и <code>setresgid()</code> следует использовать всегда, когда они доступны, поскольку они обеспечивают самое чистое и наиболее надежное поведение</p>
     <p>• Написание приложений setuid-<code>root</code> не является задачей для новичка. Если вам нужно сделать такую вещь, сначала специально изучите проблемы безопасности. Для этого можно воспользоваться приведенными выше превосходными источниками.</p>
    </section>
    <section>
     <title>
      <p>Упражнения</p>
     </title>
     <p>1. Напишите простую версию команды <code>id</code>. Ее назначением является отображение в стандартный вывод ID пользователя и группы с указанием имен групп. Когда эффективный и действительный ID различаются, выводятся оба. Например:</p>
     <p><code>$ <strong>id</strong></code></p>
     <p><code>uid=2076(arnold) gid=42(devel) groups=19(floppy), 42(devel), 2076(arnold)</code></p>
     <p>Ее использование:</p>
     <p><code>id [ <emphasis>пользователь</emphasis> ]</code></p>
     <p><code>id -G [ -nr ] [ <emphasis>пользователь</emphasis> ]</code></p>
     <p><code>id -g [ -nr ] [ <emphasis>пользователь</emphasis> ]</code></p>
     <p><code>id -u [ -nr ] [ <emphasis>пользователь</emphasis> ]</code></p>
     <p>При указанном <emphasis>пользователе</emphasis> выводятся сведения об этом пользователе; в противном случае <code>id</code> выводит сведения о пользователе, вызвавшем программу. Опции следующие:</p>
     <p><code> -G  </code>Выводит все значения групп в виде чисел, без имен.</p>
     <p><code> -n  </code>Выводит лишь имена, без числовых значений. Применяется с значениями пользователя и группы.</p>
     <p><code> -g  </code>Выводит лишь эффективный GID.</p>
     <p><code> -u  </code>Выводит лишь эффективный UID.</p>
     <p>2. Напишите простую программу с именем <code>sume</code> и установите setuid на себя. Она должна запрашивать пароль (см. <emphasis>getpass</emphasis>(3)), который в целях данного примера может быть жестко вшит в исходный код программы. Если лицо, запустившее программу, вводит пароль правильно, <code>sume</code> должна выполнить exec оболочки. Попросите другого пользователя помочь вам ее протестировать.</p>
     <p>3. Как вы относитесь к тому, чтобы сделать <code>sume</code> доступной для ваших друзей? Для ваших приятелей студентов или сотрудников? Для каждого пользователя на вашей системе?</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 12 Общие библиотечные интерфейсы — часть 2</p>
    </title>
    <section>
     <p>В главе 6, «Общие библиотечные интерфейсы — часть 1», был представлен первый набор API библиотеки общего пользования. В некотором смысле, эти API поддерживают работу с фундаментальными объектами, которыми управляют системы Linux и Unix: время дня, пользователи и группы для файлов, сортировка и поиск.</p>
     <p>Данная глава более эклектична; функции API, рассмотренные здесь, не особо связаны друг с другом. Однако, все они полезны в повседневном программировании под Linux/Unix. Наше представление движется от простых, более общих функций API к более сложным и более специализированным.</p>
    </section>
    <section>
     <title>
      <p>12.1. Операторы проверки: <code>assert()</code></p>
     </title>
     <p><emphasis>Оператор проверки (assertion)</emphasis> является утверждением, которое вы делаете о состоянии своей программы в определенный момент времени ее исполнения. Использование операторов проверок для программирования было первоначально разработано Хоаром (C.A.R. Hoare)<a l:href="#n121" type="note">[121]</a>. Общая идея является частью «верификации программы»: так же, как вы проектируете и разрабатываете программу, вы можете показать, что она правильна, делая тщательно аргументированные утверждения о проявлениях кода вашей программы. Часто такие утверждения делаются об <emphasis>инвариантах </emphasis>— фактах о состоянии программы, которые, как предполагается, остаются верными на протяжении исполнения куска программы.</p>
     <p>Операторы проверки особенно полезны для описания двух разновидностей инвариантов: <emphasis>предусловий</emphasis> и <emphasis>постусловий</emphasis>: условий, которые должны быть истинными соответственно перед и после исполнения сегмента кода. Простым примером предусловий и постусловий является линейный поиск:</p>
     <p><code>/* lsearch --- возвратить индекс с данным значением в массиве или -1,</code></p>
     <p><code>   если не найдено */</code></p>
     <p><code>int lsearch(int *array, size_t size, int value) {</code></p>
     <p><code> size_t i;</code></p>
     <p><code> /* предусловие: array != NULL */</code></p>
     <p><code> /* предусловие: size &gt; 0 */</code></p>
     <p><code> for (i = 0; i &lt; size; i++)</code></p>
     <p><code>  if (array[i] == value)</code></p>
     <p><code>   return i;</code></p>
     <p><code> /* постусловие: i == size */</code></p>
     <p><code> return -1;</code></p>
     <p><code>}</code></p>
     <p>Этот пример определяет условия, используя комментарии. Но не было бы лучше проверить условия с использованием кода? Это является задачей макроса <code>assert()</code>:</p>
     <p><code>#include &lt;assert.h&gt; /* ISO С */</code></p>
     <empty-line/>
     <p><code>void assert(/* <emphasis>скалярное выражение</emphasis> */);</code></p>
     <p>Когда <emphasis>скалярное выражение</emphasis> ложно, макрос <code>assert()</code> выводит диагностическое сообщение и завершает программу (с помощью функции <code>abort()</code>; см. раздел 12.4 «Совершение самоубийства: <code>abort()</code>»). <code>ch12-assert.c</code> снова предоставляет функцию <code>lsearch()</code>, на этот раз с оператором проверки и функцией <code>main()</code>:</p>
     <p><code>1  /* ch12-assert.с --- демонстрация операторов проверки */</code></p>
     <p><code>2</code></p>
     <p><code>3  #include &lt;stdio.h&gt;</code></p>
     <p><code>4  #include &lt;assert.h&gt;</code></p>
     <p><code>5</code></p>
     <p><code>6  /* lsearch --- возвращает индекс с данным значением в массиве или -1, если не найдено */</code></p>
     <p><code>7</code></p>
     <p><code>8  int lsearch(int *array, size_t size, int value)</code></p>
     <p><code>9  {</code></p>
     <p><code>10  size_t i;</code></p>
     <p><code>11</code> </p>
     <p><code>12  assert(array != NULL);</code></p>
     <p><code>13  assert(size &gt; 0);</code></p>
     <p><code>14  for (i = 0; i &lt; size; i++)</code></p>
     <p><code>15   if (array[i] == value)</code></p>
     <p><code>16    return i;</code></p>
     <p><code>17</code></p>
     <p><code>18  assert(i == size);</code></p>
     <p><code>19</code></p>
     <p><code>20  return -1;</code></p>
     <p><code>21 }</code></p>
     <p><code>22</code></p>
     <p><code>23 /* main --- проверить наши условия */</code></p>
     <p><code>24</code> </p>
     <p><code>25 int main(void)</code></p>
     <p><code>26 {</code></p>
     <p><code>27 #define NELEMS 4</code></p>
     <p><code>28  static int array[NELEMS] = { 1, 17, 42, 91 };</code></p>
     <p><code>29  int index;</code></p>
     <p><code>30</code></p>
     <p><code>31  index = lsearch(array, NELEMS, 21);</code></p>
     <p><code>32  assert(index == -1);</code></p>
     <p><code>33</code> </p>
     <p><code>34  index = lsearch(array, NELEMS, 17);</code></p>
     <p><code>35  assert(index == 1);</code></p>
     <p><code>36</code> </p>
     <p><code>37  index = lsearch(NULL, NELEMS, 10); /* won't return */</code></p>
     <p><code>38</code> </p>
     <p><code>39  printf("index = %d\n", index);</code></p>
     <p><code>40</code></p>
     <p><code>41  return 0;</code></p>
     <p><code>42 }</code></p>
     <p>После компиляции и запуска оператор проверки в строке 12 «выстреливает»:</p>
     <p><code>$ <strong>ch12-assert</strong> /* Запуск программы */</code></p>
     <p><code>ch12-assert: ch12-assert.c:12: lsearch: Assertion 'array != ((void *)0)' failed.</code></p>
     <p><code>Aborted (core dumped)</code></p>
     <p>Сообщение от <code>assert()</code> варьирует от системы к системе. Для GLIBC на GNU/Linux сообщение включает имя программы, имя файла с исходным кодом и номер строки, имя функции, а затем текст завершившегося неудачей условия. (В этом случае именованная константа <code>NULL</code> проявляется в виде своего макрорасширения '<code>((void*)0)'</code>.)</p>
     <p>Сообщение '<code>Aborted (core dumped)</code>' означает, что <code>ch12-assert</code> создала файл <code>core</code>; т.е. снимок адресного пространства процесса непосредственно перед его завершением.<a l:href="#n122" type="note">[122]</a> Этот файл может быть использован впоследствии с отладчиком; см. раздел 15.3 «Основы GDB». Создание файла <code>core</code> является намеренным побочным результатом <code>assert()</code>; предполагается, что произошла решительная ошибка, и вы хотите исследовать процесс с помощью отладчика для ее определения.</p>
     <p>Вы можете отменить оператор проверки, компилируя свою программу с помощью опции командной строки '<code>-DNDEBUG</code>'. Когда этот макрос определен до включения <code>&lt;assert.h&gt;</code>, макрос <code>assert()</code> расширяется в код, который ничего не делает. Например:</p>
     <p><code>$ <strong>gcc -DNDEBUG=1 ch12-assert.c -о ch12-assert</strong> /* Компиляция с -DNDEBUG */</code></p>
     <p><code>$ <strong>ch12-assert</strong> /* Запуск */</code></p>
     <p><code>Segmentation fault (core dumped) /* Что случилось? */</code></p>
     <p>Здесь мы получили настоящий дамп ядра! Мы знаем, что операторы проверки были запрещены; сообщения «failed assertion» нет. Что же случилось? Рассмотрите строку 15 <code>lsearch()</code> при вызове из строки 37 <code>main()</code>. В этом случае переменная <code>array</code> равна <code>NULL</code>. Доступ к памяти через указатель <code>NULL</code> является ошибкой. (Технически различные стандарты оставляют «неопределенным» то, что происходит при разыменовывании указателя <code>NULL</code>. Наиболее современные системы делают то же, что и GNU/Linux; они завершают процесс, посылая ему сигнал <code>SIGSEGV</code>; это, в свою очередь, создает дамп ядра. Этот процесс описан в главе 10 «Сигналы».</p>
     <p>Этот случай поднимает важный момент относительно операторов проверки. Часто программисты ошибочно используют операторы проверки <emphasis>вместо</emphasis> проверки ошибок времени исполнения. В нашем случае тест '<code>array != NULL</code>' должен был быть проверкой времени исполнения:</p>
     <p><code>if (array == NULL) return -1;</code></p>
     <p>Тест '<code>size &gt; 0</code>' (строка 13) менее проблематичен; если <code>size</code> равен 0 или меньше 0, цикл никогда не исполнится, и <code>lsearch()</code> (правильно) возвратит -1. (По правде, этот оператор проверки не нужен, поскольку код правильно обрабатывает случай '<code>size &lt;= 0</code>'.)</p>
     <p>Логика, стоящая за отменой оператора проверки, заключается в том, что дополнительные проверки могут снизить производительность программы и поэтому должны быть запрещены в заключительной версии программы. Хоар<a l:href="#n123" type="note">[123]</a>, однако, сделал такое замечание:</p>
     <cite>
      <p>«В конце концов, абсурдно делать тщательные проверки безопасности при отладочных запусках, когда к результатам нет никакого доверия, а затем удалять их из финальных версий, когда ошибочный результат может быть дорогим или катастрофическим. Что бы мы подумали об энтузиасте-мореплавателе, который надевает свой спасательный жилет при тренировке на сухой земле и снимает его, как только выходит в море?»</p>
     </cite>
     <p>С такими мнениями, наша рекомендация заключается во внимательном использовании операторов проверки- во-первых, для любого данного оператора проверки рассмотрите возможность использования вместо него проверки времени исполнения. Во-вторых, тщательно разместите свой оператор проверки, чтобы не было возражений против их оставления на своем месте лаже в финальной версии вашей программы.</p>
     <p>Наконец, отметим следующее из раздела «Ошибки» справочной страницы GNU/Linux <emphasis>assert</emphasis>(3):</p>
     <cite>
      <p><code>assert()</code> реализован как макрос: если у проверяемого выражения есть побочные результаты, поведение программы может меняться в зависимости от того, определен ли <code>NDEBUG</code>. Это может создавать гейзенберговские ошибки, которые исчезают при отключении режима отладки.</p>
     </cite>
     <p>Знаменитый принцип неопределенности Гейзенберга из физики указывает, что чем более точно вы определите скорость частицы, тем менее точно вы определите ее положение, и наоборот. В терминах непрофессионала это означает что простой факт наблюдения частицы влияет на нее.</p>
     <p>Сходное явление совершается в программировании, не связанном с физикой частиц: действие компилирования программы для отладки или запуска ее а режиме отладки может изменить поведение программы. В частности, первоначальная ошибка может исчезнуть. Такие ошибки в разговоре называют <emphasis>гейзенберговскими</emphasis>.</p>
     <p>Справочная страница предостерегает нас от использования при вызовах <code>assert()</code> выражений с побочными эффектами:</p>
     <p><code>assert(*p++ == '\n');</code></p>
     <p>Здесь побочным эффектом является увеличение указателя p как часть теста. Когда определен <code>NDEBUG</code>, аргумент выражения <emphasis>исчезает</emphasis> из исходного кода; он никогда не исполняется. Это может привести к неожиданной неудаче. Однако, как только при подготовке к отладке запрет на операторы проверки отменяется, все начинает снова работать! Такие проблемы трудно отследить.</p>
    </section>
    <section>
     <title>
      <p>12.2. Низкоуровневая память: функции <code>mem<emphasis>XXX</emphasis>()</code></p>
     </title>
     <section>
      <p>Несколько функций предоставляют возможность для работы с произвольными блоками памяти низкоуровневые службы. Все их имена начинаются с префикса '<code>mem</code>':</p>
      <p><code>#include &lt;string.h&gt; /* ISO C */</code></p>
      <empty-line/>
      <p><code>void *memset(void *buf, int val, size_t count);</code></p>
      <p><code>void *memcpy(void *dest, const void *src, size_t count);</code></p>
      <p><code>void *memmove(void *dest, const void *src, size_t count);</code></p>
      <p><code>void *memccpy(void *dest, const void *src, int val, size_t count);</code></p>
      <p><code>int memcmp(const void *buf1, const void *buf2, size_t count);</code></p>
      <p><code>void *memchr(const void *buf, int val, size_t count);</code></p>
     </section>
     <section>
      <title>
       <p>12.2.1. Заполнение памяти: <code>memset()</code></p>
      </title>
      <p>Функция <code>memset()</code> копирует значение val (интерпретируемое как <code>unsigned char</code>) в первые <code>count</code> байтов буфера <code>buf</code>. Она особенно полезна для обнуления блоков динамической памяти:</p>
      <p><code>void *p = malloc(count);</code></p>
      <p><code>if (p != NULL)</code></p>
      <p><code> memset(p, 0, count);</code></p>
      <p>Однако <code>memset()</code> может использоваться с любой разновидностью памяти, не только с динамической. Возвращаемым значением является первый аргумент: <code>buf</code>.</p>
     </section>
     <section>
      <title>
       <p>12.2.2. Копирование памяти: <code>memcpy()</code>, <code>memmove()</code> и <code>memccpy()</code></p>
      </title>
      <p>Три функции копируют один блок памяти в другой. Первые две функции отличаются в обработке <emphasis>перекрывающихся</emphasis> областей памяти; третья копирует память, но останавливается при встрече с определенным значением.</p>
      <p><code>void *memcpy(void *dest, const void *src, size_t count)</code></p>
      <p>Это простейшая функция. Она копирует <code>count</code> байтов из <code>src</code> в <code>dest</code>. Она не обрабатывает перекрывающиеся области памяти. Функция возвращает <code>dest</code>.</p>
      <p><code>void *memmove(void *dest, const void *src, size_t count)</code></p>
      <p>Подобно <code>memcpy()</code>, она также копирует <code>count</code> байтов из <code>src</code> в <code>dest</code>. Однако, она обрабатывает перекрывающиеся области памяти. Функция возвращает <code>dest</code>.</p>
      <p><code>void *memccpy(void *dest, const void *src, int val, size_t count)</code></p>
      <p>Эта копирует байты из <code>src</code> в <code>dest</code>, останавливаясь либо после копирования <code>val</code> в <code>dest</code>, либо после копирования <code>count</code> байтов. Если она находит <code>val</code>, то возвращает указатель на положение в <code>dest</code> сразу за <code>val</code>. В противном случае возвращается <code>NULL</code>.</p>
      <p>Теперь, в чем проблема с перекрывающейся памятью? Рассмотрим рис. 12.1.</p>
      <image l:href="#img_25.jpeg"/>
      <p><strong>Рис. 12.1</strong>. Перекрывающиеся копии</p>
      <p>Целью является скопировать четыре экземпляра <code>struct xyz</code> от <code>data[0]</code> до <code>data[3]</code> в участок от <code>data[3]</code> до <code>data[6]</code>. Здесь проблемой является <code>data[3]</code>, побайтовое копирование с перемещением в памяти из <code>data[0]</code> затрет <code>data[3]</code> до того, как он будет безопасно скопирован в <code>data[6]</code>! (Может возникнуть также сценарий, когда копирование в памяти в обратном направлении разрушит перекрывающиеся данные.)</p>
      <p>Функция <code>memcpy()</code> была первоначальной функцией в System V API для копирования блоков памяти; ее поведение для перекрывающихся блоков памяти не была подробно определена тем или иным способом. Для стандарта С 1989 г. комитет почувствовал, что это отсутствие определенности является проблемой, поэтому они придумали <code>memmove()</code>. Для обратной совместимости <code>memcpy()</code> была оставлена, причем поведение для перекрывающейся памяти было специально отмечено как неопределенное, а в качестве процедуры, корректно разрешающей проблемные случаи, была предложена <code>memmove()</code>.</p>
      <p>Какую из них использовать в своем коде? Для библиотечной функции, которая не знает, какие области памяти ей передаются, следует использовать <code>memmove()</code>. Таким способом вы гарантируете, что не будет проблем с перекрывающимися областями. Для кода приложения, который «знает», что две области не перекрываются, можно безопасно использовать <code>memcpy()</code>.</p>
      <p>Как для <code>memcpy()</code>, так и для <code>memmove()</code> (как и для <code>strcpy()</code>) буфер назначения является первым аргументом, а источник — вторым. Чтобы запомнить это, обратите внимание на порядок, который тот же самый, как в операторе присваивания:</p>
      <p><code>dest = src;</code></p>
      <p>(Справочные страницы во многих системах не помогают, предлагая прототип в виде '<code>void *memcpy(void *buf1, void *buf2, size_t n)</code>' и полагаясь на то, что текст объяснит, что есть что. К счастью, справочная страница GNU/Linux использует более осмысленные имена.)</p>
     </section>
     <section>
      <title>
       <p>12.2.3. Сравнение блоков памяти: <code>memcmp()</code></p>
      </title>
      <p>Функция <code>memcmp()</code> сравнивает <code>count</code> байтов из двух произвольных буферов данных. Возвращаемое ею значение подобно <code>strcmp()</code>: отрицательное, нулевое или положительное, если первый буфер меньше, равен или больше второго.</p>
      <p>Вы можете поинтересоваться: «Почему бы не использовать для такого сравнения <code>strcmp()</code>?» Разница между двумя функциями в том, что <code>memcmp()</code> не принимает во внимание нулевые байты (завершающий строку '<code>\0</code>'.) Таким образом, <code>memcmp()</code> является функцией, которая используется, когда вам нужно сравнить произвольные двоичные данные.</p>
      <p>Другим преимуществом <code>memcmp()</code> является то, что она быстрее типичной реализации на C:</p>
      <p><code>/* memcmp --- пример реализации на С, НЕ для реального использования */</code></p>
      <p><code>int memcmp(const void *buf1, const void *buf2, size_t count) {</code></p>
      <p><code> const unsigned char *cp1 = (const unsigned char*)buf1;</code></p>
      <p><code> const unsigned char *cp2 = (const unsigned char*)buf2;</code></p>
      <p><code> int diff;</code></p>
      <p><code> while (count-- != 0) {</code></p>
      <p><code>  diff = *cp1++ - *cp2++;</code></p>
      <p><code>  if (diff != 0)</code></p>
      <p><code>   return diff;</code></p>
      <p><code> }</code></p>
      <p><code> return 0;</code></p>
      <p><code>}</code></p>
      <p>Скорость может быть достигнута в результате использования специальных инструкций «блочного сравнения памяти», которые поддерживают многие архитектуры, или в результате сравнения единиц, превышающих байты. (Эта последняя операция коварна, и лучше оставить ее автору библиотеки.)</p>
      <p>По этим причинам <emphasis>всегда</emphasis> следует использовать вашу библиотечную версию <code>memcmp()</code> вместо прокручивания своей собственной. Велика вероятность, что автор библиотеки знает машину лучше вас</p>
     </section>
     <section>
      <title>
       <p>12.2.4. Поиск байта с данным значением: <code>memchr()</code></p>
      </title>
      <p>Функция <code>memchr()</code> сходна с функцией <code>strchr()</code>: она возвращает местоположение определенного значения внутри произвольного буфера. Как и в случае <code>memcmp()</code> против <code>strcmp()</code>, основной причиной для использования <code>memchr()</code> является использование произвольных двоичных данных.</p>
      <p>GNU <code>wc</code> использует <code>memchr()</code> при подсчете лишь строк и байтов<a l:href="#n124" type="note">[124]</a>, и это позволяет <code>wс</code> быть быстрой. Из <code>wc.c</code> в GNU Coreutils:</p>
      <p><code>257  else if (!count_chars &amp;&amp; !count_complicated)</code></p>
      <p><code>258  {</code></p>
      <p><code>259   /* Использует отдельный цикл при подсчете лишь строк или строк и байтов -</code></p>
      <p><code>260      но не символов или слов. */</code></p>
      <p><code>261  while ((bytes_read = safe_read(fd, buf, BUFFER_SIZE)) &gt; 0)</code></p>
      <p><code>262  {</code></p>
      <p><code>263   register char *p = buf;</code></p>
      <p><code>264</code></p>
      <p><code>265   if (bytes_read == SAFE_READ_ERROR)</code></p>
      <p><code>266   {</code></p>
      <p><code>267    error(0, errno, "%s", file);</code></p>
      <p><code>268    exit_status = 1;</code></p>
      <p><code>269    break;</code></p>
      <p><code>270   }</code></p>
      <p><code>271</code></p>
      <p><code>272   while ((p = memchr(p, '\n', (buf + bytes_read) - p)))</code></p>
      <p><code>273   {</code></p>
      <p><code>274    ++p;</code></p>
      <p><code>275    ++lines;</code></p>
      <p><code>276   }</code></p>
      <p><code>277   bytes += bytes_read;</code></p>
      <p><code>278  }</code></p>
      <p><code>279 }</code></p>
      <p>Внешний цикл (строки 261–278) читает блоки данных из входного файла. Внутренний цикл (строки 272–276) использует <code>memchr()</code> для поиска и подсчета символов конца строки. Сложное выражение '<code>(buf + bytes_read) - р</code>' сводится к числу оставшихся байтов между текущим значением p и концом буфера.</p>
      <p>Комментарии в строках 259–260 нуждаются в некотором объяснении. Вкратце, современные системы могут использовать символы, занимающие более одного байта в памяти и на диске. (Это несколько более подробно обсуждается в разделе 13.4 «Не могли бы вы произнести это для меня по буквам?».) Таким образом, <code>wc</code> должна использовать другой код, если она различает байты и символы: этот код имеет дело со случаем подсчета байтов.</p>
     </section>
    </section>
    <section>
     <title>
      <p>12.3. Временные файлы</p>
     </title>
     <section>
      <p><emphasis>Временный файл</emphasis> является в точности тем, что звучит в его названии: файл, в котором при исполнении программы хранятся данные, которые больше не нужны после завершения программы. <code>sort</code> читает со стандартного ввода, если в командной строке не указаны файлы или вы используете в качестве имени файла '<code>-</code>'. Тем не менее, <code>sort</code> должна прочесть <code>все</code> свои входные данные, прежде чем сможет вывести отсортированные результаты. (Подумайте об этом немного, и вы увидите, что это так.) Когда читается стандартный ввод, данные должны быть где-то сохранены, прежде чем <code>sort</code> сможет их отсортировать; это отличное применение для временного файла. <code>sort</code> использует временные файлы также для хранения промежуточных результатов сортировки.</p>
      <p>Удивительно, но имеются <emphasis>пять</emphasis> различных функций для создания временных файлов. Три из них работают посредством создания строк, представляющих (предположительно) уникальные имена файлов. Как мы увидим, их обычней следует избегать. Оставшиеся две работают путем создания и открытия временного файла; эти функции предпочтительнее для использования.</p>
     </section>
     <section>
      <title>
       <p>12.3.1. Создание временных имен файлов (плохо)</p>
      </title>
      <p>Имеются три функции, назначением которых является создание имени уникального, не существующего файла. Получив такое имя, вы можете использовать его для создания временного файла. Поскольку имя уникально, вам «гарантируется» исключительное использование файла. Вот объявления функций:</p>
      <p><code>#include &lt;stdio.h&gt;</code></p>
      <empty-line/>
      <p><code>char *tmpnam(char *s); /* ISO С */</code></p>
      <p><code>char *tempnam(const char *dir, const char *pfx); /* XSI */</code></p>
      <p><code>char *mktemp(char *template); /* ISO С */</code></p>
      <p>Все эти функции предусматривают различные вариации одной и той же темы они заполняют или создают буфер с путем уникального временного имени файла. Файл уникален в том, что создаваемое имя не существует во время создания и возвращения его функциями. Функции работают следующим образом:</p>
      <p><code>char *tmpnam(char *s)</code></p>
      <p>Генерирует уникальное имя файла. Если <code>s</code> не равен <code>NULL</code>, он должен быть размером по крайней мере <code>L_tmpnam</code> байтов, и в него копируется уникальное имя. Если <code>s</code> равен <code>NULL</code>, имя генерируется во внутреннем статическом буфере, который может быть переписан при последующих вызовах. Префикс каталогов в пути будет <code>P_tmpdir</code>. Как <code>P_tmpdir</code>, так и <code>L_tmpnam</code> определены в <code>&lt;stdio.h&gt;</code>.</p>
      <p><code>char *tempnam(const char *dir, const char *pfx)</code></p>
      <p>Подобно <code>tmpnam()</code> дает вам возможность указать префикс каталогов. Если <code>dir</code> равен <code>NULL</code>, используется <code>P_tmpdir</code>. Аргумент <code>pfx</code>, если он не равен <code>NULL</code>, определяет до пяти символов для использования в качестве начальных символов имени файла <code>tempnam()</code> выделяет память для имен файлов, которые она генерирует. Возвращенный указатель может впоследствии использоваться с <code>free()</code> (и это следует сделать, если хотите избежать утечек памяти).</p>
      <p><code>char *mktemp(char *template)</code></p>
      <p>Генерирует уникальные имена файлов на основе шаблона. Последними шестью символами <code>template</code> должны быть '<code>ХХХХХХ</code>'; эти символы замещаются уникальным суффиксом.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Аргумент <code>template</code> функции <code>mktemp()</code> переписывается. Поэтому он не должен быть строковой константой. Многие компиляторы, предшествовавшие стандарту С, помещают строковые константы в сегмент данных вместе с обычными глобальными переменными. Хотя в исходном коде они определены как константы, их можно переписать, таким образом, нередко встречался такой код:</p>
       <p><code>/* Код в старом стиле: не используйте его */</code></p>
       <p><code>char *tfile = mktemp("/tmp/myprogXXXXXX");</code></p>
       <p><code>/* ...использование файла... */</code></p>
       <p>На современных системах такой код. вероятно, завершится неудачей, в наши дни строковые константы находятся в сегментах памяти только для чтения.</p>
      </cite>
      <p>Использование этих функций довольно просто. Файл <code>ch12-mktemp.c</code> демонстрирует <code>mktemp()</code>; нетрудно изменить его для использования других функций:</p>
      <p><code>1  /* ch12-mktemp.с --- демонстрирует простое использование mktemp().</code></p>
      <p><code>2     Для краткости проверка ошибок опущена */</code></p>
      <p><code>3</code></p>
      <p><code>4  #include &lt;stdio.h&gt;</code></p>
      <p><code>5  #include &lt;fcntl.h&gt; /* для флагов открытия */</code></p>
      <p><code>6  #include &lt;limits.h&gt; /* для PATH_MAX */</code></p>
      <p><code>7</code></p>
      <p><code>8  int main(void)</code></p>
      <p><code>9  {</code></p>
      <p><code>10  static char template[] = "/tmp/myfileXXXXXX";</code></p>
      <p><code>11  char fname[PATH_MAX];</code></p>
      <p><code>12  static char mesg[] =</code></p>
      <p><code>13   "Here's lookin' at you, kid'\n"; /* вместо "hello, world" */</code></p>
      <p><code>14  int fd;</code></p>
      <p><code>15</code></p>
      <p><code>16  strcpy(fname, template);</code></p>
      <p><code>17  mktemp(fname);</code></p>
      <p><code>18</code></p>
      <p><code>19  /* ОКНО СОСТОЯНИЯ ГОНКИ ОТКРЫВАЕТСЯ */</code></p>
      <p><code>20</code></p>
      <p><code>21  printf("Filename is %s\n", fname);</code></p>
      <p><code>22</code></p>
      <p><code>23  /* ОКНО СОСТОЯНИЯ ГОНКИ ТЯНЕТСЯ ДОСЮДА */</code></p>
      <p><code>24</code></p>
      <p><code>25  fd = open(fname, O_CREAT|O_RDWR|O_TRUNC, 0600);</code></p>
      <p><code>26  write(fd, mesg, strlen(mesg));</code></p>
      <p><code>27  close(fd);</code></p>
      <p><code>28</code></p>
      <p><code>29  /* unlink(fname); */</code></p>
      <p><code>30</code></p>
      <p><code>31  return 0;</code></p>
      <p><code>32 }</code></p>
      <p>Переменная <code>template</code> (строка 10) определяет шаблон имени файла; '<code>ХХХХХХ</code>' будет заменен уникальным значением. Строка 16 копирует шаблон в <code>fname</code>, которая не является константой: ее можно изменить. Строка 18 вызывает <code>mktemp()</code> для генерирования имени файла, а строка 21 выводит ее, так, чтобы мы могли видеть, что это такое. (Вскоре мы объясним комментарии в строках 19 и 23.)</p>
      <p>Строка 25 открывает файл, создавая его при необходимости. Строка 26 записывает сообщение в <code>mesg</code>, а строка 27 закрывает файл. В программе, в которой файл должен быть удален после завершения работы с ним, строка 29 была бы не закомментирована. (Иногда временный файл не следует удалять; например, если файл после полной записи будет переименован.) Мы закомментировали ее, чтобы можно было запустить эту программу и посмотреть на файл впоследствии. Вот что происходит при запуске программы:</p>
      <p><code>$ <strong>ch12-mktemp</strong> /* Запуск программы */</code></p>
      <p><code>Filename is /tmp/myfileQES4WA /* Вывод имени файла */</code></p>
      <p><code>$ <strong>cat /tmp/myfileQES4WA</strong></code></p>
      <p><code>Here's lookin' at you, kid' /* Содержит то, что ожидалось */</code></p>
      <p><code>$ <strong>ls -l /tmp/myfileQES4WA</strong> /* To же с владельцем и доступом */</code></p>
      <p><code>-rw------- 1 arnold devel 28 Sep 18 09:27 /tmp/myfileQES4WA</code></p>
      <p><code>$ <strong>rm /tmp/myfileQES4WA</strong> /* Удалить его */</code></p>
      <p><code>$ <strong>ch12-mktemp</strong> / * Используется ли повторно то же имя? */</code></p>
      <p><code>Filename is /tmp/myfileic7xCy /* Нет. Это хорошо */</code></p>
      <p><code>$ <strong>cat /tmp/myfileic7xCy</strong> /* Снова проверить содержание */</code></p>
      <p><code>Here's lookin' at you, kid!</code></p>
      <p><code>$ <strong>ls -l /tmp/myfileic7xCy</strong> /* Снова проверить владельца и доступ */</code></p>
      <p><code>-rw------- 1 arnold devel 28 Sep 18 09:28 /tmp/myfileic7xCy</code></p>
      <p>Все кажется работающим замечательно, <code>mktemp()</code> возвращает уникальное имя, <code>ch12-mktemp</code> создает файл с нужными правами доступа, и содержание то самое, которое ожидалось. Так в чем же проблема со всеми этими функциями?</p>
      <p>Исторически <code>mktemp()</code> использовала простой, <emphasis>предсказуемый</emphasis> алгоритм для создания замещающих символов для '<code>ХХХХХХ</code>' в шаблоне. Более того, интервал между временем, когда <emphasis>генерируется</emphasis> имя файла, и временем, когда создается сам файл, создает состояние гонки.</p>
      <p>Как? Ну, Linux и Unix являются системами с <emphasis>квантованием времени</emphasis>, методикой, которая разделяет время процессора между всеми исполняющимися процессами. Это означает, что, хотя программа <emphasis>кажется</emphasis> выполняющейся все время, в действительности есть моменты, когда процессы <emphasis>спят</emphasis>, т.е. ожидают выполнения на процессоре.</p>
      <p>Теперь рассмотрите программу профессора для отслеживания оценок студентов. Как профессор, так и злоумышленный студент в одно и то же время используют сильно нагруженную многопользовательскую систему. Программа профессора использует для создания временных файлов <code>mktemp()</code>, видевший в прошлом, как оценивающая программа создает и удаляет временные файлы, выяснил алгоритм, который использует <code>mktemp()</code>. (В версии GLIBC нет этой проблемы, но не все системы используют GLIBC!) Рис 12.2 иллюстрирует состояние гонки и то, как студент его использует.</p>
      <image l:href="#img_26.jpeg"/>
      <p><strong>Рис. 12.2</strong>. Состояние гонки с <code>mktemp()</code></p>
      <p>Вот что случилось.</p>
      <p>1. Оценивающая программа использует <code>mktemp()</code> для создания имени файла. По возвращении из <code>mktemp()</code> открыто окно состояния гонки (строка 19 в <code>ch12-.mktemp.c</code>).</p>
      <p>2. Ядро останавливает оценивающую программу, чтобы могли поработать другие программы в системе. Это происходит до вызова <code>open()</code>.</p>
      <p>Пока оценивающая программа остановлена, студент создает файл с тем же самым именем, которое вернула <code>mktemp()</code>. (Помните, выяснить алгоритм было просто.) Студент создает файл с дополнительной ссылкой, так что когда оценивающая программа удаляет файл, он все еще будет доступен для прочтения.</p>
      <p>3. Теперь оценивающая программа открывает файл и записывает в него данные. Студент создал файл с правами доступа <code>-rw-rw-rw-</code>, поэтому это не представляет проблему.</p>
      <p>4. Когда оценивающая программа завершает работу, она удаляет временный файл. Однако, у студента все еще есть копия. Например, может быть возможность получения прибыли при заблаговременной продаже своим товарищам их оценок.</p>
      <p>Наш пример упрощенный; помимо простого похищения данных с оценками умный (хотя и аморальный) студент мог бы вместо этого <emphasis>изменить</emphasis> данные. Если бы профессор не проверял результаты работы своей программы дважды, никто бы ничего не узнал.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Мы не рекомендуем делать что-либо из этого! Если вы студент, не пытайтесь сделать что-либо подобное. Первое и самое главное, это неэтично. Во-вторых, вас могут выгнать из школы. В-третьих, ваши профессора, наверное, не сталь наивны, чтобы использовать <code>mktemp()</code> в своих программах. Этот пример лишь для иллюстрации!</p>
      </cite>
      <p>По приведенным и другим причинам, все три описанные в данном разделе функции не следует никогда использовать. Они существуют в POSIX и GLIBC лишь для поддержки старых программ, которые были написаны до того, как была осознана опасность этих процедур С этой целью системы GNU/Linux генерируют во время компоновки сообщение:</p>
      <p><code>$ <strong>cc ch12-mktemp.c -о ch12-mktemp</strong> /* Компилировать программу */</code></p>
      <p><code>/tmp/cc1XCvD9.о(.text+0x35): In function 'main':</code></p>
      <p><code>: the use of 'mktemp' is dangerous, better use 'mkstemp'</code></p>
      <p>(Мы рассмотрим <code>mkstemp()</code> в следующем подразделе.)</p>
      <p>Если бы в вашей системе не было <code>mkstemp()</code>, подумайте, как вы могли бы использовать эти интерфейсы для ее эмулирования. (См. также «Упражнения» для главы 12 в конце.)</p>
     </section>
     <section>
      <title>
       <p>12.3.2. Создание и открывание временных файлов (хорошо)</p>
      </title>
      <p>Есть две функции, не имеющие проблем состояния гонки. Одна из них предназначена для использования с библиотекой <code>&lt;stdio.h&gt;</code>:</p>
      <p><code>#include &lt;stdio.h&gt; /* ISO С */</code></p>
      <empty-line/>
      <p><code>FILE *tmpfile(void);</code></p>
      <p>Другая функция для использования с системными вызовами на основе дескрипторов файлов:</p>
      <p><code>#include &lt;stdio.h&gt; /* XSI */</code></p>
      <empty-line/>
      <p><code>int mkstemp(char* template);</code></p>
      <p><code>tmpfile()</code> возвращает значение <code>FILE*</code>, представляющее уникальный открытый временный файл. Файл открывается в режиме "<code>w+b</code>". <code>w+</code> означает «открыть для чтения и записи, сначала урезав файл», a b означает двоичный, а не текстовый режим. (На системах GNU/Linux или Unix нет разницы, но на других системах есть.) Файл автоматически удаляется, когда закрывается указатель файла; нет способа получить имя файла, чтобы сохранить его содержимое. Программа в <code>ch12-tmpfile.c</code> демонстрирует <code>tmpfile()</code>:</p>
      <p><code>/* ch12-tmpfile.с --- демонстрация tmpfile().</code></p>
      <p><code>   Проверка ошибок для краткости опущена */</code></p>
      <p><code>#include &lt;stdio.h&gt;</code></p>
      <empty-line/>
      <p><code>int main(void) {</code></p>
      <p><code> static char mesg[] =</code></p>
      <p><code>  "Here's lookin' at you, kid!"; /* заменяет "hello, world" */</code></p>
      <p><code> FILE *fp;</code></p>
      <p><code> char buf[BUFSIZ];</code></p>
      <empty-line/>
      <p><code> fp = tmpfile();                 /* Получить временный файл */</code></p>
      <p><code> fprintf(fp, "%s", mesg);        /* Записать s него */</code></p>
      <p><code> fflush(fp);                     /* Сбросить на диск */</code></p>
      <p><code> rewind(fp);                     /* Перейти в начало */</code></p>
      <p><code> fgets(buf, sizeof buf, fp);     /* Прочесть содержимое */</code></p>
      <p><code> printf("Got back &lt;%s&gt;\n", buf); /* Вывести полученные данные */</code></p>
      <p><code> fclose(fp);                     /* Закрыть файл, закончить */</code></p>
      <p><code> return 0;                       /* Все сделано */</code></p>
      <p><code>}</code></p>
      <p>Возвращенное значение <code>FILE*</code> не отличается от любого другого <code>FILE*</code>, возвращенного <code>fopen()</code>. При запуске получаем ожидавшиеся результаты:</p>
      <p><code>$ <strong>ch12-tmpfile</strong></code></p>
      <p><code>Got back &lt;Here's lookin' at you, kid!&gt;</code></p>
      <p>Ранее мы видели, что авторы GLIBC рекомендуют использование функции <code>mkstemp()</code>:</p>
      <p><code>$ <strong>cc ch12-mktemp.с -о ch12-mktemp</strong> /* Компилировать программу */</code></p>
      <p><code>/tmp/cc1XCvD9.о(.text+0x35): In function "main':</code></p>
      <p><code>: the use of 'mktemp' is dangerous, better use 'mkstemp'</code></p>
      <p>Эта функция похожа на <code>mktemp()</code> в том, что она принимает имя файла, оканчивающееся на '<code>ХХХХХХ</code>', и заменяет эти символы уникальным суффиксом для создания уникального имени файла. Однако, она идет на один шаг дальше. Она <emphasis>создает и открывает файл</emphasis>. Файл создается с доступом 0600 (т.е. <code>-rw-------</code>). Таким образом, доступ к файлу может получить только пользователь, запустивший программу.</p>
      <p>Более того, и это то, что делает <code>mkstemp()</code> более безопасной, файл создается с флагом <code>O_EXCL</code>, который гарантирует, что файл не существует, и не дает никому больше открыть файл.</p>
      <p>Возвращаемое значение является дескриптором открытого файла, который может использоваться для чтения и записи. Для удаления файла после завершения работы с ним должно использоваться имя пути, сохраненное теперь в переданном <code>mkstemp()</code> буферу. Все это демонстрируется в <code>ch12-mkstemp.c</code>, который является простой модификацией <code>ch12-tmpfile.с</code>:</p>
      <p><code>/* ch12-mkstemp.с --- демонстрирует mkstemp().</code></p>
      <p><code>   Проверка ошибок для краткости опущена */</code></p>
      <p><code>#include &lt;stdio.h&gt;</code></p>
      <p><code>#include &lt;fcntl.h&gt; /* для флагов открытия */</code></p>
      <p><code>#include &lt;limits.h&gt; /* для PATH_МАХ */</code></p>
      <empty-line/>
      <p><code>int main(void) {</code></p>
      <p><code> static char template[] = "/tmp/myfileXXXXXX";</code></p>
      <p><code> char fname[PATH_MAX];</code></p>
      <p><code> static char mesg[] =</code></p>
      <p><code>  "Here's lookin' at you, kid!\n"; /* заменяет "hello, world" */</code></p>
      <p><code> int fd;</code></p>
      <p><code> char buf[BUFSIZ];</code></p>
      <p><code> int n;</code></p>
      <empty-line/>
      <p><code> strcpy(fname, template);           /* Копировать шаблон */</code></p>
      <p><code> fd = mkstemp(fname);               /* Создать и открыть временный файл */</code></p>
      <p><code> printf("Filename is %s\n", fname); /* Вывести его для сведений */</code></p>
      <p><code> write(fd, mesg, strlen(mesg));     /* Что-нибудь записать в файл */</code></p>
      <p><code> lseek(fd, 0L, SEEK_SET);           /* Перейти в начало */</code></p>
      <p><code> n = read(fd, buf, sizeof(buf));</code></p>
      <p><code>  /* Снова прочесть данные; НЕ завышается '\0'! */</code></p>
      <p><code> printf("Got back: %.*s", n, buf);  /* Вывести его для проверки */</code></p>
      <p><code> close(fd);                         /* Закрыть файл */</code></p>
      <p><code> unlink(fname);                     /* Удалить его */</code></p>
      <p><code> return 0;</code></p>
      <p><code>}</code></p>
      <p>При запуске получаем ожидавшиеся результаты:</p>
      <p><code>$ <strong>ch12-mkstemp</strong></code></p>
      <p><code>Filename is /tmp/myfileuXFWIN</code></p>
      <p><code>Got back: Here's lookin' at you, kid!</code></p>
     </section>
     <section>
      <title>
       <p>12.3.3. Использование переменной окружения <code>TMPDIR</code></p>
      </title>
      <p>Многие стандартные утилиты обращают внимание на переменную окружения <code>TMPDIR</code>, используя обозначенный в ней каталог в качестве места для помещения временных файлов. Если <code>TMPDIR</code> не установлена, каталогом по умолчанию для временных файлов обычно является <code>/tmp</code>, хотя на многих современных системах есть также и каталог <code>/var/tmp</code>. <code>/tmp</code> обычно очищается от всех файлов и каталогов административными сценариями оболочки при запуске.</p>
      <p>Многие системы GNU/Linux предоставляют каталог <code>/dev/shm</code>, использующий файловую систему типа <code>tmpfs:</code></p>
      <p><code>$ <strong>df</strong></code></p>
      <p><code>Filesystem 1K-blocks     Used Available Use% Mounted on</code></p>
      <p><code>/dev/hda2    6198436  5136020    747544  88% /</code></p>
      <p><code>/dev/hda5   61431520 27720248  30590648  48% /d</code></p>
      <p><code>none          256616        0    256616   0% /dev/shm</code></p>
      <p>Тип файловой системы <code>tmpfs</code> предоставляет <emphasis>электронный (RAM) диск</emphasis>: часть памяти, которая используется, как если бы она была диском. Более того, файловая система <code>tmpfs</code> использует механизмы виртуальной памяти ядра Linux для его увеличения сверх фиксированного размера. Если на вашей системе уйма оперативной памяти, этот подход может обеспечить заметное ускорение. Чтобы протестировать производительность, мы начали с файла <code>/usr/share/dict/linux.words</code>, который является отсортированным списком правильно написанных слов, по одному в строке. Затем мы перемешали этот файл, так что он больше не был сортированным, и создали больший файл, содержащий 500 копий спутанной версии файла:</p>
      <p><code>$ <strong>ls -l /tmp/randwords.big</strong> /* Показать размер */</code></p>
      <p><code>-rw-r--r-- 1 arnold devel 204652500 Sep 18 16:02 /tmp/randwords.big</code></p>
      <p><code>$ <strong>wc -l /tmp/randwords.big</strong> /* Сколько слов? */</code></p>
      <p><code>22713500 /tmp/randwords.big /* Свыше 22 миллионов! */</code></p>
      <p>Затем мы отсортировали файл, используя сначала каталог <code>/tmp</code>, а затем с <code>TMPDIR</code>, установленным в <code>/dev/shm</code><a l:href="#n125" type="note">[125]</a>:</p>
      <p><code>$ <strong>time sort /tmp/randwords.big &gt; /dev/null</strong></code></p>
      <p><code> /* Использование реальных файлов */</code></p>
      <p><code>real 1m32.566s</code></p>
      <p><code>user 1m23.137s</code></p>
      <p><code>sys 0m1.740s</code></p>
      <p><code>$ <strong>time TMPDIR=/dev/shm sort /tmp/randwords.big &gt; /dev/null</strong></code></p>
      <p><code> /* Использование электронного диска */</code></p>
      <p><code>real 1m28.257s</code></p>
      <p><code>user 1m18.469s</code></p>
      <p><code>sys 0m1.602s</code></p>
      <p>Интересно, использование электронного диска было лишь незначительно быстрее, чем использование обычных файлов. (В некоторых дальнейших тестах оно было даже в действительности медленнее!) Мы предполагаем, что в игру вступил буферный кэш ядра (см. раздел 4.6.2 «Создание файлов с помощью <code>creat()</code>»), весьма эффективно ускоряя файловый ввод/вывод<a l:href="#n126" type="note">[126]</a>.</p>
      <p>У электронного диска есть важный недостаток: он ограничен сконфигурированным для вашей системы размером <emphasis>пространства для подкачки</emphasis>.<a l:href="#n127" type="note">[127]</a> Когда мы попытались отсортировать файл, содержащий 1000 копий файла с перемешанными словами, место на электронном диске закончилось, тогда как обычный sort завершился благополучно.</p>
      <p>Использовать TMPDIR для своих программ просто. Мы предлагаем следующую схему.</p>
      <p><code>const char template[] = "myprog.XXXXXX";</code></p>
      <p><code>char *tmpdir, *tfile;</code></p>
      <p><code>size_t count;</code></p>
      <p><code>int fd;</code></p>
      <p><code>if ((tmpdir = getenv("TMPDIR")) == NULL)</code></p>
      <p><code> /* Использовать значение TMPDIR, если имеется */</code></p>
      <p><code> tmpdir = "/tmp"; /* В противном случае, /tmp по умолчанию */</code></p>
      <p><code>count = strlen(tmpdir) + strlen(template) + 2;</code></p>
      <p><code> /* Вычислить размер имени файла */</code></p>
      <p><code>tfile = (char *)malloc(count); /* Выделить для него память */</code></p>
      <p><code>if (tfile == NULL) /* Проверка ошибок */</code></p>
      <p><code> /* восстановить */</code></p>
      <p><code>sprintf(tfile, "%s/%s", tmpdir, template);</code></p>
      <p><code> /* Создать завершающий шаблон */</code></p>
      <p><code>fd = mkstemp(tfile); /* Создать и открыть файл */</code></p>
      <p><code>/* ...использование tempfile через fd... */</code></p>
      <p><code>close(fd); /* Очистка */</code></p>
      <p><code>unlink(tfile);</code></p>
      <p><code>free(tfile);</code></p>
      <p>В зависимости от потребностей вашего приложения, вы можете захотеть немедленно удалить файл после его открытия, вместо его удаления как части завершающей очистки.</p>
     </section>
    </section>
    <section>
     <title>
      <p>12.4. Совершение самоубийства: <code>abort()</code></p>
     </title>
     <p>Бывают моменты, когда программа просто не может продолжаться. Обычно лучше всего при этом выдать сообщение об ошибке и вызвать <code>exit()</code>. Однако, особенно для ошибок, являющихся проблемами программирования, полезно не только завершиться, но и создать дамп ядра, который сохраняет в файле состояние работающей программы для последующего исследования в отладчике. В этом заключается работа функции <code>abort()</code>:</p>
     <p><code>#include &lt;stdlib.h&gt; /* ISO С */</code></p>
     <empty-line/>
     <p><code>void abort(void);</code></p>
     <p>Функция <code>abort()</code> посылает сигнал <code>SIGABRT</code> самому процессу. Это случится, даже если <code>SIGABRT</code> заблокирован или игнорируется. После этого осуществляется обычное для <code>SIGABRT</code> действие, которое заключается в создании дампа ядра.</p>
     <p>Примером <code>abort()</code> в действии является макрос <code>assert()</code>, описанный в начале данной главы. Когда <code>assert()</code> обнаруживает, что его выражение ложно, он выводит сообщение об ошибке, а затем вызывает <code>abort()</code> для создания дампа ядра.</p>
     <p>В соответствии со стандартом С, осуществляет <code>abort()</code> очистку или нет, зависит от реализации. Под GNU/Linux она выполняет очистку: все потоки <code>&lt;stdio.h&gt; FILE*</code> перед завершением программы закрываются. Обратите, однако, внимание, что для открытых файлов, использующих системные вызовы на основе дескрипторов файлов, ничего не делается. (Если открыты лишь файлы или каналы, ничего не нужно делать. Хотя мы не обсуждали это, дескрипторы файлов используются также для сетевых соединений, и оставление их открытыми является плохой практикой.)</p>
    </section>
    <section>
     <title>
      <p>12.5. Нелокальные переходы</p>
     </title>
     <epigraph>
      <p>«Идите прямо в тюрьму. Не проходите GO. Не забирайте 200$».</p>
      <text-author>- Монополия -</text-author>
     </epigraph>
     <section>
      <p>Вы, без сомнения, знаете, чем является <code>goto</code>: передачей потока управления на метку где-то в текущей функции. Операторы <code>goto</code> при скупом употреблении могут послужить удобочитаемости и правильности функции (Например, когда все проверки ошибок используют <code>goto</code> для перехода на метку в конце функции, такую, как <code>clean_up</code>, код с этой меткой проводит очистку [закрывая файлы и т.п.] и возвращается.) При плохом использовании операторы <code>goto</code> могут привести к так называемой «лапше» в коде, логику которого становится невозможно отследить.</p>
      <p>Оператор <code>goto</code> в языке С ограничен переходом на метку в текущей функции. Многие языки в семействе Алгола, такие, как Паскаль, допускают использование <code>goto</code> для выхода из вложенной функции в предшествующую вызывающую функцию. Однако в С нет способа, в пределах синтаксиса самого языка, перейти в определенную точку другой функции, пусть даже и вызывающей. Такой переход называется <emphasis>нелокальным переходом</emphasis>.</p>
      <p>Почему полезен нелокальный переход? Рассмотрите интерактивную программу, которая считывает и выполняет программы. Предположим, пользователь запускает длительное задание, разочаровывается или меняет мнение о данном задании и нажимает CTRL-С для генерирования сигнала <code>SIGINT</code>. Когда запускается обработчик сигнала, он может перейти обратно в начало главного цикла чтения и обработки команд. Строковый редактор ed представляет простой пример этого:</p>
      <p><code>$ <strong>ed -p '&gt; ' sayings</strong> /* Запуск ed, '&gt; ' используется как приглашение */</code></p>
      <p><code>sayings: No such file or directory</code></p>
      <p><code>&gt; <strong>a</strong> /* Добавить текст */</code></p>
      <p><code>Hello, world</code></p>
      <p><code>Don't panic</code></p>
      <p><code><strong>^C</strong> /* Сгенерировать SIGINT */</code></p>
      <p><code>? /* Сообщение об ошибке ''один размер подходит всем'' */</code></p>
      <p><code>&gt; <strong>1,$p</strong> /* ed возвращается в командную строку */</code></p>
      <p><code>Hello, world /* '1,$p' prints all the lines */</code></p>
      <p><code>Don't panic</code></p>
      <p><code>&gt; <strong>w</strong> /* Сохранить файл */</code></p>
      <p><code>25</code></p>
      <p><code>&gt; <strong>q</strong> /* Все сделано */</code></p>
      <p>Внутри себя <code>ed</code> устанавливает перед циклом команд точку возврата, и обработчик сигнала осуществляет нелокальный переход на эту точку возврата.</p>
     </section>
     <section>
      <title>
       <p>12.5.1. Использование стандартных функций: <code>setjmp()</code> и <code>longjmp()</code></p>
      </title>
      <p>Нелокальные переходы осуществляются с помощью функций <code>setjmp()</code> и <code>longjmp()</code>. Эти функции используются в двух разновидностях. Традиционные процедуры определены стандартом ISO С:</p>
      <p><code>#include &lt;setjmp.h&gt; /* ISO С */</code></p>
      <empty-line/>
      <p><code>int setjmp(jmp_buf env);</code></p>
      <p><code>void longjmp(jmp_buf env, int val);</code></p>
      <p>Тип <code>jmp_buf</code> определен через <code>typedef</code> в <code>&lt;setjmp.h&gt;</code>. <code>setjmp()</code> сохраняет текущее «окружение» в <code>env</code>. <code>env</code> обычно является глобальной или статической на уровне файла переменной, так что она может использоваться из вызванной функции. Это окружение включает любую информацию, необходимую для перехода на местоположение, из которого была вызвана <code>setjmp()</code>. Содержание <code>jmp_buf</code> по своей природе машинно-зависимо; таким образом, <code>jmp_buf</code> является непрозрачным типом: тем, что вы используете, не зная, что находится внутри него.</p>
      <p><code>setjmp()</code> возвращает 0, когда она вызывается для сохранения в <code>jmp_buf</code> текущего окружения. Ненулевое значение возвращается, когда с использованием окружения осуществляется нелокальный переход:</p>
      <p><code>jmp_buf command_loop; /* На глобальном уровне */</code></p>
      <p><code>/* ... затем в main() ... */</code></p>
      <p><code>if (setjmp(command_loop) == 0) /* Состояние сохранено, продолжить */</code></p>
      <p><code> ;</code></p>
      <p><code>else /* Мы попадаем сюда через нелокальный переход */</code></p>
      <p><code> printf("?\n"); /* ed's famous message */</code></p>
      <p><code>/* ... теперь начать цикл команд ... */</code></p>
      <p><code>longjmp()</code> осуществляет переход. Первым параметром является <code>jmp_buf</code>, который должен быть инициализирован с помощью <code>setjmp()</code>. Второй является целым <emphasis>ненулевым</emphasis> значением, которое <code>setjmp()</code> возвращает в первоначальное окружение. Это сделано так, что код, подобный только что показанному, может различить установку окружения и прибытие путем нелокального перехода.</p>
      <p>Стандарт С утверждает, что даже если <code>longjmp()</code> вызывается со вторым аргументом, равным 0, <code>setjmp()</code> по-прежнему возвращает ненулевое значение. В таком случае она возвращает 1.</p>
      <p>Возможность передать целое значение и вернуться обратно из <code>setjmp()</code> полезна; это позволяет коду уровня пользователя различать причину перехода. Например, <code>gawk</code> использует эту возможность для обработки операторов <code>break</code> и <code>continue</code> внутри циклов. (Язык awk осознанно сделан похожим на С в своем синтаксисе для циклов, с использованием <code>while</code>, <code>do-while</code>, <code>for</code>, <code>break</code> и <code>continue</code>.) Использование <code>setjmp()</code> выглядит следующим образом (из <code>eval.c</code> в дистрибутиве <code>gawk</code> 3.1.3):</p>
      <p><code>507 case Node_K_while:</code></p>
      <p><code>508  PUSH_BINDING(loop_tag_stack, loop_tag, loop_tag_valid);</code></p>
      <p><code>509</code></p>
      <p><code>510  stable_tree = tree;</code></p>
      <p><code>511  while (eval_condition(stable_tree-&gt;lnode)) {</code></p>
      <p><code>512   INCREMENT(stable_tree-&gt;exec_count);</code></p>
      <p><code>513   switch (setjmp(loop_tag)) {</code></p>
      <p><code>514   case 0: /* обычный не переход */</code></p>
      <p><code>515    (void)interpret(stable_tree-&gt;rnode);</code></p>
      <p><code>516    break;</code></p>
      <p><code>517   case TAG_CONTINUE: /* оператор continue */</code></p>
      <p><code>518    break;</code></p>
      <p><code>519   case TAG_BREAK: /* оператор break */</code></p>
      <p><code>520    RESTORE_BINDING(loop_tag_stack, loop_tag, loop_tag_valid);</code></p>
      <p><code>521    return 1;</code></p>
      <p><code>522   default:</code></p>
      <p><code>523    cant_happen();</code></p>
      <p><code>524   }</code></p>
      <p><code>525  }</code></p>
      <p><code>526  RESTORE_BINDING(loop_tag_stack, loop_tag, loop_tag_valid);</code></p>
      <p><code>527  break;</code></p>
      <p>Этот фрагмент кода представляет цикл <code>while</code>. Строка 508 управляет вложенными циклами посредством стека сохраненных переменных <code>jmp_buf</code>. Строки 511–524 выполняют цикл <code>while</code> (используя цикл С <code>while</code>!). Строка 511 проверяет условие цикла. Если оно истинно, строка 513 выполняет <code>switch</code> на возвращаемое значение <code>setjmp()</code>. Если оно равно 0 (строки 514–516), строка 515 выполняет тело оператора. Однако, когда <code>setjmp()</code> возвращает <code>TAG_BREAK</code> или <code>TAG_CONTINUE</code>, оператор <code>switch</code> обрабатывает их соответствующим образом (строки 517–518 и 519–521 соответственно).</p>
      <p>Оператор <code>break</code> на уровне <code>awk</code> передает <code>TAG_BREAK</code> функции <code>longjmp()</code>, a <code>continue</code> уровня <code>awk</code> передает <code>TAG_CONTINUE</code>. Снова из <code>eval.c</code> с некоторыми пропущенными не относящимися к делу подробностями:</p>
      <p><code>657 case Node_K_break:</code></p>
      <p><code>658  INCREMENT(tree-&gt;exec_count);</code></p>
      <p><code>     /* ... */</code></p>
      <p><code>675  longjmp(loop_tag, TAG_BREAK);</code></p>
      <p><code>676  break;</code></p>
      <p><code>677</code></p>
      <p><code>678 case Node_K_continue:</code></p>
      <p><code>679  INCREMENT(tree-&gt;exec_count);</code></p>
      <p><code>     /* ... */</code></p>
      <p><code>696  longjmp(loop_tag, TAG_CONTINUE);</code></p>
      <p><code>670  break;</code></p>
      <p>Вы можете думать о <code>setjmp()</code> как об установке метки, а о <code>longjmp()</code> как выполнении <code>goto</code> с дополнительным преимуществом возможности сказать, откуда «пришел» код (по возвращаемому значению).</p>
     </section>
     <section>
      <title>
       <p>12.5.2. Обработка масок сигналов: <code>sigsetjmp()</code> и <code>siglongjmp()</code></p>
      </title>
      <p>По историческим причинам, которые, скорее всего, утомили бы вас до слез, стандарт С 1999 г. ничего не говорит о влиянии <code>setjmp()</code> и <code>longjmp()</code> на состояние сигналов процесса, а POSIX явно констатирует, что их влияние на маску сигналов процесса (см. раздел 10.6 «Сигналы POSIX») не определено.</p>
      <p>Другими словами, если программа изменяет свою маску сигналов процесса между первым вызовом <code>setjmp()</code> и вызовом <code>longjmp()</code>, каково состояние маски сигналов процесса после <code>longjmp()</code>? Та ли эта маска, когда была впервые вызвана <code>setjmp()</code>? Или это текущая маска? POSIX явно утверждает, что «нет способа это узнать».</p>
      <p>Чтобы сделать обработку маски сигналов процесса явной, POSIX ввел две дополнительные функции и один <code>typedef</code>:</p>
      <p><code>#include &lt;setjmp.h&gt; /* POSIX */</code></p>
      <empty-line/>
      <p><code>int sigsetjmp(sigjmp_buf env, int savesigs); /* Обратите внимание:</code></p>
      <p><code>                                        sigjmp_buf, не jmp_buf! */</code></p>
      <p><code>void siglongjmp(sigjmp_buf env, int val);</code></p>
      <p>Главным отличием является аргумент <code>savesigs</code> функции <code>sigsetjmp()</code>. Если он не равен нулю, текущий набор заблокированных сигналов сохраняется в <code>env</code> вместе с остальным окружением, которое сохраняется функцией <code>setjmp()</code>. <code>siglongjmp()</code> с <code>env</code>, в которой <code>savesigs</code> содержала true, восстанавливает сохраненную маску сигналов процесса</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. POSIX также ясен в том, что если <code>savesigs</code> равен нулю (false), сохраняется ли маска сигналов процесса или восстанавливается, не определено, как в случае с <code>setjmp()</code>/<code>longjmp()</code>. Это, в свою очередь, предполагает, что если собираетесь использовать '<code>sigsetjmp(env, 0)</code>', вы также можете не беспокоиться: все дело в том, чтобы иметь контроль над сохранением и восстановлением маски сигналов процесса!</p>
      </cite>
     </section>
     <section>
      <title>
       <p>12.5.3. Важные предостережения</p>
      </title>
      <p>Есть несколько технических предостережений, о которых нужно знать.</p>
      <p>Во-первых, поскольку сохранение и восстановление среды может быть беспорядочной машинно-зависимой задачей, <code>setjmp()</code> и <code>longjmp()</code> могут быть макросами</p>
      <p>Во-вторых, стандарт С ограничивает использование <code>setjmp()</code> следующими ситуациями.</p>
      <p>• В качестве единственного контролирующего выражения в операторе цикла или условном операторе (<code>if</code>, <code>switch</code>).</p>
      <p>• В качестве одного операнда выражения сравнения (<code>==</code>, <code>&lt;</code> и т.д.), с целой константой в качестве другого операнда. Выражение сравнения может быть единственный контролирующим выражением цикла или условного оператора.</p>
      <p>• В качестве операнда унарного оператора '<code>!</code>', причем результирующее выражение является единственным контролирующим выражением цикла или условного оператора.</p>
      <p>• В качестве всего выражения оператора-выражения, возможно, приведенного к типу <code>void</code>. Например:</p>
      <p><code>(void)setjmp(buf);</code></p>
      <p>В-третьих, если вы хотите изменить локальную переменную в функции, которая вызывает <code>setjmp()</code>, <emphasis>после</emphasis> вызова и хотите, чтобы эта переменная сохранила свое последнее присвоенное после <code>longjmp()</code> значение, нужно объявить эту переменную как <code>volatile</code>. В противном случае все локальные переменные, не являющиеся <code>volatile</code> и изменившиеся после того, как была первоначально вызвана <code>setjmp()</code>, имеют неопределенные значения. (Обратите внимание, что сама переменная <code>jmp_buf</code> не должна объявляться как <code>volatile</code>.) Например:</p>
      <p><code>1  /* ch12-setjmp.с --- демонстрирует setjmp()/longjmp() и volatile. */</code></p>
      <p><code>2</code></p>
      <p><code>3  #include &lt;stdio.h&gt;</code></p>
      <p><code>4  #include &lt;setjmp.h&gt;</code></p>
      <p><code>5</code></p>
      <p><code>6  jmp_buf env;</code></p>
      <p><code>7</code></p>
      <p><code>8  /* comeback --- выполнение longjmp */</code></p>
      <p><code>9</code></p>
      <p><code>10 void comeback(void)</code></p>
      <p><code>11 {</code></p>
      <p><code>12  longjmp(env, 1);</code></p>
      <p><code>13  printf("This line is never printed\n");</code></p>
      <p><code>14 }</code></p>
      <p><code>15</code></p>
      <p><code>16 /* main - вызов setjmp, действия с переменными, вывод значений */</code></p>
      <p><code>17</code></p>
      <p><code>18 int main(void)</code></p>
      <p><code>19 {</code></p>
      <p><code>20  int i = 5;</code></p>
      <p><code>21  volatile int j = 6;</code></p>
      <p><code>22</code></p>
      <p><code>23  if (setjmp(env) == 0) { /* первый раз */</code></p>
      <p><code>24   i++;</code></p>
      <p><code>25   j++;</code></p>
      <p><code>26   printf("first time: i = %d, j = %d\n", i, j);</code></p>
      <p><code>27    comeback));</code></p>
      <p><code>28  } else /* второй раз */</code></p>
      <p><code>29   printf("second time: i = %d, j = %d\n", i, j);</code></p>
      <p><code>30</code></p>
      <p><code>31  return 0;</code></p>
      <p><code>32 }</code></p>
      <p>В этом примере сохранение своего значения ко второму вызову <code>printf()</code> гарантируется <code>лишь</code> j (строка 21). Значение (строка 20) в соответствии со стандартом С 1999 г. не определено. Это может быть 6, может быть 5, а может даже какое-нибудь другое значение!</p>
      <p>В-четвертых, как описано в разделе 12.5.2 «Обработка масок сигналов: <code>sigsetjmp()</code> и <code>siglongjmp()</code>», стандарт С 1999 г. не делает никаких утверждений о влиянии, если оно есть, <code>setjmp()</code> и <code>longjmp()</code> на состояние сигналов программы. Если это важно, вам придется вместо них использовать <code>sigsetjmp()</code> и <code>siglongjmp()</code>.</p>
      <p>В-пятых, эти процедуры содержат поразительные возможности для утечек памяти! Рассмотрим программу, в которой <code>main()</code> вызывает <code>setjmp()</code>, а затем вызывает несколько вложенных функций, каждая из которых выделяет с помощью <code>malloc()</code> динамическую память. Если наиболее глубоко вложенная функция делает <code>longjmp()</code> обратно в <code>main()</code>, указатели на динамическую память теряются. Взгляните на <code>ch12-memleak.c</code>:</p>
      <p><code>1  /* ch12-memleak.с --- демонстрирует утечки памяти с помощью setjmp()/longjmp(). */</code></p>
      <p><code>2</code></p>
      <p><code>3  #include &lt;stdio.h&gt;</code></p>
      <p><code>4  #include &lt;malloc.h&gt; /* для определения ptrdiff_t в GLIBC */</code></p>
      <p><code>5  #include &lt;setjmp.h&gt;</code></p>
      <p><code>6  #include &lt;unistd.h&gt;</code></p>
      <p><code>7</code></p>
      <p><code>8  jmp_buf env;</code></p>
      <p><code>9</code></p>
      <p><code>10 void f1(void), f2(void);</code></p>
      <p><code>11</code></p>
      <p><code>12 /* main --- утечка памяти с помощью setjmp() и longjmp() */</code></p>
      <p><code>13</code></p>
      <p><code>14 int main(void)</code></p>
      <p><code>15 {</code></p>
      <p><code>16  char *start_break;</code></p>
      <p><code>17  char *current_break;</code></p>
      <p><code>18  ptrdiff_t diff;</code></p>
      <p><code>19</code></p>
      <p><code>20  start_break = sbrk((ptrdiff_t)0);</code></p>
      <p><code>21</code></p>
      <p><code>22  if (setjmp(env) == 0) /* первый раз */</code></p>
      <p><code>23   printf("setjmp called\n");</code></p>
      <p><code>24</code></p>
      <p><code>25  current_break = sbrk((ptrdiff_t) 0);</code></p>
      <p><code>26</code></p>
      <p><code>27  diff = current_break - start_break;</code></p>
      <p><code>28  printf("memsize = %ld\n", (long)diff);</code></p>
      <p><code>29</code></p>
      <p><code>30  f1();</code></p>
      <p><code>31</code></p>
      <p><code>32  return 0;</code></p>
      <p><code>33 }</code></p>
      <p><code>34</code></p>
      <p><code>35 /* f1 --- выделяет память, осуществляет вложенный вызов */</code></p>
      <p><code>36</code></p>
      <p><code>37 void f1(void)</code></p>
      <p><code>38 {</code></p>
      <p><code>39  char *p = malloc(1024);</code></p>
      <p><code>40</code></p>
      <p><code>41  f2();</code></p>
      <p><code>42 }</code></p>
      <p><code>43</code></p>
      <p><code>44 /* f2 --- выделяет память, выполняет longjmp */</code></p>
      <p><code>45</code></p>
      <p><code>46 void f2(void)</code></p>
      <p><code>47 {</code></p>
      <p><code>48  char *p = malloc(1024);</code></p>
      <p><code>49</code></p>
      <p><code>50  longjmp(env, 1);</code></p>
      <p><code>51 }</code></p>
      <p>Эта программа устанавливает бесконечный цикл, используя <code>setjmp()</code> и <code>longjmp()</code>. Строка 20 использует для нахождения текущего начала кучи <code>sbrk()</code> (см. раздел 3.2.3 «Системные вызовы: <code>brk()</code> и <code>sbrk()</code>»), а затем строка 22 вызывает <code>setjmp()</code>. Строка 25 получает текущее начало кучи; это место каждый раз изменяется, поскольку <code>longjmp()</code> повторно входит в код. Строки 27–28 вычисляют, сколько было выделено памяти, и выводят это количество. Вот что происходит при запуске:</p>
      <p><code>$ <strong>ch12-memleak</strong> /* Запуск программы */</code></p>
      <p><code>setjmp called</code></p>
      <p><code>memsize = 0</code></p>
      <p><code>memsize = 6372</code></p>
      <p><code>memsize = 6372</code></p>
      <p><code>memsize = 6372</code></p>
      <p><code>memsize = 10468</code></p>
      <p><code>memsize = 10468</code></p>
      <p><code>memsize = 14564</code></p>
      <p><code>memsize = 14564</code></p>
      <p><code>memsize = 18660</code></p>
      <p><code>memsize = 18660</code></p>
      <p><code>...</code></p>
      <p>Память утекает из программы, как через решето. Она работает до тех пор, пока не будет прервана от клавиатуры или пока не закончится память (в этом случае образуется основательный дамп ядра).</p>
      <p>Каждая из функций <code>f1()</code> и <code>f2()</code> выделяют память, a <code>f2()</code> выполняет <code>longjmp()</code> обратно в <code>main()</code> (строка 51). Когда это происходит, локальные указатели (строки 39 и 48) на выделенную память пропали! Такие утечки памяти может оказаться трудно отследить, поскольку часто выделяются небольшие размеры памяти, и как таковые, они могут оставаться незамеченными в течение ряда лет<a l:href="#n128" type="note">[128]</a>.</p>
      <p>Этот код явно патологический, но он предназначен для иллюстрации нашей мысли: <code>setjmp()</code> и <code>longjmp()</code> могут вести к трудно обнаруживаемым утечкам памяти. Предположим, что <code>f1()</code> правильно вызвал <code>free()</code>. Было бы далеко неочевидно, что память никогда не будет освобождена. В более крупной и более реалистичной программе, в которой <code>longjmp()</code> мог быть вызван лишь посредством <code>if</code>, найти такую утечку становится даже еще труднее.</p>
      <p>Таким образом, при наличии <code>setjmp()</code> и <code>longjmp()</code> динамическая память должна управляться посредством глобальных переменных, а у вас должен быть код, который обнаруживает вход через <code>longjmp()</code> (посредством проверки возвращаемого значения <code>setjmp()</code>). Такой код должен затем освободить динамически выделенную память, которая больше не нужна.</p>
      <p>В-шестых, <code>longjmp()</code> и <code>siglongjmp()</code> не следует использовать из функций, зарегистрированных посредством <code>atexit()</code> (см. раздел 9.1.5.3 «Функции завершения»).</p>
      <p>В-седьмых, <code>setjmp()</code> и <code>longjmp()</code> могут оказаться дорогими операциями на машинах с множеством регистров.</p>
      <p>При наличии всех этих проблем вы должны строго рассмотреть дизайн своей программы. Если вам не нужно использовать <code>setjmp()</code> и <code>longjmp()</code>, то, может, стоит обойтись без их использования. Однако, если их использование является лучшим способом структурировать свою программу, продолжайте и используйте их, но делайте это осмотрительно.</p>
     </section>
    </section>
    <section>
     <title>
      <p>12.6. Псевдослучайные числа</p>
     </title>
     <section>
      <p>Многим приложениям нужны последовательности случайных чисел. Например, игровые программы, имитирующие бросание костей, раздачу карт или вращение барабанов игровой машины, нуждаются в возможности случайного выбора одного из возможных значений. (Подумайте о программе <code>fortune</code>, содержащей большую коллекцию афоризмов; каждый раз при запуске она «случайно» выдает новое высказывание.) Многие криптографические алгоритмы также требуют наличия случайных чисел «высокого качества». В данном разделе описываются различные способы получения последовательностей случайных чисел.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Природа случайности, генерация случайных чисел и их «качество» являются обширными темами, выходящими за рамки данной книги. Мы предоставляем введение в доступные функции API, но это все, что мы можем сделать Другие источники с более подробной информацией см в разделе 12.9 «Рекомендуемая литература»</p>
      </cite>
      <p>Компьютеры по своему строению являются <emphasis>детерминистическими</emphasis>. Одно и то же вычисление с одними и теми же входными данными всегда должно давать одни и те же результаты. Соответственно, они не годятся для генерации истинно случайных чисел, то есть последовательностей чисел, в которых каждое число в последовательности полностью независимо от числа (или чисел), идущих перед ним. Вместо этого разновидности чисел, обычно используемых на программном уровне, называются <emphasis>псевдослучайными</emphasis> числами. То есть в любой данной последовательности номера выглядят независимыми друг от друга, но сама последовательность в целом повторяющаяся. (Эта повторяемость может быть ценным качеством; она обеспечивает детерминизм для программы в целом.)</p>
      <p>Многие методы предоставления последовательностей псевдослучайных чисел работают посредством осуществления каждый раз одного и того же вычисления с начальным значением (<emphasis>seed</emphasis>). Сохраненное начальное значение затем обновляется для использования в следующий раз. API предоставляет способ указания нового начального значения. Каждое начальное значение дает одну и ту же последовательность псевдослучайных чисел, хотя различные начальные числа дают (должны давать) различные последовательности.</p>
     </section>
     <section>
      <title>
       <p>12.6.1. Стандартный С: <code>rand()</code> и <code>srand()</code></p>
      </title>
      <p>Стандартный С определяет две связанные функции для псевдослучайных чисел.</p>
      <p><code>#include &lt;stdlib.h&gt; /* ISO С */</code></p>
      <empty-line/>
      <p><code>int rand(void);</code></p>
      <p><code>void srand(unsigned int seed);</code></p>
      <p><code>rand()</code> каждый раз после вызова возвращает псевдослучайное число в диапазоне от 0 до <code>RAND_MAX</code> (включительно, насколько мы можем судить по стандарту C99). Константа <code>RAND_MAX</code> должна быть по крайней мере 32 767; она может быть больше.</p>
      <p><code>srand()</code> дает генератору случайных чисел в качестве начального значения <code>seed</code>. Если <code>srand()</code> никогда не вызывался приложением, <code>rand()</code> ведет себя так, как если бы seed был равен 1.</p>
      <p>Следующая программа, <code>ch12-rand.c</code>, использует <code>rand()</code> для вывода граней игральных костей.</p>
      <p><code>1  /* ch12-rand.c --- генерирует игральные кости, используя rand(). */</code></p>
      <p><code>2</code></p>
      <p><code>3  #include &lt;stdio.h&gt;</code></p>
      <p><code>4  #include &lt;stdlib.h&gt;</code></p>
      <p><code>5</code></p>
      <p><code>6  char *die_faces[] = { /* Управляет ASCII графика! */</code></p>
      <p><code>7   "       ",</code></p>
      <p><code>8   "   *   ", /* 1 */</code></p>
      <p><code>9   "       ",</code></p>
      <p><code>10</code></p>
      <p><code>11  "       ",</code></p>
      <p><code>12  " *   * ", /* 2 */</code></p>
      <p><code>13  "       ",</code></p>
      <p><code>14</code></p>
      <p><code>15  "       ",</code></p>
      <p><code>16  " * * * ", /* 3 */</code></p>
      <p><code>17  "       ",</code></p>
      <p><code>18</code></p>
      <p><code>19  " *   * ",</code></p>
      <p><code>20  "       ", /* 4 */</code></p>
      <p><code>21  " *   * ",</code></p>
      <p><code>22</code></p>
      <p><code>23  " *   * ",</code></p>
      <p><code>24  "   *   ", /* 5 */</code></p>
      <p><code>25  " *    * ",</code></p>
      <p><code>26</code></p>
      <p><code>27  " * * * ",</code></p>
      <p><code>28  "       ", /* 6 */</code></p>
      <p><code>29  " * * * ",</code></p>
      <p><code>30 };</code></p>
      <p><code>31</code></p>
      <p><code>32 /* main --- выводит N различных граней костей */</code></p>
      <p><code>33</code></p>
      <p><code>34 int main(int argc, char **argv)</code></p>
      <p><code>35 {</code></p>
      <p><code>36  int nfaces;</code></p>
      <p><code>37  int i, j, k;</code></p>
      <p><code>38</code></p>
      <p><code>39  if (argc !=2) {</code></p>
      <p><code>40   fprintf(stderr, "usage: %s number-die-faces\n", argv[0]);</code></p>
      <p><code>41   exit(1);</code></p>
      <p><code>42  }</code></p>
      <p><code>43</code></p>
      <p><code>44  nfaces = atoi(argv[1]);</code></p>
      <p><code>45</code></p>
      <p><code>46  if (nfaces &lt;= 0) {</code></p>
      <p><code>47   fprintf(stderr, "usage: %s number-die-faces\n", argv[0]);</code></p>
      <p><code>48   fprintf(stderr, "\tUse a positive number!\n");</code></p>
      <p><code>49   exit(1);</code></p>
      <p><code>50  }</code></p>
      <p><code>51</code></p>
      <p><code>52  for (i = 1; i &lt;= nfaces; i++) {</code></p>
      <p><code>53   j = rand() % 6; /* force to range 0 &lt;= j &lt;= 5 */</code></p>
      <p><code>54   printf("+-------+\n" );</code></p>
      <p><code>55   for (k = 0; k &lt; 3; k++)</code></p>
      <p><code>56    printf("|%s|\n", die_faces[(j * 3) + k]);</code></p>
      <p><code>57   printf ("+-------+\n\n");</code></p>
      <p><code>58  }</code></p>
      <p><code>59</code></p>
      <p><code>60  return 0;</code></p>
      <p><code>61 }</code></p>
      <p>Эта программа использует простую ASCII-графику для распечатывания подобия грани игральной кости. Вы вызываете ее с числом граней для вывода. Это вычисляется в строке 44 с помощью <code>atoi()</code>. (В общем, <code>atoi()</code> следует избегать в коде изделия, поскольку она не осуществляет проверку на ошибки или переполнение, также как не проверяет вводимые данные.)</p>
      <p>Ключевой является строка 53, которая преобразует возвращаемое значение <code>rand()</code> в число от нуля до пяти, используя оператор остатка, <code>%</code>. Значение '<code>j * 3</code>' действует в качестве начального индекса массива <code>die_faces</code> для трех строк, составляющих каждую грань кости. Строки 55 и 56 выводят саму грань. При запуске появляется вывод наподобие этого:</p>
      <p><code>$ <strong>ch12-rand</strong> 2 /* Вывести две кости */</code></p>
      <p><code>+-------+</code></p>
      <p><code>|       |</code></p>
      <p><code>| *   * |</code></p>
      <p><code>|       |</code></p>
      <p><code>+-------+</code></p>
      <p><code>+-------+</code></p>
      <p><code>| *   * |</code></p>
      <p><code>|   *   |</code></p>
      <p><code>| *   * |</code></p>
      <p><code>+-------+</code></p>
      <p>Интерфейс <code>rand()</code> восходит еще к V7 и PDP-11. В частности, на многих системах результатом является лишь 16-разрядное число, что значительно ограничивает диапазон чисел, которые могут быть возвращены. Более того, используемый им алгоритм по современным стандартам считается «слабым». (Версия <code>rand()</code> GLIBC не имеет этих проблем, но переносимый код должен быть написан со знанием того, что <code>rand()</code> не является лучшим API для использования.)</p>
      <p><code>ch12-rand.c</code> использует для получения значения в определенном интервале простую методику: оператор <code>%</code>. Эта методика использует младшие биты возвращенного значения (как при десятичном делении, когда остаток отделения на 10 или 100 использует одну или две младшие десятичные цифры). Оказывается, исторический генератор <code>rand()</code> производил лучшие случайные значения в средних и старших битах по сравнению с младшими битами. Поэтому, если вы должны использовать <code>rand()</code>, постарайтесь избежать младших битов. Справочная страница GNU/Linux <emphasis>rand</emphasis>(3) цитирует «Числовые рецепты на С»<a l:href="#n129" type="note">[129]</a>, которая рекомендует эту методику:</p>
      <p><code>j = 1+ (int)(10.0*rand()/(RAND_MAX+1.0)); /* для числа от 1 до 10 */</code></p>
     </section>
     <section>
      <title>
       <p>12.6.2. Функции POSIX: <code>random()</code> и <code>srandom()</code></p>
      </title>
      <p>BSD 4.3 ввело random() и сопровождающие ее функции. Эти функции используют намного более подходящий генератор случайных чисел, который возвращает 31-разрядное значение. Теперь они входят в расширение XSI, стандартизованное POSIX:</p>
      <p><code>#include &lt;stdlib.h&gt; /* XSI */</code></p>
      <empty-line/>
      <p><code>long random(void);</code></p>
      <p><code>void srandom(unsigned int seed);</code></p>
      <p><code>char *initstate(unsigned int seed, char *state, size_t n);</code></p>
      <p><code>char *setstate(char *state);</code></p>
      <p>Первые две функции близко соответствуют <code>rand()</code> и <code>srand()</code> и могут использоваться сходным образом. Однако, вместо одного начального значения, которое дает последовательность псевдослучайных чисел, эти функции используют начальное значение вместе с массивом состояния: массивом байтов, который хранит сведения о состоянии для вычисления псевдослучайных чисел. Последние две функции дают возможность управлять массивом состояния.</p>
      <p><code>long random(void);</code></p>
      <p>Возвращает число в диапазоне от 0 до 2<sup>31</sup>-1. (Хотя справочная страница GNU/Linux <emphasis>random</emphasis>(3) говорит между 0 и <code>RAND_MAX</code>, это верно лишь для систем GLIBC, где <code>RAND_MAX</code> равен 2<sup>31</sup>-1. На других системах <code>RAND_MAX</code> может быть меньше. POSIX явно называет диапазон от 0 до 2<sup>31</sup>-1.)</p>
      <p><code>void srandom(unsigned int seed);</code></p>
      <p>Устанавливает начальное число. Если <code>srandom()</code> никогда не вызывается, по умолчанию используется 1.</p>
      <p><code>char *initstate(unsigned int seed, char *state, size_t n);</code></p>
      <p>Инициализирует массив <code>state</code> информацией для использования при генерации случайных чисел, <code>seed</code> является начальным значением, как для <code>srandom()</code>, а <code>n</code> является числом байтов в массиве <code>state</code>.</p>
      <p><code>n</code> должен равняться одному из значений 8, 32, 64, 128 или 256. Большие значения дают лучшие последовательности случайных чисел. Значения меньше 8 заставляют <code>random()</code> использовать простой генератор случайных чисел, сходный с <code>rand()</code>. Значения больше 8, не равные одному из значений в списке, округляются до ближайшего подходящего значения.</p>
      <p><code>char *setstate(char *state);</code></p>
      <p>Устанавливает внутреннее состояние в соответствии с массивом <code>state</code>, который должен быть инициализирован посредством <code>initstate()</code>. Это позволяет переключаться по желанию между различными состояниями, предоставляя множество генераторов случайных чисел.</p>
      <p>Если <code>initstate()</code> и <code>setstate()</code> никогда не вызывались, <code>random()</code> использует массив внутреннего состояния размером 128.</p>
      <p>Массив <code>state</code> непрозрачен; вы инициализируете его с помощью <code>initstate()</code> и передается функции <code>random()</code> посредством <code>setstate()</code>, но в другом отношении вам не нужно заглядывать в него. Если вы используете <code>initstate()</code> и <code>setstate()</code>. <code>srandom()</code> вызывать не нужно, поскольку начальное значение включено в информацию о состоянии. <code>ch12-random.c</code> использует эти процедуры вместо <code>rand()</code>. Используется также обычная методика, которая заключается в использовании в качестве начального значения генератора случайных чисел времени дня, добавленного к PID.</p>
      <p><code>1  /* ch12-random.c --- генерация вращения костей с использованием random(). */</code></p>
      <p><code>2</code></p>
      <p><code>3  #include &lt;stdio.h&gt;</code></p>
      <p><code>4  #include &lt;stdlib.h&gt;</code></p>
      <p><code>5  #include &lt;sys/types.h&gt;</code></p>
      <p><code>6  #include &lt;unistd.h&gt;</code></p>
      <p><code>7</code></p>
      <p><code>8  char *die_faces[] = { /* Управляет ASCII графика! */</code></p>
      <p><code>    /* ... как раньше ... */</code></p>
      <p><code>32 };</code></p>
      <p><code>33</code></p>
      <p><code>34 /* main --- выводит N различных граней кубиков */</code></p>
      <p><code>35</code></p>
      <p><code>36 int main(int argc, char **argv)</code></p>
      <p><code>37 {</code></p>
      <p><code>38  int nfaces;</code></p>
      <p><code>39  int i, j, k;</code></p>
      <p><code>40  char state[256];</code></p>
      <p><code>41  time_t now;</code></p>
      <p><code>42</code></p>
      <p><code>    /* ... проверка args, вычисление nfaces, как раньше ... */</code></p>
      <p><code>55</code></p>
      <p><code>56  (void)time(&amp;now); /* В качестве начального значения используются время дня и PID */</code></p>
      <p><code>57  (void) initstate((unsigned int)(now + getpid()), state, sizeof state);</code></p>
      <p><code>58  (void)setstate(state);</code></p>
      <p><code>59</code></p>
      <p><code>60  for (i = 1; i &lt;= nfaces; i++) {</code></p>
      <p><code>61   j = random() % 6; /* использовать диапазон 0 &lt;= j &lt;= 5 */</code></p>
      <p><code>62    printf("+-------+\n");</code></p>
      <p><code>63    for (k = 0; k &lt; 3; k++)</code></p>
      <p><code>64     printf("|%s|\n", die_faces[(j * 3) + k]);</code></p>
      <p><code>65    printf("+-------+\n\n");</code></p>
      <p><code>66  }</code></p>
      <p><code>67</code></p>
      <p><code>68  return 0;</code></p>
      <p><code>69 }</code></p>
      <p>Включение PID в состав начального значения гарантирует, что вы получите различные результаты, даже если две программы будут запушены в течение одной и той же секунды.</p>
      <p>Поскольку она создает последовательности случайных чисел лучшего качества, <code>random()</code> является более предпочтительной по сравнению с <code>rand()</code>, и GNU/Linux и все современные системы Unix ее поддерживают.</p>
     </section>
     <section>
      <title>
       <p>12.6.3. Особые файлы <code>/dev/random</code> и <code>/dev/urandom</code></p>
      </title>
      <p>Как <code>rand()</code>, так и <code>srandom()</code> являются генераторами псевдослучайных чисел. Их вывод для одного и того же начального значения является воспроизводимой последовательностью чисел. Некоторым приложениям, подобным криптографическим, необходимо, чтобы их случайные числа были действительно (более) случайными. С этой целью ядро Linux, также как различные BSD и коммерческие Unix системы предусматривают специальные файлы устройств, которые предоставляют доступ к «энтропийному пулу» случайных битов, которые ядро собирает от физических устройств и других источников. Из справочной страницы <emphasis>random</emphasis>(4):</p>
      <p><code>/dev/random</code></p>
      <p>[Байты, прочитанные из этого файла, находятся] внутри предполагаемого числа шумовых битов в энтропийном пуле, <code>/dev/random</code> должен подходить для использования в случаях, когда необходим высокий уровень случайности, таких, как одноразовая генерация ключа или блока памяти. Когда энтропийный пул пустой, чтение <code>/dev/random</code> будет блокироваться до тех пор, пока не будет собран дополнительный шум окружения.</p>
      <p><code>/dev/urandom</code></p>
      <p>[Это устройство будет] возвращать столько байтов, сколько затребовано. В результате, если нет достаточной энтропии в энтропийном пуле, возвращаемые значения теоретически уязвимы для криптографической атаки алгоритма, использованного драйвером. Знание того, как это сделать, недоступно в современной не секретной литературе, но теоретически возможно существование подобной атаки. Если для вашего приложения это представляет проблему, вместо этого используйте <code>/dev/random</code>.</p>
      <p>Для большинства приложений чтения из <code>/dev/urandom</code> должно быть вполне достаточно. Если вы собираетесь написать криптографические алгоритмы высокого качества, следует сначала почитать о криптографии и случайности; не полагайтесь здесь на поверхностное представление! Вот еще одна наша программа для бросания костей, использующая <code>/dev/urandom</code>:</p>
      <p><code>1  /* ch12-devrandom.с --- генерирует бросание костей, используя /dev/urandom. */</code></p>
      <p><code>2</code></p>
      <p><code>3  #include &lt;stdio.h&gt;</code></p>
      <p><code>4  #include &lt;fcntl.h&gt;</code></p>
      <p><code>5  #include &lt;stdlib.h&gt;</code></p>
      <p><code>6</code></p>
      <p><code>7  char *die_faces[] = { /* Управляет ASCII графика! */</code></p>
      <p><code>    /* ... как ранее ... */</code></p>
      <p><code>31 };</code></p>
      <p><code>32</code></p>
      <p><code>33 /* myrandom --- возвращает данные из /dev/urandom в виде unsigned long */</code></p>
      <p><code>34</code></p>
      <p><code>35 unsigned long myrandom(void)</code></p>
      <p><code>36 {</code></p>
      <p><code>37  static int fd = -1;</code></p>
      <p><code>38  unsigned long data;</code></p>
      <p><code>39</code></p>
      <p><code>40  if (fd == -1)</code></p>
      <p><code>41  fd = open("/dev/urandom", O_RDONLY);</code></p>
      <p><code>42</code></p>
      <p><code>43  if (fd == -1 || read(fd, &amp;data, sizeof data) &lt;= 0)</code></p>
      <p><code>44   return random(); /* отступить */</code></p>
      <p><code>45</code></p>
      <p><code>46  return data;</code></p>
      <p><code>47 }</code></p>
      <p><code>48</code></p>
      <p><code>49 /* main --- вывести N различных граней кубиков */</code></p>
      <p><code>50</code></p>
      <p><code>51 int main(int argc, char **argv)</code></p>
      <p><code>52 {</code></p>
      <p><code>53  int nfaces;</code></p>
      <p><code>54  int i, j, k;</code></p>
      <p><code>55</code></p>
      <p><code>    /* ...проверка args, вычисление nfaces, как ранее... */</code></p>
      <p><code>68</code></p>
      <p><code>69  for (i = 1; i &lt;= nfaces; i++) {</code></p>
      <p><code>70   j = myrandom() % 6; /* обеспечить диапазон 0 &lt;= j &lt;= 5 */</code></p>
      <p><code>71   printf("+-------+\n");</code></p>
      <p><code>72   for (k = 0; k &lt; 3; k++)</code></p>
      <p><code>73    printf("|%s|\n", die_faces[(j * 3) + k]);</code></p>
      <p><code>74   printf("+-------+\n");</code></p>
      <p><code>75   putchar('\n');</code></p>
      <p><code>76  }</code></p>
      <p><code>77</code></p>
      <p><code>78  return 0;</code></p>
      <p><code>79 }</code></p>
      <p>Строки 35–47 предоставляют интерфейс вызова функции для <code>/dev/urandom</code>, читая каждый раз данные <code>unsigned long</code>. Издержками является один дескриптор файла, который остается открытым в течение жизни программы.</p>
     </section>
    </section>
    <section>
     <title>
      <p>12.7. Расширения метасимволов</p>
     </title>
     <section>
      <p>Три набора функции возрастающей сложности предусматривают возможность сопоставления с шаблонами групповых символов оболочки. Многим программам нужны такие библиотечные функции. Одним примером является <code>find</code>: '<code>find . -name '*.с' -print</code>'. Другим примером является опция <code>--exclude</code> во многих программах, которая принимает шаблон файлов с групповыми символами для исключения из того или иного действия. В данном разделе по очереди рассматривается каждый набор функций.</p>
     </section>
     <section>
      <title>
       <p>12.7.1. Простое сопоставление с шаблоном: <code>fnmatch()</code></p>
      </title>
      <p>Мы начинаем с функции <code>fnmatch()</code> («filename match» <strong>—</strong> сопоставление имени файла»).</p>
      <p><code>#include &lt;fnmatch.h&gt; /* POSIX */</code></p>
      <empty-line/>
      <p><code>int fnmatch(const char *pattern, const char *string, int flags);</code></p>
      <p>Эта функция сопоставляет <code>string</code> с <code>pattern</code>, который является обычным шаблоном групповых символов оболочки. Значение флагов (которое вскоре будет описано) изменяет поведение функции. Возвращаемое значение равно 0, если <code>string</code> соответствует <code>pattern</code>, <code>FNM_NOMATCH</code>, если не соответствует, и ненулевое значение, если возникла ошибка. К сожалению, POSIX не определяет каких-либо специфических ошибок; соответственно, вы можете лишь сказать, что что-то пошло не так, но не можете сказать, что.</p>
      <p>Переменная <code>flags</code> является побитовым ИЛИ одного или более флагов, перечисленных в табл. 12.1.</p>
      <empty-line/>
      <p><strong>Таблица 12.1</strong>. Значения флагов для <code>fnmatch()</code></p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Флаг </th>
        <th align="left" valign="top">Только GLIBC</th>
        <th align="left" valign="top">Значение</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>FNM_CASEFOLD</code></td>
        <td align="left" valign="top">&#8730;</td>
        <td align="left" valign="top">Сопоставление с учетом регистра</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>FNM_FILE_NAME</code></td>
        <td align="left" valign="top">&#8730;</td>
        <td align="left" valign="top">Синоним GNU для <code>FNM_PATHNAME</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>FNM_LEADING_DIR</code></td>
        <td align="left" valign="top">&#8730;</td>
        <td align="left" valign="top">Флаг для внутреннего использования GLIBC; не используйте его в своих программах. Подробности см. в <emphasis>fnmatch</emphasis>(3)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>FNM_NOESCAPE</code> </td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">Обратный слеш является обычным символом, а не знаком перехода</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>FNM_PATHNAME</code> </td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">Слеш в <code>string</code> должен соответствовать слешу в <code>pattern</code>, он не может быть подставлен через <code>*</code>, <code>?</code> или '<code>[...]</code>'</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>FNM_PERIOD</code></td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">Начальная точка в <code>string</code> подходит, лишь если в <code>pattern</code> также есть начальная точка. Точка должна быть первым символом в <code>string</code>. Однако, если также установлен <code>FNM_PATHNAME</code>, точка, которая идет за слешем, также рассматривается как начальная</td>
       </tr>
      </table>
      <p><code>fnmatch()</code> работает со строками из любого источника; сопоставляемые строки не обязательно должны быть действительными именами файлов. Хотя на практике <code>fnmatch()</code> используется в коде, читающем каталог с помощью <code>readdir()</code> (см раздел 5.3.1 «Базовое чтение каталогов»):</p>
      <p><code>struct dirent dp;</code></p>
      <p><code>DIR *dir;</code></p>
      <p><code>char pattern[100];</code></p>
      <p><code>/* ...заполнить шаблон, открыть каталог, проверить ошибки... */</code></p>
      <p><code>while ((dp = readdir(dir)) != NULL) {</code></p>
      <p><code> if (fnmatch(pattern, dir-&gt;d_name, FNM_PERIOD) == 0)</code></p>
      <p><code>  /* имя файла соответствует шаблону */</code></p>
      <p><code> else</code></p>
      <p><code>  continue; /* не соответствует */</code></p>
      <p><code>}</code></p>
      <p>GNU <code>ls</code> использует <code>fnmatch()</code> для реализации своей опции <code>--ignore</code>. Вы можете предоставить несколько игнорируемых шаблонов (с помощью нескольких опций). <code>ls</code> сопоставляет каждое имя файла со всеми шаблонами. Она делает это с помощью функции <code>file_interesting()</code> в <code>ls.с</code>:</p>
      <p><code>2269 /* Возвращает не ноль, если файл в 'next' должен быть перечислен. */</code></p>
      <p><code>2270</code></p>
      <p><code>2271 static int</code></p>
      <p><code>2272 file_interesting(const struct dirent *next)</code></p>
      <p><code>2273 {</code></p>
      <p><code>2274  register struct ignore_pattern* ignore;</code></p>
      <p><code>2275</code></p>
      <p><code>2276  for (ignore = ignore_patterns; ignore; ignore = ignore-&gt;next)</code></p>
      <p><code>2277   if (fnmatch(ignore-&gt;pattern, next-&gt;d_name, FNM_PERIOD) == 0)</code></p>
      <p><code>2278    return 0;</code></p>
      <p><code>2279</code></p>
      <p><code>2280  if (really_all_files</code></p>
      <p><code>2281   || next-&gt;d_name[0] !=</code></p>
      <p><code>2282   || (all_files</code> </p>
      <p><code>2283   &amp;&amp; next-&gt;d_name[1] != '\0 '</code></p>
      <p><code>2284   &amp;&amp; (next-&gt;d_name[1] || next-&gt;d_name[2] != '\0')))</code></p>
      <p><code>2285   return 1;</code></p>
      <p><code>2286</code></p>
      <p><code>2287  return 0;</code></p>
      <p><code>2288 }</code></p>
      <p>Цикл в строках 2276–2278 сопоставляет имя файла со списком шаблонов для игнорируемых файлов. Если один из шаблонов подходит, файл не интересен и <code>file_interesting()</code> возвращает false (то есть 0).</p>
      <p>Переменная <code>all_files</code> соответствует опции <code>-А</code>, которая показывает файлы, имена которых начинаются с точки, но не являются '<code>.</code>' и '<code>..</code>'. Переменная <code>really_all_files</code> соответствует опции <code>-а</code>, которая предполагает <code>-А</code>, а также показывает '<code>.</code>' и '<code>..</code>'. При наличии таких сведений, условие в строках 228–2284 может быть представлено следующим псевдокодом:</p>
      <p><code>if (/* <emphasis>показать все файлы независимо от их имени (-а)</emphasis> */</code></p>
      <p><code> OR /* <emphasis>первый символ имени не точка</emphasis> */</code></p>
      <p><code> OR (/* <emphasis>показать файлы с точкой (-А)</emphasis> */</code></p>
      <p><code>  AND /* <emphasis>в имени файла несколько символов</emphasis> */</code></p>
      <p><code>  AND (/* <emphasis>второй символ не точка</emphasis> */</code></p>
      <p><code>   OR /* <emphasis>третий символ не завершает имя</emphasis> */)))</code></p>
      <p><code> return TRUE;</code></p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. <code>fnmatch()</code> может оказаться дорогостоящей функцией, если она используется в локали с многобайтным набором символов. Обсудим многобайтные наборы символов в разделе 13.4 «Можете произнести это для меня по буквам?»</p>
      </cite>
     </section>
     <section>
      <title>
       <p>12.7.2. Раскрытие имени файла: <code>glob()</code> и <code>globfree()</code></p>
      </title>
      <p>Функции <code>glob()</code> и <code>globfree()</code> более разработанные, чем <code>fnmatch()</code>:</p>
      <p><code>#include &lt;glob.h&gt; /* POSIX */</code></p>
      <empty-line/>
      <p><code>int glob(const char *pattern, int flags,</code></p>
      <p><code>int (*errfunc)(const char *epath, int eerrno), glob_t *pglob);</code></p>
      <p><code>void globfree(glob_t *pglob);</code></p>
      <p>Функция <code>glob()</code> осуществляет просмотр каталога и сопоставление с шаблонами, возвращая список всех путей, соответствующих <code>pattern</code>. Символы подстановки могут быть включены в нескольких местах пути, а не только в качестве последнего компонента (например, '<code>/usr/*/*.so</code>'). Аргументы следующие:</p>
      <p><code>const char *pattern</code></p>
      <p>Шаблон для раскрывания.</p>
      <p><code>int flags</code></p>
      <p>Флаги, управляющие поведением <code>glob()</code>, вскоре будут описаны.</p>
      <p><code>int (*errfunc)(const char *epath, int eerrno)</code></p>
      <p>Указатель на функцию для использования при сообщениях об ошибках. Это значение может равняться <code>NULL</code>. Если нет и если <code>(*errfunc)()</code> возвращает ненулевое значение или в <code>flags</code> установлен <code>GLOB_ERR</code>, <code>glob()</code> прекращает обработку. Аргументами <code>(*errfunc)()</code> являются путь, вызвавший проблему, и значение errno, установленное функциями <code>opendir()</code>, <code>readdir()</code> или <code>stat()</code>.</p>
      <p><code>glob_t *pglob</code></p>
      <p>Указатель на структуру <code>glob_t</code>, использующуюся для хранения результатов. Структура <code>glob_t</code> содержит список путей, которые выдает <code>glob()</code>:</p>
      <p><code>typedef struct {  /* POSIX */</code></p>
      <p><code> size_t gl_pathc; /* Число найденных подходящих путей */</code></p>
      <p><code> char **gl_pathv; /* Список подходящих путей */</code></p>
      <p><code> size_t gl_offs;  /* Слоты для резервирования в gl_pathv */</code></p>
      <p><code>} glob_t;</code></p>
      <p><code>size_t gl_pathc</code></p>
      <p>Число путей, которые подошли.</p>
      <p><code>char **gl_pathv</code></p>
      <p>Массив подходящих путей. <code>gl_pathv[gl_pathc]</code> всегда равен <code>NULL</code>.</p>
      <p><code>size_t gl_offs</code></p>
      <p>«Зарезервированные слоты» в <code>gl_pathv</code>. Идея заключается в резервировании слотов <emphasis>спереди</emphasis> от <code>gl_pathv</code> для заполнения их приложением впоследствии, как в случае с именем команды и опциями. Список затем может быть передан непосредственно <code>execv()</code> или <code>execvp()</code> (см. раздел 9.1.4 «Запуск новой программы: семейство <code>exec()</code>»). Зарезервированные слоты устанавливаются в <code>NULL</code>. Чтобы все это работало, в <code>flags</code> должен быть установлен <code>GLOB_DOOFFS</code>.</p>
      <p>В табл. 12.2 перечислены стандартные флаги для <code>glob()</code>.</p>
      <empty-line/>
      <p><strong>Таблица 12.2</strong>. Флаги для <code>glob()</code></p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Флаг </th>
        <th align="left" valign="top">Значение</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>GLOB_APPEND</code></td>
        <td align="left" valign="top">Добавить результаты текущего вызова к предыдущим</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>GLOB_DOOFFS</code></td>
        <td align="left" valign="top">Зарезервировать места <code>gl_offs</code> спереди в <code>gl_pathv</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>GLOB_MARK</code></td>
        <td align="left" valign="top">Добавлять символ / в конец каждого имени, которое обозначает каталог</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>GLOB_NOCHECK</code></td>
        <td align="left" valign="top">Если шаблон не соответствует имени какого-нибудь файла, вернуть его без изменений</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>GLOB_NOESCAPE</code></td>
        <td align="left" valign="top">Рассматривать обратный слеш как обычный символ. Это делает невозможным обозначать метасимволы подстановок</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>GLOB_NOSORT</code></td>
        <td align="left" valign="top">Не сортировать результаты, по умолчанию они сортируются</td>
       </tr>
      </table>
      <p>GLIBC версия структуры <code>glob_t</code> содержит дополнительные члены:</p>
      <p><code>typedef struct { /* GLIBC */</code></p>
      <p><code> /* Компоненты POSIX: */</code></p>
      <p><code> size_t gl_pathc; /* Число подходящих путей */</code></p>
      <p><code> char **gl_pathv; /* Список подходящих путей */</code></p>
      <p><code> size_t gl_offs; /* Резервируемые в gl_pathv слоты */</code></p>
      <p><code> /* Компоненты GLIBC: */</code></p>
      <p><code> int gl_flags; /* Копия флагов, дополнительные флаги GLIBC */</code></p>
      <p><code> void (*gl_closedir)(DIR *); /* Частная версия closedir() */</code></p>
      <p><code> struct dirent *(*gl_readdir)(DIR *); /* Частная версия readdir)) */</code></p>
      <p><code> DIR *(*gl_opendir)(const char *); /* Частная версия opendir)) */</code></p>
      <p><code> int (*gl_lstat)(const char *, struct stat *);</code></p>
      <p><code>  /* Частная версия lstat() */</code></p>
      <p><code> int (*gl_stat)(const char *, struct stat *); /* Частная версия stat() */</code></p>
      <p><code>} glob_t;</code></p>
      <p>Члены структуры следующие:</p>
      <p><code>int gl_flags</code></p>
      <p>Копия флагов. Включает также <code>GLOB_MAGCHAR</code>, если <code>pattern</code> включал какие-либо метасимволы.</p>
      <p><code>void (*gl_closedir)(DIR *)</code></p>
      <p>Указатель на альтернативную версию <code>closedir()</code>.</p>
      <p><code>struct dirent *(*gl_readdir)(DIR *)</code></p>
      <p>Указатель на альтернативную версию <code>readdir()</code>.</p>
      <p><code>DIR *(*gl_opendir)(const char *)</code></p>
      <p>Указатель на альтернативную версию <code>opendir()</code>.</p>
      <p><code>int (*gl_lstat)(const char *, struct stat*)</code></p>
      <p>Указатель на альтернативную версию <code>lstat()</code>.</p>
      <p><code>int (*gl_stat)(const char*, struct stat*)</code></p>
      <p>Указатель на альтернативную версию <code>stat()</code>.</p>
      <p>Указатели на альтернативные версии стандартных функций предназначены главным образом для использования в реализации GLIBC; крайне маловероятно, что вы когда-нибудь их используете. Поскольку GLIBC предусматривает поле <code>gl_flags</code> и дополнительные значения флагов, справочная страница и руководство Info документируют оставшуюся часть структуры GLIBC <code>glob_t</code>. В табл. 12.3 перечислены дополнительные флаги.</p>
      <empty-line/>
      <p><strong>Таблица 12.3</strong>. Дополнительные флаги GLIBC для <code>glob()</code></p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Флаг</th>
        <th align="left" valign="top">Значение</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>GLOB_ALTDIRFUNC</code></td>
        <td align="left" valign="top">Использовать для доступа к каталогам альтернативные функции (см. текст)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>GLOB_BRACE</code></td>
        <td align="left" valign="top">Выполнить раскрытие фигурных скобок в стиле <code>csh</code> и Bash.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>GLOB_MAGCHAR</code></td>
        <td align="left" valign="top">Вставить <code>gl_flags</code>, если были найдены метасимволы.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>GLOB_NOMAGIC</code></td>
        <td align="left" valign="top">Вернуть шаблон, если он не содержит метасимволов</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>GLOB_ONLYDIR</code></td>
        <td align="left" valign="top">По возможности сопоставлять лишь каталоги. См. текст.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>GLOB_PERIOD</code></td>
        <td align="left" valign="top">Разрешить соответствие метасимволов наподобие <code>*</code> и <code>?</code> начальной точке</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>GLOB_TILDE</code></td>
        <td align="left" valign="top">Выполнить раскрывание тильды в стиле оболочки.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>GLOB_TILDE_CHECK</code></td>
        <td align="left" valign="top">Подобно <code>GLOB_TILDE</code>, но если есть проблемы с указанным домашним каталогом, вернуть <code>GLOB_NOMATCH</code> вместо помещения <code>pattern</code> в список.</td>
       </tr>
      </table>
      <p>Флаг <code>GLOB_ONLYDIR</code> действует в качестве <emphasis>подсказки</emphasis> реализации, потому что вызывающий интересуется лишь каталогами. Главным его предназначением является использование другими функциями в GLIBC, а вызывающий по-прежнему должен быть готов обрабатывать файлы, не являющиеся каталогами. Вам не следует использовать этот флаг в своих программах.</p>
      <p><code>glob()</code> может быть вызвана более одного раза: при первом вызове флаг <code>GLOB_APPEND</code> <emphasis>не</emphasis> должен быть указан, при всех последующих вызовах он <emphasis>должен</emphasis> быть указан. Вы не можете между вызовами изменять <code>gl_offs</code>, а если вы изменили какие-нибудь значения в <code>gl_pathv</code> или <code>gl_pathc</code>, нужно их восстановить перед последующим вызовом <code>glob()</code>.</p>
      <p>Возможность многократного вызова <code>glob()</code> позволяет накапливать результаты в одном списке. Это довольно практично, приближается к мощным возможностям раскрывания групповых символов оболочки, но на уровне языка программирования С.</p>
      <p><code>glob()</code> возвращает 0, если не было проблем, или одно из значений из табл. 12.4, если были.</p>
      <empty-line/>
      <p><strong>Таблица 12.4</strong>. Возвращаемые <code>glob()</code> значения</p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Флаг</th>
        <th align="left" valign="top">Значение</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>GLOB_ABORTED</code></td>
        <td align="left" valign="top">Просмотр остановлен раньше времени, поскольку был установлен <code>GLOB_ERR</code> или функция <code>(*errfunc)()</code> возвратила ненулевой результат</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>GLOB_NOMATCH</code></td>
        <td align="left" valign="top">Ни одно имя файла не соответствовало <code>pattern</code>, а флаг <code>GLOB_NOCHECK</code> не был установлен</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>GLOB_NOSPACE</code></td>
        <td align="left" valign="top">Была проблема с выделением динамической памяти</td>
       </tr>
      </table>
      <p><code>globfree()</code> освобождает всю память, которую динамически выделила <code>glob()</code> Следующая программа, <code>ch12-glob.с</code>, демонстрирует <code>glob()</code>:</p>
      <p><code>1  /* ch12-glob.c --- демонстрирует glob(). */</code></p>
      <p><code>2</code></p>
      <p><code>3  #include &lt;stdio.h&gt;</code></p>
      <p><code>4  #include &lt;errno.h&gt;</code></p>
      <p><code>5  #include &lt;glob.h&gt;</code></p>
      <p><code>6</code></p>
      <p><code>7  char *myname;</code></p>
      <p><code>8</code></p>
      <p><code>9  /* globerr --- выводит сообщение об ошибке для glob() */</code></p>
      <p><code>10</code></p>
      <p><code>11 int globerr(const char *path, int eerrno)</code></p>
      <p><code>12 {</code></p>
      <p><code>13  fprintf(stderr, "%s: %s: %s\n", myname, path, strerror(eerrno));</code></p>
      <p><code>14  return 0; /* let glob() keep going */</code></p>
      <p><code>15 }</code></p>
      <p><code>16</code></p>
      <p><code>17 /* main() --- раскрывает символы подстановки в командной строке и выводит результаты */</code></p>
      <p><code>18</code></p>
      <p><code>19 int main(int argc, char **argv)</code></p>
      <p><code>20 {</code></p>
      <p><code>21  int i;</code></p>
      <p><code>22  int flags = 0;</code></p>
      <p><code>23  glob_t results;</code></p>
      <p><code>24  int ret;</code></p>
      <p><code>25</code></p>
      <p><code>26  if (argc == 1) {</code></p>
      <p><code>27   fprintf(stderr, "usage: %s wildcard ...\n", argv[0]);</code></p>
      <p><code>28   exit(1);</code></p>
      <p><code>29  }</code></p>
      <p><code>30</code></p>
      <p><code>31  myname = argv[0]; /* для globerr() */</code></p>
      <p><code>32</code></p>
      <p><code>33  for (i = 1; i &lt; argc; i++) {</code></p>
      <p><code>34   flags |= (i &gt; 1 ? GLOB_APPEND : 0);</code></p>
      <p><code>35   ret = glob(argv[i], flags, globerr, &amp;results);</code></p>
      <p><code>36   if (ret != 0) {</code></p>
      <p><code>37    fprintf(stderr, "%s: problem with %s (%s),</code></p>
      <p><code>38     stopping early\n", myname, argv[i],</code></p>
      <p><code>39     /* опасно: */ (ret == GLOB_ABORTED ? "filesystem problem" :</code></p>
      <p><code>40     ret == GLOB_NOMATCH ? "no match of pattern" :</code></p>
      <p><code>41     ret == GLOB_NOSPACE ? "no dynamic memory" :</code></p>
      <p><code>42     "unknown problem"));</code></p>
      <p><code>43    break;</code></p>
      <p><code>44   }</code></p>
      <p><code>45  }</code></p>
      <p><code>46</code></p>
      <p><code>47  for (i = 0; i &lt; results.gl_pathc; i++)</code></p>
      <p><code>48   printf("%s\n", results.gl_pathv[i]);</code></p>
      <p><code>49</code></p>
      <p><code>50  globfree(&amp;results);</code></p>
      <p><code>51  return 0;</code></p>
      <p><code>52 }</code></p>
      <p>Строка 7 определяет <code>myname</code>, которая указывает на имя программы; эта переменная для сообщений об ошибках от <code>globerr()</code>, определенной в строках 11–15.</p>
      <p>Строки 33–45 являются основой программы. Они перебирают в цикле шаблоны, приведенные в командной строке, вызывая для каждого <code>glob()</code> для добавления к списку результатов. Большую часть цикла составляет обработка ошибок (строки 36–44). Строки 47–48 выводят результирующий список, а строки 50–51 проводят завершающую очистку и возвращаются.</p>
      <p>Строки 39–41 не являются хорошими; нужно было использовать отдельную функцию, преобразующую целые константы в строки; мы сделали это главным образом ради экономии места. Код наподобие этого может быть сносным для небольших программ, но более крупные должны использовать функцию.</p>
      <p>Если вы подумаете о работе, происходящей под капотом (открытие и чтение каталогов, сопоставление шаблонов, динамическое выделение памяти для увеличения списка, сортировка списка), можете качать ценить, как много для вас делает <code>glob()</code>! Вот некоторые результаты:</p>
      <p><code>$ <strong>ch12-glob '/usr/lib/x*.so' '../../*.texi'</strong></code></p>
      <p><code>/usr/lib/xchat-autob5.so</code></p>
      <p><code>/usr/lib/xchat-autogb.so</code></p>
      <p><code>../../00-preface.texi</code></p>
      <p><code>../../01-intro.texi</code></p>
      <p><code>../../02-cmdline.texi</code></p>
      <p><code>../../03-memory.texi</code></p>
      <p><code>...</code></p>
      <p>Обратите внимание, что нам пришлось взять аргументы в кавычки, чтобы предотвратить их разворачивание оболочкой!</p>
      <cite>
       <subtitle>Универсализация имен? Что это?</subtitle>
       <p>В былые времена, около V6 Unix, для осуществления разворачивания символов подстановки оболочка использовала за кулисами отдельную программу. Эта программа называлась <code>/etc/glob</code>, и согласно исходному коду V6<a l:href="#n130" type="note">[130]</a>, имя «glob» было сокращением от «global».</p>
       <p>Таким образом глагол «to glob» проник в лексикон Unix со значением «осуществлять разворачивание символов подстановки». Это, в свою очередь, дает нам имена функций <code>glob()</code> и <code>globfree()</code>. Так что обычно недооцениваемое чувство юмора, время от времени проглядывающее из руководства Unix, все еще живо, официально сохраненное в стандарте POSIX. (Можете ли вы представить кого-нибудь в IBM в 70-х или 80-х годах XX века, называющего системную процедуру <code>glob()</code>?)</p>
      </cite>
     </section>
     <section>
      <title>
       <p>12.7.3. Разворачивание слов оболочкой: <code>wordexp()</code> и <code>wordfree()</code></p>
      </title>
      <p>Многие члены комитета POSIX чувствовали, что <code>glob()</code> делает недостаточно: им нужна была библиотечная процедура, способная делать все, что может делать оболочка разворачивание тильды ('<code>echo ~arnold</code>'), разворачивание переменных оболочки ('<code>echo $HOME</code>') и подстановку команд ('<code>echo $(cd ; pwd)</code>'). Многие другие чувствовали, что <code>glob()</code> не подходила для этой цели. Чтобы «удовлетворить» каждого, POSIX предоставляет две дополнительные функции, которые делают все:</p>
      <p><code>#include &lt;wordexp.h&gt; /* POSIX */</code></p>
      <empty-line/>
      <p><code>int wordexp(const char *words, wordexp_t *pwordexp, int flags);</code></p>
      <p><code>void wordfree(wordexp_t *wordexp);</code></p>
      <p>Эти функции работают сходным с <code>glob()</code> и <code>globfree()</code> образом, но со структурой <code>wordexp_t</code>:</p>
      <p><code>typedef struct {</code></p>
      <p><code> size_t we_wordc; /* Число подходящих слов */</code></p>
      <p><code> char **we_wordv; /* Список развернутых слов */</code></p>
      <p><code> size_t we_offs;  /* Резервируемые в we_wordv слоты */</code></p>
      <p><code>} wordexp_t;</code></p>
      <p>Члены структуры полностью аналогичны описанным ранее для <code>glob_t</code>; мы не будем здесь повторять все описание.</p>
      <p>Как и для <code>glob()</code>, поведение <code>wordexp()</code> управляется несколькими флагами. Флаги перечислены в табл. 12.5.</p>
      <empty-line/>
      <p><strong>Таблица 12.5</strong>. Флаги для <code>wordexp()</code></p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Константа</th>
        <th align="left" valign="top">Значение</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>WRDE_APPEND</code></td>
        <td align="left" valign="top">Добавить результаты текущего вызова к предыдущим</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>WRDE_DOOFFS</code></td>
        <td align="left" valign="top">Зарезервировать <code>we_offs</code> мест в начале <code>we_wordv</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>WRDE_NOCMD</code></td>
        <td align="left" valign="top">Запретить подстановку команд</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>WRDE_REUSE</code></td>
        <td align="left" valign="top">Повторно использовать память, на которую указывает <code>we_wordv</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>WRDE_SHOWERR</code></td>
        <td align="left" valign="top">Не молчать при возникновении во время разворачивания ошибок</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>WRDE_UNDEF</code></td>
        <td align="left" valign="top">Неопределенные переменные оболочки должны вызывать ошибку</td>
       </tr>
      </table>
      <p>Возвращаемое значение равно 0, если все прошло хорошо, или одно из значений из табл. 12.6, если нет.</p>
      <empty-line/>
      <p><strong>Таблица 12.6</strong>. Возвращаемые значения ошибок для <code>wordexp()</code></p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Константа</th>
        <th align="left" valign="top">Значение</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>WRDE_BADCHAR</code></td>
        <td align="left" valign="top">Метасимвол (конец строки, '|', &amp;, ;, &lt;, &gt;, (, ), {, или }) в недопустимом месте</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>WRDE_BADVAL</code></td>
        <td align="left" valign="top">Переменная не определена при установленном <code>WRDE_UNDEF</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>WRDE_CMDSUB</code></td>
        <td align="left" valign="top">Попытка подстановки команды при установленном <code>WRDE_NOCMD</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>WRDE_NOSPACE</code></td>
        <td align="left" valign="top">Была проблема с выделением динамической памяти</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>WRDE_SYNTAX</code></td>
        <td align="left" valign="top">Синтаксическая ошибка оболочки.</td>
       </tr>
      </table>
      <p>Мы оставляем вам в качестве упражнения (см. далее) модификацию <code>ch12-glob.c</code> для использования <code>wordexp()</code> и <code>wordfree()</code>. Вот наша версия в действии:</p>
      <p><code>$ <strong>ch12-wordexp</strong> 'echo $HOME' /* Развертывание переменных оболочки */</code></p>
      <p><code>echo</code></p>
      <p><code>/home/arnold</code></p>
      <p><code>$ <strong>ch12-wordexp 'echo $HOME/*.gz'</strong> /* Переменные и символы подстановки */</code></p>
      <p><code>echo</code></p>
      <p><code>/home/arnold/48000.wav.gz</code></p>
      <p><code>/home/arnold/ipmasq-HOWTO.tar.gz</code></p>
      <p><code>/home/arnold/rc.firewall-examples.tar.gz</code></p>
      <p><code>$ <strong>ch12-wordexp 'echo ~arnold'</strong> /* Развертывание тильды */</code></p>
      <p><code>echo</code></p>
      <p><code>/home/arnold</code></p>
      <p><code>$ <strong>ch12-wordexp 'echo ~arnold/.p*'</strong> /* Тильда и символы подстановки */</code></p>
      <p><code>echo</code></p>
      <p><code>/home/arnold/.postitnotes</code></p>
      <p><code>/home/arnold/.procmailrc</code></p>
      <p><code>/home/arnold/.profile</code></p>
      <p><code>$ <strong>ch12-wordexp "echo '~arnold/.p*'"</strong> /* Кавычки работают */</code></p>
      <p><code>echo</code></p>
      <p><code>~arnold/.p*</code></p>
     </section>
    </section>
    <section>
     <title>
      <p>12.8. Регулярные выражения</p>
     </title>
     <p><emphasis>Регулярные выражения</emphasis> являются способом описания текстовых шаблонов для сопоставления. Если вы вообще сколько-нибудь использовали GNU/Linux или Unix, вы без сомнения знакомы с регулярными выражениями: они являются фундаментальной частью инструментария программиста Unix. Они неотъемлемы от таких повседневных программ, как <code>grep</code>, <code>egrep</code>, <code>sed</code>, <code>awk</code>, Perl, а также редакторы <code>ed</code>, <code>vi</code>, <code>vim</code> и Emacs. Если вы вообще не знакомы с регулярными выражениями, мы рекомендуем ознакомиться с некоторыми из книг или URL, указанных в разделе 12.9 «Рекомендуемая литература».</p>
     <p>POSIX определяет два вида регулярных выражений: базовый и расширенный. Программы типа <code>grep</code>, <code>sed</code> и строчный редактор <code>ed</code> используют базовые регулярные выражения. Программы типа <code>egrep</code> и <code>awk</code> используют расширенные регулярные выражения. Следующие функции дают вам возможность использовать в своих программах любой вид.</p>
     <p><code>#include &lt;sys/types.h&gt; /* POSIX */</code></p>
     <p><code>#include &lt;regex.h&gt;</code></p>
     <empty-line/>
     <p><code>int regcomp(regex_t *preg, const char *regex, int cflags);</code></p>
     <p><code>int regexec(const regex_t *preg, const char *string, size_t nmatch,</code></p>
     <p><code> regmatch_t pmatch[], int eflags);</code></p>
     <p><code>size_t regerror(int errcode, const regex_t *preg,</code></p>
     <p><code> char *errbuf, size_t errbuf_size);</code></p>
     <p><code>void regfree(regex_t *preg);</code></p>
     <p>Чтобы сопоставить регулярное выражение, нужно сначала <emphasis>откомпилировать</emphasis> строчную версию регулярного выражения. Компиляция преобразует регулярное выражение во внутренний формат. Затем откомпилированная форма <emphasis>исполняется</emphasis> для строки для проверки, совпадает ли она с первоначальным регулярным выражением. Функции следующие.</p>
     <p><code>int regcomp(regex_t *preg, const char *regex, int cflags)</code></p>
     <p>Компилирует регулярное выражение <code>regex</code> во внутреннее представление, сохраняя его в структуре <code>regex_t</code>, на которую указывает <code>preg</code>. <code>cflags</code> контролирует процесс компиляции; ее значение равно 0 или побитовому ИЛИ одного или более флагов из табл. 12.7</p>
     <p><code>int regexec(const regex_t *preg, const char *string, size_t nmatch,</code></p>
     <p><code> regmatch_t pmatch[], int eflags)</code></p>
     <p>Выполняет откомпилированное регулярное выражение в <code>*preg</code> в строке <code>string eflags</code> контролирует способ выполнения; ее значение равно 0 или побитовому ИЛИ одного или более флагов из табл. 12.8. Вскоре мы обсудим другие аргументы.</p>
     <p><code>size_t regerror(int errcode, const regex_t *preg,</code></p>
     <p><code> char *errbuf, size_t errbuf_size)</code></p>
     <p>Преобразует ошибку, возвращенную <code>regcomp()</code> или <code>regexec()</code>, в удобочитаемую строку.</p>
     <p><code>void regfree(regex_t *preg)</code></p>
     <p>Освобождает динамическую память, используемую откомпилированным регулярным выражением в <code>*preg</code>.</p>
     <p>Заголовочный файл <code>&lt;regex.h&gt;</code> определяет ряд флагов. Некоторые используются с <code>regcomp()</code>; другие используются с <code>regexec()</code>. Однако, все они начинаются с префикса '<code>REG_</code>'. В табл. 12.7 перечислены флаги для компиляции регулярных выражений с помощью <code>regcomp()</code>.</p>
     <empty-line/>
     <p><strong>Таблица 12.7</strong>. Флаги для <code>regcomp()</code></p>
     <table>
      <tr align="left">
       <th align="left" valign="top">Константа</th>
       <th align="left" valign="top">Значение</th>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_EXTENDED</code></td>
       <td align="left" valign="top">Использовать расширенные регулярные выражения. По умолчанию используются базовые регулярные выражения</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_ICASE</code></td>
       <td align="left" valign="top">Сопоставление <code>regexec()</code> игнорирует регистр символов</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_NEWLINE</code></td>
       <td align="left" valign="top">Операторы, заменяющие любой символ, не включают символ конца строки</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_NOSUB</code></td>
       <td align="left" valign="top">Информация о начале и конце вложенною шаблона не требуется (см текст)</td>
      </tr>
     </table>
     <p>Флаги для сопоставления регулярных выражений с помощью <code>regexec()</code> приведены в табл. 12.8.</p>
     <empty-line/>
     <p><strong>Таблица 12.8</strong>. Флаги дли <code>regexec()</code></p>
     <table>
      <tr align="left">
       <th align="left" valign="top">Константа</th>
       <th align="left" valign="top">Значение</th>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_NOTBOL</code></td>
       <td align="left" valign="top">Оператор ^ (начало строки) не сопоставляется</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_NOTEOL</code></td>
       <td align="left" valign="top">Оператор $ (конец строки) не сопоставляется</td>
      </tr>
     </table>
     <p>Флаги <code>REG_NEWLINE</code>, <code>REG_NOTBOL</code> и <code>REG_NOTEOL</code> взаимодействуют друг с другом. Это немного запутано, поэтому мы будем продвигаться небольшими шажками.</p>
     <p>• Когда в <code>cflags</code> не включен <code>REG_NEWLINE</code>, символ конца строки действует в качестве обычного символа. С ним может быть сопоставлен метасимвол '<code>.</code>' (любой символ), а также дополненные списки символов ('<code>[^...]</code>'). При этом <code>$</code> не сопоставляется немедленно с началом вставленного символа новой строки, а <code>^</code> не сопоставляется немедленно с его концом.</p>
     <p>• Когда в <code>eflags</code> установлен <code>REG_NOTBOL</code>, оператор <code>^</code> не соответствует началу строки. Это полезно, когда параметр <code>string</code> является адресом символа в середине сопоставляемого текста.</p>
     <p>• Сходным образом, когда в <code>eflags</code> установлен <code>REG_NOTEOL</code>, оператор <code>$</code> не соответствует концу строки.</p>
     <p>• Когда в <code>cflags</code> включен <code>REG_NEWLINE</code>, то:</p>
     <p> • Символ конца строки не соответствует '<code>.</code>' или дополненному списку символов.</p>
     <p> • Оператор <code>^</code> всегда соответствует положению непосредственно за вставленным символом конца строки независимо от установки <code>REG_BOL</code>.</p>
     <p> • Оператор <code>$</code> всегда соответствует положению непосредственно перед вставленным символом конца строки независимо от установки <code>REG_EOL</code>.</p>
     <p>Когда вы осуществляете построчный ввод/вывод, как в случае с <code>grep</code>, можно не включать <code>REG_NEWLINE</code> в <code>cflags</code>. Если в буфере несколько строк, и каждую из них нужно рассматривать как отдельную, с сопоставлением <code>^</code> и <code>$</code>, тогда следует включить <code>REG_NEWLINE</code>.</p>
     <p>Структура <code>regex_t</code> по большей части непрозрачна. Код уровня пользователя может исследовать лишь один член этой структуры; остальное предназначено для внутреннего использования процедурами регулярных выражений:</p>
     <p><code>typedef struct {</code></p>
     <p><code> /* ...здесь внутренний материал... */</code></p>
     <p><code> size_t re_nsub;</code></p>
     <p><code> /* ...здесь внутренний материал... */</code></p>
     <p><code>} regex_t;</code></p>
     <p>В структуре <code>regmatch_t</code> есть по крайней мере два члена для использования кодом уровня пользователя:</p>
     <p><code>typedef struct {</code></p>
     <p><code> /* ...здесь возможный внутренний материал... */</code></p>
     <p><code> regoff_t rm_so; /* Смещение начала вложенной строки в байтах */</code></p>
     <p><code> regoff_t rm_eo; /* Смещение первого байта после вложенной строки */</code></p>
     <p><code> /* ...здесь возможный внутренний материал... */</code></p>
     <p><code>} regmatch_t;</code></p>
     <p>Как поле <code>re_nsub</code>, так и структура <code>regmatch_t</code> предназначены для <emphasis>сопоставления вложенных выражений</emphasis>. Рассмотрим такое регулярное выражение: </p>
     <p><code>[:пробел:]]+([[:цифра:]]+)[[:пробел:]]+([[:буква:]])+</code></p>
     <p>Каждое из двух вложенных выражений в скобках могут соответствовать одному или более символам. Более того, текст, соответствующий каждому вложенному выражению, может начинаться и заканчиваться в произвольных участках строки.</p>
     <p><code>regcomp()</code> устанавливает в поле <code>re_nsub</code> число вложенных выражений в скобках внутри регулярного выражения, <code>regexec()</code> заполняет массив <code>pmatch</code> структур <code>regmatch_t</code> смещениями начальных и конечных байтов текста, соответствующих этим вложенным выражениям. Вместе эти данные позволяют заменять текст — удалять его или заменять другим текстом, точно так же, как в текстовом редакторе</p>
     <p><code>pmatch[0]</code> описывает часть строки, соответствующую всему регулярному выражению. Участок от <code>pmatch[1]</code> до <code>pmatch[preg-&gt;re_nsub]</code> описывает ту часть, которая соответствует каждому вложенному выражению в скобках. (Таким образом, вложенные выражения нумеруются начиная с 1.) Элементы <code>rm_so</code> и <code>rm_eo</code> не используемых элементов массива <code>pmatch</code> установлены в -1.</p>
     <p><code>regexec()</code> заполняет не более <code>nmatch-1</code> элементов <code>pmatch</code>; поэтому следует убедиться, что имеется по крайней мере на 1 элемент больше, чем в <code>preg-&gt;re_nsub</code>.</p>
     <p>Наконец, флаг <code>REG_NOSUB</code> для <code>regcomp()</code> означает, что начальная и завершающая информация не нужна. Этот флаг следует использовать, когда эти сведения не нужны; это потенциально может довольно значительно повысить производительность <code>regexec()</code>.</p>
     <p>Другими словами, если все, что вам нужно знать, это «соответствует ли?», включите <code>REG_NOSUB</code>. Однако, если нужно также знать, «где находится соответствующий текст?», этот флаг следует опустить.</p>
     <p>В заключение, как <code>regcomp()</code>, так и <code>regexec()</code> возвращают 0, если они успешны, или определенный код ошибки, если нет. Коды ошибок перечислены в табл. 12.9.</p>
     <empty-line/>
     <p><strong>Таблица 12.9</strong>. Коды ошибок <code>regcomp()</code> и <code>regexec()</code></p>
     <table>
      <tr align="left">
       <th align="left" valign="top">Константа</th>
       <th align="left" valign="top">Значение</th>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_BADBR</code></td>
       <td align="left" valign="top">Содержимое '<code>\{...\}</code>' недействительно.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_BADPAT</code></td>
       <td align="left" valign="top">Регулярное выражение недействительно</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_BADRPT</code></td>
       <td align="left" valign="top">Символу <code>?</code>, <code>+</code> или <code>*</code> не предшествует действительное регулярное выражение.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_EBRACE</code></td>
       <td align="left" valign="top">Фигурные скобки ('<code>\{...\}</code>') не сбалансированы</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_EBRACK</code></td>
       <td align="left" valign="top">Квадратные скобки ('<code>[...]</code>') не сбалансированы</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_ECOLLATE</code></td>
       <td align="left" valign="top">В шаблоне использован недействительный элемент сортировки</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_ECTYPE</code></td>
       <td align="left" valign="top">В шаблоне использован недействительный класс символов</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_EESCAPE</code></td>
       <td align="left" valign="top">В шаблоне есть завершающий символ <code>\</code></td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_EPAREN</code></td>
       <td align="left" valign="top">Группирующие скобки ('<code>(...)</code>' или '<code>\(...\)</code>') не сбалансированы</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_ERANGE</code></td>
       <td align="left" valign="top">Конечная точка в диапазоне не действительна</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_ESPACE</code></td>
       <td align="left" valign="top">Функции не хватило памяти</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_ESUBREG</code></td>
       <td align="left" valign="top">Цифра в '<code>\<emphasis>цифра</emphasis></code>' недействительна</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><code>REG_NOMATCH</code></td>
       <td align="left" valign="top">Строка не соответствует шаблону</td>
      </tr>
     </table>
     <p>Для демонстрации регулярных выражений <code>ch12-grep.c</code> предусматривает базовую реализацию стандартной программы <code>grep</code>, которая отыскивает соответствие шаблону. Наша версия использует по умолчанию базовые регулярные выражения. Для использования вместо этого расширенных регулярных выражений она принимает опцию <code>-E</code>, а для игнорирования регистра символов опцию <code>-i</code>. Как и настоящая <code>grep</code>, если в командной строке не указаны файлы, наша <code>grep</code> читает со стандартного ввода, а для обозначения стандартного ввода, как и в настоящей <code>grep</code>, может быть использовано имя файла '<code>-</code>'. (Эта методика полезна для поиска в стандартном вводе наряду с другими файлами.) Вот программа:</p>
     <p><code>1  /* ch12-grep.c - Простая версия grep, использующая функции POSIX */</code></p>
     <p><code>2</code></p>
     <p><code>3  #define _GNU_SOURCE 1 /* для getline)) */</code></p>
     <p><code>4  #include &lt;stdio.h&gt;</code></p>
     <p><code>5  #include &lt;errno.h&gt;</code></p>
     <p><code>6  #include &lt;regex.h&gt;</code></p>
     <p><code>7  #include &lt;unistd.h&gt;</code></p>
     <p><code>8  #include &lt;sys/types.h&gt;</code></p>
     <p><code>9</code></p>
     <p><code>10 char *myname; /* для сообщений об ошибках */</code></p>
     <p><code>11 int ignore_case = 0; /* опция -i: игнорировать регистр */</code></p>
     <p><code>12 int extended = 0; /* опция -E: использовать расширенные регулярные выражения */</code></p>
     <p><code>13 int errors = 0; /* число ошибок */</code></p>
     <p><code>14</code></p>
     <p><code>15 regex_t pattern; /* шаблон для поиска */</code></p>
     <p><code>16</code></p>
     <p><code>17 void compile_pattern(const char *pat);</code></p>
     <p><code>18 void process(const char *name, FILE *fp);</code></p>
     <p><code>19 void usage(void);</code></p>
     <p>Строки 10–15 объявляют глобальные переменные программы. Первый набор (строки 10–13) для опций и сообщений об ошибках. Строка 15 объявляет <code>pattern</code>, в которой хранится откомпилированный шаблон. Строки 17–19 объявляют другие функции программы.</p>
     <p><code>21 /* main --- обработка опций, открывание файлов */</code></p>
     <p><code>22</code></p>
     <p><code>23 int main(int argc, char **argv)</code></p>
     <p><code>24 {</code></p>
     <p><code>25  int с;</code></p>
     <p><code>26  int i;</code></p>
     <p><code>27  FILE *fp;</code></p>
     <p><code>28</code></p>
     <p><code>29  myname = argv[0];</code></p>
     <p><code>30  while ((c = getopt(argc, argv, ":iE")) != -1) {</code></p>
     <p><code>31   switch (c) {</code></p>
     <p><code>32   case 'i':</code></p>
     <p><code>33    ignore_case = 1;</code></p>
     <p><code>34    break;</code></p>
     <p><code>35   case 'E':</code></p>
     <p><code>36    extended = 1;</code></p>
     <p><code>37    break;</code></p>
     <p><code>38   case '?':</code></p>
     <p><code>39    usage();</code></p>
     <p><code>40    break;</code></p>
     <p><code>41   }</code></p>
     <p><code>42  }</code></p>
     <p><code>43</code></p>
     <p><code>44  if (optind == argc) /* проверка исправности */</code></p>
     <p><code>45   usage();</code></p>
     <p><code>46</code></p>
     <p><code>47  compile_pattern(argv[optind]); /* компилировать шаблон */</code></p>
     <p><code>48  if (errors) /* ошибка компиляции */</code></p>
     <p><code>49   return 1;</code></p>
     <p><code>50  else</code></p>
     <p><code>51   optind++;</code></p>
     <p>В строке 29 устанавливается значение <code>myname</code>, а строки 30–45 анализируют опции. Строки 47–51 компилируют регулярное выражение, помещая результаты в <code>pattern</code>, <code>compilе_раttern()</code> увеличивает значение <code>errors</code>, если была проблема. (Соединение функций посредством глобальной переменной, как здесь, обычно считается плохой манерой. Для небольших программ, подобным этой, это сойдет, но для более крупных программ такое сопряжение может стать проблемой.) Если не было ошибок, строка 51 увеличивает значение <code>optind</code> так, что оставшиеся аргументы представляют файлы для обработки.</p>
     <p><code>53  if (optind == argc) /* файлов нет, по умолчанию stdin */</code></p>
     <p><code>54   process("standard input", stdin);</code></p>
     <p><code>55  else {</code></p>
     <p><code>56   /* цикл с файлами */</code></p>
     <p><code>57   for (i = optind; i &lt; argc; i++) {</code></p>
     <p><code>58    if (strcmp(argv[i], "-") == 0)</code></p>
     <p><code>59    process("standard input", stdin);</code></p>
     <p><code>60    else if ((fp = fopen(argv[i], "r")) != NULL) {</code></p>
     <p><code>61     process(argv[i], fp);</code></p>
     <p><code>62     fclose(fp);</code></p>
     <p><code>63    } else {</code></p>
     <p><code>64     fprintf(stderr, "%s: %s: could not open: %s\n",</code></p>
     <p><code>65      argv[0], argv[i], strerror(errno));</code></p>
     <p><code>66     errors++;</code></p>
     <p><code>67    }</code></p>
     <p><code>68   }</code></p>
     <p><code>69  }</code></p>
     <p><code>70</code></p>
     <p><code>71  regfree(&amp;pattern);</code></p>
     <p><code>72  return errors != 0;</code></p>
     <p><code>73 }</code></p>
     <p>Строки 53–69 обрабатывают файлы, отыскивая соответствующие шаблону строки. Строки 53–54 обрабатывают случай, когда файлы не указаны: программа читает со стандартного ввода. В противном случае, строки 57–68 обрабатывают в цикле файлы. Строка 58 обрабатывает особый случай '<code>-</code>', обозначающий стандартный ввод, строки 60–62 обрабатывают обычные файлы, а строки 63–67 обрабатывают ошибки.</p>
     <p><code>75 /* compile_pattern --- компиляция шаблона */</code></p>
     <p><code>76</code></p>
     <p><code>77 void compile_pattern(const char *pat)</code></p>
     <p><code>78 {</code></p>
     <p><code>79  int flags = REG_NOSUB; /* информация о месте совпадения не требуется */</code></p>
     <p><code>80  int ret;</code></p>
     <p><code>81 #define MSGBUFSIZE 512 /* произвольно */</code></p>
     <p><code>82  char error[MSGBUFSIZE];</code></p>
     <p><code>83</code></p>
     <p><code>84  if (ignore_case)</code></p>
     <p><code>85   flags |= REG_ICASE;</code></p>
     <p><code>86  if (extended)</code></p>
     <p><code>87   flags |= REG_EXTENDED;</code></p>
     <p><code>88</code></p>
     <p><code>89  ret = regcomp(&amp;pattern, pat, flags);</code></p>
     <p><code>90  if (ret != 0) {</code></p>
     <p><code>91   (void)regerror(ret, &amp;pattern, error, sizeof error);</code></p>
     <p><code>92   fprintf(stderr, "%s: pattern '%s': %s\n", myname, pat, error);</code></p>
     <p><code>93   errors++;</code></p>
     <p><code>94  }</code></p>
     <p><code>95 }</code></p>
     <p>Строки 75–95 определяют функцию <code>compile_pattern()</code>. Она сначала устанавливает <code>REG_NOSUB</code> в <code>flags</code>, поскольку нам нужно знать лишь «подходит ли строка?», а не «где в строке располагается подходящий текст?»</p>
     <p>Строки 84-85 добавляют дополнительные флаги в соответствии с опциями командной строки. Строка 89 компилирует шаблон, а строки 90–94 сообщают о возникших ошибках</p>
     <p><code>97  /* process --- читает строки текста и сопоставляет их с шаблоном */</code></p>
     <p><code>98</code></p>
     <p><code>99  void process(const char *name, FILE *fp)</code></p>
     <p><code>100 {</code></p>
     <p><code>101  char *buf = NULL;</code></p>
     <p><code>102  size_t size = 0;</code></p>
     <p><code>103  char error[MSGBUFSIZE];</code></p>
     <p><code>104  int ret;</code></p>
     <p><code>105</code></p>
     <p><code>106  while (getline(&amp;buf, &amp;size, fp) != -1) {</code></p>
     <p><code>107   ret = regexec(&amp;pattern, buf, 0, NULL, 0);</code></p>
     <p><code>108   if (ret != 0) {</code></p>
     <p><code>109    if (ret != REG_NOMATCH) {</code></p>
     <p><code>110     (void)regerror(ret, &amp;pattern, error, sizeof error);</code></p>
     <p><code>111     fprintf(stderr, "%s: file %s: %s\n", myname, name, error);</code></p>
     <p><code>112     free(buf);</code></p>
     <p><code>113     errors++;</code></p>
     <p><code>114     return;</code></p>
     <p><code>115    }</code></p>
     <p><code>116   } else</code></p>
     <p><code>117   printf("%s: %s", name, buf); /* вывести подходящие строки */</code></p>
     <p><code>118  }</code></p>
     <p><code>119  free(buf);</code></p>
     <p><code>120 }</code></p>
     <p>Строки 97–120 определяют функцию <code>process()</code>, которая читает файл и выполняет сопоставление с регулярным выражением. Внешний цикл (строки 106–119) читает строки ввода. Для избежания проблем с длиной строки мы используем <code>getline()</code> (см. раздел 3.2.1.9 «Только GLIBC: чтение целых строк: <code>getline()</code> и <code>getdelim()</code>»). Строка 107 вызывает <code>regexec()</code>. Ненулевое возвращаемое значение означает либо неудачное сопоставление, либо какую-нибудь другую ошибку. Строки 109–115 соответственно проверяют <code>REG_NOMATCН</code> и выводят ошибку лишь тогда, когда возникла какая-нибудь <emphasis>другая</emphasis> проблема — неудачное сопоставление не является ошибкой</p>
     <p>Если возвращаемое значение равно 0, строка совпала с шаблоном и соответственно строка 117 выводит имя файла и совпавшую строку.</p>
     <p><code>122 /* usage --- вывод сообщения об использовании и выход */</code></p>
     <p><code>123</code></p>
     <p><code>124 void usage(void)</code></p>
     <p><code>125 {</code></p>
     <p><code>126  fprintf(stderr, "usage: %s [-i] [-E] pattern [ files ... ]\n", myname);</code></p>
     <p><code>127  exit(1);</code></p>
     <p><code>128 }</code></p>
     <p>Функция <code>usage()</code> выводит сообщение об использовании и завершает программу. Она вызывается, когда предоставлены недействительные аргументы или не предоставлен шаблон (строки 38–40 и 44–45).</p>
     <p>Вот и все! Скромная, но тем не менее полезная версия <code>grep</code> в 130 строк кода.</p>
    </section>
    <section>
     <title>
      <p>12.9. Рекомендуемая литература</p>
     </title>
     <p>1. <emphasis>Programming Pearls</emphasis>, 2nd edition, by Jon Louis Bentley Addison-Wesley, Reading, Massachusetts, USA, 2000. ISBN- 0-201-65788-0. См. также веб-сайт этой книги.<a l:href="#n131" type="note">[131]</a></p>
     <p>Проектирование программы с операторами проверки является одной из главных тем в этой книге.</p>
     <p>2. <emphasis>Building Secure Software How to Avoid Security Problems the Right Way</emphasis>, by John Viega and Gary McGraw Addison-Wesley, Reading, Massachusetts, USA, 2001. ISBN: 0-201-72152-X.</p>
     <p>Состояния гонки являются одной из многих проблем, о которых нужно побеспокоиться при написании безопасного программного обеспечения. Другой проблемой являются случайные числа. Данная книга рассматривает наряду с другими обе эти проблемы (Мы упоминали о ней в предыдущей главе.)</p>
     <p>3. <emphasis>The Art of Computer Programming. Volume 2. Seminumerical Algorithms</emphasis>, 3<sup>rd</sup> edition, by Donald E. Knuth Addison-Wesley, Reading, Massachusetts, USA, 1998. ISBN- 0-201-89684-2.<a l:href="#n132" type="note">[132]</a> См также веб-сайт этой книги.<a l:href="#n133" type="note">[133]</a></p>
     <p>Это классическое справочное руководство по генерации случайных чисел.</p>
     <p>4. <emphasis>Random Number Generation and Monte Carlo Methods</emphasis>, 2nd edition, by James E. Gentle Springer-Verlag, Berlin, Germany. 2003. ISBN: 0-387-00178-6.</p>
     <p>Данная книга широко освещает методы генерации и тестирования псевдослучайных чисел. Хотя для неё также требуется математическая и статистическая подготовка, уровень не такой высокий, как в книге Кнута. (Благодарим Nelson H.F. Beebe за указание этой ссылки.)</p>
     <p>5. <emphasis>sed &amp; awk</emphasis>, 2nd edition, by Dale Dougherty and Arnold Robbins. O'Reilly and Associates, Sebastopol, California, USA, 1997. ISBN: 1-56592-225-5.</p>
     <p>Эта книга осторожно вводит в регулярные выражения и обработку текста, начиная с <code>grep</code> и продвигаясь к более мощным инструментам <code>sed</code> и <code>awk</code>.</p>
     <p>6. <emphasis>Mastering Regular Expressions</emphasis>, 2nd edition, by Jeffrey E.F. Friedl. O'Reilly and Associates, Sebastopol, California, USA, 2002.<a l:href="#n134" type="note">[134]</a> ISBN: 0-59600-289-0.</p>
     <p>Регулярные выражения являются важной частью Unix. Чтобы научиться заменять, вырезать и распределять текст с использованием регулярных выражений, мы рекомендуем эту книгу</p>
     <p>7. Руководство для GNU <code>grep</code> также объясняет регулярные выражения. На системе GNU/Linux для просмотра локальной копии вы можете использовать '<code>info grep</code>'. Или использовать браузер для прочтения онлайн-документации проекта GNU для <code>grep</code>.<a l:href="#n135" type="note">[135]</a></p>
    </section>
    <section>
     <title>
      <p>12.10. Резюме</p>
     </title>
     <p>• Операторы проверки предоставляют способ сделать утверждения о предполагаемом состоянии программы. Они являются полезным инструментом для проектирования и отладки и обычно должны оставаться в коде изделия. Однако, будьте внимательны, чтобы не перепутать операторы проверки с проверками возможных ошибок времени исполнения.</p>
     <p>• Функции <code>mem<emphasis>XXX</emphasis>()</code> являются аналогичными более известным функциям <code>str<emphasis>XXX</emphasis>()</code>. Самой большой их ценностью является то. что они могут работать с двоичными данными; нулевые байты не отличаются от других байтов. Больше известна <code>memcpy()</code> против <code>memmove()</code>, обрабатывающей перекрывающиеся копии.</p>
     <p>• Временные файлы полезны во многих приложениях. Функции API <code>tmpfile()</code> и <code>mkstemp()</code> являются предпочтительными способами создания временных файлов, в то же время позволяя избежать состояния гонки и связанных с ней проблем безопасности. Многие программы для указания местоположения своих временных файлов используют переменную окружения <code>TMPDIR</code>, а если она не определена, приемлемое значение по умолчанию (обычно <code>/tmp</code>). Это хорошее соглашение, которое следует принять на вооружение в своих программах.</p>
     <p>• Функция <code>abort()</code> посылает вызывающему процессу сигнал <code>SIGABRT</code>. Результатом является завершение процесса и создание дампа ядра, предположительно для отладки.</p>
     <p>• <code>setjmp()</code> и <code>longjmp()</code> обеспечивают нелокальный переход. Это мощная возможность, которая должна использоваться с осторожностью. <code>sigsetjmp()</code> и <code>siglongjmp()</code> сохраняют и восстанавливают маску сигналов процесса, когда программа осуществляет нелокальный переход. Проблемы с нелокальными переходами иногда перевешивают их преимущества, соответственно используйте эти процедуры лишь когда нет лучшего способа структурировать ваше приложение.</p>
     <p>• Случайные числа полезны для множества приложений. Большинство программ используют псевдослучайные числа — последовательности номеров, которые кажутся случайными, но которые могут быть воспроизведены с помощью одного и того же начального значения. <code>rand()</code> и <code>srand()</code> являются первоначальными функциями API, стандартизованными языком С. На многих системах <code>rand()</code> использует низкокачественный алгоритм, <code>random()</code> и <code>srandom()</code> используют лучший алгоритм, включены в стандарт POSIX и являются предпочтительными по сравнению с <code>rand()</code> и <code>srand()</code>. Используйте специальные файлы <code>/dev/random</code> и <code>/dev/urandom</code>, если (а) они доступны и (б) если вам нужны случайные числа высокого качества.</p>
     <p>• Три функции API предоставляют все более мощные возможности для развертывания метасимволов (подстановки символов).</p>
     <p>  • <code>fnmatch()</code> является простейшей, возвращающей true/false, если данная строка соответствует или не соответствует шаблону символов подстановки оболочки.</p>
     <p>  • <code>glob()</code> просматривает файловую систему, возвращая список путей, которые соответствуют данному шаблону. Когда требуются стандартные возможности <code>glob()</code>, следует использовать эту функцию. Хотя GLIBC версия <code>glob()</code> имеет некоторые расширения, переносимые программы, которым нужны дополнительные возможности, должны вместо этого использовать <code>wordexp()</code>. (Программы, которые будут работать лишь на системах GNU/Linux, не должны стесняться использовать полную мощь GLIBC <code>glob()</code>.)</p>
     <p>  • <code>wordexp()</code> не только делает то, что делает <code>glob()</code>, но также выполняет полное развертывание слов в стиле оболочки, включая развертывание тильды, развертывание переменных оболочки и подстановку команд.</p>
     <p>• Функции <code>regcomp()</code> и <code>regexec()</code> обеспечивают доступ к базовым и расширенным регулярным выражениям POSIX. Используя одну из этих функций, можно заставить свою программу вести себя идентично со стандартными утилитами, значительно упрощая использование программы пользователями, знакомыми с GNU/Linux и Unix.</p>
    </section>
    <section>
     <title>
      <p>Упражнения</p>
     </title>
     <p>1. Используйте <code>read()</code> и <code>memcmp()</code> для написания простой версии программы <code>cmp</code>, которая сравнивает два файла. Вашей версии не нужно поддерживать какие-нибудь опции.</p>
     <p>2. Используйте макрос <code>&lt;stdio.h&gt; getc()</code> и прямое сравнение каждого прочитанного символа для написания другой версии <code>cmp</code>, которая сравнивает два файла. Сравните производительность этой версии с производительностью написанной в предыдущем упражнении.</p>
     <p>3. (Средней трудности) Рассмотрите функции <code>&lt;stdio.h&gt; fgets()</code> и GLIBC <code>getline()</code>. Полезна ли <code>memcpy()</code> для их реализации? Набросайте с ее использованием возможную реализацию <code>fgets()</code>.</p>
     <p>4. (Трудное) Найдите исходный код GLIBC версии <code>memcmp()</code>. Он должен быть на одном из CD-ROM с исходным кодом в вашем дистрибутиве GNU/Linux, или же вы можете найти его в сети. Исследуйте код и объясните его.</p>
     <p>5. Проверьте свою память. Как <code>tmpfile()</code> организует удаление файла, когда закрыт указатель файла?</p>
     <p>6. Используя <code>mkstemp()</code> и <code>fdopen()</code>, а также другие необходимые функции или системные вызовы, напишите свою версию <code>tmpfile()</code>. Протестируйте ее тоже.</p>
     <p>7. Опишите преимущества и недостатки использования <code>unlink()</code> для имени файла, созданного <code>mkstemp()</code>, непосредственно после возвращения <code>mkstemp()</code>.</p>
     <p>8. Напишите свою версию <code>mkstemp()</code>, используя <code>mktemp()</code> и <code>open()</code>. Как вы можете обеспечить те же гарантии уникальности, которые обеспечивает <code>mkstemp()</code>?</p>
     <p>9. Программы, использующие <code>mkstemp()</code>, должны обеспечивать удаление файла при завершении. (Предположим, что файл не удаляется сразу же после открытия по тем или иным причинам.) Это включает в себя случай, когда может поступить сигнал завершения. Поэтому удаление файла должно быть частью перехватчика сигнала. Как вы это сделаете?</p>
     <p>10. (Трудное) Даже с урезанной очисткой при обработке сигнала все еще имеется состояние гонки. Есть небольшое окно между созданием временного файла функцией <code>mkstemp()</code> и возвращением и записью его имени в переменной (для использования функцией обработки сигнала). Если в это окно попадает не перехваченный сигнал, программа завершается и оставляет временный файл. Как вы закроете это окно? (Спасибо Jim Meyering.)</p>
     <p>11. Попробуйте откомпилировать и запустить <code>ch12-setjmp.c</code> на как можно большем количестве различных систем с использованием как можно большего количества различных компиляторов, к каким у вас есть доступ. Попробуйте компилировать с различными уровнями оптимизации. Какие изменения поведения вы видели (если они были)?</p>
     <p>12. Посмотрите файл <code>/usr/src/libc/gen/sleep.c</code> в дистрибутиве исходного кода V7 Unix. Он содержит реализацию функции <code>sleep()</code>, описанную в разделе 10.8.1 «Сигнальные часы: <code>sleep()</code>, <code>alarm()</code> и <code>SIGALARM</code>». Распечатайте ее и прокомментируйте в стиле наших примеров, чтобы объяснить ее работу.</p>
     <p>13. Посмотрите справочную страницу <emphasis>lrand48</emphasis>(3) на системе GNU/Linux или System V. Выглядит ли этот интерфейс более простым или трудным для использования, чем <code>random()</code>?</p>
     <p>14. Возьмите <code>ch08-nftw.c</code> из раздела 8.4.3 «Перемещение по иерархии: <code>nftw()</code>» и добавьте опцию <code>--exclude=pattern</code>. Файлы, соответствующие паттерну, не должны выводиться.</p>
     <p>15. (Трудное) Почему GLIBC нужны указатели на альтернативные версии функций стандартных каталогов и <code>stat()</code>? Не может ли она вызывать их непосредственно?</p>
     <p>16. Измените <code>ch12-glob.c</code> для использования функции <code>wordexp()</code>. Поэкспериментируйте с ней, проделав несколько дополнительных вещей, которые она предоставляет. Не забудьте взять аргументы командной строки в кавычки, чтобы <code>wordexp()</code> на самом деле выполнила свою работу!</p>
     <p>17. Стандартная <code>grep</code> выводит имя файла, лишь когда в командной строке указано больше одного файла. Сделайте так, чтобы <code>ch12-grep.c</code> действовала таким же образом.</p>
     <p>18. Посмотрите справочную страницу <emphasis>grep</emphasis>(1). Добавьте к <code>ch12-grep.c</code> стандартные опции <code>-e</code>, <code>-s</code> и <code>-v</code>.</p>
     <p>19. Напишите простую замещающую программу:</p>
     <p><code>subst [-g] <emphasis>шаблон подстановка</emphasis> [<emphasis>файлы</emphasis> ...]</code></p>
     <p>Она должна читать текстовые строки из указанных <emphasis>файлов</emphasis> или из стандартного ввода, если они не указаны. Каждая строка должна сравниваться на соответствие <emphasis>шаблону</emphasis>. Если обнаружено соответствие, оно должно замещаться <emphasis>подстановкой</emphasis>.</p>
     <p>Если указана опция <code>-g</code>, замещаться должно не только первое совпадение, но и все остальные совпадения в строке.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 13</p>
     <p>Интернационализация и локализация</p>
    </title>
    <section>
     <p>Ранние вычислительные системы обычно для своего вывода (приглашений, сообщений об ошибках) и ввода (ответы на запросы, такие, как «да» и «нет») использовали английский язык. Это было верно для систем Unix вплоть до середины 1980-х. В конце 80-х, начиная с первого стандарта ISO для С и продолжая стандартами POSIX 1990-х и современным стандартом POSIX, были разработаны возможности для работы программ на нескольких языках без необходимости поддержки нескольких версий одной и той же программы. Данная глава описывает, как современные программы должны справляться с многоязычными проблемами.</p>
    </section>
    <section>
     <title>
      <p>13.1. Введение</p>
     </title>
     <p>Центральной концепцией является <emphasis>окружение</emphasis>, место, в котором работает программа. Локали содержат в себе следующие сведения: локальный набор символов; сведения о формате отображения даты и времени; форматирование и отображение денежных сумм; форматирование и отображение числовых значений (с или без разделителей тысяч, какой символ используется в качестве разделителя дробной части числа и т.д.).</p>
     <p><emphasis>Интернационализация</emphasis> является процессом написания (или изменения) программы таким образом, что она может работать с различными локалями. <emphasis>Локализация</emphasis> является процессом приспособления интернационализированной программы для определенной локали. Часто вместо этих терминов используют сокращения <emphasis>i18n</emphasis> и <emphasis>l10n</emphasis> соответственно. (Числовое значение указывает, сколько букв в середине слова, а эти сокращения имеют небольшое сходство с полными терминами.<a l:href="#n136" type="note">[136]</a> Их также гораздо легче набирать.) Другим часто встречающимся термином является <emphasis>поддержка родного языка</emphasis>, обозначаемая как <emphasis>NLS</emphasis><a l:href="#n137" type="note">[137]</a>; NLS обозначает программную поддержку для i18n и l10n.</p>
     <p>Кроме того, некоторые люди используют термин <emphasis>глобализация</emphasis> (сокращенно <emphasis>g10n</emphasis>) для обозначения процесса подготовки всех возможных локализаций для интернационализированной программы. Другими словами, подготовки программы для глобального использования.</p>
     <p>Возможности NLS существуют на двух уровнях. Первым уровнем является библиотека С. Она предоставляет сведения о локали; процедуры для обработки большей части низкоуровневых подробностей работы по форматированию даты/времени, числовых и денежных значений; и процедуры для корректного для данной локали сопоставления регулярных выражений и классификации символов и сравнений. Именно возможности библиотеки появляются в стандартах С и POSIX.</p>
     <p>На уровне приложения GNU <code>gettext</code> предоставляет команды и библиотеку для локализации программы: т.е. для возможности вывода сообщений на одном или более естественных языках. GNU <code>gettext</code> основана на плане, первоначально разработанном Sun Microsystems для Solaris<a l:href="#n138" type="note">[138]</a>; однако, она была реализована с нуля и теперь предоставляет расширения к первоначальному <code>gettext</code> Solaris. GNU <code>gettext</code> является стандартом де-факто для локализации программ, особенно в мире GNU.</p>
     <p>В дополнение к локалям и <code>gettext</code> стандарт С предоставляет возможности для работы с несколькими наборами символов и с их <emphasis>кодировками</emphasis> — способом представления больших наборов символов с помощью меньшего числа байтов. Мы кратко затронем эти проблемы в конце главы.</p>
    </section>
    <section>
     <title>
      <p>13.2. Локали и библиотека С</p>
     </title>
     <section>
      <p>Специфичное для локали поведение управляется посредством установки переменных окружения, описывающих, какую локаль (локали) использовать для той или иной информации. Число доступных локалей, предлагаемых каждой конкретной операционной системой, колеблется от менее чем десяти на некоторых коммерческих системах Unix до сотен локалей на системах GNU/Linux. ('<code>locale -a</code>' выводит полный список доступных локалей.)</p>
      <p>Гарантируется существование двух локалей, «С» и «POSIX». Они действуют в качестве локали по умолчанию, предоставляя окружение 7-разрядного ASCII, поведение которого такое же, как на традиционных системах Unix без поддержки локалей. В противном случае, локали обозначают язык, страну, а также могут включать сведения о наборе символов. Например, '<code>it_IT</code>' используется для итальянского языка в Италии с использованием системного набора символов по умолчанию, a '<code>it_IT.UTF-8</code>' использует кодировку UTF-8 для набора символов Unicode.</p>
      <p>Дополнительные подробности об именах локалей можно найти в справочной странице GNU/Linux <emphasis>setlocale</emphasis>(3). Обычно дистрибутивы GNU/Linux устанавливают для системы локаль по умолчанию при ее установке, основываясь на языке, выбранном тем кто устанавливал ее, и пользователям больше не приходится об этом беспокоиться.</p>
     </section>
     <section>
      <title>
       <p>13.2.1. Категории локалей и переменные окружения</p>
      </title>
      <p>Заголовочный файл <code>&lt;locale.h&gt;</code> определяет функции и структуры локали. Категории локали определяют разновидности информации, которые будут для программы зависимы от локали. Категории доступны в виде набора именованных констант. Они перечислены в табл. 13.1.</p>
      <empty-line/>
      <p><strong>Таблица 13.1</strong>. Константы категорий локалей ISO С, определенные в <code>&lt;locale.h&gt;</code></p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Категория</th>
        <th align="left" valign="top">Значение</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>LC_ALL</code></td>
        <td align="left" valign="top">Эта категория включает всю возможную информацию локали. Она состоит из оставшейся части элементов этой таблицы</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>LC_COLLATE</code></td>
        <td align="left" valign="top">Категория для сравнения строк (обсуждаемого ниже) и областей регулярных выражений</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>LC_CTYPE</code></td>
        <td align="left" valign="top">Категория для классификации символов (заглавные, строчные и т.д.) Это влияет на сопоставление регулярных выражений и функции <code>is<emphasis>XXX</emphasis>()</code> в <code>&lt;ctype.h&gt;</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>LC_MESSAGES</code></td>
        <td align="left" valign="top">Категория для специфичных для локали сообщений. Эта категория вступает в игру с GNU <code>gettext</code>, которая обсуждает далее в главе</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>LC_MONETARY</code></td>
        <td align="left" valign="top">Категория для форматирования денежной информации, такой, как локальные и международные символы для местной валюты (например, $ против USD для доллара США), форматирования отрицательных величин и т.д.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>LC_NUMERIC</code></td>
        <td align="left" valign="top">Категория для форматирования числовых значений</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>LC_TIME</code></td>
        <td align="left" valign="top">Категория для форматирования дат и времени</td>
       </tr>
      </table>
      <p>Эти категории определены различными стандартами. Некоторые системы могут поддерживать дополнительные категории, такие, как <code>LC_TELEPHONE</code> или <code>LC_ADDRESS</code>. Однако, они не стандартизованы; любой программе, которой нужно их использовать, но которая все равно должна быть переносимой, следует использовать <code>#ifdef</code> для окружения соответствующих разделов.</p>
      <p>По умолчанию, программы С и библиотека С ведут себя так, как если бы они находились в локали «С» или «POSIX» для обеспечения обратной совместимости со старыми системами. Однако, вызвав <code>setlocale()</code> (как описано ниже), программа может включить действие локали. После того, как программа это сделала, пользователь может, установив переменные окружения, включать и выключать возможности локали, которые будет иметь программа.</p>
      <p>Переменные окружения имеют те же самые имена, что и перечисленные в табл. 13.1 категории локалей. Таким образом, команда —</p>
      <p><code>export LC_NUMERIС=en_DK LC_TIME=C</code></p>
      <p>— определяет, что числа должны выводиться в соответствии с локалью '<code>en_DK</code>' (английский язык в Дании), но что значения даты и времени должны выводиться в соответствии с обычной локалью '<code>С</code>'. (Этот пример просто иллюстрирует, что вы можете указывать для различных категорий различные локали; это не является чем-то обязательным, что вы <emphasis>должны</emphasis> делать.)</p>
      <p>Переменная окружения <code>LC_ALL</code> перекрывает все другие переменные <code>LC_<emphasis>xxx</emphasis></code>. Если <code>LC_ALL</code> не установлена, библиотека ищет определенные переменные (<code>LC_CTYPE</code>, <code>LC_MONETARY</code> и т.д.). Наконец, если ни одна из них не установлена, библиотека ищет переменную <code>LANG</code>. Вот небольшая демонстрация с использованием <code>gawk</code>:</p>
      <p><code>$ <strong>unset LC_ALL LANG</strong> /* Удалить переменные по умолчанию */</code></p>
      <p><code>$ <strong>export LС_NUMERIC=en_DK LC_TIME=C</strong></code></p>
      <p><code> /* Европейские числа, дата и время по умолчанию */</code></p>
      <p><code>$ <strong>gawk 'BEGIN { print 1.234 ; print strftime() }'</strong></code></p>
      <p><code> /* Вывести число, текущие дату и время */</code></p>
      <p><code>1,234</code></p>
      <p><code>Wed Jul 09 09:32:18 PDT 2003</code></p>
      <p><code>$ <strong>export LC_NUMERIC=it_IT LC_TIME=it_IT</strong></code></p>
      <p><code> /* Итальянские числа, дата и время */</code></p>
      <p><code>$ <strong>gawk 'BEGIN { print 1.234 ; print strftime() }'</strong></code></p>
      <p><code> /* Вывести число, текущие дату и время */</code></p>
      <p><code>1,234</code></p>
      <p><code>mer lug 09 09:32:40 PDT 2003</code></p>
      <p><code>$ <strong>export LC_ALL=C</strong> /* Установить перекрывающую переменную */</code></p>
      <p><code>$ <strong>gawk 'BEGIN { print 1.234 ; print strftime() }'</strong></code></p>
      <p><code> /* Вывести число, текущие дату и время */</code></p>
      <p><code>1.234</code></p>
      <p><code>Wed Jul 09 09:33:00 PDT 2003</code></p>
      <p>Для <code>awk</code> стандарт POSIX констатирует, что числовые константы в исходном коде всегда используют в качестве десятичного разделителя '<code>.</code>' тогда как числовой вывод следует правилам локали).</p>
      <p>Почти все GNU версии стандартных утилит Unix могут использовать локали. Таким образом, особенно на системах GNU/Linux, установка этих переменных позволяет вам контролировать поведение системы<a l:href="#n139" type="note">[139]</a>.</p>
     </section>
     <section>
      <title>
       <p>13.2.2. Установка локали: <code>setlocale()</code></p>
      </title>
      <p>Как уже упоминалось, если вы ничего не делаете, программы на С и библиотека С ведет себя так, как если бы использовалась локаль «С». Функция <code>setlocale()</code> устанавливает соответствующую локаль:</p>
      <p><code>#include &lt;locale.h&gt; /* ISO С */</code></p>
      <empty-line/>
      <p><code>char *setlocale(int category, const char *locale);</code></p>
      <p>Аргумент <code>category</code> является одной из категорий, описанных в разделе 13.2.1 «Категории локалей и переменные окружения». Аргумент <code>locale</code> является строкой, именующей используемую для этой категории локаль. Когда <code>locale</code> является пустой строкой (<code>""</code>), <code>setlocale()</code> проверяет соответствующие переменные окружения.</p>
      <p>Если <code>locale</code> равно <code>NULL</code>, сведения о локали не изменяются. Вместо этого функция возвращает строку, представляющую текущую локаль для данной категории.</p>
      <p>Поскольку каждая категория может быть установлена индивидуально, автор приложения решает, насколько будет программа использовать локаль. Например, если <code>main()</code> делает <emphasis>лишь</emphasis> это —</p>
      <p><code>setlocale(LC_TIME, "");</code></p>
      <p><code> /* Использование локали только для времени и все */</code></p>
      <p>— тогда, независимо от установленных в окружении других переменных <code>LC_<emphasis>xxx</emphasis></code>, локали подчиняются лишь функции времени и даты. Все остальные действуют так, как если бы программа по-прежнему работала в локали «С». Сходным образом вызов:</p>
      <p><code>setlocale(LC_TIME, "it_IT"); /* Время всегда итальянское */</code></p>
      <p>заменяет переменную окружения <code>LC_TIME</code> (также, как <code>LC_ALL</code>), заставляя программу использовать для вычислений времени/даты данные для Италии. (Хотя Италия может быть прекрасным местом, программам лучше использовать <code>""</code>, чтобы они могли корректно работать везде; этот пример предназначен лишь для объяснения того, как работает <code>setlocale()</code>.)</p>
      <p>Можно индивидуально вызывать <code>setlocale()</code> для каждой категории, но простейшим способом является установка всего одним махом:</p>
      <p><code>/* Находясь в Риме, вместо «всего» делайте все как римляне. :-) */</code></p>
      <p><code>setlocale(LC_ALL, "");</code></p>
      <p>Возвращаемое <code>setlocale()</code> значение является текущей установкой локали. Это либо строковое значение, переданное в предыдущем вызове, либо <emphasis>непрозрачное</emphasis> значение, представляющее используемую вначале локаль. Это самое значение может быть затем передано обратно <code>setlocale()</code>. Для последующего использования возвращаемое значение должно быть скопировано в локальное хранилище, поскольку это указатель на внутренние данные.</p>
      <p><code>char *initial_locale;</code></p>
      <p><code>initial_locale = strdup(setlocale(LC_ALL, "")); /* сохранить копию */</code></p>
      <p><code>...</code></p>
      <p><code>(void)setlocale(LC_ALL, initial_locale); /* восстановить ее */</code></p>
      <p>Здесь мы сохранили копию, использовав функцию POSIX <code>strdup()</code> (см. раздел 3.2.2 «Копирование строк: <code>strdup()</code>»).</p>
     </section>
     <section>
      <title>
       <p>13.2.3. Сравнение строк: <code>strcoll()</code> и <code>strxfrm</code>()</p>
      </title>
      <p>Знакомая функция <code>strcmp()</code> сравнивает две строки, возвращая отрицательное, нулевое или положительное значения, если первая строка меньше, равна или больше второй. Это сравнение основано на числовых значениях символов в машинном наборе символов. Из-за этого результаты <code>strcmp()</code> <emphasis>никогда не изменяются</emphasis>.</p>
      <p>Однако, при наличии локалей простого числового сравнения недостаточно. Каждая локаль определяет для содержащихся в ней символов <emphasis>последовательность сортировки</emphasis>, другими словами, относительный порядок символов внутри локали. Например, в простом 7-битном ASCII у двух символов '<code>А</code>' и '<code>а</code>' десятичные значения равны 65 и 97 соответственно. Соответственно, во фрагменте</p>
      <p><code>int i = strcmp("А", "a");</code></p>
      <p><code>i</code> имеет отрицательное значение. Однако, в локали "<code>en_US.UTF-8</code>" '<code>A</code>' идет <emphasis>после</emphasis> '<code>a</code>', а не перед ним. Таким образом, использование <code>strcmp()</code> для приложений, использующих локаль, является плохой мыслью, мы могли бы сказать, что она возвращает игнорирующий локаль ответ.</p>
      <p>Функция <code>strcoll()</code> (string collate — сортировка строк) существует для сравнения строк с использованием локали:</p>
      <p><code>#include &lt;string.h&gt; /* ISO С */</code></p>
      <empty-line/>
      <p><code>int strcoll(const char *s1, const char *s2);</code></p>
      <p>Она возвращает такие же отрицательные/нулевые/положительные значения, что и <code>strcmp()</code>. Следующая программа, <code>ch13-compare.c</code>, интерактивно демонстрирует разницу:</p>
      <p><code>1  /* ch13-compare.с --- демонстрация strcmp() против strcoll() */</code></p>
      <p><code>2</code></p>
      <p><code>3  #include &lt;stdio.h&gt;</code></p>
      <p><code>4  #include &lt;locale.h&gt;</code></p>
      <p><code>5  #include &lt;string.h&gt;</code></p>
      <p><code>6</code></p>
      <p><code>7  int main(void)</code></p>
      <p><code>8  {</code></p>
      <p><code>9  #define STRBUFSIZE 1024</code></p>
      <p><code>10  char locale[STRBUFSIZE], curloc[STRBUFSIZE];</code></p>
      <p><code>11  char left[STRBUFSIZE], right[STRBUFSIZE];</code></p>
      <p><code>12  char buf[BUFSIZ];</code></p>
      <p><code>13  int count;</code></p>
      <p><code>14</code></p>
      <p><code>15  setlocale(LC_ALL, ""); /* установить локаль */</code></p>
      <p><code>16  strcpy(curloc, setlocale(LC_ALL, NULL)); /* сохранить ее */</code></p>
      <p><code>17</code></p>
      <p><code>18  printf("--&gt; "); fflush(stdout);</code></p>
      <p><code>19  while (fgets(buf, sizeof buf, stdin) != NULL) {</code></p>
      <p><code>20   locale[0] = '\0';</code></p>
      <p><code>21   count = sscanf(buf, "%s %s %s", left, right, locale);</code></p>
      <p><code>22   if (count &lt; 2)</code></p>
      <p><code>23    break;</code></p>
      <p><code>24</code></p>
      <p><code>25   if (*locale) {</code></p>
      <p><code>26    setlocale(LC_ALL, locale);</code></p>
      <p><code>27    strcpy(curloc, locale);</code></p>
      <p><code>28   }</code></p>
      <p><code>29</code></p>
      <p><code>30   printf("%s: strcmp(\"%s\", \"%s\") is %d\n", curloc, left,</code></p>
      <p><code>31    right, strcmp(left, right));</code></p>
      <p><code>32   printf("%s: strcoll(\"%s\", \"%s\") is %d\n", curloc, left,</code></p>
      <p><code>33    right, strcoll(left, right));</code></p>
      <p><code>34</code></p>
      <p><code>35   printf("\n--&gt; "); fflush(stdout);</code></p>
      <p><code>36  }</code></p>
      <p><code>37</code></p>
      <p><code>38  exit(0);</code></p>
      <p><code>39 }</code></p>
      <p>Программа читает входные строки, состоящие из двух сравниваемых слов и необязательной локали, использующейся для сравнения. Если локаль дана, она становится локалью для последующих элементов. Программа начинает с любой локалью, которая установлена в окружении.</p>
      <p>Массив <code>curloc</code> сохраняет текущую локаль для вывода результатов; <code>left</code> и <code>right</code> являются левым и правым сравниваемыми словами (строки 10–11). Основную часть программы составляет цикл (строки 19–36), который читает строки и выполняет работу. Строки 20–23 разделяют входную строку, <code>locale</code> инициализируется пустой строкой, если третья строка не предусмотрена.</p>
      <p>Строки 25–28 устанавливают новую локаль, если она приведена. Строки 30–33 выводят результаты сравнения, а строка 35 приглашает для дальнейшего ввода. Вот демонстрация:</p>
      <p><code>$ <strong>ch13-compare</strong> /* Запуск программы */</code></p>
      <p><code>--&gt; <strong>ABC abc</strong> /* Ввести два слова */</code></p>
      <p><code>С: strcmp("ABC", "abc") is -1 /* Программа началась в локали "С" */</code></p>
      <p><code>С: strcoll("ABC", "abc") is -1 /* В локали "С" идентичные рез-ты */</code></p>
      <empty-line/>
      <p><code>--&gt; <strong>ABC abc en_US</strong> /* Слова те же, локаль "en_US" */</code></p>
      <p><code>en_US: strcmp("ABC", "abc") is -1 /* strcmp() без изменений */</code></p>
      <p><code>en_US: strcoll("ABC", "abc") is 2 /* рез-ты strcoll() изменились' */</code></p>
      <empty-line/>
      <p><code>--&gt; <strong>ABC abc en_US.UTF-8</strong> /* Слова те же, локаль "en_US.UTF-8" */</code></p>
      <p><code>en_US.UTF-8: strcmp("ABC", "abc") is -1</code></p>
      <p><code>en_US. UTF-8: strcoll("ABC", "abc") is 6</code></p>
      <p><code> /* Другое значение, все еще положительное */</code></p>
      <empty-line/>
      <p><code>--&gt; <strong>junk JUNK</strong> /* Новые слова */</code></p>
      <p><code>en_US.UTF-8: strcmp("junk", "JUNK") is 1 /* предыдущая локаль */</code></p>
      <p><code>en_US.UTF-8: strcoll("junk", "JUNK") is -6</code></p>
      <p>Эта программа ясно показывает различие между <code>strcmp()</code> и <code>strcoll()</code>. Поскольку <code>strcmp()</code> работает в соответствии с числовыми значениями символов, она всегда возвращает тот же самый результат, <code>strcoll()</code> понимает проблемы сортировки, и ее результат меняется в соответствии с локалью. Мы видим, что в обеих локалях <code>en_US</code> заглавные буквы идут после строчных.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Специфическая для локали сортировка строк является проблемой также и для сопоставления регулярных выражений. Регулярные выражения допускают диапазоны символов внутри выражений со скобками, такие, как '<code>[a-z]</code>' или '<code>["-/]</code>'. Точное значение такой конструкции (символы, численно располагающиеся между начальной и конечной точками включительно) определено лишь для локалей «С» и «POSIX»</p>
       <p>Для локалей, не являющихся ASCII, такие диапазоны как '<code>[a-z]</code>' могут соответствовать также и заглавным буквам, а не только строчным! Диапазон '<code>["-/]</code>' действителен в ASCII, но не в "<code>en_US.UTF-8</code>".</p>
       <p>Долговременным наиболее переносимым решением является использование классов символов POSIX, таких, как '<code>[[:lower:]]</code>' и '<code>[[:punct:]]</code>'. Если вам кажется, что нужно использовать выражения с диапазонами на системах, использующих локали, и на более старых системах, не использующих их, без изменения своей программы, решение заключается в применении грубой силы и индивидуальном перечислении каждого символа внутри скобок. Это неприятно, но это работает.</p>
      </cite>
      <p>Основанная на локалях сортировка потенциально дорогостоящая. Если вы ожидаете большого числа сравнений, где по крайней мере одна из строк не будет изменяться или где значения строк будут сравниваться друг с другом по несколько раз (как при сортировке списка), следует рассмотреть использование функции <code>strxfrm()</code> для преобразования своих строк для использования с <code>strcmp()</code>. Функция <code>strxfrm()</code> объявлена следующим образом:</p>
      <p><code>#include &lt;string.h&gt; /* ISO С */</code></p>
      <empty-line/>
      <p><code>size_t strxfrm(char *dest, const char *src, size_t n);</code></p>
      <p>Идея в том, что <code>strxfrm()</code> преобразует первые n символов <code>src</code>, помещая их в <code>dest</code>. Возвращаемое значение является числом символов, необходимых для сохранения преобразованных символов. Если она превышает n, содержимое <code>dest</code> «неопределенно».</p>
      <p>Стандарт POSIX явным образом разрешает устанавливать в <code>n</code> ноль, а в <code>dest NULL</code>. В этом случае <code>strxfrm()</code> возвращает размер массива, необходимого для сохранения преобразованной версии <code>src</code> (не включая завершающий символ '<code>\0</code>'). Предполагается, что это значение впоследствии будет использовано с <code>malloc()</code> для создания массива <code>dest</code> или для проверки размера предопределенных границ массива (При этом, очевидно, <code>src</code> должен иметь завершающий нулевой байт.) Этот фрагмент иллюстрирует использование <code>strxfrm()</code>:</p>
      <p><code>#define STRBUFSIZE ...</code></p>
      <p><code>char s1[STRBUFSIZE], s2[STRBUFSIZE]; /* Оригинальные строки */</code></p>
      <p><code>char s1x[STRBUFSIZE], s2x[STRBUFSIZE]; /* Преобразованные копии */</code></p>
      <p><code>size_t len1, len2;</code></p>
      <p><code>int cmp;</code></p>
      <empty-line/>
      <p><code>/* ... заполнить s1 и s2 ... */</code></p>
      <p><code>len1 = strlen(s1);</code></p>
      <p><code>len2 = strlen(s2);</code></p>
      <empty-line/>
      <p><code>if (strxfrm(s1x, s1, len1) &gt;= STRBUFSIZE ||</code></p>
      <p><code> strxfrm(s2x, s2, len2) &gt;= STRBUFSIZE)</code></p>
      <p><code> /* слишком большой, восстановить */</code></p>
      <empty-line/>
      <p><code>cmp = strcmp(s1x, s2x);</code></p>
      <p><code>if (cmp == 0)</code></p>
      <p><code> /* равны */</code></p>
      <p><code>else if (cmp &lt; 0)</code></p>
      <p><code> /* s1 &lt; s2 */</code></p>
      <p><code>else</code></p>
      <p><code> /* s1 &gt; s2 */</code></p>
      <p>Для одноразовых сравнений, возможно, быстрее непосредственно использовать <code>strcoll()</code>. Но если строки будут сравниваться несколько раз, более быстрым будет использование сначала <code>strxfrm()</code>, а затем <code>strcmp()</code> с преобразованными значениями. Функций для локали, соответствующих <code>strncmp()</code> или <code>strcasecmp()</code>, нет.</p>
     </section>
     <section>
      <title>
       <p>13.2.4. Числовое и денежное низкоуровневое форматирование: <code>localeconv()</code></p>
      </title>
      <p>Корректное форматирование числовых и денежных значений требует значительной низкоуровневой информации. Указанная информация доступна в <code>struct lconv</code>, которую получают с помощью функции <code>localeconv()</code>:</p>
      <p><code>#include &lt;locale.h&gt; /* ISO С */</code></p>
      <empty-line/>
      <p><code>struct lconv *localeconv(void);</code></p>
      <p>Подобно функции <code>ctime()</code>, эта функция возвращает указатель на внутренние статические данные. Следует сделать копию возвращенных данных, поскольку последующие вызовы могут возвратить другие значения, если локаль изменилась. Вот <code>struct lconv</code> (слегка сжатая), непосредственно из GLIBC <code>&lt;locale.h&gt;</code>:</p>
      <p><code>struct lconv {</code></p>
      <p><code> /* Числовая (не денежная) информация. */</code></p>
      <p><code> char *decimal_point; /* Разделитель десятичной дроби. */</code></p>
      <p><code> char *thousands_sep; /* Разделитель тысяч. */</code></p>
      <p><code> /* Каждый элемент является числом цифр в каждой группе;</code></p>
      <p><code>    элементы с большими индексами оставлены дальше. Элемент со</code></p>
      <p><code>    значением CHAR_MAX означает, что дальнейшая группировка не</code></p>
      <p><code>    производится. Элемент со значением 0 означает, что предыдущий</code></p>
      <p><code>    элемент используется для всех оставшихся групп. */</code></p>
      <p><code> char *grouping;</code></p>
      <p><code> /* Денежная информация. */</code></p>
      <p><code> /* Первые три символа являются символами валют из ISO 4217.</code></p>
      <p><code>    Четвертый символ является разделителем. Пятый символ '\0'. */</code></p>
      <p><code> char *int_curr_symbol;</code></p>
      <p><code> char *currency_symbol; /* Символ местной валюты. */</code></p>
      <p><code> char *mon_decimal_point; /* Символ десятичной точки. */</code></p>
      <p><code> char *mon_thousands_sep; /* Разделитель тысяч. */</code></p>
      <p><code> char *mon_grouping; /* Аналогично элементу 'группировки' (выше). */</code></p>
      <p><code> char *positive_sign; /* Знак для положительных значений. */</code></p>
      <p><code> char *negative_sign; /* Знак для отрицательных значений. */</code></p>
      <p><code> char int_frac_digits; /* Международные цифры дробей. */</code></p>
      <p><code> char frac_digits; /* Местные цифры дробей. */</code></p>
      <p><code> /* 1, если символ валюты перед положит, значением, 0, если после. */</code></p>
      <p><code> char p_cs_precedes;</code></p>
      <p><code> /* 1, если символ валюты отделяется от положит, значения пробелом. */</code></p>
      <p><code> char p_sep_by_space;</code></p>
      <p><code> /* 1, если символ валюты перед отриц. значением, 0, если после. */</code></p>
      <p><code> char n_cs_precedes;</code></p>
      <p><code> /* 1, если символ валюты отделяется от отриц. значения пробелом. */</code></p>
      <p><code> char n_sep_by_space;</code></p>
      <p><code> /* Размещение положительного и отрицательного знака:</code></p>
      <p><code>    0 Количество и символ валюты окружены скобками.</code></p>
      <p><code>    1 Строка знака перед количеством и символом валюты.</code></p>
      <p><code>    2 Строка знака за количеством и символом валюты.</code></p>
      <p><code>    3 Строка знака непосредственно перед символом валюты.</code></p>
      <p><code>    4 Строка знака непосредственно после символа валюты. */</code></p>
      <p><code> char p_sign_posn;</code></p>
      <p><code> char n_sign_posn;</code></p>
      <p><code> /* 1, если int_curr_symbol до положит. значения, 0, если после. */</code></p>
      <p><code> char int_p_cs_precedes;</code></p>
      <p><code> /* 1, если int_curr_symbol отделен от положит, знач. пробелом. */</code></p>
      <p><code> char int_p_sep_by_space;</code></p>
      <p><code> /* 1, если int_curr_symbol перед отриц. значением, 0, если после. */</code></p>
      <p><code> char int_n_cs_precedes;</code></p>
      <p><code> /* 1, если int_curr_symbol отделен от отриц. знач. пробелом. */</code></p>
      <p><code> char int_n_sep_by_space;</code></p>
      <p><code> /* Размещение положительного и отрицательного знака:</code></p>
      <p><code>    0 Количество и int_curr_symbol окружены скобками.</code></p>
      <p><code>    1 Строка знака до количества и int_curr_symbol.</code></p>
      <p><code>    2 Строка знака после количества и int_curr_symbol.</code></p>
      <p><code>    3 Строка знака непосредственно до int_curr_symbol.</code></p>
      <p><code>    4 Строка знака непосредственно после int_curr_symbol. */</code></p>
      <p><code> char int_p_sign_posn;</code></p>
      <p><code> char int_n_sign_posn;</code></p>
      <p><code>};</code></p>
      <p>Комментарии показывают довольно ясно, что происходит. Давайте посмотрим на несколько первых полей <code>struct lconv</code>:</p>
      <p><code>decimal_point</code></p>
      <p>Используемый символ разделителя десятичной дроби. В Соединенных Штатах и других англоязычных странах это точка, но во многих странах используется запятая.</p>
      <p><code>thousands_sep</code></p>
      <p>Символ, используемый для разделения каждых 3 цифр значения.</p>
      <p><code>grouping</code></p>
      <p>Массив однобайтных целых значений. Каждый элемент указывает, сколько цифр в группе. Как сказано в комментарии, <code>CHAR_MAX</code> означает, что дальше группировка не используется, а 0 означает повторное использование последнего элемента (Далее в главе мы покажем пример кода.)</p>
      <p><code>int_curr_symbol</code></p>
      <p>Это международный символ для местной валюты. Например, 'USD' для доллара США.</p>
      <p><code>currency_symbol</code></p>
      <p>Локальный символ для местной валюты. Например, $ для доллара США.</p>
      <p><code>mon_decimal_point</code>, <code>mon_thousands_sep</code>, <code>mon_grouping</code></p>
      <p>Соответствуют предыдущим полям, предоставляя те же сведения, но для денежных сумм.</p>
      <p>Большая часть оставшихся значений не имеет значения для повседневного программирования. Следующая программа, <code>ch13-lconv.c</code>, выводит некоторые из этих значений, чтобы дать вам представление, для какого рода сведений они используются:</p>
      <p><code>/* ch13-lconv.c --- показывает некоторые компоненты struct lconv */</code></p>
      <p><code>#include &lt;stdio.h&gt;</code></p>
      <p><code>#include &lt;limits.h&gt;</code></p>
      <p><code>#include &lt;locale.h&gt;</code></p>
      <empty-line/>
      <p><code>int main(void) {</code></p>
      <p><code> struct lconv l;</code></p>
      <p><code> int i;</code></p>
      <empty-line/>
      <p><code> setlocale(LC_ALL, "");</code></p>
      <p><code> l = *localeconv();</code></p>
      <empty-line/>
      <p><code> printf("decimal_point = [%s]\n", l.decimal_point);</code></p>
      <p><code> printf("thousands_sep = [%s]\n", l.thousands_sep);</code></p>
      <empty-line/>
      <p><code> for (i = 0; l.grouping[i] != 0 &amp;&amp; l.grouping[i] != CHAR_MAX; i++)</code></p>
      <p><code>  printf("grouping[%d] = [%dj\n", i, l.grouping[i]);</code></p>
      <empty-line/>
      <p><code> printf("int_curr_symbol = [%s]\n", l.int_curr_symbol);</code></p>
      <p><code> printf("currency_symbol = f%s]\n", l.currency_symbol);</code></p>
      <p><code> printf("mon_decimal_point = f%s]\n", l.mon_decimal_point);</code></p>
      <p><code> printf("mon_thousands_sep = [%s]\n", l.mon_thousands_sep);</code></p>
      <p><code> printf("positive_sign = [%s]\n", l.positive_sign);</code></p>
      <p><code> printf("negative_sign = [%s]\n", l.negative_sign);</code></p>
      <p><code>}</code></p>
      <p>Неудивительно, при запуске в различных локалях мы получаем различные результаты.</p>
      <p><code>$ <strong>LC_ALL=en_US ch13-lconv</strong> /* Результаты для Соединенных Штатов */</code></p>
      <p><code>decimal_point = [.]</code></p>
      <p><code>thousands_sep = [,]</code></p>
      <p><code>grouping[0] = [3]</code></p>
      <p><code>grouping[1] = [3]</code></p>
      <p><code>int_curr_symbol = [USD ]</code></p>
      <p><code>currency_symbol = [$]</code></p>
      <p><code>mon_decimal_point = [.]</code></p>
      <p><code>mon_thousands_sep = [,]</code></p>
      <p><code>positive_sign = []</code></p>
      <p><code>negative_sign = [-]</code></p>
      <p><code>$ <strong>LC_ALL=it_IT ch13-lconv</strong> /* Результаты для Италии */</code></p>
      <p><code>decimal_point = [.]</code></p>
      <p><code>thousands_sep = []</code></p>
      <p><code>int_curr_symbol = []</code></p>
      <p><code>currency_symbol = []</code></p>
      <p><code>mon_decimal_point = []</code></p>
      <p><code>mon_thousands_sep = []</code></p>
      <p><code>positive_sign = []</code></p>
      <p><code>negative_sign = []</code></p>
      <p>Обратите внимание, что значение <code>int_curr_symbol</code> в локали "<code>en_US</code>" включает завершающий символ пробела, который служит для отделения символа от последующего денежного значения.</p>
     </section>
     <section>
      <title>
       <p>13.2.5. Высокоуровневое числовое и денежное форматирование: <code>strfmon()</code> и <code>printf()</code></p>
      </title>
      <p>После рассмотрения всех полей <code>struct lconv</code> вы можете поинтересоваться: «Нужно ли мне <emphasis>на самом деле</emphasis> выяснять, как использовать все эти сведения, просто для форматирования денежного значения?» К счастью, ответом является «нет».<a l:href="#n140" type="note">[140]</a> Функция <code>strfmon()</code> делает за вас всю работу:</p>
      <p><code>#include &lt;monetary.h&gt; /* POSIX */</code></p>
      <empty-line/>
      <p><code>ssize_t strfmon(char *s, size_t max, const char *format, ...);</code></p>
      <p>Эта функция во многом подобна <code>strftime()</code> (см. раздел 6.1.3.2 «Сложное форматирование времени: <code>strftime()</code>»), используя <code>format</code> для копирования символов букв и форматированных числовых значений в <code>s</code>, помещая в нее не более max символов. Следующая простая программа, <code>ch13-strfmon.c</code>, демонстрирует работу <code>strfmon()</code>:</p>
      <p><code>/* ch13-strfmon.c --- демонстрация strfmon() */</code></p>
      <p><code>#include &lt;stdio.h&gt;</code></p>
      <p><code>#include &lt;locale.h&gt;</code></p>
      <p><code>#include &lt;monetary.h&gt;</code></p>
      <empty-line/>
      <p><code>int main(void) {</code></p>
      <p><code> char buf[BUFSIZ];</code></p>
      <p><code> double val = 1234.567;</code></p>
      <empty-line/>
      <p><code> setlocale(LC_ALL, "");</code></p>
      <p><code> strfmon(buf, sizeof buf, "You owe me %n (%i)\n", val, val);</code></p>
      <p><code> fputs(buf, stdout);</code></p>
      <p><code> return 0;</code></p>
      <p><code>}</code></p>
      <p>При запуске в двух различных локалях она выдает такой результат:</p>
      <p><code>$ <strong>LC_ALL=en_US ch13-strfmon</strong> /* В Соединенных Штатах */</code></p>
      <p><code>You owe me $1,234.57 (USD 1,234.57)</code></p>
      <p><code>$ <strong>LC_ALL=it_IT ch13-strfmon</strong> /* В Италии */</code></p>
      <p><code>You owe me EUR 1.235 (EUR 1.235)</code></p>
      <p>Как вы можете видеть, <code>strfmon()</code> подобна <code>strftime()</code>, копируя обычные символы в буфер назначения без изменений и форматируя аргументы в соответствии со своими собственными спецификациями форматирования. Их всего три.</p>
      <p><code>%n  </code>Вывести национальное (т.е. местное) представление значения валюты.</p>
      <p><code>%i  </code>Вывести международное представление значения валюты.</p>
      <p><code>%%  </code>Вывести символ '<code>%</code>'.</p>
      <p>Форматируемые значения должны иметь тип <code>double</code>. Разницу между <code>%n</code> и <code>%i</code> мы видим в локали "<code>en_US</code>": <code>%n</code> использует символ <code>$</code>, тогда как <code>%i</code> использует USD, которая означает «доллары США».</p>
      <p>Гибкость — и соответственно определенная сложность — сопровождают многие функции API, разработанные для POSIX, и <code>strfmon()</code> не является исключением. Как и с <code>printf()</code>, несколько необязательных элементов, которые могут быть между <code>%</code> и <code>i</code> или <code>n</code>, обеспечивают повышенный контроль. Полные формы следующие:</p>
      <p><code>%[<emphasis>флаги</emphasis>][<emphasis>ширина поля</emphasis>][#<emphasis>точность_слева</emphasis>][.<emphasis>точность_справа</emphasis>]i</code></p>
      <p><code>%[<emphasis>флаги</emphasis>][<emphasis>ширина поля</emphasis>][#<emphasis>точность_слева</emphasis>][.<emphasis>точность_справа</emphasis>]n</code></p>
      <p><code>%% /* Не допускаются поля флагов, ширины и т.д. */</code></p>
      <p>Флаги перечислены в табл. 13.2.</p>
      <empty-line/>
      <p><strong>Таблица 13.2</strong>. Флаги для <code>strfmon()</code></p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Флаг</th>
        <th align="left" valign="top">Значение</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>=с</code></td>
        <td align="left" valign="top">Использовать символ <emphasis>с</emphasis> в качестве символа числового заполнения слева. Символом по умолчанию является пробел. Обычной альтернативой является 0</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>^</code></td>
        <td align="left" valign="top">Запретить использование символа группировки (например, запятой в Соединенных Штатах)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>(</code></td>
        <td align="left" valign="top">Отрицательные значения заключать в скобки. Несовместим с флагом <code>+</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>+</code></td>
        <td align="left" valign="top">Обрабатывать положительные/отрицательные значения обычным образом. Использовать положительные и отрицательные знаки локали. Несовместим с флагом <code>(</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>!</code></td>
        <td align="left" valign="top">Не включать символ валюты. Этот флаг полезен, если вы хотите использовать <code>strfmon()</code> для более гибкого форматирования обычных чисел, чем это предусматривает <code>sprintf()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>-</code></td>
        <td align="left" valign="top">Выровнять результат слева. По умолчанию используется выравнивание справа. Этот флаг не действует без указания ширины поля</td>
       </tr>
      </table>
      <p>Ширина поля является строкой десятичных цифр, представляющих минимальную ширину. По умолчанию использует столько символов, сколько необходимо, основываясь на оставшейся части спецификации. Значения, меньшие ширины поля, дополняются пробелами слева (или справа, если указан флаг '<code>-</code>').</p>
      <p>Точность слева состоит из символа <code>#</code> и строки десятичных цифр. Она указывает минимальное число цифр, которые должны быть слева от десятичного символа-разделителя дробной части<a l:href="#n141" type="note">[141]</a>; если преобразованное значение меньше этого, результат выравнивается символом числового заполнения. По умолчанию используется пробел, однако для его изменения можно использовать флаг <code>=</code>. Символы группировки не включаются в общий счет.</p>
      <p>Наконец, точность справа состоит из символа '<code>.</code>' и строки десятичных цифр. Она указывает, с каким числом значащих цифр округлить значение до форматирования. По умолчанию используются поля <code>frac_digits</code> и <code>int_frac_digits</code> в <code>struct lconv</code>. Если это значение равно 0, десятичная точка не выводится.</p>
      <p><code>strfmon()</code> возвращает число символов, помещенных в буфер, не включая завершающий нулевой байт. Если недостаточно места, функция возвращает -1 и устанавливает <code>errno</code> в <code>E2BIG</code>.</p>
      <p>Помимо <code>strfmon()</code>, POSIX (но <emphasis>не</emphasis> ISO С) предусматривает специальный флаг — символ одинарной кавычки, <code>'</code> — для форматов <code>printf()</code> <code>%i</code>, <code>%d</code>, <code>%u</code>, <code>%f</code>, <code>%F</code>, <code>%g</code> и <code>%G</code>. В локалях, имеющих разделитель тысяч, этот флаг добавляет и его. Следующая простая программа, <code>ch13-quoteflag.c</code>, демонстрирует вывод:</p>
      <p><code>/* ch13-quoteflag.c --- демонстрация флага кавычки printf */</code></p>
      <p><code>#include &lt;stdio.h&gt;</code></p>
      <p><code>#include &lt;locale.h&gt;</code></p>
      <empty-line/>
      <p><code>int main(void) {</code></p>
      <p><code> setlocale(LC_ALL, ""); /* Это нужно, иначе не будет работать */</code></p>
      <p><code> printf("%'d\n", 1234567);</code></p>
      <p><code>return 0;</code></p>
      <p><code>}</code></p>
      <p>Вот что происходит для двух различных локалей: в одной есть разделитель тысяч, в другой нет:</p>
      <p><code>$ <strong>LC_ALL=C ch13-quoteflag</strong> /* Обычное окружение без разделителя */</code></p>
      <p><code>1234567</code></p>
      <p><code>$ <strong>LC_ALL=en_US ch13-quoteflag</strong> /* Локаль с разделителем (англ.) */</code></p>
      <p><code>1,234,567</code></p>
      <p>На время написания лишь GNU/Linux и Solaris поддерживают флаг <code>'</code>. Дважды проверьте справочную страницу <emphasis>printf</emphasis>(3) на своей системе.</p>
     </section>
     <section>
      <title>
       <p>13.2.6. Пример: форматирование числовых значений в <code>gawk</code></p>
      </title>
      <p><code>gawk</code> реализует свои собственные версии функций <code>printf()</code> и <code>sprintf()</code>. Для полного использования локали <code>gawk</code> должен поддерживать флаг <code>'</code>, как в С. Следующий фрагмент из файла <code>builtin.c</code> в <code>gawk</code> 3.1.4 показывает, как <code>gawk</code> использует <code>struct lconv</code> для числового форматирования:</p>
      <p><code>1  case 'd':</code></p>
      <p><code>2  case 'i':</code></p>
      <p><code>3   ...</code></p>
      <p><code>4   tmpval = force_number(arg);</code></p>
      <p><code>5</code></p>
      <p><code>6   ...</code></p>
      <p><code>7   uval = (uintmax_t)tmpval;</code></p>
      <p><code>8   ...</code></p>
      <p><code>9   ii = jj = 0;</code></p>
      <p><code>10  do {</code></p>
      <p><code>11   *--cp = (char)('0' + uval % 10);</code></p>
      <p><code>12 #ifdef HAVE_LOCALE_H</code></p>
      <p><code>13   if (quote_flag &amp;&amp; loc.grouping[ii] &amp;&amp; ++jj == loc.grouping[ii]) {</code></p>
      <p><code>14    *--cp = loc.thousands_sep[0]; /* XXX - предположение, что это один символ */</code></p>
      <p><code>15    if (loc.grouping[ii+1] == 0)</code></p>
      <p><code>16     jj = 0; /* продолжить использовать текущий val в loc.grouping [ii] */</code></p>
      <p><code>17    else if (loc.grouping[ii+1] == CHAR_MAX)</code></p>
      <p><code>18     quote_flag = FALSE;</code></p>
      <p><code>19    else {</code></p>
      <p><code>20     ii++;</code></p>
      <p><code>21     jj = 0;</code></p>
      <p><code>22    }</code></p>
      <p><code>23   }</code></p>
      <p><code>24 #endif</code></p>
      <p><code>25   uval /= 10;</code></p>
      <p><code>26  } while (uval &gt; 0);</code></p>
      <p>(Номера строк даны относительно начала фрагмента.) Некоторые части кода, не имеющие отношения к обсуждению, были опущены, чтобы облегчить фокусировку на важных частях.</p>
      <p>Переменная <code>loc</code>, используемая в строках 13–17, представляет <code>struct lconv</code>. Она инициализируется в <code>main()</code>. Здесь для нас интерес представляет <code>loc.thousands_sep</code>, который является символом разделителя тысяч, и <code>loc.grouping</code>, который является массивом, описывающим число цифр между разделителями. Нулевой элемент означает «использовать для всех последующих цифр значение предыдущего элемента», а значение <code>CHAR_MAX</code> означает «прекратить вставку разделителей тысяч».</p>
      <p>С таким введением, давайте посмотрим на код. Строка 7 устанавливает <code>uval</code>, которая является беззнаковой версией форматируемого значения. <code>ii</code> и <code>jj</code> отслеживают положение в <code>loc.grouping</code> и число цифр в текущей группе, которые были преобразованы, соответственно<a l:href="#n142" type="note">[142]</a>. <code>quote_flag</code> равен true, когда в спецификации преобразования был отмечен символ <code>'</code>.</p>
      <p>Цикл <code>do-while</code> генерирует символы цифр в обратном порядке, заполняя буфер с конца к началу. Каждая цифра создается в строке 11. Затем строка 25 делится на 10 путем смещения значения вправо на одну десятичную цифру.</p>
      <p>Нас интересуют строки 12–24. Эта работа осуществляется только на системе, поддерживающей локали, на что указывает наличие заголовочного файла <code>&lt;locale.h&gt;</code>. Именованная константа <code>HAVE_LOCALE</code> в такой системе будет равна true<a l:href="#n143" type="note">[143]</a>.</p>
      <p>Когда условие в строке 13 истинно, настало время добавить символ разделителя тысяч. Это условие можно прочесть как «если требуется группировка <emphasis>и</emphasis> текущее положение в <code>loc.grouping</code> указывает нужное для группировки количество <emphasis>и</emphasis> текущее число цифр равно группируемому количеству». Если это условие истинно, строка 14 добавляет символ разделителя тысяч. Комментарий обращает внимание на предположение, которое, вероятно, истинно, но которое может вновь появиться позже. ('XXX' является традиционным способом выделения опасного или сомнительного кода. Его легко отыскать, и он весьма заметен для читателя кода.)</p>
      <p>После использования текущего положения в <code>loc.grouping</code> строки 15–22 заглядывают в значение в следующем положении. Если это 0, продолжает использоваться значение текущего положения. Мы указываем на это, восстанавливая 0 в <code>jj</code> (строка 16). С другой стороны, если в следующем положении <code>CHAR_MAX</code>, группировка должна быть прекращена, и строка 18 убирает ее, устанавливая <code>quote_flag</code> в false. В противном случае, следующее значение является значением группировки, поэтому строка 20 восстанавливает 0 в <code>jj</code>, а строка 21 увеличивает значение <code>ii</code>.</p>
      <p>Это низкоуровневый, подробный код. Однако, поняв один раз, как представляется информация в <code>struct lconv</code>, код читать просто (и его было просто писать).</p>
     </section>
     <section>
      <title>
       <p>13.2.7. Форматирование значений даты и времени: <code>ctime()</code> и <code>strftime()</code></p>
      </title>
      <p>В разделе 6.1 «Времена и даты» описаны функции для получения и форматирования значений времени и даты. Функция <code>strftime()</code> также может использовать локаль, если <code>setlocale()</code> была вызвана должным образом. Это демонстрирует следующая простая программа, <code>ch13-times.с</code>:</p>
      <p><code>/* ch13-times.c --- демонстрация времени на основе локали */</code></p>
      <p><code>#include &lt;stdio.h&gt;</code></p>
      <p><code>#include &lt;locale.h&gt;</code></p>
      <p><code>#include &lt;time.h&gt;</code></p>
      <empty-line/>
      <p><code>int main(void) {</code></p>
      <p><code> char buf[100];</code></p>
      <p><code> time_t now;</code></p>
      <p><code> struct tm *curtime;</code></p>
      <empty-line/>
      <p><code> setlocale(LC_ALL, "");</code></p>
      <p><code> time(&amp;now);</code></p>
      <p><code> curtime = localtime(&amp;now);</code></p>
      <p><code> (void)strftime(buf, sizeof buf,</code></p>
      <p><code>  "It is now %A, %B %d, %Y, %I:%M %p", curtime);</code></p>
      <p><code> printf("%s\n", buf);</code></p>
      <p><code> printf("ctime() says: %s", ctime(&amp;now));</code></p>
      <p><code> exit(0);</code></p>
      <p><code>}</code></p>
      <p>При запуске программы мы видим, что результаты <code>strftime()</code> в самом деле варьируют, тогда как результаты <code>ctime()</code> — нет:</p>
      <p><code>$ <strong>LC_ALL=en_US ch13-times</strong> /* Время в Соединенных Штатах */</code></p>
      <p><code>It is now Friday, July 11, 2003, 10:35 AM</code></p>
      <p><code>ctime() says: Fri Jul 11 10:35:55 2003</code></p>
      <p><code>$ <strong>LC_ALL=it_IT ch13-times</strong> /* Время в Италии */</code></p>
      <p><code>It is now venerdi, luglio 11, 2003, 10:36</code></p>
      <p><code>ctime() says: Fri Jul 11 10:36:00 2003</code></p>
      <p><code>$ <strong>LC_ALL=fr_FR ch13-times</strong> /* Время во Франции */</code></p>
      <p><code>It is now vendredi, juillet 11, 2003, 10:36</code></p>
      <p><code>ctime() says: Fri Jul 11 10:36:05 2003</code></p>
      <p>Причина отсутствия изменений в том, что <code>ctime()</code> (и <code>asctime()</code>, на которой основана <code>ctime()</code>) является традиционным интерфейсом; он существует для поддержки старого кода, <code>strftime()</code>, будучи более новым интерфейсом (первоначально разработанным для C89), свободен использовать локали.</p>
     </section>
     <section>
      <title>
       <p>13.2.8. Другие данные локали: <code>nl_langinfo()</code></p>
      </title>
      <p>Хотя ранее мы сказали, что API <code>catgets()</code> трудно использовать, одна часть этого API обычно полезна: <code>nl_langinfo()</code>. Она предоставляет дополнительные связанные с локалью сведения, помимо тех, которые доступны из <code>struct lconv</code>:</p>
      <p><code>#include &lt;nl_types.h&gt;</code></p>
      <p><code>#include &lt;langinfo.h&gt;</code></p>
      <empty-line/>
      <p><code>char *nl_langinfo(nl_item item);</code></p>
      <p>Заголовочный файл <code>&lt;nl_types.h&gt;</code> определяет тип <code>nl_item</code>. (Это скорее всего <code>int</code> или <code>enum</code>.) Параметр <code>item</code> является одной из именованных констант, определенных в <code>&lt;langinfo.h&gt;</code>. Возвращаемое значение является строкой, которую можно при необходимости использовать либо непосредственно, либо в качестве форматирующей строки для <code>strftime()</code>.</p>
      <p>Доступная информация поступает из нескольких категорий локали. В табл. 13.3 перечислены константы элементов, соответствующие категории локали и их значения.</p>
      <empty-line/>
      <p><strong>Таблица 13.3</strong>. Значения элементов для <code>nl_langinfo()</code></p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Элемент</th>
        <th align="left" valign="top">Категория</th>
        <th align="left" valign="top">Значение</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ABDAY_1</code>, …, <code>ABDAY_7</code></td>
        <td align="left" valign="top"><code>LC_TIME</code></td>
        <td align="left" valign="top">Сокращенные названия дней недели. Воскресенье является днем 1</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ABMON_1</code>, …, <code>ABMON_12</code></td>
        <td align="left" valign="top"><code>LC_TIME</code></td>
        <td align="left" valign="top">Сокращенные названия месяцев</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ALT_DIGITS</code></td>
        <td align="left" valign="top"><code>LC_TIME</code></td>
        <td align="left" valign="top">Альтернативные символы для цифр; см. текст</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>AM_STR</code>, <code>PM_STR</code></td>
        <td align="left" valign="top"><code>LC_TIME</code></td>
        <td align="left" valign="top">Обозначения a.m/p.m. для локали.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>CODESET</code></td>
        <td align="left" valign="top"><code>LC_TYPE</code></td>
        <td align="left" valign="top">Имя <emphasis>кодовой страницы</emphasis> для локали, т.е. использующиеся набор символов и кодировка</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>CRNCYSTR</code></td>
        <td align="left" valign="top"><code>LC_MONETARY</code></td>
        <td align="left" valign="top">Символ местной валюты, описанный ниже</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>DAY_1</code>, …, <code>DAY_7</code></td>
        <td align="left" valign="top"><code>LC_TIME</code></td>
        <td align="left" valign="top">Названия дней недели. Воскресенье является днем 1</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>D_FMT</code></td>
        <td align="left" valign="top"><code>LC_TIME</code></td>
        <td align="left" valign="top">Формат даты</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>D_T_FMT</code></td>
        <td align="left" valign="top"><code>LC_TIME</code></td>
        <td align="left" valign="top">Формат даты и времени</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ERA_D_FMT</code></td>
        <td align="left" valign="top"><code>LC_TIME</code></td>
        <td align="left" valign="top">Формат даты эры.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ERA_D_T_FMT</code></td>
        <td align="left" valign="top"><code>LC_TIME</code></td>
        <td align="left" valign="top">Формат даты и времени эры.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ERA_T_FMT</code></td>
        <td align="left" valign="top"><code>LC_TIME</code></td>
        <td align="left" valign="top">Формат времени эры.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ERA</code></td>
        <td align="left" valign="top"><code>LC_TIME</code></td>
        <td align="left" valign="top">Сегменты описания эры, см. текст.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>MON_1</code>, …, <code>MON_12</code></td>
        <td align="left" valign="top"><code>LC_TIME</code></td>
        <td align="left" valign="top">Названия месяцев.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>RADIXCHAR</code></td>
        <td align="left" valign="top"><code>LC_NUMERIC</code></td>
        <td align="left" valign="top">Символ системы счисления. Для базы 10 это символ точки в десятичной дроби.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>THOUSEP</code></td>
        <td align="left" valign="top"><code>LC_NUMERIC</code></td>
        <td align="left" valign="top">Символ-разделитель тысяч</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>T_FMT_AMPM</code></td>
        <td align="left" valign="top"><code>LC_TIME</code></td>
        <td align="left" valign="top">Формат времени в записи a.m/p.m.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>T_FMT</code></td>
        <td align="left" valign="top"><code>LC_TIME</code></td>
        <td align="left" valign="top">Формат времени.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>YESEXPR</code>, <code>NOEXPR</code></td>
        <td align="left" valign="top"><code>LC_MESSAGES</code></td>
        <td align="left" valign="top">Строка, представляющая положительный и отрицательный ответы.</td>
       </tr>
      </table>
      <p><emphasis>Эра</emphasis> является определенным временем в истории. Поскольку она имеет отношение к датам и временам, она имеет наибольший смысл в странах, управляемых императорами и династиями.<a l:href="#n144" type="note">[144]</a></p>
      <p>Спецификации эр POSIX могут определять эры ранее 1 г. н.э. В таких случаях у начальной даты большее абсолютное числовое значение, чем у конечной даты. Например, Александр Великий правил с 336 г. до н.э. по 323 г до н.э.</p>
      <p>Значение, возвращенное '<code>nl_langinfo(ERA)</code>', если оно не равно <code>NULL</code>, состоит из одной или более спецификаций эр. Каждая спецификация отделена от следующей символом '<code>;</code>'. Компоненты спецификации каждой эры отделяются друг от друга символом '<code>:</code>'. Компоненты описаны в табл. 13.4.</p>
      <empty-line/>
      <p><strong>Таблица 13.4</strong>. Компоненты спецификации эры</p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Компонент</th>
        <th align="left" valign="top">Значение</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top">Направление</td>
        <td align="left" valign="top">Символы '<code>+</code>' или '<code>-</code>'. '<code>+</code>' означает, что эра отсчитывается от численно меньшего года к численно большему году, а '<code>-</code>' означает обратный порядок</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top">Смешение</td>
        <td align="left" valign="top">Ближайший к дате начала эры год</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top">Дата начала</td>
        <td align="left" valign="top">Дата начала эры в виде '<emphasis>гггг/мм/дд</emphasis>'. Это соответственно год, месяц и день. Годы до н.э используют для гггг отрицательные значения</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top">Дата конца</td>
        <td align="left" valign="top">Дата завершения эры в том же самом виде. Допустимы два дополнительных вида: <code>-*</code> означает «начало времени», а <code>+*</code> означает «конец времени»</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top">Название эры</td>
        <td align="left" valign="top">Название эры, соответствующее спецификации преобразования <code>%EC</code> функции <code>strftime()</code></td>
       </tr>
       <tr align="left">
        <td align="left" valign="top">Формат эры</td>
        <td align="left" valign="top">Формат года в пределах эры, соответствующий спецификации преобразования <code>%EY</code> функции <code>strftime()</code></td>
       </tr>
      </table>
      <p>Значение <code>ALT_DIGITS</code> также нуждается в некотором объяснении. Некоторые локали предоставляют «альтернативные цифры». (Рассмотрите арабский язык, в котором используется десятичная система счисления, но изображения для цифр 0–9 другие. Или рассмотрите гипотетическую локаль «Древнего Рима», использующую римские цифры.) Они появляются, например, в различных спецификациях преобразования <code>%OC</code> в функции <code>strftime()</code>. Возвращаемое значение для '<code>nl_langinfo(ALT_DIGITS)</code>' является разделяемым точками с запятой списком строк символов для альтернативных цифр. Первая должна использоваться для 0, следующая для 1 и т.д. POSIX утверждает, что могут быть предоставлены до 100 альтернативных символов. Сущность в том, чтобы избежать ограничения локалей использованием символов цифр ASCII, когда у локали есть собственная система счисления.</p>
      <p>Наконец, '<code>nl_langinfo(CRNCYSTR)</code>' возвращает символ местной валюты. Первый символ возвращаемого значения, если это '<code>-</code>', '<code>+</code>' или '<code>.</code>', указывает, как должен использоваться символ:</p>
      <p><code>- </code>Символ должен быть перед значением.</p>
      <p><code>+ </code>Символ должен быть после значения.</p>
      <p><code>. </code>Символ должен заменить символ основания (разделитель десятичной дроби).</p>
     </section>
    </section>
    <section>
     <title>
      <p>13.3. Динамический перевод сообщений программ</p>
     </title>
     <section>
      <p>Только что освещенные интерфейсы стандартной библиотеки С решают простые части проблемы локализации. Для денежных, числовых значений, значений времени и даты, также, как для проблем сортировки строк, применяется управление посредством таблиц специфичных для локали данных (таких, как списки названий месяцев и дней).</p>
      <p>Однако, большая часть взаимодействия пользователя с текстовой программой осуществляется в виде выводимых сообщений, таких, как приглашения или сообщения об ошибках. Проблема заключается в необходимости избежания множества версий одной и той же программы, которые отличаются лишь содержанием строк сообщений. Решением де-факто в мире GNU является GNU <code>gettext</code>. (GNU программы сталкиваются с подобными проблемами с элементами меню; обычно у каждого большого инструментария пользовательского интерфейса свой способ решения этой проблемы.)</p>
      <p>GNU <code>gettext</code> дает возможность перевода сообщений программы на другие языки во время исполнения. Внутри кода программы этот перевод включает несколько шагов, каждый из которых использует свои библиотечные функции. Когда сама программа должным образом подготовлена, несколько утилит на уровне оболочки дают возможность подготовить переводы на другие языки. Каждый такой перевод называется <emphasis>списком сообщений (message catalog)</emphasis>.</p>
     </section>
     <section>
      <title>
       <p>13.3.1. Установка текстового домена: <code>textdomain()</code></p>
      </title>
      <p>Законченное приложение может содержать множество компонентов: отдельные исполняемые файлы, написанные на С или C++ или на языках сценариев, которые также могут получить доступ к возможностям <code>gettext</code>, таких, как <code>gawk</code> или оболочка Bash Все компоненты приложения разделяют один и тот же <emphasis>текстовый домен</emphasis>, который является строкой, уникально идентифицирующей приложение. (Примерами могут быть «<code>gawk</code>» или «<code>coreutils</code>»; первое является простой программой, а последнее — целым набором программ.) Текстовый домен устанавливается функцией <code>textdomain()</code>:</p>
      <p><code>#include &lt;libintl.h&gt; /* GLIBC */</code></p>
      <empty-line/>
      <p><code>char* textdomain(const char *domainname)</code></p>
      <p>Каждый компонент должен вызывать эту функцию со строкой, указывающей на текстовый домен, в составе первоначальной инициализации в <code>main()</code>. Возвращаемое значение является текущим текстовым доменом. Если аргумент <code>domainname</code> равен <code>NULL</code>, возвращается текущий домен; в противном случае, он устанавливается в указанное значение, а последнее возвращается. Возвращаемое значение <code>NULL</code> указывает на какую-нибудь разновидность ошибки.</p>
      <p>Если текстовый домен не установлен с помощью <code>textdomain()</code>, по умолчанию используется «<code>messages</code>».</p>
     </section>
     <section>
      <title>
       <p>13.3.2. Перевод сообщений: <code>gettext()</code></p>
      </title>
      <p>Следующим после установки текстового домена шагом является использование функции <code>gettext()</code> (или ее разновидности) для каждой строки, которая должна быть переведена. Несколько функций предоставляют службы перевода:</p>
      <p><code>#include &lt;libintl.h&gt; /* GLIBC */</code></p>
      <empty-line/>
      <p><code>char *gettext(const char *msgid);</code></p>
      <p><code>char *dgettext(const char *domainname, const char *msgid);</code></p>
      <p><code>char *dcgettext(const char *domainname, const char *msgid, int category);</code></p>
      <p>Аргументы, используемые в этих функциях, следующие:</p>
      <p><code>const char *msgid</code></p>
      <p>Переводимая строка. Она действует в качестве ключа к базе данных переводов.</p>
      <p><code>const char *domainname</code></p>
      <p>Текстовый домен, из которого нужно получить перевод. Таким образом, хотя <code>main()</code> вызвала <code>textdomain()</code> для установки собственного домена приложения, сообщения могут быть получены из других текстовых доменов. (Это наиболее применимо к сообщениям, которые могли бы быть, например, в текстовом домене библиотеки от третьей стороны.)</p>
      <p><code>int category</code></p>
      <p>Одна из описанных ранее категорий доменов (<code>LC_TIME</code> и т.п.). Доменом по умолчанию является то, что было раньше установлено с помощью <code>textdomain()</code> («<code>messages</code>», если <code>textdomain()</code> никогда не вызывалась). Категорией по умолчанию является <code>LC_MESSAGES</code>. Предположим, <code>main()</code> делает следующий вызов:</p>
      <p><code>textdomain("killerapp");</code></p>
      <p>Тогда '<code>gettext("my message")</code>' эквивалентно '<code>dgettext("killerapp", "my message")</code>'. Обе функции, в свою очередь, эквивалентны '<code>dcgettext("killerapp", "my message", LC_MESSAGES)</code>'.</p>
      <p>В 99,9% времени бывает нужно использовать <code>gettext()</code>. Однако, другие функции обеспечивают гибкость при работе с другими текстовыми доменами или категориями локалей. Скорее всего, эта гибкость потребуется при программировании библиотек, поскольку автономная библиотека почти наверняка будет использовать свой собственный текстовый домен.</p>
      <p>Все функции возвращают строки. Строка является либо переводом данного <code>msgid</code>, либо, если перевода не существует, первоначальной строкой. Таким образом, всегда имеется какой-нибудь вывод, даже если это первоначальное сообщение (предположительно на английском). Например:</p>
      <p><code>/* Каноническая первая программа, локализованная версия. */</code></p>
      <p><code>#include &lt;stdio.h&gt;</code></p>
      <p><code>#include &lt;locale.h&gt;</code></p>
      <p><code>#include &lt;libintl.h&gt;</code></p>
      <empty-line/>
      <p><code>int main(void) {</code></p>
      <p><code> setlocale(LC_ALL, "");</code></p>
      <p><code> printf("%s\n", gettext("hello, world"));</code></p>
      <p><code> return 0;</code></p>
      <p><code>}</code></p>
      <p>Хотя сообщение является простой строкой, мы не используем ее непосредственно в форматирующей строке <code>printf()</code>, поскольку в общем перевод может содержать символы <code>%</code>.</p>
      <p>Вскоре, в разделе 13.3.4 «Упрощение использования <code>gettext()</code>», мы увидим, как облегчить использование <code>gettext()</code> в крупномасштабных, реальных программах.</p>
     </section>
     <section>
      <title>
       <p>13.3.3. Работа с множественными числами: <code>ngettext()</code></p>
      </title>
      <p>Перевод во множественном числе доставляет дополнительные трудности. Простой код мог бы выглядеть примерно так:</p>
      <p><code>printf("%d word%s misspelled\n", nwords, nwords &gt; 1 ? "s" : "");</code></p>
      <p><code>/* или */</code></p>
      <p><code>printf("%d %s misspelled\n", nwords, nwords == 1 ? "word" : "words").</code></p>
      <p>Это подходит для английского языка, но перевод становится трудным. Во-первых, во многих языках множественное число не образуется с такой же легкостью, как в английском (добавлением суффикса <code>s</code> для большинства слов). Во-вторых, во многих языках, особенно в Восточной Европе, имеются несколько форм множественного числа, каждая из которых указывает на то, сколько объектов обозначает форма. Соответственно даже код наподобие следующего не будет достаточным:</p>
      <p><code>if (nwords == l)</code></p>
      <p><code> printf("one word misspelled\n");</code></p>
      <p><code>else</code></p>
      <p><code> printf("%d words misspelled\n", nwords);</code></p>
      <p>Решением является параллельный набор процедур специально для форматирования множественных значений:</p>
      <p><code>#include &lt;libintl.h&gt; /* GLIBC */</code></p>
      <empty-line/>
      <p><code>char *ngettext(const char *msgid, const char *msgid_plural,</code></p>
      <p><code> unsigned long int n);</code></p>
      <p><code>char *dngettext(const char *domainname, const char *msgid,</code></p>
      <p><code> const char *msgid_plural, unsigned long int n);</code></p>
      <p><code>char *dcngettext(const char *domainname, const char *nmgid,</code></p>
      <p><code> const char *msgid_plural, unsigned long int n,</code></p>
      <p><code> int category)</code></p>
      <p>Помимо первоначального аргумента <code>msgid</code>, эти функции принимают дополнительные аргументы:</p>
      <p><code>const char *msgid_plural</code></p>
      <p>Строка по умолчанию для использования в качестве множественного числа. Вскоре будут примеры.</p>
      <p><code>unsigned long int n</code></p>
      <p>Число имеющихся элементов.</p>
      <p>Список сообщений каждой локали указывает, как переводить множественные числа.<a l:href="#n145" type="note">[145]</a> Функция <code>ngettext()</code> (и ее варианты) проверяет <code>n</code> и на основании спецификации в списке сообщений возвращает соответствующий перевод <code>msgid</code>. Если в списке нет перевода для <code>msgid</code>, или находясь в локали «С», <code>ngettext()</code> возвращает <code>msgid</code>, если '<code>n == 1</code>'; в противном случае она возвращает <code>msgid_plural</code>. Таким образом, наш пример ошибочных слов выглядит следующим образом:</p>
      <p><code>printf("%s\n", ngettext("%d word misspelled", "%d words misspelled", nwords), nwords);</code></p>
      <p>Обратите внимание, что <code>nwords</code> должен быть передан <code>ngettext()</code> для выбора форматирующей строки, а затем <code>printf()</code> для форматирования. Вдобавок, будьте осмотрительны и не используйте макрос или выражение, значение которого каждый раз изменяется, как в случае '<code>n++</code>'! Такое может случиться, если вы осуществляете глобальное редактирование, добавляя вызовы <code>ngettext()</code> и не обращая на это внимания.</p>
     </section>
     <section>
      <title>
       <p>13.3.4. Упрощение использования <code>gettext()</code></p>
      </title>
      <section>
       <p>Вызов <code>gettext()</code> в исходном коде программы служит двум целям. Во-первых, он осуществляет перевод во время исполнения, что является в конце концов главным. Однако, он служит также для <emphasis>отметки</emphasis> строк, которые нужно перевести. Утилита <code>xgettext</code> читает исходный код программы и извлекает все оригинальные строки, которые нужно перевести. (Далее в главе мы кратко рассмотрим это.)</p>
       <p>Рассмотрим все-таки случай, когда статические строки не используются непосредственно:</p>
       <p><code>static char *copyrights[] = {</code></p>
       <p><code> "Copyright 2004, Jane Programmer",</code></p>
       <p><code> "Permission is granted ...",</code></p>
       <p><code> /* ... Здесь куча легальностей */</code></p>
       <p><code> NULL</code></p>
       <p><code>};</code></p>
       <empty-line/>
       <p><code>void copyright(void) {</code></p>
       <p><code> int i;</code></p>
       <p><code> for (i = 0; copyrights[i] != NULL, i++)</code></p>
       <p><code>  printf("%s\n", gettext(copyrights[i]));</code></p>
       <p><code>}</code></p>
       <p>Здесь мы хотели бы иметь возможность вывести переводы строк об авторских правах, если они доступны. Однако, как извлекающее устройство <code>xgettext</code> предполагает найти эти строки? Мы не можем заключить их в вызовы <code>gettext()</code>, поскольку это не будет работать во время компиляции:</p>
       <p>/<code>* ПЛОХОЙ КОД: не будет компилироваться */</code></p>
       <p><code>static char *copyrights[] = {</code></p>
       <p><code> gettext("Copyright 2004, Jane Programmer"),</code></p>
       <p><code> gettext("Permission is granted ..."),</code></p>
       <p><code> /* ... Здесь куча легальностей */</code></p>
       <p><code> NULL</code></p>
       <p><code>};</code></p>
      </section>
      <section>
       <title>
        <p>13.3.4.1. Переносимые программы: "<code>gettext.h</code>"</p>
       </title>
       <p>Здесь мы предполагаем, что вы хотите написать программу, которая может использоваться вместе с библиотекой GNU <code>gettext</code> на любой системе Unix, а не только GNU/Linux. Следующий раздел описывает, что сделать для программ только для GNU/Linux.</p>
       <p>Пометка строк включает два шага. Первый заключается в использовании вспомогательного заголовка <code>gettext.h</code>, который поставляется с дистрибутивом GNU <code>gettext</code>. Этот файл обрабатывает несколько проблем переносимости и компиляции, упрощая использование <code>gettext()</code> в ваших собственных программах:</p>
       <p><code>#define ENABLELNLS 1 /* ENABLE_NLS должен быть true, чтобы gettext() работала */</code></p>
       <p><code>#include "gettext.h" /* Вместо &lt;libintl.h&gt; */</code></p>
       <p>Если макрос <code>ENABLE_NLS</code> не определен<a l:href="#n146" type="note">[146]</a> или установлен в ноль, <code>gettext.h</code> развертывает вызовы <code>gettext()</code> в первый аргумент. Это делает возможным перенос кода, использующего <code>gettext()</code>, на системы, в которых не установлены ни GNU <code>gettext</code>, ни собственная их версия. Помимо прочего, этот заголовочный файл определяет следующий макрос:</p>
       <p><code>/* Вызов псевдофункции, который служит в качестве маркера для</code></p>
       <p><code>   автоматического извлечения сообщений, но не осуществляющий вызов</code></p>
       <p><code>   gettext(). Перевод времени исполнения осуществляется в другом</code></p>
       <p><code>   месте кода. Аргумент String должен быть символической строкой.</code></p>
       <p><code>   Сцепленные строки и другие строковые выражения не будут работать.</code></p>
       <p><code>   Разворачивание макроса не параметризовано, так что он подходит для</code></p>
       <p><code>   инициализации статических переменных 'char[]' или 'const char[]'. */</code></p>
       <p><code>#define gettext_noop(String) String</code></p>
       <p>Комментарий самодостаточен. С помощью этого макроса мы можем теперь перейти ко второму шагу. Мы перепишем код следующим образом:</p>
       <p><code>#define ENABLE_NLS 1</code></p>
       <p><code>#include "gettext.h"</code></p>
       <empty-line/>
       <p><code>static char copyrights[] =</code></p>
       <p><code> gettext_noop("Copyright 2004, Jane Programmer\n"</code></p>
       <p><code> "Permission is granted ...\n"</code></p>
       <p><code> /* ... Здесь куча легальностей */</code></p>
       <p><code> "So there.");</code></p>
       <empty-line/>
       <p><code>void copyright(void) {</code></p>
       <p><code> printf("%s\n", gettext(copyrights));</code></p>
       <p><code>}</code></p>
       <p>Обратите внимание, что мы сделали два изменения. Во-первых, <code>copyrights</code> теперь является одной длинной строкой, созданной с использованием возможности конкатенации строк стандартного C. Эта простая строка затем включена в вызов <code>gettext_noop()</code>. Нам нужна одна строка, чтобы легальности могли быть переведены в виде одного элемента</p>
       <p>Второе изменение заключается в непосредственном выводе перевода в виде одной строки в <code>copyright()</code>.</p>
       <p>К этому времени вы, возможно, думаете: «Вот здорово, набирать каждый раз '<code>gettext(...)</code>' довольно неприятно». Ну, вы правы. Это не только создает лишнюю работу по набиванию, но также и затрудняет чтение исходного кода. Соответственно, когда вы используете заголовочный файл <code>gettext.h</code>, руководство GNU <code>gettext</code> рекомендует включить два других макроса с именами <code>_()</code> и <code>N_()</code> следующим образом:</p>
       <p><code>#define ENABLE_NLS 1</code></p>
       <p><code>#include "gettext.h"</code></p>
       <p><code>#define _(msgid) gettext(msgid)</code></p>
       <p><code>#define N_(msgid) msgid</code></p>
       <p>Такой подход снижает накладные расходы по использованию <code>gettext()</code> всего лишь тремя дополнительными символами для переводимой строковой константы и всего лишь четырьмя символами для статических строк:</p>
       <p><code>#include &lt;stdio.h&gt;</code></p>
       <p><code>#define ENABLE_NLS 1</code></p>
       <p><code>#include "gettext.h"</code></p>
       <p><code>#define _(msgid) gettext(msgid)</code></p>
       <p><code>#define N_(msgid) msgid</code></p>
       <p><code>...</code></p>
       <p><code>static char copyrights[] =</code></p>
       <p><code> N_("Copyright 2004, Jane Programmer\n"</code></p>
       <p><code> "Permission is granted ...\n"</code></p>
       <p><code> /* ... Здесь куча легальностей */</code></p>
       <p><code> "So there.");</code></p>
       <empty-line/>
       <p><code>void copyright(void) {</code></p>
       <p><code> printf("%s\n", gettext(copyrights));</code></p>
       <p><code>}</code></p>
       <empty-line/>
       <p><code>int main(void) {</code></p>
       <p><code> setlocale(LC_ALL, ""); /* gettext.h gets &lt;locale.h&gt; for us too */</code></p>
       <p><code> printf("%s\n", _("hello, world"));</code></p>
       <p><code> copyright();</code></p>
       <p><code> exit(0);</code></p>
       <p><code>}</code></p>
       <p>Эти макросы скромны, и на практике все GNU программы, использующие GNU <code>gettext</code>, следуют этому соглашению. Если вы собираетесь использовать GNU <code>gettext</code>, вам тоже нужно следовать этому соглашению.</p>
      </section>
      <section>
       <title>
        <p>13.3.4.2. Только GLIBC: <code>&lt;libintl.h&gt;</code></p>
       </title>
       <p>Для программ, которые будут использоваться лишь на системах с GLIBC, использование заголовочных файлов и макросов похоже, но проще:</p>
       <p><code>#include &lt;stdio.h&gt;</code></p>
       <p><code>#include &lt;libintl.h&gt;</code></p>
       <p><code>#define _(msgid) gettext(msgid)</code></p>
       <p><code>#define N_(msgid) msgid</code></p>
       <p><code>/* ... все остальное то же ... */</code></p>
       <p>Как мы видели ранее, заголовочный файл <code>&lt;libintl.h&gt;</code> объявляет <code>gettext()</code> и другие функции. Вам все равно нужно определять <code>_()</code> и <code>N_()</code>, но не нужно беспокоиться о <code>ENABLE_NLS</code> или включении с исходным кодом вашей программы файла <code>gettext.h</code>.</p>
      </section>
     </section>
     <section>
      <title>
       <p>13.3.5. Перестановка порядка слов с помощью <code>printf()</code></p>
      </title>
      <p>Иногда при переводах порядок слов, естественный для английского языка, не подходит в других языках. Например, на английском прилагательные идут перед определяемыми существительными, а на многих других языках — после. Таким образом, следующий код представляет проблему:</p>
      <p><code>char *animal_color, *animal;</code></p>
      <empty-line/>
      <p><code>if (...) {</code></p>
      <p><code> animal_color = _("brown");</code></p>
      <p><code> animal = _("cat");</code></p>
      <p><code>} else if (...) {</code></p>
      <p><code> ...</code></p>
      <p><code>} else {</code></p>
      <p><code> ...</code></p>
      <p><code>}</code></p>
      <p><code>printf(_("the %s %s looks at you enquiringly.\n"), animal_color, color);</code></p>
      <p>Здесь форматирующая строка, <code>animal_color</code> и <code>animal</code> неудачно включены в вызов <code>gettext()</code>. Однако, после перевода утверждение будет неверным, поскольку <emphasis>порядок аргументов не может быть изменен во время исполнения</emphasis>.</p>
      <p>Чтобы обойти это, версия семейства <code>printf()</code> POSIX (но <emphasis>не</emphasis> ISO С) допускает использовать в описателе формата <emphasis>указатель положения</emphasis>. Он принимает форму десятичного числа, за которым следует символ <code>$</code>, <emphasis>сразу</emphasis> после начального символа <code>%</code>. Например <code>printf("%2$s, %1s\n", "world", "hello")</code>;</p>
      <p>Указатель положения обозначает аргумент из списка, который следует использовать, отсчет начинается с 1 и не включает саму форматирующую строку. Этот пример выводит знаменитое сообщение '<code>hello, world</code>' в правильном порядке.</p>
      <p>GLIBC и Solaris реализуют эту возможность. Поскольку это часть POSIX, если <code>printf()</code> вашего поставщика Unix не реализует ее, она вскоре должна появиться.</p>
      <p>За указателем положения могут следовать любые обычные флаги <code>printf()</code>, указатели ширины полей и точности. Вот правила для использования указателей положения:</p>
      <p>• Форма с указателем положения не может смешиваться с формой без нее. Другими словами, или каждый указатель формата включает указатель положения, или ни один его не включает. Конечно, <code>%%</code> может использоваться всегда.</p>
      <p>• Если в форматирующей строке используется <emphasis>N</emphasis>-й аргумент, в этой строке должны использоваться также все аргументы до <emphasis>N</emphasis>. Соответственно, следующее неверно <code>printf("%3$s %1$s\n", "hello", "cruel", "world")</code>;</p>
      <p>• Ссылка на определенный аргумент может быть сделана указателем положения несколько раз. Не позиционные спецификаторы формата всегда движутся через список аргументов последовательно.</p>
      <p>Эта возможность не предназначена для непосредственного использования программистами приложений, она скорее для переводчиков. Например, перевод предыдущей форматирующей строки, <code>"The %s %s looks at you enquiringly.\n"</code>, на французский мог бы быть:</p>
      <p><code>"Le %2$s %1$s te regarde d'un aire interrogateur.\n"</code></p>
      <p>(Даже этот перевод не совершенен: артикль «Le» имеет род. Подготовка программы к переводу трудная задача!)</p>
     </section>
     <section>
      <title>
       <p>13.3.6. Тестирование переводов в персональном каталоге</p>
      </title>
      <p>Коллекция сообщений в программе называется <emphasis>списком сообщений (message catalog)</emphasis>. Этот термин применяется также к каждому из переводов сообщений на другой язык. Когда программа установлена, каждый перевод также устанавливается в стандартное место, где <code>gettext()</code> может во время исполнения найти нужный перевод.</p>
      <p>Может оказаться полезным разместить переводы не в стандартном, а в другом каталоге, особенно для тестирования программы. Особенно на больших системах, у обычного пользователя может не быть необходимых разрешений для установки файлов в системные каталоги. Функция <code>bindtextdomain()</code> дает <code>gettext()</code> альтернативное место для поиска переводов:</p>
      <p><code>#include &lt;libintl.h&gt; /* GLIBC */</code></p>
      <empty-line/>
      <p><code>char *bindtextdomain(const char *domainname,</code></p>
      <p><code>const char *dirname);</code></p>
      <p>Полезные каталоги включают '<code>.</code>' для текущего каталога и <code>/tmp</code>. Может оказаться удобным также получить каталог из переменной окружения, подобно этому:</p>
      <p><code>char *td_dir;</code></p>
      <p><code>setlocale(LC_ALL, "");</code></p>
      <p><code>textdomain("killerapp");</code></p>
      <p><code>if ((td_dir = getenv("KILLERAPP_TD_DIR")) != NULL)</code></p>
      <p><code> bindtextdomain("killerapp", td_dir);</code></p>
      <p><code>bindtextdomain()</code> должна быть вызвана до вызовов любой из функций из семейства <code>gettext()</code>. Мы увидим пример ее использования в разделе 13.3.8 «Создание переводов»</p>
     </section>
     <section>
      <title>
       <p>13.3.7. Подготовка интернационализированных программ</p>
      </title>
      <p>К настоящему моменту мы рассмотрели все компоненты, из которых состоит интернационализированная программа. Данный раздел подводит итоги.</p>
      <p>1. Включите в свое приложение заголовочный файл <code>gettext.h</code>, добавьте определения для макросов <code>_()</code> и <code>N_()</code> в заголовочный файл, который включается во все ваши исходные файлы на С. Не забудьте определить именованную константу <code>ENABLE_NLS</code>.</p>
      <p>2. Вызовите соответствующим образом <code>setlocale()</code>. Проще всего вызвать '<code>setlocale(LC_ALL, "")</code>', но иногда приложению может потребоваться быть более разборчивым в отношении используемых категорий локали.</p>
      <p>3. Выберите для приложения текстовый домен и установите его с помощью <code>textdomain()</code>.</p>
      <p>4. При тестировании свяжите текстовый домен с определенным каталогом при помощи <code>bindtextdomain()</code>.</p>
      <p>5. Используйте соответствующим образом <code>strfmon()</code>, <code>strftime()</code> и флаг <code>'</code>. Если нужна другая информация о локали, используйте <code>nl_langinfo()</code>, особенно в сочетании с <code>strftime()</code>.</p>
      <p>6. Пометьте все строки, которые должны быть переведены, соответствующими вызовами <code>_()</code> или <code>N_()</code>.</p>
      <p>Хотя некоторые не следует так помечать. Например, если вы используете <code>getopt_long()</code> (см. раздел 2.1.2 «Длинные опции GNU»), вы, вероятно, не захотите, чтобы имена длинных опций были помечены для перевода. Не требуют перевода и простые форматирующие строки наподобие "<code>%d %d\n</code>", также как отладочные сообщения.</p>
      <p>7. В нужных местах используйте <code>ngettext()</code> (или ее варианты) для значений, которые могут быть 1 или больше 1.</p>
      <p>8. Упростите жизнь для своих переводчиков, используя строки с полными предложениями вместо замены слов с помощью <code>%s</code> и <code>?:</code>. Например:</p>
      <p><code>if (/* <emphasis>возникла ошибка</emphasis> */) { /* ВЕРНО */</code></p>
      <p><code> /* Использовать несколько строк для упрощения перевода. */</code></p>
      <p><code> if (input_type == INPUT_FILE)</code></p>
      <p><code>  fprintf(stderr, _("%s: cannot read file: %s\n"),</code></p>
      <p><code>   argv[0], strerror(errno));</code></p>
      <p><code> else</code></p>
      <p><code>  fprintf(stderr, _("%s: cannot read pipe: %s\n"),</code></p>
      <p><code>   argv[0], strerror(errno));</code></p>
      <p>Это лучше, чем</p>
      <p><code>if (/* <emphasis>возникла ошибка</emphasis> */) { /* НЕВЕРНО */</code></p>
      <p><code> fprintf(stderr, _("%s: cannot read %s: %s\n"), argv[0],</code></p>
      <p><code> input_type == INPUT_FILE ? _("file") : _("pipe"),</code></p>
      <p><code> strerror(errno));</code></p>
      <p><code>}</code></p>
      <p>Как только что показано, хорошей мыслью является включение комментария, сообщающего о намеренном использовании нескольких строк, чтобы упростить перевод сообщений.</p>
     </section>
     <section>
      <title>
       <p>13.3.8. Создание переводов</p>
      </title>
      <p>После интернационализации программы необходимо подготовить переводы. Это осуществляется с помощью нескольких инструментов уровня оболочки. Мы начнем с интернационализированной версии <code>ch06-echodate.c</code> из раздела 6.1.4 «Преобразование разложенного времени в <code>time_t</code>»:</p>
      <p><code>/* ch13-echodate.c --- демонстрация переводов */</code></p>
      <p><code>#include &lt;stdio.h&gt;</code></p>
      <p><code>#include &lt;time.h&gt;</code></p>
      <p><code>#include &lt;locale.h&gt;</code></p>
      <p><code>#define ENABLE_NLS 1</code></p>
      <p><code>#include "gettext.h"</code></p>
      <p><code>#define _(msgid) gettext(msgid)</code></p>
      <p><code>#define N_(msgid) msgid</code></p>
      <empty-line/>
      <p><code>int main (void) {</code></p>
      <p><code> struct tm tm;</code></p>
      <p><code> time_t then;</code></p>
      <empty-line/>
      <p><code> setlocale(LC_ALL, "");</code></p>
      <p><code> bindtextdomain("echodate", ".");</code></p>
      <p><code> textdomain("echodate");</code></p>
      <empty-line/>
      <p><code> printf("%s", _("Enter a Date/time as YYYY/MM/DD HH:MM:SS : "));</code></p>
      <p><code> scanf("%d/%d/%d %d:%d:%d",</code></p>
      <p><code>  &amp;tm.tm_year, &amp;tm.tm_mon, &amp;tm.tm_mday,</code></p>
      <p><code>  &amp;tm.tm_hour, &amp;tm.tm_min, &amp;tm.tm_sec);</code></p>
      <empty-line/>
      <p><code> /* Проверка ошибок для краткости опущена. */</code></p>
      <p><code> tm.tm_year -= 1900;</code></p>
      <p><code> tm.tm_mon -= 1;</code></p>
      <p><code> tm.tm_isdst = -1; /* О летнем времени ничего не известно */</code></p>
      <empty-line/>
      <p><code> then = mktime(&amp;tm);</code></p>
      <p><code> printf(_("Got: %s"), ctime(&amp;then));</code></p>
      <p><code> exit(0);</code></p>
      <p><code>}</code></p>
      <p>Мы намеренно использовали <code>"gettext.h"</code>, а не <code>&lt;gettext.h&gt;</code>. Если наше приложение поставляется с отдельной копией библиотеки <code>gettext</code>, тогда <code>"gettext.h"</code> найдет ее, избежав использования системной копии. С другой стороны, если имеется лишь системная копия, она будет найдена, если локальной копии нет. Общеизвестно, что ситуация усложнена фактом наличия на системах Solaris библиотеки <code>gettext</code>, которая не имеет всех возможностей версии GNU.</p>
      <p>Переходя к созданию переводов, первым шагом является извлечение переводимых строк. Это осуществляется программой <code>xgettext</code>:</p>
      <p><code>$ <strong>xgettext --keyword=_ --keyword=N_ \</strong></code></p>
      <p><code>&gt; <strong>--default-domain=echodate ch13-echodate.с</strong></code></p>
      <p>Опции <code>--keyword</code> сообщает <code>xgettext</code>, что нужно искать макросы <code>_()</code> и <code>N_()</code>. Программа уже знает, как извлекать строки из <code>gettext()</code> и ее вариантов, а также из <code>gettext_noop()</code>.</p>
      <p>Вывод <code>xgettext</code> называется переносимым объектным файлом. Имя файла по умолчанию <code>messages.ро</code>, что соответствует текстовому домену по умолчанию <code>"messages"</code>. Опция <code>--default-domain</code> обозначает текстовый домен для использования в имени выходного файла. В данном случае, файл назван <code>echodate.ро</code>. Вот его содержание:</p>
      <p><code># SOME DESCRIPTIVE TITLE. /* Шаблон, нужно отредактировать */</code></p>
      <p><code># Copyright (С) YEAR THE PACKAGE'S COPYRIGHT HOLDER</code></p>
      <p><code># This file is distributed under the same license as the PACKAGE package.</code></p>
      <p><code># FIRST AUTHOR &lt;EMAIL@ADDRESS&gt;, YEAR.</code></p>
      <p><code>#</code></p>
      <p><code>#, fuzzy</code></p>
      <p><code>msgid "" /* Подробная информация */</code></p>
      <p><code>msgstr "" /* Заполняет каждый переводчик */</code></p>
      <p><code>"Project-Id-Version: PACKAGE VERSION\n"</code></p>
      <p><code>"Report-Msgid-Bugs-To: \n"</code></p>
      <p><code>"POT-Creation-Date: 2003-07-14 18:46-0700\n"</code></p>
      <p><code>"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"</code></p>
      <p><code>"Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt;\n"</code></p>
      <p><code>"Language-Team: LANGUAGE &lt;LL@li.org&gt;\n"</code></p>
      <p><code>"MIME-Version: 1.0\n"</code></p>
      <p><code>"Content-Type: text/plain; charset=CHARSET\n"</code></p>
      <p><code>"Content-Transfer-Encoding: 8bit\n"</code></p>
      <empty-line/>
      <p><code>#: ch13-echodate.c:19 /* Местоположение сообщения */</code></p>
      <p><code>msgid "Enter a Date/time as YYYY/MM/DD HH:MM:SS : " /* Оригинальное</code></p>
      <p><code>                                                       сообщение */</code></p>
      <p><code>msgstr "" /* Здесь перевод */</code></p>
      <empty-line/>
      <p><code>#: ch13-echodate.с:32 /* To же самое для каждого сообщения */</code></p>
      <p><code>#, с-format</code></p>
      <p><code>msgid "Got: %s"</code></p>
      <p><code>msgstr ""</code></p>
      <p>Этот первоначальный файл используется повторно для каждого перевода. Таким образом, это <emphasis>шаблон</emphasis> для переводов, и по соглашению, для отображения этого факта он должен быть переименован с расширением <code>.pot</code> (<emphasis>portable object template — переносимый объектный шаблон</emphasis>):</p>
      <p><code>$ <strong>mv echodate.ро echodate.pot</strong></code></p>
      <p>He владея свободно несколькими языками, мы решили перевести сообщения на свинский латинский. Следующим шагом является создание перевода. Это осуществляется копированием файла шаблона и добавлением к новой копии перевода:</p>
      <p><code>$ <strong>cp echodate.pot piglat.po</strong></code></p>
      <p><code>$ <strong>vi piglat.po</strong> /* Добавить переводы, используя любимый редактор */</code></p>
      <p>Имя по соглашению должно быть <code><emphasis>язык</emphasis>.po</code>, где <code><emphasis>язык</emphasis></code> является стандартным международным сокращением из двух или трех букв для обозначения языка. Иногда используется форма <code><emphasis>язык_страна</emphasis>.po</code><emphasis>:</emphasis> например, <code>pt_BR.po</code> для португальского в Бразилии. Поскольку свинский латинский не является настоящим языком, мы назвали файл <code>piglat.ро</code>.<a l:href="#n147" type="note">[147]</a> Вот содержание после добавления перевода:</p>
      <p><code># echodate translations into pig Latin</code></p>
      <p><code># Copyright (C) 2004 Prentice-Hall</code></p>
      <p><code># This file is distributed under the same license as the echodate package.</code></p>
      <p><code># Arnold Robbins &lt;arnold@example.com&gt; 2004</code></p>
      <p><code>#</code></p>
      <p><code>#, fuzzy</code></p>
      <p><code>msgid ""</code></p>
      <p><code>msgstr ""</code></p>
      <p><code>"Project-Id-Version: echodate 1.0\n"</code></p>
      <p><code>"Report-Msgid-Bugs-To: arnold@example.com\n"</code></p>
      <p><code>"POT-Creation-Date: 2003-07-14 18:46-0700\n"</code></p>
      <p><code>"PO-Revision-Date: 2003-07-14 19:00+8\n"</code></p>
      <p><code>"Last-Translator: Arnold Robbins &lt;arnold@example.com&gt;\n"</code></p>
      <p><code>"Language-Team: Pig Latin &lt;piglat@li.example.org&gt;\n"</code></p>
      <p><code>"MIME-Version: 1.0\n"</code></p>
      <p><code>"Content-Type: text/plain; charset=ASCII\n"</code></p>
      <p><code>"Content-Transfer-Encoding: 8bit\n"</code></p>
      <empty-line/>
      <p><code>#: ch13-echodate.с:19</code></p>
      <p><code>msgid "Enter a Date/time as YYYY/MM/DD HH:MM:SS : "</code></p>
      <p><code>msgstr "Enteray A Ateday/imetay asay YYYY/MM/DD HH:MM:SS : "</code></p>
      <empty-line/>
      <p><code>#: ch13-echodate.c:32</code></p>
      <p><code>#, c-format</code></p>
      <p><code>msgid "Got: %s"</code></p>
      <p><code>msgstr "Otgay: %s"</code></p>
      <p>Хотя можно было бы произвести линейный поиск в переносимом объектном файле, такой поиск был бы медленным. Например, в <code>gawk</code> имеется примерно 350 отдельных сообщений, а в GNU Coreutils — свыше 670. Линейный поиск в файле с сотнями сообщений был бы заметно медленным. Поэтому GNU <code>gettext</code> использует для быстрого поиска сообщений двоичный формат. Сравнение осуществляет <code>msgfmt</code>, выдавая объектный файл сообщений:</p>
      <p><code>$ <strong>msgfmt piglat.po -о piglat.mo</strong></code></p>
      <p>При сопровождении программы изменяются строки, используемые программой: добавляются новые, другие удаляются или изменяются. По крайней мере, может измениться положение строки в исходном файле. Таким образом, файлы переводов <code>.ро</code>, вероятно, устареют. Программа <code>msgmerge</code> объединяет старые файлы переводов с новым файлом <code>.pot</code>. Затем результат может быть обновлен. Этот пример выполняет объединение и повторное компилирование:</p>
      <p><code>$ <strong>msgmerge piglat.po echodate.pot -o piglat.new.po</strong> /* Объединить файлы */</code></p>
      <p><code>$ <strong>mv piglat.new.po piglat.po</strong> /* Переименовать результат */</code></p>
      <p><code>$ <strong>vi piglat.po</strong> /* Модернизировать перевод */</code></p>
      <p><code>$ <strong>msgfmt piglat.po -o piglat.mo</strong> /* Восстановить файл .mo */</code></p>
      <p>Откомпилированные файлы <code>.mo</code> помещаются в файл <code><emphasis>base</emphasis>/<emphasis>locale</emphasis>/category/<emphasis>textdomain</emphasis>.mo</code>. На системах GNU/Linux <code>base</code> является <code>/usr/share/locale</code>. <code>locale</code> является обозначением языка, например, '<code>es</code>', '<code>fr</code>' и т.д. <code>category</code> является категорией локали; для сообщений это <code>LC_MESSAGES</code>. <code>textdomain</code> является текстовым доменом программы, в нашем случае это <code>echodate</code>. В качестве реального примера в <code>/usr/share/locale/es/LC_MESSAGES/coreutils.mo</code> находится перевод GNU Coreutils на испанский.</p>
      <p>Функция <code>bindtextdomain()</code> изменяет в местоположении часть <code>base</code>. В <code>ch13-echodate.c</code> мы меняем ее на '<code>.</code>'. Таким образом, нужно создать соответствующие каталоги и поместить туда перевод на свинский латинский:</p>
      <p><code>$ <strong>mkdir -р en_US/LC_MESSAGES</strong> /* Нужно использовать реальную локаль */</code></p>
      <p><code>$ <strong>cp piglat.mo en_US/LC_MESSAGES/echodate.mo</strong> /* Поместить файл в нужное место */</code></p>
      <p>Должна использоваться реальная локаль<a l:href="#n148" type="note">[148]</a>; мы «притворяемся» использующими "<code>en_US</code>". Разместив перевод, устанавливаем соответствующим образом <code>LC_ALL</code>, скрещиваем пальцы и запускаем программу:</p>
      <p><code>$ <strong>LC_ALL=en_US ch13-echodate</strong> /* Запуск программы */</code></p>
      <p><code>Enteray A Ateday/imetay asay YYYY/MM/DD HH:MM:SS : 2003/07/14 21:19:26</code></p>
      <p><code>Otgay: Mon Jul 14 21:19:26 2003</code></p>
      <p>Последнюю версию GNU <code>gettext</code> можно найти в каталоге дистрибутива GNU <code>gettext</code>.<a l:href="#n149" type="note">[149]</a></p>
      <p>Этот раздел лишь слегка коснулся поверхности процесса локализации. GNU <code>gettext</code> предоставляет множество инструментов для работы с переводами, и в особенности для облегчения поддержания современности переводов по мере развития исходного кода программы. Процесс ручного обновления переводов осуществим, но утомителен. Эта задача легко автоматизируется с помощью <code>make</code>; в частности, GNU <code>gettext</code> хорошо интегрируется для обеспечения этой возможности с Autoconf и Automake, снимая с программиста значительный груз по разработке.</p>
      <p>Рекомендуем прочесть документацию GNU <code>gettext</code>, чтобы больше узнать как об этих проблемах в частности, так и о GNU <code>gettext</code> в общем.</p>
     </section>
    </section>
    <section>
     <title>
      <p>13.4. Не могли бы вы произнести это для меня по буквам?</p>
     </title>
     <section>
      <p>В самые ранние дни вычислительной техники различные системы назначали различные соответствия между числовыми значениями и <emphasis>глифами (glyphs)</emphasis> — символами, такими, как буквы, цифры и знаки пунктуации, используемыми для общения с людьми. В конечном счете появились два широко использующихся стандарта: кодировка EBCDIC, используемая IBM и подобными ей мэйнфреймами, и ASCII, использующаяся для всего остального. Сегодня, за исключением мэйнфреймов, ASCII является основой для всех других использующихся наборов символов.</p>
      <p>Оригинальный семиразрядный набор символов ASCII достаточен для американского английского и большинства знаков пунктуации и специальных символов (таких, как <code>$</code>, но нет символа для «цента»). Однако, имеется много языков и много стран, которым нужны другие наборы символов. ASCII не оперирует версиями романских символов с надстрочными значками, использующимися в Европе, а во многих азиатских языках тысячи символов. Для устранения этих недостатков были разработаны новые технологии.</p>
      <p>Литература по интернационализации изобилует ссылками на три фундаментальных термина. Определив их и взаимоотношения между ними, мы сможем представить общее описание соответствующих функций API С.</p>
      <p><emphasis>Набор символов (character set)</emphasis></p>
      <p>Определение значений, присваиваемых различным целым величинам; например того, что A равно 65. Любой набор символов, использующий более восьми битов на символ, называется многобайтным <emphasis>набором символов</emphasis>.</p>
      <p><emphasis>Представление набора символов (character set encoding)</emphasis></p>
      <p>ASCII использует для представления символов один байт. Таким образом, целое значение хранится само по себе, непосредственно в дисковых файлах. Более современные наборы символов, особенно различные версии Unicode<a l:href="#n150" type="note">[150]</a>, используют для представления символов 16-разрядные или даже 32-разрядные целые значения. Для большинства определенных символов один, два или даже три старших байта целого значения равны нулю, что делает непосредственное хранение таких значений на диске неэффективным. Представление набора символов описывает механизм для преобразования 16- или 32-разрядных значений в последовательности от одного до шести байтов для сохранения на диске таким образом, что в целом наблюдается значительная экономия дисковой памяти.</p>
      <p><emphasis>Язык</emphasis></p>
      <p>Правила данного языка определяют использование набора символов. В частности, правила влияют на сортировку символов. Например, на французском е, &#233; и &#232; все должны находиться между d и f, независимо от назначенных этим символам числовых значений. Различные языки могут назначить (и назначают) одним и тем же глифам различный порядок сортировки.</p>
      <p>Со временем для поддержки многобайтных наборов символов были разработаны различные технологии. Вычислительная практика медленно стремится к Unicode и соответствующим его представлениям, но стандартный С и POSIX поддерживают как старые, так и современные технологии. В данном разделе представлен концептуальный обзор различных возможностей. Нам самим не приходилось их использовать, поэтому мы предпочитаем просто познакомить с ними и предоставить ссылки на дополнительную информацию.</p>
     </section>
     <section>
      <title>
       <p>13.4.1. Широкие символы</p>
      </title>
      <p>Мы начнем с концепции <emphasis>широких символов (wide character)</emphasis>. Широкий символ является целым типом, в котором может храниться любое значение из определенного используемого многобайтного набора символов.</p>
      <p>Широкие символы представлены на С типом <code>wchar_t</code>. C99 предоставляет соответствующий тип <code>wint_t</code>, в котором может находиться любое значение, допустимое для <code>wchar_t</code>, а также специальное значение <code>WEOF</code>, аналогичное обычному <code>EOF</code> из <code>&lt;stdio.h&gt;</code>. В заголовочном файле <code>&lt;wchar.h</code>&gt; определены различные типы. Ряд функций, сходных с функциями в <code>&lt;ctype.h&gt;</code>, такие, как <code>iswalnum()</code> и др., определены в заголовочном файле <code>&lt;wctype.h&gt;</code>.</p>
      <p>Широкие символы могут быть от 16 до 32 битов размером в зависимости от реализации. Как упоминалось, они нацелены на манипулирование данными в памяти и обычно не хранятся в файлах непосредственно.</p>
      <p>Стандарт C предусматривает для широких символов большое число функций и макросов, соответствующих традиционным функциям, работающим с данными <code>char</code>. Например, <code>wprintf()</code>, <code>iswlower()</code> и т.д. Они документированы в справочных страницах GNU/Linux и в книгах по стандартному С.</p>
     </section>
     <section>
      <title>
       <p>13.4.2. Представления многобайтных символов</p>
      </title>
      <p>Строки широких символов сохраняются на диске путем преобразования их в памяти в многобайтное представление набора символов с последующей записью в дисковый файл. Сходным образом, такие строки считываются с диска через низкоуровневый блочный ввод/вывод, а затем конвертируются в памяти из многобайтной версии в версию широких символов.</p>
      <p>Многие описанные кодировки используют для представления многобайтных символов <emphasis>состояния регистра (shift states)</emphasis>. Другими словами, в данном потоке байтов значения байтов представляют самих себя до тех пор, пока не встретится специальное управляющее значение. В этот момент интерпретация изменяется в соответствии с текущим состоянием регистра. Таким образом, одно и то же восьмибитовое значение может иметь два значения: одно для обычного состояния, без использования регистра, и другое для использования регистра. Предполагается, что правильно закодированные строки начинаются и заканчиваются с одним и тем же состоянием регистра.</p>
      <p>Значительным преимуществом Unicode является то, что его представления являются самокорректирующимися; кодировки не используют состояния регистров, поэтому потеря данных в середине не может повредить последующим закодированным данным.</p>
      <p>Первоначальные версии функций преобразования многобайтных символов в широкие и широких в многобайтные поддерживали закрытую копию состояния преобразования (например, состояние регистра, а также все остальное, что могло понадобиться) Такая модель ограничивает использование функции лишь одним видом преобразования в течение жизни программы. Примерами являются <code>mblen()</code> (определение длины многобайтной строки), <code>mbtowc()</code> (преобразование многобайтного символа в широкий), <code>wctomb()</code> (преобразование широкого символа в многобайтный), <code>mbstowcs()</code> (преобразование многобайтной строки в строку широких символов), <code>wcstombs()</code> (преобразование строки широких символов в многобайтную строку).</p>
      <p>Новые версии этих процедур называются повторно <emphasis>запускаемыми (restartable)</emphasis>. Это означает, что код уровня пользователя сохраняет состояние преобразования в отдельном объекте типа <code>mbstate_t</code>. Соответствующими примерами являются <code>mbrlen()</code>, <code>mbrtowc()</code>, <code>wcrtomb()</code>, <code>mbsrtowcs()</code> и <code>wcsrtombs()</code>. (Обратите внимание на <code>r</code> в их именах, это означает «restartable».)</p>
     </section>
     <section>
      <title>
       <p>13.4.3. Языки</p>
      </title>
      <p>Языковые проблемы управляются локалью. Ранее в главе мы уже видели <code>setlocale()</code> POSIX предоставляет продуманный механизм для определения правил, посредством которых работает локаль; некоторые подробности см. в справочной странице GNU/Linux <emphasis>locale</emphasis>(5), а полностью — в самом стандарте POSIX.</p>
      <p>Правда в том, что подробности на самом деле не нужны. Вам, как разработчику программ, не нужно беспокоиться о них; как заставить все работать, зависит от разработчиков библиотек. Все, что нужно, это понять концепции и использовать в своем коде соответствующие функции, такие, как <code>strcoll()</code> (см. раздел 13.2.3 «Сравнение строк: <code>strcoll()</code> и <code>strxfrm()</code>»).</p>
      <p>Современные системы GLIBC предоставляют отличную поддержку локалей, включая поддерживающие локали процедуры сопоставления регулярных выражений. Например, расширенное регулярное выражение POSIX <code>[[:alpha:]][[:alnum:]]+</code> соответствует букве, за которой следуют одна или более букв или цифр (алфавитный символ, за которым следуют один или более алфавитно-цифровых символов). Определение того, какие символы соответствуют этим классам, зависит от локали. Например, это регулярное выражение соответствовало бы двум символам '<code>e&#232;</code>', тогда как регулярное выражение <code>[a-zA-Z][a-A-Zz0-9]+</code> традиционного, ориентированного на ASCII Unix — скорее всего нет. Классы символов POSIX перечислены в табл. 13.5.</p>
      <empty-line/>
      <p><strong>Таблица 13.5</strong>. Классы символов регулярных выражений POSIX</p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Класс</th>
        <th align="left" valign="top">Соответствует</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>[:alnum:]</code></td>
        <td align="left" valign="top">Алфавитно-цифровые символы</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>[:alpha:]</code></td>
        <td align="left" valign="top">Алфавитные символы</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>[:blank:]</code></td>
        <td align="left" valign="top">Символы пробела и табуляции.</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>[:cntrl:]</code></td>
        <td align="left" valign="top">Управляющие символы</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>[:digit:]</code></td>
        <td align="left" valign="top">Цифровые символы</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>[:graph:]</code></td>
        <td align="left" valign="top">Символы, являющиеся одновременно печатными и видимыми. (Символ конца строки печатный, но не видимый, тогда как <code>$</code> является и тем, и другим.)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>[:lower:]</code></td>
        <td align="left" valign="top">Строчные алфавитные символы</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>[:print:]</code></td>
        <td align="left" valign="top">Печатные (не управляющие) символы</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>[:punct:]</code></td>
        <td align="left" valign="top">Знаки пунктуации (не буквы, цифры, управляющие или пробельные символы)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>[:space:]</code></td>
        <td align="left" valign="top">Пробельные символы (такие, как сам пробел, символы табуляции, конца строки и т.д)</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>[:upper:]</code></td>
        <td align="left" valign="top">Заглавные алфавитные символы</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>[:xdigit:]</code></td>
        <td align="left" valign="top">Символы из набора <code>abcdefABCDEF0123456789</code></td>
       </tr>
      </table>
     </section>
     <section>
      <title>
       <p>13.4.4. Заключение</p>
      </title>
      <p>Возможно, вам никогда не придется иметь дело с различными наборами символов и их представлениями. С другой стороны, мир быстро становится «глобальным сообществом», и авторы программ не могут позволить себе быть ограниченными. Следовательно, стоит знать о проблемах интернационализации и наборов символов, а также способах их влияния на поведение вашей системы. По крайней мере, уже один из поставщиков дистрибутивов GNU/Linux устанавливает для систем в Соединенных Штатах локаль по умолчанию <code>en_US.UTF-8</code>.</p>
     </section>
    </section>
    <section>
     <title>
      <p>13.5. Рекомендуемая литература</p>
     </title>
     <p>1. <emphasis>С, A Reference Manual</emphasis>, 5th edition, by Samuel P. Harbison III and Guy L. Steele, Jr., Prentice-Hall, Upper Saddle River, New Jersey, USA, 2002. ISBN: 0-13-089592-X.</p>
     <p>Мы уже упоминали эту книгу раньше. Она дает точное и исчерпывающее описание развития и использования возможностей стандартной библиотеки С для работы с многобайтными и широкими символами. Это особенно ценно для современных систем, поддерживающих C99, поскольку библиотека была значительно усовершенствована для стандарта С 1999 г.</p>
     <p>2. <emphasis>GNU gettext tools</emphasis>, by Ulrich Drepper, Jim Meyering, Fran&#231;ois Pinard, and Bruno Haible. Это руководство по GNU <code>gettext</code>. На системе GNU/Linux вы можете посмотреть локальную копию через '<code>info gettext</code>'. Или загрузить и распечатать последнюю версию (по адресу <code>ftp://ftp.gnu.org/gnu/gettext/</code>).</p>
    </section>
    <section>
     <title>
      <p>13.6. Резюме</p>
     </title>
     <p>• Интернационализация и локализация программ подпадают под общее название <emphasis>поддержки родного языка</emphasis>. Широко распространенными сокращениями являются <emphasis>i18n</emphasis>, <emphasis>l10n</emphasis> и <emphasis>NLS</emphasis>. Центральным является понятие локали, которая позволяет настраивать набор символов, отображение даты, времени, денежных и числовых величин в соответствии с принятыми для данного языка и в данной стране нормами.</p>
     <p>• Использование локали устанавливается с помощью функции <code>setlocale()</code>. Различные категории локали предоставляют доступ к различным видам информации локали. Не использующие локаль программы действуют, как если бы они находились в локали «С», которая выдает типичные для систем Unix до NLS результаты: 7-разрядный ASCII, английские названия месяцев и дней и т.д. Локаль «POSIX» эквивалентна локали «С».</p>
     <p>• Сравнение строк с учетом локали осуществляется функцией <code>strcoll()</code> или комбинацией <code>strxfrm()</code> и <code>strcmp()</code>. Возможности библиотеки предоставляют доступ к сведениям о локали (<code>localeconv()</code> и <code>nl_langinfo()</code>), а также к специфического для локали форматирования (<code>strfmon()</code>, <code>strftime()</code> и <code>printf()</code>).</p>
     <p>• Обратной стороной получения относящейся к локали информации является вывод сообщений на местном языке. Модель <code>catgets()</code> System V, хотя и стандартизована POSIX, трудна для использования и поэтому не рекомендуется.<a l:href="#n151" type="note">[151]</a> Вместо этого GNU <code>gettext</code> реализует и расширяет оригинальный замысел Solaris.</p>
     <p>• При использовании <code>gettext()</code> оригинальная строка сообщения на английском действует в качестве ключа в двоичном файле перевода, из которого получается перевод строки. Каждое приложение указывает уникальный текстовый домен таким образом, чтобы <code>gettext()</code> могла найти нужный файл с переводом (известный как «список сообщений»). Текстовый домен устанавливается с помощью функции <code>textdomain()</code>. При тестировании или иной надобности местоположение списка сообщений можно изменить с помощью функции <code>bindtextdomain()</code>.</p>
     <p>• <code>gettext()</code> и ее варианты предоставляют доступ к переводам в различных текстовых доменах или различных категориях локалей. Вдобавок, функция <code>ngettext()</code> и ее варианты дают возможность делать правильные переводы множественных чисел, не перегружая разработчика. Указатель положения в спецификаторе формата <code>printf()</code> дает возможность перевода форматирующих строк, аргументы которых должны выводиться в другом порядке, чем они располагаются в строке.</p>
     <p>• На практике GNU программы используют для пометки переводимых строк в исходных файлах заголовочный файл <code>gettext.h</code> и макросы <code>_()</code> и <code>N_()</code>. Такая практика обеспечивает удобочитаемость исходного кода и возможность его поддержки, предоставляя в то же время преимущества интернационализации и локализации.</p>
     <p>• GNU <code>gettext</code> предоставляет многочисленные инструменты для создания и управления базами данных переводов (переносимых объектных файлов) и их двоичными эквивалентами (объектными файлами сообщений).</p>
     <p>• Наконец, стоит быть в курсе проблем наборов символов и их представлений. Поставщики программного обеспечения не могут больше позволить себе предполагать, что их пользователи хотят работать лишь на одном языке.</p>
    </section>
    <section>
     <title>
      <p>Упражнения</p>
     </title>
     <p>1. Поддерживает ли ваша система локали? Если да, какая локаль используется по умолчанию?</p>
     <p>2. Просмотрите справочную страницу <emphasis>locale</emphasis>(1), если она у вас есть. Сколько имеется локалей, если вы посчитаете их с помощью '<code>locale -a | wc -l</code>'?</p>
     <p>3. Поэкспериментируйте с <code>ch13-strings.с</code>, <code>ch13-lconv.c</code>, <code>ch13-strfmon.с</code>, <code>ch13-quoteflag.c</code> и <code>ch13-times.c</code> в различных локалях. Какая из найденных локалей самая «необычная» и почему?</p>
     <p>4. Возьмите одну из своих программ. Интернационализируйте ее с использованием GNU <code>gettext</code>. Постарайтесь найти кого-нибудь, кто говорит на другом языке, чтобы перевести для вас сообщения. Откомпилируйте перевод и протестируйте его, использовав <code>bindtextdomain()</code>. Какова была реакция вашего переводчика при виде использования перевода?</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 14</p>
     <p>Расширенные интерфейсы</p>
    </title>
    <section>
     <p>В данной главе описываются несколько расширенных API. Они сходны по своей природе с описанными ранее в книге или предоставляют дополнительные возможности. Некоторые из них трудно было свободно обсуждать, пока не были освещены предварительные темы.</p>
     <p>Порядок представления здесь соответствует порядку глав в первой половине книги. В другом отношении темы не связаны друг с другом. Мы освещаем следующие вопросы: динамическое выделение выровненной памяти; блокировку файлов; ряд функций, работающих со значениями долей секунды; и более развитый набор функций для сохранения и получения произвольных значений данных. Если не указано противное, все API в данной главе включены в стандарт POSIX.</p>
    </section>
    <section>
     <title>
      <p>14.1. Выделение выровненной памяти: <code>posix_memalign()</code> и <code>memalign()</code></p>
     </title>
     <p>Для большинства задач отлично подходят стандартные процедуры выделения памяти — <code>malloc()</code>, <code>realloc()</code> и т.д. Но иногда может понадобиться память, которая выровнена тем или иным способом. Другими словами, адрес первого выделенного байта является кратным какого-нибудь числа. (Например, на некоторых системах копирование памяти осуществляется значительно быстрее, если используются буфера, выровненные по границе слова.) Такую службу предоставляют две функции:</p>
     <p><code>#include &lt;stdlib.h&gt;</code></p>
     <empty-line/>
     <p><code>int posix_memalign(void **memptr, size_t alignment, size_t size);</code></p>
     <p><code> /* POSIX ADV */</code></p>
     <p><code>void *memalign(size_t boundary, size_t size); /* Обычная */</code></p>
     <p><code>posix_memalign()</code> является более новой функцией; она является частью другого необязательного расширения, «Консультативной информации» («Advisory Information»). Работа функции отличается от других функций выделения памяти Linux. При наличии проблемы она не возвращает -1. Вместо этого возвращаемое значение равно 0 при успехе <emphasis>или значению</emphasis> <code><emphasis>errno</emphasis></code> <emphasis>в случае неудачи</emphasis>. Аргументы следующие:</p>
     <p><code>void **memptr</code></p>
     <p>Указатель на переменную <code>void*</code>. Указываемая переменная будет содержать адрес выделенного блока памяти. Выделенная память освобождается с помощью <code>free()</code>.</p>
     <p><code>size_t alignment</code></p>
     <p>Требуемое выравнивание. Оно должно быть кратно <code>sizeof(void*)</code> и быть степенью двойки.</p>
     <p><code>size_t size</code></p>
     <p>Число выделяемых байтов.</p>
     <p><code>memalign()</code> является нестандартной, но широко доступной функцией, которая работает сходным образом. Возвращаемое значение равно <code>NULL</code> в случае неудачи и запрошенному блоку памяти при успехе, причем <code>boundary</code> (степень двойки) обозначает выравнивание, a <code>size</code> — затребованный размер памяти.</p>
     <p>Традиционно выделенная <code>memalign()</code> память <emphasis>не</emphasis> могла быть освобождена с помощью <code>free()</code>, поскольку <code>memalign()</code> использовала для выделения памяти <code>malloc()</code> и возвращала указатель на выровненный подходящим образом байт где-то внутри блока. Версия GLIBC не имеет этой проблемы. Из этих двух функций следует использовать <code>posix_memalign()</code>, если она у вас есть.</p>
    </section>
    <section>
     <title>
      <p>14.2. Блокировка файлов</p>
     </title>
     <section>
      <p>Современные системы Unix, включая GNU/Linux, дают вам возможность заблокировать часть файла или весь файл для чтения или записи. Подобно многим частям Unix API, которые были разработаны после V7, имеется несколько несовместимых способов осуществить блокировку файлов. Данный раздел рассматривает эти возможности.</p>
     </section>
     <section>
      <title>
       <p>14.2.1. Концепции блокировки файлов</p>
      </title>
      <p>Также, как замок на вашей двери предотвращает нежелательные проникновения в ваш дом, <emphasis>блокировка</emphasis> файла предотвращает доступ к данным в файле. Блокировка файлов была добавлена в Unix после разработки V7 (от которой происходят все современные системы Unix), и соответственно в течение некоторого времени в различных системах Unix были доступны и использовались несколько несовместимых механизмов блокировки файлов. Как в BSD Unix, так и в System V были собственные несочетающиеся вызовы для блокировки. В конечном счете POSIX формализовал способ осуществления блокировки файлов System V. К счастью, названия функций в System V и BSD были различны, так что GNU/Linux, в попытке угодить всем, поддерживает обе разновидности блокировок.</p>
      <p>Табл. 14.1 суммирует различные виды блокировок.</p>
      <empty-line/>
      <p><strong>Таблица 14.1</strong>. Функции блокировки файлов</p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Источник</th>
        <th align="left" valign="top">Функция</th>
        <th align="left" valign="top">Диапазон</th>
        <th align="left" valign="top">Весь файл</th>
        <th align="left" valign="top">Чтение/запись</th>
        <th align="left" valign="top">Вспомогательный</th>
        <th align="left" valign="top">Обязательный</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top">BSD</td>
        <td align="left" valign="top"><code>flock()</code></td>
        <td align="left" valign="top"/>
        <td align="left" valign="top">&#8730;</td>
        <td align="left" valign="top">&#8730;</td>
        <td align="left" valign="top">&#8730;</td>
        <td align="left" valign="top"/>
       </tr>
       <tr align="left">
        <td align="left" valign="top">POSIX</td>
        <td align="left" valign="top"><code>fcntl()</code></td>
        <td align="left" valign="top">&#8730;</td>
        <td align="left" valign="top">&#8730;</td>
        <td align="left" valign="top">&#8730;</td>
        <td align="left" valign="top">&#8730;</td>
        <td align="left" valign="top">&#8730;</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top">POSIX</td>
        <td align="left" valign="top"><code>lockf()</code></td>
        <td align="left" valign="top">&#8730;</td>
        <td align="left" valign="top">&#8730;</td>
        <td align="left" valign="top">&#8730;</td>
        <td align="left" valign="top">&#8730;</td>
        <td align="left" valign="top">&#8730;</td>
       </tr>
      </table>
      <p>Имеются следующие аспекты блокировки файлов:</p>
      <p><emphasis>Блокировка записей</emphasis></p>
      <p>Блокировка записи является блокировкой части файла. Поскольку файлы Unix являются просто потоками байтов, было бы корректнее использовать термин <emphasis>блокировка диапазона (range lock)</emphasis>, поскольку осуществляется блокировка диапазона байтов. Тем не менее, термин «блокировка записей» общеупотребительный.</p>
      <p><emphasis>Блокировка всего файла</emphasis></p>
      <p>Блокировка всего файла, как предполагает название, блокирует весь файл, даже если его размер меняется в блокированном состоянии. Интерфейс BSD предусматривает блокирование лишь всего файла. Для блокирования всего файла с использованием интерфейса POSIX указывают нулевую длину. Это интерпретируется особым образом как «весь файл».</p>
      <p><emphasis>Блокировка чтения</emphasis></p>
      <p>Блокировка чтения предотвращает запись в читаемую область. В файле может быть несколько заблокированных для чтения участков, даже в одной области файла, не мешающих друг другу, поскольку к данным осуществляется лишь доступ и они не изменяются.</p>
      <p><emphasis>Блокировка записи</emphasis></p>
      <p>Блокировка записи предоставляет исключительный доступ к записываемой области. Если эта область заблокирована также и для чтения, попытка получения блокировки записи либо блокируется, либо завершается неудачей в зависимости от запрошенного типа блокировки. После получения блокировки записи попытка получить блокировку чтения завершается неудачей.</p>
      <p><emphasis>Вспомогательная блокировка</emphasis></p>
      <p>Вспомогательная блокировка (advisory lock) тесно соответствует замку на двери. Говорят, «замки существуют для честных людей», что означает, что если кто-нибудь <emphasis>на самом деле</emphasis> захочет вломиться в ваш дом, он, возможно, найдет способ это сделать, несмотря на наличие замка в двери. То же и со вспомогательной блокировкой; она работает лишь тогда, когда тот, кто пытается получить доступ к заблокированному файлу, сначала пытается получить блокировку. Однако, программа может совершенно игнорировать вспомогательные блокировки и делать с файлом, что захочет (конечно, пока это разрешается правами допуска файла).</p>
      <p><emphasis>Обязательная блокировка</emphasis></p>
      <p>Обязательная блокировка является более строгой: когда установлена обязательная блокировка, ни один другой процесс не может получить доступ к заблокированному файлу. Любой процесс, который пытается игнорировать это, либо сам блокируется до снятия блокировки файла, либо его попытка завершится неудачей. (Под GNU/Linux по крайней мере это включает <code>root</code>!)</p>
      <p>Вспомогательная блокировка достаточна для взаимодействующих программ, разделяющих индивидуальный файл, когда не предполагается использование этого файла ни одним другим приложением. Обязательная блокировка подходит в ситуации, когда избежание конфликта в использовании файла является критическим, как в коммерческих системах баз данных.</p>
      <p>POSIX стандартизует лишь вспомогательную блокировку. Обязательная блокировка доступна на GNU/Linux, а также в ряде коммерческих систем Unix, но детали варьируют. Далее в данном разделе мы рассмотрим детали для GNU/Linux.</p>
     </section>
     <section>
      <title>
       <p>14.2.2. Блокировка POSIX: <code>fcntl()</code> и <code>lockf()</code></p>
      </title>
      <section>
       <p>Системный вызов <code>fcntl()</code> (file control — управление файлом) используется для блокировки файла. (Другое использование <code>fcntl()</code> было описано в разделе 9.4.3 «Управление атрибутами файла: <code>fcntl()</code>».) Он объявлен следующим образом:</p>
       <p><code>#include &lt;unistd.h&gt; /* POSIX */</code></p>
       <p><code>#include &lt;fcntl.h&gt;</code></p>
       <empty-line/>
       <p><code>int fcntl(int fd, int cmd); /* Not relevant for file locking */</code></p>
       <p><code>int fcntl(int fd, int cmd, long arg); /* Not relevant for file locking */</code></p>
       <p><code>int fcntl(int fd, int cmd, struct flock *lock);</code></p>
       <p>Аргументы следующие:</p>
       <p><code>fd</code> Дескриптор файла для открытого файла.</p>
       <p><code>cmd</code> Одна или более именованных констант, определенных в <code>&lt;fcntl.h&gt;</code>. Ниже они описаны более подробно.</p>
       <p><code>lock</code> Указатель на <code>struct flock</code>, описывающую нужный блок.</p>
      </section>
      <section>
       <title>
        <p>14.2.2.1. Описание блокировки</p>
       </title>
       <p>Прежде чем рассмотреть осуществление блокировки, давайте исследуем описание блокировки в операционной системе. Это делается при помощи структуры <code>struct flock</code>, которая описывает диапазон блокируемых байтов и вид нужной блокировки. Стандарт POSIX утверждает, что <code>struct lock</code> содержит «по крайней мере» определенные члены. Это позволяет разработчикам предоставлять при желании дополнительные члены структуры. Из слегка отредактированной справочной страницы <emphasis>fcntl</emphasis>(3):</p>
       <p><code>struct flock {</code></p>
       <p><code> ...</code></p>
       <p><code> short l_type; /* Тип блокировки: F_RDLCK, F_WRLCK, F_UNLCK */</code></p>
       <p><code> short l_whence; /* Как интерпретируется l_start:</code></p>
       <p><code>                    SEEK_SET, SEEK_CUR, SEEK_END */</code></p>
       <p><code> off_t l_start; /* Начальное блокируемое смещение */</code></p>
       <p><code> off_t l_len; /* Число блокируемых байтов;</code></p>
       <p><code>                 0 означает от начала до конца файла */</code></p>
       <p><code> pid_t l_pid; /* PID блокирующего процесса (только F_GETLK) */</code></p>
       <p><code> ...</code></p>
       <p><code>};</code></p>
       <p>Поле <code>l_start</code> является смешением начального байта блокируемого участка. <code>l_len</code> является длиной блокируемого участка, т. е. общим числом блокируемых байтов. <code>l_whence</code> указывает место в файле, относительно которого отсчитывается <code>l_start</code>, значения те же, что и для аргумента <code>whence</code> функции <code>lseek()</code> (см раздел 4.5 «Произвольный доступ: перемещения внутри файла»), отсюда и название поля. Эта структура самодостаточна: смещение <code>l_start</code> и значение <code>l_whence</code> <emphasis>не</emphasis> связаны с текущим файловым указателем для чтения или записи. Пример кода мог бы выглядеть таким образом:</p>
       <p><code>struct employee { /* что угодно */ }; /* Описание сотрудника */</code></p>
       <p><code>struct flock lock; /* Структура блока */</code></p>
       <p><code>...</code></p>
       <p><code>/* Заблокировать структуру для шестого сотрудника */</code></p>
       <p><code>lock.l_whence = SEEK_SET; /* Абсолютное положение */</code></p>
       <p><code>lock.l_start = 5 * sizeof(struct employee); /* Начало 6-й структуры */</code></p>
       <p><code>lock.l_len = sizeof(struct employee); /* Блокировать одну запись */</code></p>
       <p>Используя <code>SEEK_CUR</code> или <code>SEEK_END</code>, вы можете заблокировать участки, начиная от текущего смещения в файле или относительно конца файла соответственно. Для этих двух случаев <code>l_start</code> может быть отрицательным, пока абсолютное начало не меньше нуля. Таким образом, чтобы заблокировать последнюю запись в файле:</p>
       <p><code>/* Заблокировать запись последнего сотрудника */</code></p>
       <p><code>lock.l_whence = SEEK_END; /* Относительно EOF */</code></p>
       <p><code>lock.l_start = -1 * sizeof (struct employee);</code></p>
       <p><code> /* Начало последней структуры */</code></p>
       <p><code>lock.l_len = sizeof(struct employee); /* Заблокировать одну запись */</code></p>
       <p>Установка <code>l_len</code> в 0 является особым случаем. Он означает блокировку файла от начального положения, указанного с помощью <code>l_start</code> и <code>l_whence</code>, и до конца файла. Сюда входят также любые области за концом файла. (Другими словами, если заблокированный файл увеличивается в размере, область блокировки расширяется таким образом, чтобы продолжать охватывать весь файл.) Таким образом, блокирование всего файла является вырожденным случаем блокирования одной записи:</p>
       <p><code>lock.l_whence = SEEK_SET; /* Абсолютное положение */</code></p>
       <p><code>lock.l_start = 0; /* Начало файла */</code></p>
       <p><code>lock.l_len = 0; /* До конца файла */</code></p>
       <p>Справочная страница <emphasis>fnctl</emphasis>(3) имеет примечание:</p>
       <cite>
        <p>POSIX 1003.1-2001 допускает отрицательные значения <code>l_len</code>. (И если это так, описываемый блоком интервал охватывает байты с <code>l_start + l_len</code> вплоть до <code>l_start - 1</code> включительно.) Однако, в этой ситуации системный вызов Linux для современных ядер возвращает <code>EINVAL</code>.</p>
       </cite>
       <p>(Мы заметили, что справочная страница относится к версиям ядер 2.4.x; стоит проверить текущую справочную страницу, если ваша система новее.)</p>
       <p>Теперь, когда мы знаем, как описать <emphasis>где</emphasis> блокируется файл, мы можем описать <emphasis>тип</emphasis> блокировки с помощью <code>l_type</code>. Возможные значения следующие:</p>
       <p><code>F_RDLCK  </code>Блокировка чтения. Для применения блокировки чтения файл должен быть открыт для чтения.</p>
       <p><code>F_WRLCK  </code>Блокировка записи. Для применения блокировки записи файл должен быть открыт для записи.</p>
       <p><code>F_UNLCK  </code>Освобождение предыдущей блокировки.</p>
       <p>Таким образом, полная спецификация блокировки включает установку в структуре <code>struct flock</code> значений четырех полей: трех для указания блокируемой области и четвертого для описания нужного типа блока.</p>
       <p>Значение <code>F_UNLCK</code> для <code>l_type</code> снимает блокировку. В общем, это простейший способ снять те самые блоки, которые были установлены ранее, но можно «расщепить» блок, освободив диапазон байтов в середине ранее установленного более крупного блока. Например:</p>
       <p><code>struct employee { /* что угодно */ }; /* Описание сотрудника */</code></p>
       <p><code>struct flock lock; /* Структура блока */</code></p>
       <p><code>...</code></p>
       <p><code>/* Заблокировать сотрудников 6-8 */</code></p>
       <p><code>lock.l_whence = SEEK_SET; /* Абсолютное положение */</code></p>
       <p><code>lock.l_start = 5 * sizeof(struct employee); /* Начало 6-й структуры */</code></p>
       <p><code>lock.l_len = sizeof(struct employee) * 3; /* Заблокировать 3 записи */</code></p>
       <p><code>/* ...установка блокировки (см. следующий раздел)... */</code></p>
       <p><code>/* Освобождение записи 7: предыдущий блок расщепляется на два: */</code></p>
       <p><code>lock.l_whence = SEEK_SET; /* Абсолютное положение */</code></p>
       <p><code>lock.l_start = 6 * sizeof(struct employee); /* Начало 7-й структуры */</code></p>
       <p><code>lock.l_len = sizeof(struct employee) * 1; /* Разблокирование 1-й записи */</code></p>
       <p><code>/* ...снятие блокировки (см. следующий раздел)... */</code></p>
      </section>
      <section>
       <title>
        <p>14.2.2.2. Установка и снятие блокировок</p>
       </title>
       <p>После заполнения структуры <code>struct flock</code> следующим шагом является запрос блокировки. Этот шаг осуществляется с помощью соответствующего значения аргумента <code>cmd</code> функции <code>fcntl()</code>:</p>
       <p><code>F_GETLK   </code>Узнать, можно ли установить блокировку.</p>
       <p><code>F_SETLK   </code>Установить или снять блокировку.</p>
       <p><code>F_SETLKW  </code>Установить блокировку, подождав, пока это будет возможным.</p>
       <p>Команда <code>F_GETLK</code> является командой «Мама, можно мне?» Она осведомляется, доступна ли описанная <code>struct flock</code> блокировка. Если она доступна, блокировка <emphasis>не</emphasis> устанавливается; вместо этого операционная система изменяет поле <code>l_type</code> на <code>F_UNLCK</code>. Другие поля остаются без изменений.</p>
       <p>Если блокировка недоступна, операционная система заполняет различные поля сведениями, описывающими уже установленные блокировки, которые препятствуют установке новой. В этом случае <code>l_pid</code> содержит PID процесса, владеющего соответствующей блокировкой.<a l:href="#n152" type="note">[152]</a> Если блокировка уже установлена, нет другого выбора, кроме ожидания в течение некоторого времени и новой попытки установки блокировки или вывода сообщения об ошибке и отказа от дальнейших попыток.</p>
       <p>Команда <code>F_SETLK</code> пытается установить указанную блокировку. Если <code>fcntl()</code> возвращает 0, блокировка была успешно установлена. Если она возвращает -1, блокировку установил другой процесс. В этом случае в errno устанавливается либо <code>EAGAIN</code> (попытайтесь снова позже) или <code>EACCESS</code> (нет доступа). Возможны два значения, чтобы удовлетворить старым системам.</p>
       <p>Команда <code>F_SETLKW</code> также пытается установить указанную блокировку. Она отличается от <code>F_SETLK</code> тем, что будет ждать, пока установка блокировки не окажется возможной.</p>
       <p>Выбрав соответствующее значение для аргумента <code>cmd</code>, передайте его в качестве второго аргумента <code>fcntl()</code> вместе с указателем на заполненную структуру <code>struct flock</code> в качестве третьего аргумента:</p>
       <p><code>struct flock lock;</code></p>
       <p><code> int fd;</code></p>
       <p><code> /* ...открыть файл, заполнить struct flock... */</code></p>
       <p><code> if (fcntl(fd, F_SETLK, &amp;lock) &lt; 0) {</code></p>
       <p><code> /* Установить не удалось, попытаться восстановиться */</code></p>
       <p><code>}</code></p>
       <p>Функция <code>lockf()</code><a l:href="#n153" type="note">[153]</a> предоставляет альтернативный способ установки блокировки <emphasis>в текущем положении файла</emphasis>.</p>
       <p><code>#include &lt;sys/file.h&gt; /* XSI */</code></p>
       <empty-line/>
       <p><code>int lockf(int fd, int cmd, off_t len);</code></p>
       <p>Дескриптор файла <code>fd</code> должен быть открыт для записи. <code>len</code> указывает число блокируемых байтов: от текущего положения (назовем его <code>pos</code>) до <code>pos + len</code> байтов, если <code>len</code> положительно, или от <code>pos - len</code> до <code>pos - 1</code>, если len отрицательно. Команды следующие:</p>
       <p><code>F_LOCK   </code>Устанавливает исключительную блокировку диапазона. Вызов блокируется до тех пор, пока блокировка диапазона не станет возможной.</p>
       <p><code>F_TLOCK  </code>Пытается установить блокировку. Это похоже на <code>F_LOCK</code>, но если блокировка недоступна, <code>F_TLOCK</code> возвращает ошибку.</p>
       <p><code>F_ULOCK  </code>Разблокирует указанный раздел. Это может вызвать расщепление блокировки, как описано выше.</p>
       <p><code>F_TEST   </code>Проверяет, доступна ли блокировка. Если доступна, возвращает 0 и устанавливает блокировку. В противном случае возвращает -1 и устанавливает в <code>errno</code> <code>EACCESS</code>.</p>
       <p>Возвращаемое значение равно 0 в случае успеха и -1 при ошибке, с соответствующим значением в <code>errno</code>. Возможные значения ошибок включают:</p>
       <p><code>EAGAIN</code> Файл заблокирован, для <code>F_TLOCK</code> или <code>F_TEST</code>.</p>
       <p><code>EDEADLK</code> Для <code>F_TLOCK</code> эта операция создала бы тупик.<a l:href="#n154" type="note">[154]</a></p>
       <p><code>ENOLCK</code> Операционная система не смогла выделить блок.</p>
       <p>Полезна комбинация <code>F_TLOCK</code> и <code>EDEADLK</code>: если вы знаете, что тупик не может возникнуть никогда, используйте <code>F_LOCK</code>. В противном случае, стоит обезопасить себя и использовать <code>F_TLOCK</code>. Если блокировка доступна, она осуществляется, но если нет, у вас появляется возможность восстановления вместо блокирования в ожидании, возможно, навечно.</p>
       <p>Завершив работу с заблокированным участком, его следует освободить. Для <code>fcntl()</code> возьмите первоначальную <code>struct lock</code>, использованную для блокирования, и измените поле <code>l_type</code> на <code>F_UNLCK</code>. Затем используйте <code>F_SETLK</code> в качестве аргумента <code>cmd</code>:</p>
       <p><code>lock.l_whence = ... ; /* Как раньше */</code></p>
       <p><code>lock.l_start = ... ; /* Как раньше */</code></p>
       <p><code>lock.l_len = ... ; /* Как раньше */</code></p>
       <p><code>lock.l_type = F_UNLCK; /* Разблокировать */</code></p>
       <p><code>if (fcntl(fd, F_SETLK, &amp;lock) &lt; 0) {</code></p>
       <p><code> /* обработать ошибку */</code></p>
       <p><code>}</code></p>
       <p><code>/* Блокировка была снята */</code></p>
       <p>Код, использующий <code>lockf()</code>, несколько проще. Для краткости мы опустили проверку ошибок:</p>
       <p><code>off_t curpos, len;</code></p>
       <p><code>curpos = lseek(fd, (off_t)0, SEEK_CUR); /* Получить текущее положение */</code></p>
       <p><code>len = ... ; / * Установить соответствующее число блокируемых байтов */</code></p>
       <p><code>lockf(fd, F_LOCK, len); / * Осуществить блокировку */</code></p>
       <p><code>/* ...здесь использование заблокированного участка... */</code></p>
       <p><code>lseek(fd, curpos, SEEK_SET); / * Вернуться к началу блокировки */</code></p>
       <p><code>lockf(fd, F_ULOCK, len); /* Разблокировать файл */</code></p>
       <p>Если вы не освободите блокировку явным образом, операционная система сделает это за вас в двух случаях. Первый случай, когда процесс завершается (либо при возвращении из <code>main()</code>, либо с использованием функции <code>exit()</code>, которую мы рассматривали в разделе 9.1.5.1 «Определение статуса завершения процесса»). Другим случаем является вызов <code>close()</code> с дескриптором файла: больше об этом в следующем разделе.</p>
      </section>
      <section>
       <title>
        <p>14.2.2.3. Предостережения по поводу блокировок</p>
       </title>
       <p>Имеется несколько предостережений, о которых нужно знать при блокировках файлов:</p>
       <p>• Как описано ранее, вспомогательная блокировка является именно этим. Не взаимодействующий процесс может делать все, что хочет, за спиной (так сказать) процесса, осуществляющего блокировку.</p>
       <p>• Эти вызовы <emphasis>не</emphasis> следует использовать в сочетании с библиотекой <code>&lt;stdio.h&gt;</code>. Эта библиотека осуществляет свое собственное буферирование. Хотя вы можете получить с помощью <code>fileno()</code> дескриптор нижележащего файла, действительное положение в файле может быть не там, где вы думаете. В общем, стандартная библиотека ввода/вывода не понимает блокировок файлов.</p>
       <p>• Держите в уме, что блокировки после <code>fork</code> <emphasis>не</emphasis> наследуются порожденными процессами, но они <emphasis>остаются</emphasis> на своем месте после <code>exec</code>.</p>
       <p>• Вызов <code>close()</code> с <emphasis>любым</emphasis> открытым для файла дескриптором удаляет <emphasis>все</emphasis> блокировки файла процессом, даже если другие дескрипторы для файла остаются открытыми.</p>
       <p>То, что <code>close()</code> работает таким образом, является неудачным, но поскольку так была реализована первоначальная блокировка в <code>fcntl()</code>, POSIX ее стандартизует. Стандартизация такого поведения позволяет избежать порчи существующего кода для Unix.</p>
      </section>
     </section>
     <section>
      <title>
       <p>14.2.3. Блокирование BSD: <code>flock()</code></p>
      </title>
      <p>4.2 BSD представило свой собственный механизм блокировки, <code>flock()</code><a l:href="#n155" type="note">[155]</a>. Функция объявлена следующим образом:</p>
      <p><code>#include &lt;sys/file.h&gt; /* Обычный */</code></p>
      <empty-line/>
      <p><code>int flock(int fd, int operation);</code></p>
      <p>Дескриптор <code>fd</code> представляет открытый файл. Имеются следующие операции:</p>
      <p><code>LOCK_SH  </code>Создает совместную блокировку. Может быть несколько совместных блокировок.</p>
      <p><code>LOCK_EX  </code>Создает исключительную блокировку. Может быть лишь одна такая блокировка.</p>
      <p><code>LOCK_UN  </code>Удаляет предыдущую блокировку.</p>
      <p><code>LOCK_NB  </code>При использовании побитового ИЛИ с <code>LOCK_SH</code> или <code>LOCK_EX</code> позволяет избежать блокирования функции, если блокировка файла невозможна.</p>
      <p>По умолчанию запросы блокировки файла будут блокировать функцию (не давать ей вернуться), если существует конкурирующая блокировка. Запрашивающая функция возвращается, когда конкурирующая блокировка файла снимается и осуществляется запрошенная функцией блокировка файла. (Это предполагает, что по умолчанию имеется возможность возникновения тупика.) Чтобы попытаться заблокировать файл без блокирования функции, добавьте посредством побитового ИЛИ значение <code>LOCK_NB</code> к имеющемуся значению <code>operation</code>.</p>
      <p>Отличительными моментами <code>flock()</code> являются следующие:</p>
      <p>• Блокировка с помощью <code>flock()</code> является вспомогательной; программа, не использующая блокировку, может прийти и испортить без всяких сообщений об ошибках файл, заблокированный с помощью <code>flock()</code>.</p>
      <p>• Блокируется весь файл. Нет механизма для блокировки только части файла.</p>
      <p>• То, как был открыт файл, не влияет на тип блокировки, который может быть использован. (Сравните это с <code>fcntl()</code>, при использовании которой файл должен быть открыт для чтения для получения блокировки чтения, или для записи для блокировки записи.)</p>
      <p>• Несколько открытых для одного и того же файла дескрипторов используют совместную блокировку. Для удаления блокировки может использоваться любой из них. В отличие от <code>fcntl()</code>, когда нет явного разблокирования, блокировка не удаляется до тех пор, пока не будут закрыты <emphasis>все</emphasis> открытые дескрипторы файла.</p>
      <p>• Процесс может иметь лишь одну блокировку файла с помощью <code>flock()</code>; последовательный вызов <code>flock()</code> с двумя различными типами блокировок изменяет тип блокировки на новый.</p>
      <p>• На системах GNU/Linux блокировки <code>flock()</code> совершенно независимы от блокировок <code>fcntl()</code>. Многие коммерческие системы Unix реализуют <code>flock()</code> в виде «оболочки» поверх <code>fcntl()</code>, но их семантика различается.</p>
      <p>Мы не рекомендуем использовать <code>flock()</code> в новых программах, поскольку ее семантика не такая гибкая и поскольку она не стандартизована POSIX. Поддержка ее в GNU/Linux осуществляется главным образом для обратной совместимости с программным обеспечением, написанным для старых систем BSD Unix.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Справочная страница GNU/Linux <emphasis>flock</emphasis>(2) предупреждает, что блокировки <code>flock()</code> не работают для смонтированных удаленных файлов. Блокировки <code>fcntl()</code> работают, при условии, что у вас достаточно новая версия Linux и сервер NFS поддерживает блокировки файлов</p>
      </cite>
     </section>
     <section>
      <title>
       <p>14.2.4. Обязательная блокировка</p>
      </title>
      <p>Большинство коммерческих систем Unix поддерживают в дополнение к вспомогательной обязательную блокировку файлов. Обязательная блокировка работает лишь с <code>fcntl()</code>. Обязательная блокировка файла контролируется установками прав доступа файла, в частности, путем добавления к файлу бита setgid с помощью команды <code>chmod</code>.</p>
      <p><code>$ <strong>echo hello, world &gt; myfile</strong> /* Создать файл */</code></p>
      <p><code>$ <strong>ls -l myfile</strong> /* Отобразить права доступа */</code></p>
      <p><code>-rw-r--r-- 1 arnold devel 13 Apr 3 17:11 myfile</code></p>
      <p><code>$ <strong>chmod g+s myfile</strong> /* Добавить бит setgid */</code></p>
      <p><code>$ <strong>ls -l myfile</strong> /* Показать новые права доступа */</code></p>
      <p><code>-rw-r-Sr-- 1 arnold devel 13 Apr 3 17:11 myfile</code></p>
      <p>Бит права на исполнение группой должен быть оставлен сброшенным. <code>S</code> показывает, что бит setgid установлен, но что бит права на исполнение — нет; если бы были установлены оба бита, была бы использована строчная буква <code>s</code>.</p>
      <p>Комбинация установленного бита setgid и сброшенного бита права на исполнение группой обычно бессмысленно. По этой причине, она была выбрана разработчиками System V для обозначения «использования обязательного блокирования». И в самом деле, добавления этого бита достаточно, чтобы заставить коммерческую систему Unix, такую как Solaris, использовать блокировку файлов.</p>
      <p>На системах GNU/Linux несколько другая история. Для обязательных блокировок файл должен иметь установленный бит setgid, но этого одного недостаточно. Файловая система, содержащая файл, также должна быть смонтирована с опцией <code>mand</code> в команде <code>mount</code>.</p>
      <p>Мы уже рассмотрели файловые системы, разделы диска, монтирование и команду mount, главным образом, в разделе 8.1 «Монтирование и демонтирование файловых систем». Мы можем продемонстрировать обязательную блокировку с помощью небольшой программы и файловой системой для тестирования на гибком диске. Для начала, вот программа:</p>
      <p><code>1  /* ch14-lockall.c --- Демонстрация обязательной блокировки. */</code></p>
      <p><code>2</code></p>
      <p><code>3  #include &lt;stdio.h&gt; /* для fprintf(), stderr, BUFSIZ */</code></p>
      <p><code>4  #include &lt;errno.h&gt; /* объявление errno */</code></p>
      <p><code>5  #include &lt;fcntl.h&gt; /* для флагов open() */</code></p>
      <p><code>6  #include &lt;string.h&gt; /* объявление strerror() */</code></p>
      <p><code>7  #include &lt;unistd.h&gt; /* для ssize_t */</code></p>
      <p><code>8  #include &lt;sys/types.h&gt;</code></p>
      <p><code>9  #include &lt;sys/stat.h&gt; /* для mode_t */</code></p>
      <p><code>10</code></p>
      <p><code>11 int</code></p>
      <p><code>12 main(int argc, char **argv)</code></p>
      <p><code>13 {</code></p>
      <p><code>14  int fd;</code></p>
      <p><code>15  int i, j;</code></p>
      <p><code>16  mode_t rw_mode;</code></p>
      <p><code>17  static char message[] = "hello, world\n";</code></p>
      <p><code>18  struct flock lock;</code></p>
      <p><code>19</code></p>
      <p><code>20  if (argc != 2) {</code></p>
      <p><code>21   fprintf(stderr, "usage: %s file\n", argv[0]);</code></p>
      <p><code>22   exit(1);</code></p>
      <p><code>23  }</code></p>
      <p><code>24</code></p>
      <p><code>25  rw_mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH; / * 0644 */</code></p>
      <p><code>26  fd = open(argv[1], O_RDWR|O_TRUNC|O_CREAT|O_EXCL, rw_mode);</code></p>
      <p><code>27  if (fd &lt; 0) {</code></p>
      <p><code>28   fprintf(stderr, "%s: %s: cannot open for read/write: %s\n",</code></p>
      <p><code>29    argv[0], argv[1], strerror(errno));</code></p>
      <p><code>30   (void)close(fd);</code></p>
      <p><code>31   return 1;</code></p>
      <p><code>32  }</code></p>
      <p><code>33</code></p>
      <p><code>34  if (write(fd, message, strlen(message)) != strlen(message)) {</code></p>
      <p><code>35   fprintf(stderr, "%s: %s: cannot write: %s\n",</code></p>
      <p><code>36    argv[0], argv[1], strerror(errno));</code></p>
      <p><code>37   (void)close(fd);</code></p>
      <p><code>38   return 1;</code></p>
      <p><code>39  }</code></p>
      <p><code>40</code></p>
      <p><code>41  rw_mode |= S_ISGID; /* добавить бит обязательной блокировки */</code></p>
      <p><code>42</code></p>
      <p><code>43  if (fchmod(fd, rw_mode) &lt; 0) {</code></p>
      <p><code>44   fprintf(stderr, "%s: %s: cannot change mode to %o: %s\n",</code></p>
      <p><code>45    argv[0], argv[1], rw_mode, strerror(errno));</code></p>
      <p><code>46   (void)close(fd);</code></p>
      <p><code>47   return 1;</code></p>
      <p><code>48  }</code></p>
      <p><code>49</code></p>
      <p><code>50  /* заблокировать файл */</code></p>
      <p><code>51  memset(&amp;lock, '\0', sizeof(lock));</code></p>
      <p><code>52  lock.l_whence = SEEK_SET;</code></p>
      <p><code>53  lock.l_start = 0;</code></p>
      <p><code>54  lock.l_len =0; /* блокировка всего файла */</code></p>
      <p><code>55  lock.l_type = F_WRLCK; /* блокировка записи */</code></p>
      <p><code>56</code></p>
      <p><code>57  if (fcntl(fd, F_SETLK, &amp;lock) &lt; 0) {</code></p>
      <p><code>58   fprintf(stderr, "%s: %s: cannot lock the file: %s\n",</code></p>
      <p><code>59    argv[0], argv[1], strerror(errno));</code></p>
      <p><code>60   (void)close(fd);</code></p>
      <p><code>61   return 1;</code></p>
      <p><code>62  }</code></p>
      <p><code>63</code></p>
      <p><code>64  pause();</code></p>
      <p><code>65</code></p>
      <p><code>66  (void)close(fd);</code></p>
      <p><code>67</code></p>
      <p><code>68  return 0;</code></p>
      <p><code>69 }</code></p>
      <p>Программа устанавливает права доступа и создает файл, указанный в командной строке (строки 25 и 26). Затем она записывает в файл некоторые данные (строка 34). Строка 41 добавляет к правам доступа бит setgid, а строка 43 изменяет их. (Системный вызов <code>fchmod()</code> обсуждался в разделе 5.5.2 «Изменение прав доступа: <code>chmod()</code> и <code>fchmod()</code>».)</p>
      <p>Строки 51–55 устанавливают <code>struct flock</code> для блокировки всего файла, а затем блокировка осуществляется реально в строке 57. Выполнив блокировку, программа засыпает, используя системный вызов <code>pause()</code> (см. раздел 10.7 «Сигналы для межпроцессного взаимодействия»). После этого программа закрывает дескриптор файла и завершается. Вот расшифровка с комментариями, демонстрирующая использование обязательной блокировки файлов:</p>
      <p><code>$ <strong>fdformat /dev/fd0</strong> /* Форматировать гибкий диск */</code></p>
      <p><code>Double -sided, 80 tracks, 18 sec/track. Total capacity 1440 kB.</code></p>
      <p><code>Formatting ... done</code></p>
      <p><code>Verifying ... done</code></p>
      <p><code>$ <strong>/sbin/mke2fs /dev/fd0</strong> /* Создать файловую систему Linux */</code></p>
      <p><code>/* ...множество вывода опущено... */</code></p>
      <p><code>$ <strong>su</strong> /* Стать root, чтобы использовать mount */</code></p>
      <p><code>Password: /* Пароль не отображается */</code></p>
      <p><code># <strong>mount -t ext2 -о mand /dev/fd0 /mnt/floppy</strong> /* Смонтировать гибкий</code></p>
      <p><code>диск, с возможностью блокировок */</code></p>
      <p><code># <strong>suspend</strong> /* Приостановить оболочку root */</code></p>
      <p><code>[1]+ Stopped su</code></p>
      <p><code>$ <strong>ch14-lockall /mnt/floppy/x &amp;</strong> /* Фоновая программа */</code></p>
      <p><code>[2] 23311 /* содержит блокировку */</code></p>
      <p><code>$ <strong>ls -l /mnt/floppy/x</strong> /* Посмотреть файл */</code></p>
      <p><code>-rw-r-Sr-- 1 arnold devel 13 Apr 6 14:23 /mnt/floppy/x</code></p>
      <p><code>$ <strong>echo something &gt; /mnt/floppy/x</strong> /* Попытаться изменить файл */</code></p>
      <p><code>bash2: /mnt/floppy/x: Resource temporarily unavailable</code></p>
      <p><code> /* Возвращается ошибка */</code></p>
      <p><code>$ <strong>kill %2</strong> /* Завершить программу с блокировкой */</code></p>
      <p><code>$ /* Нажать ENTER */</code></p>
      <p><code>[2]- Terminated ch14-lockall /mnt/floppy/x /* Программа завершена */</code></p>
      <p><code>$ <strong>echo something &gt; /mnt/floppy/x</strong> /* Новая попытка изменения работает */</code></p>
      <p><code>$ <strong>fg</strong> /* Вернуться в оболочку root */</code></p>
      <p><code>su</code></p>
      <p><code># <strong>umount /mnt/floppy</strong> /* Демонтировать гибкий диск */</code></p>
      <p><code># <strong>exit</strong> /* Работа с оболочкой root закончена */</code></p>
      <p><code>$</code></p>
      <p>Пока выполняется <code>ch14-lockall</code>, она владеет блокировкой. Поскольку это обязательная блокировка, перенаправления ввода/вывода оболочки завершаются неудачей. После завершения <code>ch14-lockall</code> блокировки освобождаются, и перенаправление ввода/вывода достигает цели. Как упоминалось ранее, под GNU/Linux даже <code>root</code> не может аннулировать обязательную блокировку файла.</p>
      <p>Немного отклоняясь в сторону, гибкие диски представляют отличный испытательный стенд для изучения того, как использовать инструменты, работающие с файловыми системами. Если вы сделаете что-то, что разрушит данные на гибком диске, это вряд ли будет катастрофическим, тогда как экспериментирование с действующими разделами на обычных жестких дисках значительно более рискованно.</p>
     </section>
    </section>
    <section>
     <title>
      <p>14.3. Более точное время</p>
     </title>
     <section>
      <p>Системный вызов <code>time()</code> и тип <code>time_t</code> представляют время в секундах в формате отсчета с начала Эпохи. <emphasis>Разрешения</emphasis> в одну секунду на самом деле недостаточно, сегодняшние машины быстры, и часто бывает полезно различать временные интервалы в долях секунды. Начиная с 4.2 BSD, Berkley Unix представил ряд системных вызовов, которые сделали возможным получение и использование времени в долях секунд. Эти вызовы доступны на всех современных системах Unix, включая GNU/Linux.</p>
     </section>
     <section>
      <title>
       <p>14.3.1. Время в микросекундах: <code>gettimeofday()</code></p>
      </title>
      <p>Первой задачей является получение времени дня:</p>
      <p><code>#include &lt;sys/time.h&gt;</code></p>
      <empty-line/>
      <p><code>int gettimeofday(struct timeval *tv, void *tz); /* определение POSIX, а не GLIBC */</code></p>
      <p><code>gettimeofday()</code> позволяет получить время дня.<a l:href="#n156" type="note">[156]</a> В случае успеха возвращается 0, при ошибке -1. Аргументы следующие:</p>
      <p><code>struct timeval *tv</code></p>
      <p>Этот аргумент является указателем на <code>struct timeval</code>, которая вскоре будет описана и в которую система помещает текущее время.</p>
      <p><code>void *tz</code></p>
      <p>Это аргумент больше не используется; он имеет тип <code>void*</code>, поэтому он всегда должен равняться <code>NULL</code>. (Справочная страница описывает, для чего он использовался, а затем утверждает, что он устарел. Прочтите, если интересуетесь подробностями.)</p>
      <p>Время представлено структурой <code>struct timeval</code>:</p>
      <p><code>struct timeval {</code></p>
      <p><code> long tv_sec; /* секунды */</code></p>
      <p><code> long tv_usec; /* микросекунды */</code></p>
      <p><code>};</code></p>
      <p>Значение <code>tv_sec</code> представляет секунды с начала Эпохи; <code>tv_usec</code> является числом микросекунд в секунде.</p>
      <p>Справочная страница GNU/Linux <emphasis>gettimeofday</emphasis>(2) документирует также следующие макросы:</p>
      <p><code>#define timerisset(tvp) ((tvp)-&gt;tv_sec || (tvp)-&gt;tv_usec)</code></p>
      <p><code>#define timercmp(tvp, uvp, cmp) \</code></p>
      <p><code> ((tvp)-&gt;tv_sec cmp (uvp)-&gt;tv_sec || \</code></p>
      <p><code> (tvp)-&gt;tv_sec == (uvp)-&gt;tv_sec &amp;&amp; \</code></p>
      <p><code> (tvp)-&gt;tv_usec cmp (uvp)-&gt;tv_usec)</code></p>
      <p><code>#define timerclear(tvp) ((tvp)-&gt;tv_sec = (tvp)-&gt;tv_usec = 0)</code></p>
      <p>Эти макросы работают со значениями <code>struct timeval*</code>; то есть указателями на структуры, и их использование должно быть очевидным из их названий и кода. Особенно интересен макрос <code>timercmp()</code>: третьим аргументом является оператор сравнения для указания вида сравнения. Например, рассмотрим определение того, является ли одна <code>struct timeval</code> меньше другой:</p>
      <p><code>struct timeval t1, t2;</code></p>
      <p><code>...</code></p>
      <p><code>if (timercmp(&amp;t1, &amp; t2, &lt;))</code></p>
      <p><code> /* t1 меньше, чем t2 */</code></p>
      <p>Макрос развертывается в</p>
      <p><code>((&amp;t1)-&gt;tv_sec &lt; (&amp;t2)-&gt;tv_sec || \</code></p>
      <p><code>(&amp;t1)-&gt;tv_sec == (&amp;t2)-&gt;tv_sec &amp;&amp; \</code></p>
      <p><code>(&amp;t1)-&gt;tv_usec &lt; (&amp;t2)-&gt;tv_usec)</code></p>
      <p>Это значит: «если <code>t1.tv_sec</code> меньше, чем <code>t2.tv_sec</code>, ИЛИ если они равны и <code>t1.tv_usec</code> меньше, чем <code>t2.tv_usec</code>, тогда…».</p>
     </section>
     <section>
      <title>
       <p>14.3.2. Файловое время в микросекундах: <code>utimes()</code></p>
      </title>
      <p>В разделе 5.5.3 «Изменение временных отметок: <code>utime()</code>» был описан системный вызов <code>utime()</code> для установки времени последнего обращения и изменения данного файла. Некоторые файловые системы хранят эти временные отметки с разрешением в микросекунды (или еще точнее). Такие системы предусматривают системный вызов <code>utimes()</code> (обратите внимание на завершающую s в названии) для установки времени обращения к файлу и его изменения с точностью до микросекунд:</p>
      <p><code>#include &lt;sys/time.h&gt; /* XSI */</code></p>
      <empty-line/>
      <p><code>int utimes(char *filename, struct timeval tvp[2]);</code></p>
      <p>Аргумент <code>tvp</code> должен указывать на массив из двух структур <code>struct timeval</code>, значения используются для времени доступа и изменения соответственно. Если <code>tvp</code> равен <code>NULL</code>, система использует текущее время дня.</p>
      <p>POSIX обозначает ее как «традиционную» функцию, что означает, что она стандартизуется лишь для поддержки старого кода и не должна использоваться для новых приложений. Главная причина, пожалуй, в том, что нет определенного интерфейса для получения времени доступа и изменения файла в микросекундах; <code>struct stat</code> содержит лишь значения <code>time_t</code>, а не значения <code>struct timeval</code>.</p>
      <p>Однако, как упоминалось в разделе 5.4.3 «Только Linux: указание файлового времени повышенной точности», Linux 2.6 (и более поздние версии) действительно предоставляет доступ к временным отметкам с разрешением в наносекунды при помощи функции <code>stat()</code>. Некоторые другие системы (такие, как Solaris) также это делают.<a l:href="#n157" type="note">[157]</a> Таким образом, <code>utimes()</code> полезнее, чем кажется на первый взгляд, и несмотря на ее «традиционный» статус, нет причин не использовать ее в своих программах.</p>
     </section>
     <section>
      <title>
       <p>14.3.3. Интервальные таймеры: <code>setitimer()</code> и <code>getitimer()</code></p>
      </title>
      <p>Функция <code>alarm()</code> (см. раздел 10.8.1 «Сигнальные часы: <code>sleep()</code>, <code>alarm()</code> и <code>SIGALRM</code>») организует отправку сигнала <code>SIGALRM</code> после истечения данного числа секунд. Ее предельным разрешением является одна секунда. Здесь также BSD 4.2 ввело функцию и три различных таймера, которые используют время в долях секунды.</p>
      <p><emphasis>Интервальный таймер</emphasis> подобен многократно использующимся сигнальным часам. Вы устанавливаете начальное время, когда он должен «сработать», а также как часто это должно впоследствии повторяться. Оба этих значения используют объекты <code>struct timeval</code>; т.е. они (потенциально) имеют разрешение в микросекундах. Таймер «срабатывает», доставляя сигнал; таким образом, нужно установить для таймера обработчик сигнала, желательно до установки самого таймера.</p>
      <p>Существуют три различных таймера, описанных в табл. 14.2.</p>
      <empty-line/>
      <p>Таблица 14.2. Интервальные таймеры</p>
      <table>
       <tr align="left">
        <th align="left" valign="top">Таймер</th>
        <th align="left" valign="top">Сигнал</th>
        <th align="left" valign="top">Функция</th>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ITIMER_REAL</code></td>
        <td align="left" valign="top"><code>SIGALRM</code></td>
        <td align="left" valign="top">Работает в реальном режиме</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ITIMER_VIRTUAL</code></td>
        <td align="left" valign="top"><code>SIGVTALRM</code></td>
        <td align="left" valign="top">Работает, когда процесс выполняется в режиме пользователя</td>
       </tr>
       <tr align="left">
        <td align="left" valign="top"><code>ITIMER_PROF</code></td>
        <td align="left" valign="top"><code>SIGPROF</code></td>
        <td align="left" valign="top">Работает, когда процесс выполняется в режиме пользователя или ядра.</td>
       </tr>
      </table>
      <p>Использование первого таймера, <code>ITIMER_REAL</code>, просто. Таймер работает в реальном времени, посылая <code>SIGALRM</code> по истечении заданного количества времени. (Поскольку посылается <code>SIGALRM</code>, нельзя смешивать вызовы <code>setitimer()</code> с вызовами <code>alarm()</code>, а смешивание их с вызовом <code>sleep()</code> также опасно; см. раздел 10.8.1 «Сигнальные часы, <code>sleep()</code>, <code>alarm()</code> и <code>SIGALRM</code>».)</p>
      <p>Второй таймер, <code>ITIMER_VIRTUAL</code>, также довольно прост. Он действует, когда процесс исполняется, но лишь при выполнении кода пользователя (приложения) Если процесс заблокирован во время ввода/вывода, например, на диск, или, еще важнее, на терминал, таймер приостанавливается.</p>
      <p>Третий таймер, <code>ITIMER_PROF</code>, более специализированный. Он действует все время, пока выполняется процесс, даже если операционная система делает что-нибудь для процесса (вроде ввода/вывода). В соответствии со стандартом POSIX, он «предназначен для использования интерпретаторами при статистическом профилировании выполнения интерпретируемых программ». Установив как для <code>ITIMER_VIRTUAL</code>, так и для <code>ITIMER_PROF</code> идентичные интервалы и сравнивая разницу времени срабатывания двух таймеров, интерпретатор может узнать, сколько времени проводится в системных вызовах для выполняющейся интерпретируемой программы<a l:href="#n158" type="note">[158]</a>. (Как сказано, это довольно специализировано.) Двумя системными вызовами являются:</p>
      <p><code>#include &lt;sys/time.h&gt; /* XSI */</code></p>
      <empty-line/>
      <p><code>int getitimer(int which, struct itimerval *value);</code></p>
      <p><code>int setitimer(int which, const struct itimerval *value,</code></p>
      <p><code> struct itimerval *ovalue);</code></p>
      <p>Аргумент <code>which</code> является одной из перечисленных ранее именованных констант, указывающих таймер, <code>getitimer()</code> заполняет <code>struct itimerval</code>, на которую указывает <code>value</code>, текущими установками данного таймера, <code>setitimer()</code> устанавливает для данного таймера значение в <code>value</code>. Если имеется <code>ovalue</code>, функция заполняет ее текущим значением таймера. Используйте для <code>ovalue NULL</code>, если не хотите беспокоиться о текущем значении. Обе функции возвращают в случае успеха 0 и -1 при ошибке, <code>struct itimerval</code> состоит из двух членов <code>struct timeval</code>:</p>
      <p><code>struct itimerval {</code></p>
      <p><code> struct timeval it_interval; /* следующее значение */</code></p>
      <p><code> struct timeval it_value;    /* текущее значение */</code></p>
      <p><code>};</code></p>
      <p>Прикладным программам не следует ожидать, что таймеры будут с точностью до микросекунд. Справочная страница <emphasis>getitimer</emphasis>(2) дает следующее объяснение:</p>
      <cite>
       <p>Таймеры никогда не срабатывают раньше заданного времени, вместо этого срабатывая спустя небольшой постоянный интервал времени, зависящий от разрешения системного таймера (в настоящее время 10 мс). После срабатывания будет сгенерирован сигнал, а таймер будет сброшен. Если таймер срабатывает, когда процесс выполняется (для таймера <code>ITIMER_VIRT</code> это всегда верно), сигнал будет доставлен немедленно после создания. В противном случае, доставка будет сдвинута на небольшой промежуток времени, зависящий от загрузки системы.</p>
      </cite>
      <p>Из этих трех таймеров <code>ITIMER_REAL</code> кажется наиболее полезным. Следующая программа, <code>ch14-timers.c</code>, показывает, как читать данные с терминала, но с тайм-аутом, чтобы программа не зависала на бесконечное время, ожидая ввода:</p>
      <p><code>1  /* ch14-timers.c --- демонстрация интервальных таймеров */</code></p>
      <p><code>2</code></p>
      <p><code>3  #include &lt;stdio.h&gt;</code></p>
      <p><code>4  #include &lt;assert.h&gt;</code></p>
      <p><code>5  #include &lt;signal.h&gt;</code></p>
      <p><code>6  #include &lt;sys/time.h&gt;</code></p>
      <p><code>7</code></p>
      <p><code>8  /* handler --- обрабатывает SIGALRM */</code></p>
      <p><code>9</code></p>
      <p><code>10 void handler(int signo)</code></p>
      <p><code>11 {</code></p>
      <p><code>12  static const char msg[] = "\n*** Timer expired, you lose ***\n";</code></p>
      <p><code>13</code></p>
      <p><code>14  assert(signo == SIGALRM);</code></p>
      <p><code>15</code></p>
      <p><code>16  write(2, msg, sizeof(msg) - 1);</code></p>
      <p><code>17  exit(1);</code></p>
      <p><code>18 }</code></p>
      <p><code>19</code></p>
      <p><code>20 /* main --- установить таймер, прочесть данные с тайм-аутом */</code></p>
      <p><code>21</code></p>
      <p><code>22 int main(void)</code></p>
      <p><code>23 {</code></p>
      <p><code>24  struct itimerval tval;</code></p>
      <p><code>25  char string[BUFSIZ];</code></p>
      <p><code>26</code></p>
      <p><code>27  timerclear(&amp;tval.it_interval); /* нулевой интервал означает не сбрасывать таймер */</code></p>
      <p><code>28  timerclear(&amp;tval.it_value);</code></p>
      <p><code>29</code></p>
      <p><code>30  tval.it_value.tv_sec = 10; /* тайм-аут 10 секунд */</code></p>
      <p><code>31</code></p>
      <p><code>32  (void)signal(SIGALRM, handler);</code></p>
      <p><code>33</code></p>
      <p><code>34</code></p>
      <p><code>35  printf("You have ten seconds to enter\nyour name, rank, and serial number: ");</code></p>
      <p><code>36  (void)setitimer(ITIMER_REAL, &amp;tval, NULL);</code></p>
      <p><code>37  if (fgets(string, sizeof string, stdin) != NULL) {</code></p>
      <p><code>38   (void)setitimer(ITIMER_REAL, NULL, NULL); /* выключить таймер */</code></p>
      <p><code>39   /* обработать оставшиеся данные, вывод диагностики для иллюстрации */</code></p>
      <p><code>40   printf("I'm glad you are being cooperative.\n");</code></p>
      <p><code>41  } else</code></p>
      <p><code>42   printf("\nEOF, eh? We won't give up so easily'\n");</code></p>
      <p><code>43</code></p>
      <p><code>44  exit(0);</code></p>
      <p><code>45 }</code></p>
      <p>Строки 10–18 представляют обработчик сигнала для <code>SIGALRM</code>; вызов <code>assert()</code> гарантирует, что обработчик сигнала был установлен соответствующим образом. Тело обработчика выводит сообщение и выходит, но оно может делать что-нибудь более подходящее для крупномасштабной программы.</p>
      <p>В функции <code>main()</code> строки 27–28 очищают два члена <code>struct timeval</code> структуры <code>struct itimerval.tval</code>. Затем строка 30 устанавливает тайм-аут в 10 секунд. Установка <code>tval.it_interval</code> в 0 означает, что нет повторяющегося сигнала; он срабатывает лишь однажды. Строка 32 устанавливает обработчик сигнала, а строка 34 выводит приглашение.</p>
      <p>Строка 36 устанавливает таймер, а строки 37–42 выводят соответствующие сообщения, основываясь на действиях пользователя. Реальная программа выполняла бы в этот момент свою задачу. Важно здесь обратить внимание на строку 38, которая отменяет таймер, поскольку были введены действительные данные.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Между строками 37 и 38 имеется намеренное состояние гонки. Все дело в том, что если пользователь не вводит строку в течение отведенного таймером времени, будет доставлен сигнал, и обработчик сигнала выведет сообщение «you lose».</p>
      </cite>
      <p>Вот три успешных запуска программы:</p>
      <p><code>$ <strong>ch14-timers</strong> /* Первый запуск, ничего не вводится */</code></p>
      <p><code>You have ten seconds to enter</code></p>
      <p><code>your name, rank, and serial number:</code></p>
      <p><code>*** Timer expired, you lose ***</code></p>
      <empty-line/>
      <p><code>$ <strong>ch14-timers</strong> /* Второй запуск, ввод данных */</code></p>
      <p><code>You have ten seconds to enter</code></p>
      <p><code>your name, rank, and serial number: <strong>Jamas Kirk, Starfleet Captain, 1234</strong></code></p>
      <p><code>I'm glad you are being cooperative.</code></p>
      <empty-line/>
      <p><code>$ <strong>ch14-timers</strong> /* Третий запуск, ввод EOF (^D) */</code></p>
      <p><code>You have ten seconds to enter</code></p>
      <p><code>your name, rank, and serial number: <strong>^D</strong></code></p>
      <p><code>EOF, eh? We won't give up so easily!</code></p>
      <p>POSIX оставляет неопределенным, как интервальные таймеры взаимодействуют с функцией <code>sleep()</code>, если вообще взаимодействуют. GLIBC не использует для реализации <code>sleep()</code> функцию <code>alarm()</code>, поэтому на системах GNU/Linux <code>sleep()</code> не взаимодействует с интервальным таймером. Однако, для переносимых программ, вы не можете делать такое предположение.</p>
     </section>
     <section>
      <title>
       <p>14.3.4. Более точные паузы: <code>nanosleep()</code></p>
      </title>
      <p>Функция <code>sleep()</code> (см. раздел 10.8.1 «Сигнальные часы: <code>sleep()</code>, <code>alarm()</code> и <code>SIGALRM</code>») дает программе возможность приостановиться на указанное число секунд. Но, как мы видели, она принимает лишь целое число секунд, что делает невозможным задержки на короткие периоды, она потенциально может также взаимодействовать с обработчиками <code>SIGALRM</code>. Функция <code>nanosleep()</code> компенсирует эти недостатки:</p>
      <p><code>#include &lt;time.h&gt; /* POSIX ТМР */</code></p>
      <empty-line/>
      <p><code>int nanosleep(const struct timespec *req, struct timespec *rem);</code></p>
      <p>Эта функция является частью необязательного расширения POSIX «Таймеры» (TMR). Два аргумента являются запрошенным временем задержки и оставшимся числом времени в случае раннего возвращения (если <code>rem</code> не равен <code>NULL</code>). Оба являются значениями <code>struct timespec</code>:</p>
      <p><code>struct timespec {</code></p>
      <p><code> time_t tv_sec; /* секунды */</code></p>
      <p><code> long tv_nsec;  /* наносекунды */</code></p>
      <p><code>};</code></p>
      <p>Значение <code>tv_nsec</code> должно быть в диапазоне от 0 до 999 999 999. Как и в случае со <code>sleep()</code>, время задержки может быть больше запрошенного в зависимости оттого, когда и как ядро распределяет время для исполнения процессов.</p>
      <p>В отличие от <code>sleep()</code>, <code>nanosleep()</code> не взаимодействует ни с какими сигналами, делая ее более безопасной и более простой для использования.</p>
      <p>Возвращаемое значение равно 0, если выполнение процесса было задержано в течение всего указанного времени. В противном случае оно равно -1, с <code>errno</code>, указывающим ошибку. В частности, если <code>errno</code> равен <code>EINTR</code>, <code>nanosleep()</code> была прервана сигналом. В этом случае, если <code>rem</code> не равен <code>NULL</code>, <code>struct timespec</code>, на которую она указывает, содержит оставшееся время задержки. Это облегчает повторный вызов <code>nanosleep()</code> для продолжения задержки.</p>
      <p>Хотя это выглядит немного странным, вполне допустимо использовать одну и ту же структуру для обоих параметров:</p>
      <p><code>struct timespec sleeptime = /* что угодно */;</code></p>
      <p><code>int ret;</code></p>
      <p><code>ret = nanosleep(&amp;sleeptime, &amp;sleeptime);</code></p>
      <p><code>struct timeval</code> и <code>struct timespec</code> сходны друг с другом, отличаясь лишь компонентом долей секунд. Заголовочный файл GLIBC <code>&lt;sys/time.h&gt;</code> определяет для их взаимного преобразования друг в друга два полезных макроса:</p>
      <p><code>#include &lt;sys/time.h&gt; /* GLIBC */</code></p>
      <empty-line/>
      <p><code>void TIMEVAL_TO_TIMESPEC(struct timeval *tv, struct timespec *ts);</code></p>
      <p><code>void TIMEPSEC_TO_TIMEVAL(struct timespec *ts, struct timeval *tv);</code></p>
      <p>Вот они:</p>
      <p><code># define TIMEVAL_TO_TIMESPEC(tv, ts) { \</code></p>
      <p><code> (ts)-&gt;tv_sec = (tv)-&gt;tv_sec; \</code></p>
      <p><code> (ts)-&gt;tv_nsec = (tv)-&gt;tv_usec * 1000; \</code></p>
      <p><code>}</code></p>
      <p><code># define TIMESPEC_TO_TIMEVAL(tv, ts) { \</code></p>
      <p><code> (tv)-&gt;tv_sec = (ts)-&gt;tv_sec; \</code></p>
      <p><code> (tv)-&gt;tv_usec = (ts)-&gt;tv_nsec / 1000; \</code></p>
      <p><code>}</code></p>
      <p><code>#endif</code></p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. To, что некоторые системные вызовы используют микросекунды, а другие — наносекунды, в самом деле сбивает с толку. Причина этого историческая: микросекундные вызовы были разработаны на системах, аппаратные часы которых не имели более высокого разрешения, тогда как наносекундные вызовы были разработаны более недавно для систем со значительно более точными часами. C'est la vie. Почти все, что вы можете сделать, это держать под руками ваше руководство.</p>
      </cite>
     </section>
    </section>
    <section>
     <title>
      <p>14.4. Расширенный поиск с помощью двоичных деревьев</p>
     </title>
     <section>
      <p>В разделе 6.2 «Функции сортировки и поиска» мы представили функции для поиска и сортировки массивов. В данном разделе мы рассмотрим более продвинутые возможности.</p>
     </section>
     <section>
      <title>
       <p>14.4.1. Введение в двоичные деревья</p>
      </title>
      <p>Массивы являются почти простейшим видом структурированных данных. Их просто понимать и использовать. Хотя у них есть недостаток, заключающийся в том, что их размер фиксируется во время компиляции. Таким образом, если у вас больше данных, чем помещается в массив, вам не повезло. Если у вас значительно меньше данных, чем размер массива, память расходуется зря. (Хотя на современных системах много памяти, подумайте об ограничениях программистов, пишущих программы для внедренных систем, таких, как микроволновые печи и мобильные телефоны. С другого конца спектра, подумайте о проблемах программистов, имеющих дело с огромными объемами ввода, таких, как прогнозирование погоды.</p>
      <p>В области компьютерных наук были придуманы многочисленные <emphasis>динамические структуры данных</emphasis>, структуры, которые увеличивают и уменьшают свой размер по требованию и которые являются более гибкими, чем простые массивы, даже массивы, создаваемые и изменяемые динамически с помощью <code>malloc()</code> и <code>realloc()</code>. Массивы при добавлении или удалении новых элементов требуется также повторно сортировать.</p>
      <p>Одной из таких структур является <emphasis>дерево двоичного поиска</emphasis>, которое мы для краткости будем называть просто «двоичным деревом» («binary tree»). Двоичное дерево хранит элементы в сортированном порядке, вводя их в дерево в нужном месте при их появлении. Поиск по двоичному дереву также осуществляется быстро, время поиска примерно такое же, как при двоичном поиске в массиве. В отличие от массивов, двоичные деревья не нужно каждый раз повторно сортировать с самого начала при добавлении к ним элементов.</p>
      <p>У двоичных деревьев есть один недостаток. В случае, когда вводимые данные <emphasis>уже отсортированы</emphasis>, время поиска в двоичном дереве сводится ко времени линейного поиска. Техническая сторона этого вопроса должна иметь дело с тем, как двоичные деревья управляются внутренне, что вскоре будет описано.</p>
      <p>Теперь не избежать некоторой формальной терминологии, относящейся к структурам данных. На рис. 14.1 показано двоичное дерево. В информатике деревья изображаются, начиная сверху и расширяясь вниз. Чем ниже спускаетесь вы по дереву, тем больше его <emphasis>глубина</emphasis>. Каждый объект внутри дерева обозначается как <emphasis>вершина (node)</emphasis>. На вершине дерева находится <emphasis>корень дерева</emphasis> с глубиной 0. Внизу находятся <emphasis>концевые вершины</emphasis> различной глубины. Концевые вершины отличают по тому, что у них нет ответвляющихся <emphasis>поддеревьев (subtrees)</emphasis>, тогда как у внутренних вершин есть по крайней мере одно поддерево. Вершины с поддеревьями иногда называют <emphasis>родительскими (parent)</emphasis>, они содержат <emphasis>порожденные вершины (children)</emphasis>.</p>
      <image l:href="#img_27.jpeg"/>
      <p><strong>Рис. 14.1</strong>. Двоичное дерево</p>
      <p>Чистые двоичные деревья отличаются тем, что каждая вершина содержит не более двух порожденных вершин. (Деревья с более чем двумя вершинами полезны, но не существенны для нашего обсуждения.) Порожденные вершины называются в этом случае левой и правой соответственно.</p>
      <p>Деревья двоичного поиска отличаются еще и тем, что значения, хранящиеся в левой порожденной вершине, всегда меньше значения в родительской вершине, а значения, хранящиеся в правой порожденной вершине, всегда больше значения в родительской вершине. Это предполагает, что внутри дерева нет повторяющихся значений. Этот факт также объясняет, почему деревья не эффективны при работе с предварительно отсортированными данными: в зависимости от порядка сортировки, каждый новый элемент данных сохраняется либо только слева, либо только справа от находящегося впереди него элемента, образуя простой линейный список.</p>
      <p>К двоичным деревьям применяют следующие операции:</p>
      <p><emphasis>Ввод</emphasis></p>
      <p>Добавление к дереву нового элемента.</p>
      <p><emphasis>Поиск</emphasis></p>
      <p>Нахождение элемента в дереве.</p>
      <p><emphasis>Удаление</emphasis></p>
      <p>Удаление элемента из дерева.</p>
      <p><emphasis>Прохождение (traversal)</emphasis></p>
      <p>Осуществление какой-либо операции с каждым хранящимся в дереве элементом. Прохождение дерева называют также <emphasis>обходом дерева (tree walk)</emphasis>. Есть разнообразные способы «посещения» хранящихся в дереве элементов. Обсуждаемые здесь функции реализуют лишь один из таких способов. Мы дополнительно расскажем об этом позже.</p>
     </section>
     <section>
      <title>
       <p>14.4.2. Функции управления деревьями</p>
      </title>
      <p>Только что описанные операции соответствуют следующим функциям:</p>
      <p><code>#include &lt;search.h&gt; /* XSI */</code></p>
      <empty-line/>
      <p><code>void *tsearch(const void *key, void **rootp,</code></p>
      <p><code>int (*compare)(const void*, const void*));</code></p>
      <p><code>void *tfind(const void *key, const void **rootp,</code></p>
      <p><code>int (*compare)(const void*, const void*));</code></p>
      <p><code>void *tdelete(const void *key, void **rootp,</code></p>
      <p><code>int (*compare)(const void*, const void*));</code></p>
      <empty-line/>
      <p><code>typedef enum { preorder, postorder, endorder, leaf } VISIT;</code></p>
      <p><code>void twalk(const void *root,</code></p>
      <p><code>void (*action)(const void *nodep, const VISIT which,</code></p>
      <p><code>const int depth));</code></p>
      <empty-line/>
      <p><code>void tdestroy(void *root, void (*free_node)(void *nodep)); /* GLIBC*/</code></p>
      <p>Эти функции были впервые определены для System V, а теперь формально стандартизованы POSIX. Они следуют структуре других, которые мы видели в разделе 6.2 «Функции сортировки и поиска»: использование указателей <code>void*</code> для указания на произвольные типы данных и предоставляемые пользователем функции сравнения для определения порядка. Как и для <code>qsort()</code> и <code>bsearch()</code>, функции сравнения должны возвращать отрицательное/нулевое/положительное значение, когда <code>key</code> сравнивается со значением в вершине дерева.</p>
     </section>
     <section>
      <title>
       <p>14.4.3. Ввод элемента в дерево: <code>tsearch()</code></p>
      </title>
      <p>Эти процедуры выделяют память для вершин дерева. Для их использования с несколькими деревьями нужно предоставить им указатель на переменную <code>void*</code>, в которую они заносят адрес корневой вершины. При создании нового дерева инициализируйте этот указатель в <code>NULL</code>:</p>
      <p><code>void *root = NULL; /* Корень нового дерева */</code></p>
      <p><code>void *val; /* Указатель на возвращенные данные */</code></p>
      <p><code>extern int my_compare(const void*, const void*); /* Функция сравнения */</code></p>
      <p><code>extern char key[], key2[]; /* Значения для ввода в дерево */</code></p>
      <p><code>val = tsearch(key, &amp;root, my_compare);</code></p>
      <p><code> /* Ввести в дерево первый элемент */</code></p>
      <p><code>/* ...заполнить key2 другим значением. НЕ изменять корень... */</code></p>
      <p><code>val = tsearch(key2, &amp;root, my_compare);</code></p>
      <p><code> /* Ввести в дерево последующий элемент */</code></p>
      <p>Как показано, в переменной <code>root</code> должен быть <code>NULL</code> лишь в первый раз, после чего нужно оставить ее как есть. При каждом последующем вызове <code>tsearch()</code> использует ее для управления деревом.</p>
      <p>Когда разыскиваемый <code>key</code> найден, как <code>tsearch()</code>, так и <code>tfind()</code> возвращают указатель на содержащую его вершину. Поведение функций различно, когда <code>key</code> не найден: <code>tfind()</code> возвращает <code>NULL</code>, a <code>tsearch()</code> вводит в дерево новое значение и возвращает указатель на него. Функции <code>tsearch()</code> и <code>tfind()</code> возвращают указатели на внутренние вершины дерева. Они могут использоваться в последующих вызовах в качестве значения root для работы с поддеревьями. Как мы вскоре увидим, значение key может быть указателем на произвольную структуру; он не ограничен символьной строкой, как можно было бы предположить из предыдущего примера.</p>
      <p>Эти процедуры сохраняют лишь указатели на данные, использующиеся в качестве ключей. Соответственно это ваше дело управлять памятью для хранения значений данных, обычно с помощью <code>malloc()</code>.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Поскольку функции деревьев хранят указатели, тщательно позаботьтесь о том, чтобы не использовать <code>realloc()</code> для значений, которые были использованы в качестве ключей! <code>realloc()</code> может переместить данные, вернув новый указатель, но процедуры деревьев все равно сохранят висящие (dangling) указатели на старые данные.</p>
      </cite>
     </section>
     <section>
      <title>
       <p>14.4.4. Поиск по дереву и использование возвращенного указателя: <code>tfind()</code> и <code>tsearch()</code></p>
      </title>
      <p>Функции <code>tfind()</code> и <code>tsearch()</code> осуществляют поиск в двоичном дереве по данному ключу. Они принимают тот же самый набор аргументов: ключ для поиска <code>key</code>. указатель на корень дерева, <code>rootp</code>; и <code>compare</code>, указатель на функцию сравнения. Обе функции возвращают указатель на вершину, которая соответствует <code>key</code>.</p>
      <p>Как именно использовать указатель, возвращенный <code>tfind()</code> и <code>tsearch()</code>? Во всяком случае, на что именно он указывает? Ответ заключается в том, что он указывает на вершину в дереве. Это <emphasis>внутренний</emphasis> тип; вы не можете увидеть, как он определен. Однако, POSIX гарантирует, что этот указатель может быть приведен к <emphasis>указателю на указатель</emphasis> на что бы то ни было, что вы используете в качестве ключа. Вот обрывочный код для демонстрации, а затем мы покажем, как это работает:</p>
      <p><code>struct employee { /* Из главы 6 */</code></p>
      <p><code> char lastname[30];</code></p>
      <p><code> char firstname[30];</code></p>
      <p><code> long emp_id;</code></p>
      <p><code> time_t start_date;</code></p>
      <p><code>};</code></p>
      <empty-line/>
      <p><code>/* emp_name_id_compare --- сравнение по имени, затем no ID */</code></p>
      <p><code>int emp_name_id_compare(const void *e1p, const void *e2p) {</code></p>
      <p><code> /* ...также из главы 6, полностью представлено позже... */</code></p>
      <p><code>}</code></p>
      <empty-line/>
      <p><code>struct employee key = { ... };</code></p>
      <p><code>void *vp, *root;</code></p>
      <p><code>struct employee *e;</code></p>
      <p><code>/* ...заполнение данными... */</code></p>
      <empty-line/>
      <p><code>vp = tfind(&amp;key, root, emp_name_id_compare);</code></p>
      <p><code>if (vp != NULL) { /* it's there, use it */</code></p>
      <p><code> e = *((struct employee**)vp); /* Получить хранящиеся в дереве данные */</code></p>
      <p><code> /* использование данных в *е ... */</code></p>
      <p><code>}</code></p>
      <p>Как можно указатель на вершину использовать как указатель на указатель данных? Рассмотрим, как была бы реализована вершина двоичного дерева. В каждой вершине хранится по крайней мере указатель на элемент данных пользователя и указатели на потенциальные порожденные вершины справа и слева. Поэтому она должна выглядеть примерно так.</p>
      <p><code>struct binary_tree {</code></p>
      <p><code> void *user_data; /* Указатель на данные пользователя */</code></p>
      <p><code> struct binary_tree *left; /* Порожденная вершина слева или NULL */</code></p>
      <p><code> struct binary_tree *right; /* Порожденная вершина справа или NULL */</code></p>
      <p><code>/* ...здесь возможны другие поля... */</code></p>
      <p><code>} node;</code></p>
      <p>С и C++ гарантируют, что поля внутри структуры располагаются в порядке возрастания адресов. Таким образом, выражение '<code>&amp;node.left &lt; &amp;node.right</code>' истинно. Более того, адрес структуры является <emphasis>также</emphasis> адресом ее первого поля (другими словами, игнорируя проблемы типов, '<code>&amp;node == &amp;node.user_data</code>').</p>
      <p>Следовательно, концептуально '<code>е = *((struct employee**)vp);</code>' означает:</p>
      <p>1. <code>vp</code> является <code>void*</code>, то есть общим указателем. Это адрес внутренней вершины дерева, но это <emphasis>также</emphasis> адрес части вершины (скорее всего, другого <code>void*</code>), которая указывает на данные пользователя.</p>
      <p>2. '<code>(struct employee**)vp</code>' приводит адрес внутреннего указателя к нужному типу; он остается указателем на указатель, но в этот раз на <code>struct employee</code>. Помните, что приведение одного типа указателя к другому не изменяют значения (паттерна битов); оно меняет лишь способ интерпретации компилятором значения для анализа типов.</p>
      <p>3. '<code>*((struct employee**)vp)</code>' разыменовывает вновь созданный <code>struct employee**</code>, возвращая годный к употреблению указатель <code>struct employee*</code>.</p>
      <p>4. '<code>е = *((struct employee**)vp)'</code> сохраняет это значение в <code>е</code> для непосредственного использования позже.</p>
      <p>Идея проиллюстрирована на рис. 14.2.</p>
      <image l:href="#img_28.jpeg"/>
      <p><strong>Рис. 14.2</strong>. Вершины дерева и их указатели</p>
      <p>Для упрощения использования возвращенного указателя вы могли бы рассмотреть определение макроса:</p>
      <p><code>#define tree_data(ptr, type)(*(type**)(ptr))</code></p>
      <p><code>...</code></p>
      <p><code>struct employee *e;</code></p>
      <p><code>void *vp;</code></p>
      <empty-line/>
      <p><code>vp = tfind(&amp;key, root, emp_name_id_compare);</code></p>
      <p><code>if (vp != NULL) { /* it's there, use it */</code></p>
      <p><code> e = tree_data(vp, struct employee);</code></p>
      <p><code> /* использование сведений в *e ... */</code></p>
      <p><code>}</code></p>
     </section>
     <section>
      <title>
       <p>14.4.5. Обход дерева: <code>twalk()</code></p>
      </title>
      <p>Функция <code>twalk()</code> объявлена в <code>&lt;search.h&gt;</code> следующим образом:</p>
      <p><code>typedef enum { preorder, postorder, endorder, leaf } VISIT;</code></p>
      <p><code>void twalk(const void *root,</code></p>
      <p><code> void (*action)(const void *nodep, const VISIT which,</code></p>
      <p><code>const int depth));</code></p>
      <p>Первый параметр является корнем дерева (не указателем на корень). Второй является указателем на функцию обратного вызова, которая вызывается с тремя аргументами, указателем на исследуемую вершину дерева; типом перечисления, указывающим, как осуществляется обход данной вершины; и целого, обозначающего глубину текущей вершины (корень находится на глубине 0, как объяснялось ранее).</p>
      <p>Использование функции обратного вызова здесь такое же, как для <code>nftw()</code> (см. раздел 8.4.3.2 «Функция обратного вызова <code>nftw()</code>»). Там функция обратного вызова вызывается для каждого объекта в файловой системе. Здесь функция обратного вызова вызывается для каждого объекта, хранящегося в дереве.</p>
      <p>Есть несколько способов прохождения, или «обхода», двоичного дерева:</p>
      <p>• Левая вершина, родительская вершина, правая вершина.</p>
      <p>• Родительская вершина, левая вершина, правая вершина.</p>
      <p>• Левая вершина, правая вершина, родительская вершина.</p>
      <p>Функция GLIBC <code>twalk()</code> использует второй способ: сначала родительская вершина, затем левая, затем правая. Каждый раз при встрече с вершиной говорят, что она <emphasis>посещается</emphasis>.<a l:href="#n159" type="note">[159]</a> В ходе посещения порожденной вершины функция должна посетить и родительскую. Соответственно, значения типа <code>VISIT</code> указывают, на какой стадии произошла встреча с этой вершиной:</p>
      <p><code>preorder   </code>До посещения порожденных.</p>
      <p><code>postorder  </code>После посещения первой, но до посещения второй порожденной вершины.</p>
      <p><code>endorder   </code>После посещения обеих порожденных.</p>
      <p><code>leaf</code> Эта вершина является концевой, не имеющей порожденных вершин.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Использованная здесь терминология не соответствует точно той, которая используется в формальных руководствах по структурированию данных. Там используются термины inorder, preorder и postorder для обозначения соответствующих трех перечисленных ранее способов прохождения дерева. Таким образом, <code>twalk()</code> использует прохождение по типу <code>preorder</code>, но использует именованные константы preorder и т.д. для обозначения того, на какой стадии была посещена вершина. Это может сбивать с толку.</p>
      </cite>
      <p>Следующая программа, <code>ch14-tsearch.c</code>, демонстрирует построение и обход дерева. Она повторно использует структуру <code>struct employee</code> и функцию <code>emp_name_id_compare()</code> из раздела 6.2 «Функции сортировки и поиска».</p>
      <p><code>1  /* ch14-tsearch.c --- демонстрация управления деревом */</code></p>
      <p><code>2</code></p>
      <p><code>3  #include &lt;stdio.h&gt;</code></p>
      <p><code>4  #include &lt;search.h&gt;</code></p>
      <p><code>5  #include &lt;time.h&gt;</code></p>
      <p><code>6</code></p>
      <p><code>7  struct employee {</code></p>
      <p><code>8   char lastname[30];</code></p>
      <p><code>9   char firstname[30];</code></p>
      <p><code>10  long emp_id;</code></p>
      <p><code>11  time_t start_date;</code></p>
      <p><code>12 };</code></p>
      <p><code>13</code></p>
      <p><code>14 /* emp_name_id_compare --- сравнение по имени, затем no ID */</code></p>
      <p><code>15</code></p>
      <p><code>16 int emp_name_id_compare(const void *e1p, const void *e2p)</code></p>
      <p><code>17 {</code></p>
      <p><code>18  const struct employee *e1, *e2;</code></p>
      <p><code>19  int last, first;</code></p>
      <p><code>20</code></p>
      <p><code>21  e1 = (const struct employee*)e1p;</code></p>
      <p><code>22  e2 = (const struct employee*)e2p;</code></p>
      <p><code>23</code></p>
      <p><code>24  if ((last = strcmp(e1-&gt;lastname, e2-&gt;lastname)) != 0)</code></p>
      <p><code>25   return last;</code></p>
      <p><code>26</code></p>
      <p><code>27  /* фамилии совпадают, проверить имена */</code></p>
      <p><code>28  if ((first = strcmp(e1-&gt;firstname, e2-&gt;firstname)) != 0)</code></p>
      <p><code>29   return first;</code></p>
      <p><code>30</code></p>
      <p><code>31  /* имена совпадают, проверить ID */</code></p>
      <p><code>32  if (e1-&gt;emp_id &lt; e2-&gt;emp_id)</code></p>
      <p><code>33   return -1;</code></p>
      <p><code>34  else if (e1-&gt;emp_id == e2-&gt;emp_id)</code></p>
      <p><code>35   return 0;</code></p>
      <p><code>36  else</code></p>
      <p><code>37   return 1;</code></p>
      <p><code>38 }</code></p>
      <p><code>39</code></p>
      <p><code>40 /* print_emp --- вывод структуры employee во время обхода дерева */</code></p>
      <p><code>41</code></p>
      <p><code>42 void print_emp(const void *nodep, const VISIT which, const int depth)</code></p>
      <p><code>43 {</code></p>
      <p><code>44  struct employee *e = *((struct employee**)nodep);</code></p>
      <p><code>45</code></p>
      <p><code>46  switch (which) {</code></p>
      <p><code>47  case leaf:</code></p>
      <p><code>48  case postorder:</code></p>
      <p><code>49   printf("Depth: %d. Employee: \n", depth);</code></p>
      <p><code>50   printf("\t%s, %s\t%d\t%s\n", e-&gt;lastname, e-&gt;firstname,</code></p>
      <p><code>51    e-&gt;emp_id, ctime(&amp;e-&gt;start_date));</code></p>
      <p><code>52   break;</code></p>
      <p><code>53  default:</code></p>
      <p><code>54   break;</code></p>
      <p><code>55  }</code></p>
      <p><code>56 }</code></p>
      <p>Строки 7–12 определяют <code>struct employee</code>, а строки 14–38 определяют <code>emp_name_id_compare()</code>.</p>
      <p>Строки 40–56 определяют <code>print_emp()</code>, функцию обратного вызова, которая выводит <code>struct employee</code> наряду с глубиной дерева в текущей вершине. Обратите внимание на магическое приведение типа в строке 44 для получения указателя на сохраненные данные.</p>
      <p><code>58 /* main --- демонстрация хранения данных в двоичном дереве */</code></p>
      <p><code>59</code></p>
      <p><code>60 int main(void)</code></p>
      <p><code>61 {</code></p>
      <p><code>62 #define NPRES 10</code></p>
      <p><code>63  struct employee presidents[NPRES];</code></p>
      <p><code>64  int i, npres;</code></p>
      <p><code>65  char buf[BUFSIZ];</code></p>
      <p><code>66  void *root = NULL;</code></p>
      <p><code>67</code></p>
      <p><code>68  /* Очень простой код для чтения данных: */</code></p>
      <p><code>69  for (npres = 0; npres &lt; NPRES &amp;&amp; fgets(buf, BUFSIZ, stdin) != NULL;</code></p>
      <p><code>70   npres++) {</code></p>
      <p><code>71   sscanf(buf, "%s %s %ld %ld\n",</code></p>
      <p><code>72   presidents[npres].lastname,</code></p>
      <p><code>73   presidents[npres].firstname,</code></p>
      <p><code>74   &amp;presidents[npres].emp_id,</code></p>
      <p><code>75   &amp;presidents[npres].start_date);</code></p>
      <p><code>76  }</code></p>
      <p><code>77</code></p>
      <p><code>78  for (i = 0; i &lt; npres; i++)</code></p>
      <p><code>79   (void)tsearch(&amp;presidents[i], &amp;root, emp_name_id_compare);</code></p>
      <p><code>80</code></p>
      <p><code>81  twalk(root, print_emp);</code></p>
      <p><code>82  return 0;</code></p>
      <p><code>83 }</code></p>
      <p>Целью вывода дерева является вывод содержащихся в нем элементов в отсортированном порядке. Помните, что <code>twalk()</code> посещает промежуточные вершины по три раза и что левая вершина меньше родительской, тогда как правая больше. Таким образом, оператор <code>switch</code> выводит сведения о вершине, лишь если <code>which</code> равно <code>leaf</code>, является концевой вершиной, или <code>postorder</code>, что означает, что была посещена левая вершина, а правая еще не была посещена.</p>
      <p>Используемые данные представляют собой список президентов, тоже из раздела 6.2 «Функции сортировки и поиска». Чтобы освежить вашу память, полями являются фамилия, имя, номер сотрудника и время начала работы в виде временной отметки в секундах с начала Эпохи:</p>
      <p><code>$ <strong>cat presdata.txt</strong></code></p>
      <p><code>Bush George 43 980013600</code></p>
      <p><code>Clinton William 42 727552800</code></p>
      <p><code>Bush George 41 601322400</code></p>
      <p><code>Reagan Ronald 40 348861600</code></p>
      <p><code>Carter James 39 222631200</code></p>
      <p>Данные сортируются на основе сначала фамилии, затем имени, а затем старшинства. При запуске<a l:href="#n160" type="note">[160]</a> программа выдает следующий результат:</p>
      <p><code>$ <strong>ch14-tsearch &lt; presdata.txt</strong></code></p>
      <p><code>Depth: 1. Employee:</code></p>
      <p><code>Bush, George 41 Fri Jan 20 13:00:00 1989</code></p>
      <empty-line/>
      <p><code>Depth: 0. Employee:</code></p>
      <p><code>Bush, George 43 Sat Jan 20 13:00:00 2001</code></p>
      <empty-line/>
      <p><code>Depth: 2. Employee:</code></p>
      <p><code>Carter, James 39 Thu Jan 20 13:00:00 1977</code></p>
      <empty-line/>
      <p><code>Depth: 1. Employee:</code></p>
      <p><code>Clinton, William 42 Wed Jan 20 13:00:00 1993</code></p>
      <empty-line/>
      <p><code>Depth: 2. Employee:</code></p>
      <p><code>Reagan, Ronald 40 Tue Jan 20 13:00:00 1981</code></p>
     </section>
     <section>
      <title>
       <p>14.4.6. Удаление вершины дерева и удаление дерева: <code>tdelete()</code> и <code>tdestroy()</code></p>
      </title>
      <p>Наконец, вы можете удалить элементы из дерева и, на системах GLIBC, удалить само дерево целиком:</p>
      <p><code>void *tdelete(const void *key, void **rootp,</code></p>
      <p><code>int (*compare)(const void*, const void*));</code></p>
      <p><code>/* Расширение GLIBC, в POSIX нет: */</code></p>
      <p><code>void tdestroy(void *root, void (*free_node)(void *nodep));</code></p>
      <p>Аргументы для <code>tdelete()</code> те же, что и для <code>tsearch()</code>: ключ, адрес корня дерева и функция сравнения. Если в дереве найден данный элемент, он удаляется, и <code>tdelete()</code> возвращает указатель на <emphasis>родительскую</emphasis> вершину. В противном случае возвращается <code>NULL</code>. С этим поведением следует обращаться в своем коде осмотрительно, если вам нужен первоначальный удаляемый элемент, например, для освобождения занимаемой им памяти.</p>
      <p><code>struct employee *е, key; /* Объявления переменных */</code></p>
      <p><code>void *vp, *root;</code></p>
      <p><code>/* ...заполнить ключ для удаляемого из дерева элемента... */</code></p>
      <p><code>vp = tfind(&amp;key, root, emp_name_id_compare); /* Найти удаляемый элемент */</code></p>
      <p><code>if (vp != NULL) {</code></p>
      <p><code> e = *((struct employee**)vp); /* Преобразовать указатель */</code></p>
      <p><code> free(e); /* Освободить память */</code></p>
      <p><code>}</code></p>
      <p><code>(void)tdelete(&amp;key, &amp;root, emp_name_id_compare); /* Теперь удалить его из дерева */</code></p>
      <p>Хотя это и не указано в справочных страницах или стандарте POSIX, под GNU/Linux, если вы удаляете элемент, хранящийся в корневой вершине, возвращается значение новой корневой вершины. Для переносимого кода не следует полагаться на это поведение</p>
      <p>Функция <code>tdestroy()</code> является расширением GLIBC. Она позволяет удалить дерево целиком. Первый аргумент является корнем дерева. Второй является указателем на функцию, которая освобождает <emphasis>данные</emphasis>, на которые указывает каждая вершина дерева. Если с этими данными ничего не надо делать (например, они хранятся в обычном массиве, как в примере нашей программы), эта функция ничего не должна делать. <emphasis>Не</emphasis> передавайте указатель <code>NULL</code>! Это приведет к аварийной ситуации.</p>
     </section>
    </section>
    <section>
     <title>
      <p>14.5. Резюме</p>
     </title>
     <p>• Иногда бывает необходимо выделить память, выровненную по определенной границе. Это осуществляет <code>posix_memalign()</code>. Ее возвращаемое значение отличается от большинства из рассмотренных в данной книге функций. <code>memalign()</code> также выделяет выровненную память, но не все системы поддерживают освобождение памяти с помощью <code>free()</code>.</p>
     <p>• Блокирование файлов с помощью <code>fcntl()</code> предусматривает блокировку диапазонов, вплоть до блокирования отдельных байтов в файле. Блокировки чтения предотвращают запись в заблокированную область, а блокировки записи предотвращают чтение и запись другими процессами в заблокированную область. По умолчанию используется вспомогательная блокировка, и POSIX стандартизует лишь вспомогательную блокировку. Большинство современных систем Unix поддерживают обязательную блокировку, используя для файла бит setgid прав доступа, а также возможные дополнительные опции монтирования файловой системы.</p>
     <p>• GNU/Linux функция <code>lockf()</code> действует в качестве оболочки вокруг блокировки POSIX с помощью <code>fcntl()</code>; блокировки функции BSD <code>flock()</code> совершенно независимы от блокировок <code>fcntl()</code>. Блокировки BSD <code>flock()</code> используются лишь для всего файла в целом и не работают на удаленных файловых системах. По этим причинам использование блокировки <code>flock()</code> не рекомендуется.</p>
     <p>• <code>gettimeofday</code>() получает время дня в виде пар (секунды, микросекунды) в <code>struct timeval</code>. Эти значения используются <code>utimes()</code> для обновления времени доступа и модификации файла. Системные вызовы <code>gettimer()</code> и <code>settimer()</code> используют пары <code>struct timeva</code>l в <code>struct itimerval</code> для создания интервальных таймеров — сигнальных часов, которые «срабатывают» в установленное время и продолжают срабатывать впоследствии с заданным интервалом. Три различных таймера обеспечивают контроль тех состояний, когда таймер продолжает действовать.</p>
     <p>• Функция <code>nanosleep()</code> использует <code>struct timespec</code>, которая указывает время в секундах и наносекундах, чтобы приостановить выполнение процесса в течение определенного интервала времени. У нее есть удачная особенность не взаимодействовать вообще с механизмами сигналов.</p>
     <p>• Три API являются стандартным набором функций для хранения и поиска данных, которые сохраняют данные в двоичных деревьях в отсортированном виде. Эти три API очень гибкие, позволяя использовать множество деревьев и произвольные данные.</p>
    </section>
    <section>
     <title>
      <p>Упражнения</p>
     </title>
     <p>1. Напишите функцию <code>lockf()</code>, используя <code>fcntl()</code> для осуществления блокировки.</p>
     <p>2. Каталог <code>/usr/src/linux/Documentation</code> содержит набор файлов, которые описывают различные аспекты поведения операционной системы. Прочитайте файлы <code>locks.txt</code> и <code>mandatory.txt</code>, чтобы получить больше сведений об обработке Linux блокировок файлов.</p>
     <p>3. Запустите на своей системе программу <code>ch14-lockall</code> без обязательной блокировки и посмотрите, сможете ли изменить файл-операнд.</p>
     <p>4. Если у вас не-Linux система, поддерживающая обязательную блокировку, попробуйте исполнить на ней программу <code>ch14-lockall</code>.</p>
     <p>5. Напишите функцию <code>strftimes()</code> следующего вида:</p>
     <p><code>size_t strftimes(char *buf, size_t size, const char *format,</code></p>
     <p><code> const struct timeval *tp);</code></p>
     <p>Она должна вести себя подобно стандартной функции <code>strftime()</code> за тем исключением, что должна использовать <code>%q</code> для обозначения «текущего числа микросекунд».</p>
     <p>6. Используя только что написанную функцию <code>strftimes()</code>, напишите расширенную версию date, которая принимает форматирующую строку, начинающуюся с ведущего <code>+</code>, и форматирует текущие дату и время (см. <emphasis>date</emphasis>(1)).</p>
     <p>7. Обработка тайм-аута в <code>ch14-timers.c</code> довольно примитивна. Перепишите программу с использованием <code>setjmp()</code> после вывода приглашения и <code>longjmp()</code> из обработчика сигнала. Улучшает ли это структуру или ясность программы?</p>
     <p>8. Мы заметили, что <code>ch14-timers.c</code> содержит намеренное состояние гонки. Предположим, пользователь вводит ответ в нужное время, но <code>ch14-timers</code> приостановлена, прежде чем сигнал может быть отменен. Какой вызов вы сделаете, чтобы уменьшить размер проблемного окна?</p>
     <p>9. Нарисуйте дерево, как показано в выводе <code>ch14-tsearch</code> в разделе 14.4.5 «Обход дерева: <code>twalk()</code>».</p>
     <p>10. Исследуйте файл <code>/usr/share/dict/words</code> на системе GNU/Linux. (Это словарь проверки правописания для <code>spell</code>; на различных системах он может находиться в разных местах.) В файле слова размешены в отсортированном порядке, по одному в строке.</p>
     <p>Для начала используйте программу <code>awk</code> для создания нового списка в случайном порядке:</p>
     <p><code>$ <strong>awk '{ list[$0]++ }</strong></code></p>
     <p><code>&gt; <strong>END { for (i in list) print i }' /usr/share/dict/words &gt; /tmp/wlist</strong></code></p>
     <p>Далее, напишите две программы. Каждая должна читать новый список и сохранять каждое прочитанное слово в дереве и массиве соответственно. Вторая программа должна использовать для сортировки массива <code>qsort()</code>, а для поиска — <code>bsearch()</code>. Получите из дерева или массива слово '<code>gravy</code>'. Вычислите время работы двух программ, чтобы увидеть, какая быстрее. Вам может потребоваться заключить получение слова внутрь цикла, повторяющегося множество раз (скажем, 1000), чтобы получить достаточное для определения разницы время.</p>
     <p>Используйте вывод <code>ps</code>, чтобы посмотреть, сколько памяти используют программы</p>
     <p>11. Повторно запустите обе программы, использовав оригинальный отсортированный словарный файл, и посмотрите, как изменятся временные результаты (если они вообще изменятся).</p>
    </section>
   </section>
  </section>
  <section>
   <title>
    <p>Часть 3</p>
    <p>Отладка и заключительный проект</p>
   </title>
   <section>
    <title>
     <p>Глава 15</p>
     <p>Отладка</p>
    </title>
    <section>
     <p>Имеется множество правил, начиная с логики программы и расположения данных, через организацию и расположение кода и кончая реализацией, которые могут минимизировать ошибки и проблемы. Мы рекомендуем вам изучить их; найдите хорошие книги по проектированию и дизайну программного обеспечения и реализуйте содержащиеся там советы на практике! Каждая программа, размером превышающая несколько сот строк кода, должна быть тщательно продумана и спроектирована, а не обтяпана, пока не начнет работать.</p>
     <p>Однако, поскольку программисты люди, ошибки программирования неизбежны. <emphasis>Отладка</emphasis> является процессом обнаружения и устранения ошибок в программах. Даже хорошо спроектированные и хорошо реализованные программы иногда не работают; когда что-то идет не так и вы не можете выяснить, почему, хорошей мыслью является нацелить на код отладчик и понаблюдать за появлением ошибки.</p>
     <p>Данная глава охватывает ряд тем, начиная с общих методик и советов по отладке (компилирование для отладки и элементарное использование GDB, отладчика GNU), переходя к ряду методик для использования при разработке и отладке программы, упрощающих отладку, и затем рассмотрением ряда инструментов, помогающих в процессе отладки. Глава завершается краткими сведениями по тестированию программного обеспечения и великолепным набором «правил отладки», извлеченных из книги, которую мы весьма рекомендуем.</p>
     <p>Большая часть наших советов основана на нашем долгосрочном опыте участия в качестве добровольца в проекте GNU по поддержке <code>gawk</code> (GNU <code>awk</code>). Большинство, если не все, специфические примеры, которые мы представляем, происходят от этой программы. На протяжении главы особые рекомендации помечены словом <strong>Рекомендация</strong>.</p>
    </section>
    <section>
     <title>
      <p>15.1. Сначала главное</p>
     </title>
     <p>Когда программа ведет себя неправильно, вы можете быть в затруднении, что делать сначала. Часто странное поведение возникает из-за неправильного использования памяти — использования неинициализированных значений, чтения или записи за пределами динамической памяти и т.д. Поэтому вы можете быстрее получить результаты, попробовав средства отладки памяти <emphasis>до</emphasis> того, как заведете отладчик.</p>
     <p>Довод заключается в том, что утилиты памяти могут указать вам непосредственно на вызывающую сбой строку кода, тогда как использование отладчика больше напоминает миссию «найти и уничтожить», в которой вам нужно сначала изолировать проблему, а затем исправить ее. Убедившись, что дело не в проблемах памяти, можно переходить к использованию отладчика.</p>
     <p>Поскольку отладчик является более универсальным средством, мы рассмотрим его вначале. Далее в главе мы обсудим ряд инструментов для отладки памяти.</p>
    </section>
    <section>
     <title>
      <p>15.2. Компиляция для отладки</p>
     </title>
     <p>Для использования отладчика исходного кода, отлаживаемый исполняемый файл должен быть откомпилирован с опцией компилятора <code>-g</code>. Эта опция заставляет компилятор внедрять в объектный код дополнительные <emphasis>отладочные идентификаторы</emphasis>; то есть дополнительные сведения, содержащие имена и типы переменных, констант, функций и так далее. Отладчик затем использует эту информацию для приведения в соответствие местоположения исходного кода с исполняемым кодом и получения или сохранения значений переменных в работающей программе.</p>
     <p>На многих системах Unix опция компилятора <code>-g</code> является взаимно исключающей с опцией <code>-O</code>, которая включает оптимизацию. Это потому, что оптимизации могут вызвать перестановку битов и участков объектного кода, так что больше не будет прямого соответствия с тем, что исполняется, и линейным прочтением исходного кода. Отменив оптимизации, вы значительно облегчаете отладчику установление связи между объектным и исходным кодом, и в свою очередь, пошаговое прохождение программы работает очевидным образом. (Пошаговое исполнение вскоре будет описано.)</p>
     <p>GCC, GNU Compiler Collection (коллекция компиляторов GNU), на самом деле допускает совместное использование <code>-g</code> и <code>-O</code>. Однако, это привносит как раз ту проблему, которую мы хотим избежать при отладке: следование исполнению в отладчике становится значительно более трудным. Преимуществом совместного использования опций является то, что вы можете оставить отладочные идентификаторы в конечном оптимизированном исполняемом модуле. Они занимают лишь дисковое пространство, а не память. После этого установленный исполняемый файл все еще можно отлаживать при непредвиденных случаях.</p>
     <p>По нашему опыту, если нужно использовать отладчик, лучше перекомпилировать приложение с самого начала, использовав лишь опцию <code>-g</code>. Это значительно упрощает трассировку; имеется достаточно деталей, за которыми нужно следить при простом прохождении написанной программы, не беспокоясь о том, как компилятор переставляет код.</p>
     <p>Есть одно предостережение: <emphasis>убедитесь, что поведение программы все еще неправильное</emphasis>. Воспроизводимость является ключевой при отладке; если вы не можете воспроизвести проблему, <emphasis>гораздо</emphasis> труднее ее выследить и исправить. В редких случаях компиляция без опции <code>-O</code> может устранить ошибку<a l:href="#n161" type="note">[161]</a>. Обычно проблема остается при компиляции без использования опции <code>-O</code>, что означает, что на самом деле действительно имеется какая-то разновидность логической ошибки, ждущая своего обнаружения.</p>
    </section>
    <section>
     <title>
      <p>15.3. Основы GDB</p>
     </title>
     <section>
      <p><emphasis>Отладчик</emphasis> является программой, позволяющей контролировать исполнение другой программы и исследовать и изменять состояние подчиненной программы (такое, как значения переменных). Имеются два вида отладчиков: <emphasis>отладчики машинного уровня</emphasis>, работающие на уровне машинных инструкций, и <emphasis>отладчики исходного кода</emphasis>, работающие на основе исходного кода программы. Например, в отладчике машинного уровня для изменения значения переменной вы указываете адрес в памяти. В отладчике исходного уровня вы просто используете имя переменной.</p>
      <p>Исторически в V7 Unix был <code>adb</code>, который являлся отладчиком машинного уровня В System III был <code>sdb</code>, который являлся отладчиком исходного кода, a BDS Unix предоставляла dbx, также отладчик исходного кода. (Обе продолжали предоставлять <code>adb</code>.) <code>dbx</code> продолжает существовать на некоторых коммерческих системах Unix.</p>
      <p>GDB, отладчик GNU, является отладчиком исходного кода. У него значительно больше возможностей, он значительно более переносим и более практичен, чем любой из <code>sdb</code> или <code>dbx</code><a l:href="#n162" type="note">[162]</a>.</p>
      <p>Как и его предшественники, GDB является отладчиком командной строки. Он выводит по одной строке исходного кода за раз, выдает приглашение и читает одну строку ввода, содержащего команду для исполнения.</p>
      <p>Имеются графические отладчики; они предоставляют больший обзор исходного кода и обычно предоставляют возможность манипулировать программой как из окна командной строки, так и через компоненты GUI, такие, как кнопки и меню. Отладчик <code>ddd</code><a l:href="#n163" type="note">[163]</a> является одним из таких; он построен поверх GDB, так что если вы изучите GDB, вы сразу же сможете начать использовать <code>ddd</code>. (У <code>ddd</code> есть собственное руководство, которое следует прочесть, если вы собираетесь интенсивно его использовать.) Другим графическим отладчиком является Insight<a l:href="#n164" type="note">[164]</a>, который использует для предоставления поверх GDB графического интерфейса Tcl/Tk. (Следует использовать графический отладчик, если он доступен и нравится вам. Поскольку мы собираемся предоставить введение в отладчики и отладку, мы выбрали использование простого интерфейса, который можно представить в напечатанном виде.)</p>
      <p>GDB понимает С и С++, включая поддержку <emphasis>восстановления имен (name demangling)</emphasis>, что означает, что вы можете использовать для функций-членов классов и перегруженных функций обычные имена исходного кода С++. В частности, GDB распознает синтаксис выражений С, что полезно при проверке значения сложных выражений, таких, как '<code>*ptr-&gt;x.a[1]-&gt;q</code>'. Он понимает также Fortran 77, хотя вам может понадобиться добавить к имени функции или переменной Фортрана символ подчеркивания GDB также частично поддерживает Modula-2 и имеет ограниченную поддержку Паскаля.</p>
      <p>Если вы работаете на системе GNU/Linux или BSD (и установили средства разработки), у вас, вероятно, уже установлена готовая к использованию последняя версия GDB. Если нет, исходный код GDB можно загрузить с FTP-сайта проекта GNU для GDB<a l:href="#n165" type="note">[165]</a> и самостоятельно его построить.</p>
      <p>GDB поставляется с собственным руководством, которое занимает 300 страниц. В каталоге исходного кода GDB можно сгенерировать печатную версию руководства и самостоятельно его распечатать. Можно также купить в Free Software Foundation (FSF) готовые печатные экземпляры; ваша покупка поможет FSF и непосредственно внесет вклад в производство большего количества свободного программного обеспечения. (Информацию для заказа см. на веб-сайте FSF)<a l:href="#n166" type="note">[166]</a>. Данный раздел описывает лишь основы GDB; мы рекомендуем прочесть руководство, чтобы научиться использовать все преимущества возможностей GDB.</p>
     </section>
     <section>
      <title>
       <p>15.3.1. Запуск GDB</p>
      </title>
      <p>Основное использование следующее:</p>
      <p><code>gdb [<emphasis>опции</emphasis>][<emphasis>исполняемый файл</emphasis> [<emphasis>имя файла дампа</emphasis>]]</code></p>
      <p>Здесь <emphasis>исполняемый файл</emphasis> является отлаживаемой программой. Имя файла дампа, если оно имеется, является именем файла <code>core</code>, созданном при завершении программы операционной системой с созданием снимка процесса. Под GNU/Linux такие файлы (по умолчанию) называются <code>core.<emphasis>pid</emphasis></code><a l:href="#n167" type="note">[167]</a>, где <code><emphasis>pid</emphasis></code> является ID процесса запущенной программы, которая была завершена. Расширение <code><emphasis>pid</emphasis></code> означает, что в одном каталоге могут находиться несколько дампов ядра, что бывает полезно, но также занимает дисковое пространство!</p>
      <p>Если вы забыли указать в командной строке имена файлов, для сообщения GDB имени исполняемого файла можно использовать '<code>file <emphasis>исполняемый-файл</emphasis></code>', а для имени файла дампа — '<code>core-file <emphasis>имя-файла-дампа</emphasis></code>'.</p>
      <p>При наличии дампа ядра GDB указывает место завершения программы. Следующая программа, <code>ch15-abort.c</code>, делает несколько вложенных вызовов функций, а затем намеренно завершается посредством <code>abort()</code>, чтобы создать дамп ядра:</p>
      <p><code>/* ch15-abort.c --- создает дамп ядра */</code></p>
      <p><code>#include &lt;stdio.h&gt;</code></p>
      <p><code>#include &lt;stdlib.h&gt;</code></p>
      <empty-line/>
      <p><code>/* recurse --- создание нескольких вызовов функций */</code></p>
      <p><code>void recurse(void)</code></p>
      <p><code>{</code></p>
      <p><code> static int i;</code></p>
      <p><code> if (++i == 3)</code></p>
      <p><code>  abort();</code></p>
      <p><code> else</code></p>
      <p><code>  recurse();</code></p>
      <p><code>}</code></p>
      <empty-line/>
      <p><code>int main(int argc, char **argv)</code></p>
      <p><code>{</code></p>
      <p><code> recurse();</code></p>
      <p><code>}</code></p>
      <p>Вот небольшой сеанс GDB с этой программой:</p>
      <p><code>$ <strong>gcc -g ch15-abort.c -o ch15-abort</strong> /* Компилировать без -O */</code></p>
      <p><code>$ <strong>ch15-abort</strong> /* Запустить программу */</code></p>
      <p><code>Aborted (core dumped) /* Она печально завершается */</code></p>
      <p><code>$ <strong>gdb ch15-abort core.4124</strong> /* Запустить для нее GDB */</code></p>
      <p><code>GNU gdb 5.3</code></p>
      <p><code>Copyright 2002 Free Software Foundation, Inc.</code></p>
      <p><code>GDB is free software, covered by the GNU</code></p>
      <p><code>General Public License, and you are</code></p>
      <p><code>welcome to change it and/or distribute copies of it</code></p>
      <p><code>under certain conditions.</code></p>
      <p><code>Type "show copying" to see the conditions.</code></p>
      <p><code>There is absolutely no warranty for GDB. Type "show warranty" for details.</code></p>
      <p><code>This GDB was configured as "i686-pc-linux-gnu"...</code></p>
      <p><code>Core was generated by 'ch15-abort'.</code></p>
      <p><code>Program terminated with signal 6, Aborted.</code></p>
      <p><code>Reading symbols from /lib/i686/libc.so.6...done.</code></p>
      <p><code>Loaded symbols for /lib/i686/libc.so.6</code></p>
      <p><code>Reading symbols from /lib/ld-linux.so.2...done.</code></p>
      <p><code>Loaded symbols for /lib/ld-linux.so.2</code></p>
      <p><code>#0 0x42028ccl in kill() from /lib/i686/libc.so.6</code></p>
      <p><code>(gdb) <strong>where</strong> /* Вывести трассировку стека */</code></p>
      <p><code>#0 0x42028cc1 in kill() from /lib/i686/libc.so.6</code></p>
      <p><code>#1 0x42028ac8 in raise() from /lib/i686/libc.so.6</code></p>
      <p><code>#2 0x4202a019 in abort() from /lib/1686/libc.so.6</code></p>
      <p><code>#3 0x08048342 in recurse() at ch15-abort.c:13</code></p>
      <p><code> /* &lt;-- Нам нужно исследовать здесь */</code></p>
      <p><code>#4 0x08048347 in recurse() at ch15-abort.с:15</code></p>
      <p><code>#5 0x08048347 in recurse() at ch15-abort.c:15</code></p>
      <p><code>#6 0x0804835f in main (argc=1, argv=0xbffff8f4) at ch15-abort.c:20</code></p>
      <p><code>#7 0x420158d4 in __libc_start_main() from /lib/i686/libc.so.6</code></p>
      <p>Команда <code>where</code> выводит <emphasis>трассировку стека</emphasis>, то есть список всех вызванных функций, начиная с самых недавних. Обратите внимание, что имеется три вызова функции <code>recurse()</code>. Команда <code>bt</code>, означающая 'back trace' (обратная трассировка), является другим названием для <code>where</code>; ее легче набирать.</p>
      <p>Вызов каждой функции в стеке называется <emphasis>фреймом</emphasis>. Этот термин пришел из области компиляторов, в которой параметры, локальные переменные и адреса возврата каждой функции, сгруппированные в стеке, называются <emphasis>фреймом стека</emphasis>. Команда <code>frame</code> GDB дает вам возможность исследовать определенный фрейм. В данном случае нам нужен фрейм 3. Это последний вызов <code>recurse()</code>, который вызвал <code>abort()</code>:</p>
      <p><code>(gdb) <strong>frame 3</strong> /* Переместиться в фрейм 3 */</code></p>
      <p><code>#3 0x08048342 in recurse() at ch15-abort.с:13</code></p>
      <p><code>13 abort(); /* GDB выводит в фрейме положение в исходном коде */</code></p>
      <p><code>(gdb) <strong>list</strong> /* Показать несколько строк исходного кода */</code></p>
      <p><code>8  void recurse(void)</code></p>
      <p><code>9  {</code></p>
      <p><code>10  static int i;</code></p>
      <p><code>11</code></p>
      <p><code>12  if (++i == 3)</code></p>
      <p><code>13   abort();</code></p>
      <p><code>14  else</code></p>
      <p><code>15   recurse();</code></p>
      <p><code>16 }</code></p>
      <p><code>17</code></p>
      <p><code>(gdb) /* Нажатие ENTER повторяет последнюю команду */</code></p>
      <p><code>18 int main(int argc, char **argv)</code></p>
      <p><code>19 {</code></p>
      <p><code>20  recurse();</code></p>
      <p><code>21 }</code></p>
      <p><code>(gdb) <strong>quit</strong> /* Выйти из отладчика (пока) */</code></p>
      <p>Как показано, нажатие ENTER повторяет последнюю команду, в данном случае <code>list</code>, для отображения строк исходного кода. Это простой способ прохождения исходного кода.</p>
      <p>Для редактирования командной строки GDB использует библиотеку <code>readline</code>, поэтому для повторения и редактирования ранее введенных команд можно использовать команды Emacs или <code>vi</code>. Оболочка Bash использует ту же самую библиотеку, поэтому если вам более знакомо редактирование командной строки в приглашении оболочки, GDB работает таким же образом. Эта особенность дает возможность избежать утомительного ручного ввода.</p>
     </section>
     <section>
      <title>
       <p>15.3.2. Установка контрольных точек, пошаговое выполнение и отслеживаемые точки</p>
      </title>
      <p>Часто при ошибках программ создается дамп ядра. Первым шагом является использование GDB с файлом core для определения процедуры, в которой произошло завершение программы. Если оригинальный двоичный файл не был откомпилирован для отладки (т.е. без <code>-g</code>), все, что может сообщить GDB, это имя функции, но больше никаких деталей.</p>
      <p>Следующим шагом является перекомпилирование программы с возможностью отладки и без оптимизации, а также проверка того, <emphasis>что она все еще содержит ошибку</emphasis>. Предположив, что это так, можно запустить программу под контролем отладчика и установить контрольную точку в процедуре, вызывающей ошибку.</p>
      <p><emphasis>Контрольная точка (breakpoint)</emphasis> является точкой, в которой исполнение должно прерваться, остановиться. Контрольные точки можно установить по имени функции, номеру строки исходного файла, файлу исходного файла совместно с номером строки, а также другими способами.</p>
      <p>После установки контрольной точки программа запускается с использованием команды <code>run</code>, за которой могут следовать аргументы командной строки, которые должны быть переданы отлаживаемой программе. (GDB удобным образом запоминает за вас аргументы; если нужно снова запустить программу с начала, все что нужно — это напечатать лишь саму команду <code>run</code>, и GDB запустит новую копию с теми же аргументами, как и ранее). Вот короткий сеанс с использованием <code>gawk</code>:</p>
      <p><code>$ <strong>gdb gawk</strong> /* Запуск GDB для gawk */</code></p>
      <p><code>GNU gdb 5.3</code></p>
      <p><code>...</code></p>
      <p><code>(gdb) <strong>break do_print</strong> /* Прерывание в do_print */</code></p>
      <p><code>Breakpoint 1 at 0x805a36a: file builtin.c, line 1504.</code></p>
      <p><code>(gdb) <strong>run 'BEGIN { print "hello, world" }'</strong> /* Запуск программы */</code></p>
      <p><code>Starting program: /home/arnold/Gnu/gawk/gawk-3.1.3/gawk 'BEGIN { print "hello, world" }'</code></p>
      <p><code>Breakpoint 1, do_print (tree=0x8095290) at builtin.c:1504</code></p>
      <p><code>1504 struct redirect *rp = NULL; /* Исполнение достигает контрольной точки */</code></p>
      <p><code>(gdb) <strong>list</strong> /* Показать исходный код */</code></p>
      <p><code>1499</code></p>
      <p><code>1500 void</code></p>
      <p><code>1501 do_print(register NODE *tree)</code></p>
      <p><code>1502 {</code></p>
      <p><code>1503  register NODE **t;</code></p>
      <p><code>1504  struct redirect *rp = NULL;</code></p>
      <p><code>1505  register FILE *fp;</code></p>
      <p><code>1506  int numnodes, i;</code></p>
      <p><code>1507  NODE *save;</code></p>
      <p><code>1508  NODE *tval;</code></p>
      <p>По достижении контрольной точки вы проходите программу в <emphasis>пошаговом режиме</emphasis>. Это означает, что GDB разрешает программе исполнять лишь по одному оператору исходного кода за раз. GDB выводит строку, которую собирается выполнить, и выводит приглашение. Чтобы выполнить оператор, используется команда <code>next</code>:</p>
      <p><code>(gdb) <strong>next</strong> /* Выполнить текущий оператор (строка 1504 выше) */</code></p>
      <p><code>1510 fp = redirect_to_fp(tree-&gt;rnode, &amp;rp); /* GDB выводит следующий оператор */</code></p>
      <p><code>(gdb) /* Нажмите ENTER для его выполнения и перехода к следующему */</code></p>
      <p><code>1511 if (fp == NULL)</code></p>
      <p><code>(gdb) /* снова ENTER */</code></p>
      <p><code>1519 save = tree = tree-&gt;lnode; (gdb) /* И снова */</code></p>
      <p><code>1520 for (numnodes = 0; tree != NULL; tree = tree-&gt;rnode)</code></p>
      <p>Команда <code>step</code> является альтернативной командой для пошагового исполнения. Между <code>next</code> и <code>step</code> есть важное различие, <code>next</code> выполняет следующий оператор. Если этот оператор содержит вызов функции, эта функция вызывается и возвращается до того, как GDB вернет себе управление от работающей программы.</p>
      <p>С другой стороны, когда вы используете с содержащим вызов функции оператором <code>step</code>, GDB входит в вызываемую функцию, позволяя вам продолжить пошаговое исполнение (или <emphasis>трассировку</emphasis>) программы. Если оператор не содержит вызов функции, <code>step</code> аналогична <code>next</code>.</p>
      <cite>
       <p><strong>ЗАМЕЧАНИЕ</strong>. Легко забыть, какая команда была использована, и продолжать нажимать ENTER для выполнения последующих операторов. Если вы используете <code>step</code>, вы случайно можете войти в библиотечную функцию, такую как <code>strlen()</code> или <code>printf()</code>, с которой на самом деле не хотите возиться. В таком случае можно использовать команду <code>finish</code>, которая вызывает исполнение программы до возврата из текущей функции</p>
      </cite>
      <p>Вывести содержимое памяти можно с использованием команды <code>print</code>. GDB распознает синтаксис выражений С, что упрощает и делает естественным проверку структур, на которые ссылаются указатели:</p>
      <p><code>(gdb) <strong>print *save</strong> /* Вывести структуру, на которую указывает save */</code></p>
      <p><code>$1 = {sub = {nodep = {l = {lptr = 0x8095250, param_name = 0x8095250 "pR\t\b",</code></p>
      <p><code> l1 = 134828624}, r = {rptr = 0x0, pptr = 0, preg = 0x0,</code></p>
      <p><code> hd = 0x0, av = 0x0, r_ent =0}, x = {extra = 0x0, x1 = 0,</code></p>
      <p><code> param_list = 0x0},</code></p>
      <p><code> name = 0x0, number = 1, reflags = 0}, val = {</code></p>
      <p><code> fltnum = 6.6614191194446594e-316, sp = 0x0, slen = 0, sref = 1,</code></p>
      <p><code> idx = 0}, hash = {next = 0x8095250, name = 0x0, length = 0, value = 0x0,</code></p>
      <p><code> ref = 1}}, type = Node_expression_list, flags = 1}</code></p>
      <p>В заключение, команда <code>cont</code> (continue — продолжить) дает возможность продолжить выполнение программы. Она будет выполняться до следующей контрольной точки или до нормального завершения, если других контрольных точек нет. Этот пример продолжается с того места, на котором остановился предыдущий:</p>
      <p><code>1520 for (numnodes = 0; tree != NULL; tree = tree-&gt;rnode)</code></p>
      <p><code>(gdb) <strong>cont</strong> /* Продолжить *!</code></p>
      <p><code>Continuing.</code></p>
      <p><code>hello, world</code></p>
      <empty-line/>
      <p><code>Program exited normally. /* Сообщение от GDB */</code></p>
      <p><code>(gdb) <strong>quit</strong> /* Выйти из отладчика */</code></p>
      <p><emphasis>Отслеживаемая точка (watchpoint)</emphasis> подобна контрольной точке, но используется для данных, а не для кода. Отслеживаемые точки устанавливаются для переменной (или поля структуры или объединения или элемента массива), при их изменении GDB посылает уведомления. GDB проверяет значение отслеживаемой точки по мере пошагового исполнения программы и останавливается при изменении значения. Например, переменная <code>do_lint_old</code> в <code>gawk</code> равна true, когда была использована опция <code>--lint_old</code>. Эта переменная устанавливается в true функцией <code>getopt_long()</code>. (Мы рассмотрели <code>getopt_long()</code> в разделе 2.1.2 «Длинные опции GNU»). В файле <code>main.c</code> программы <code>gawk</code>:</p>
      <p><code>int do_lint_old = FALSE;</code></p>
      <p><code> /* предупредить о материале, не имевшейся в V7 awk */</code></p>
      <p><code>...</code></p>
      <p><code>static const struct option optab[] = {</code></p>
      <p><code> ...</code></p>
      <p><code> { "lint-old", no_argument, &amp;do_lint_old, 1 },</code></p>
      <p><code> ...</code></p>
      <p><code>};</code></p>
      <p>Вот пример сеанса, показывающего отслеживаемую точку в действии:</p>
      <p><code>$ <strong>gdb gawk</strong> /* Запустить GDB с gawk */</code></p>
      <p><code>GNU gdb 5.3</code></p>
      <p><code>...</code></p>
      <p><code>(gdb) <strong>watch do_lint_old</strong></code></p>
      <p><code> /* Установить отслеживаемую точку для переменной */</code></p>
      <p><code>Hardware watchpoint 1: do_lint_old</code></p>
      <p><code>(gdb) <strong>run --lint-old 'BEGIN { print "hello, world" }'</strong></code></p>
      <p><code> /* Запустить программу */</code></p>
      <p><code>Starting program: /home/arnold/Gnu/gawk/gawk-3.1.4/gawk —lint-old</code></p>
      <p><code>'BEGIN { print "hello, world" }'</code></p>
      <p><code>Hardware watchpoint 1: do_lint_old</code></p>
      <p><code>Hardware watchpoint 1: do_lint_old</code></p>
      <p><code>Hardware watchpoint 1: do_lint_old</code></p>
      <p><code> /* Проверка отслеживаемой точки при работе программы */</code></p>
      <p><code>Hardware watchpoint 1: do_lint_old</code></p>
      <p><code>Hardware watchpoint 1: do_lint_old</code></p>
      <p><code>Old value = 0 /* Отслеживаемая точка останавливает программу */</code></p>
      <p><code>New value = 1</code></p>
      <p><code>0x420c4219 in _getopt_internal() from /lib/i686/libc.so.6</code></p>
      <p><code>(gdb) <strong>where</strong> /* Трассировка стека */</code></p>
      <p><code>#0 0x420c4219 in _getopt_internal() from /lib/i686/libc.so.6</code></p>
      <p><code>#1 0x420c4e83 in getopt_long() from /lib/i686/libc.so.6</code></p>
      <p><code>#2 0x080683a1 in main (argc=3, argv=0xbffff8a4) at main.c:293</code></p>
      <p><code>#3 0x420158d4 in __libc_start_main() from /lib/i686/libc.so.6</code></p>
      <p><code>(gdb) <strong>quit</strong> /* На данный момент мы закончили */</code></p>
      <p><code>The program is running. Exit anyway? (y or n) <strong>y</strong> /* Да */</code></p>
      <p>GDB может делать гораздо больше, чем мы здесь показали. Хотя руководство GDB большое, его стоит прочесть целиком хотя бы один раз, чтобы ознакомиться с его командами и возможностями. После этого, возможно, будет достаточно просмотреть файл <code>NEWS</code> в каждом новом дистрибутиве GDB, чтобы узнать, что нового или что изменилось.</p>
      <p>Стоит также распечатать справочную карточку GDB, которая поставляется в дистрибутиве GDB в файле <code>gdb/doc/refcard.tex</code>. Создать печатную версию справочной карточки для PostScript после извлечения исходника и запуска configure можно с помощью следующих команд:</p>
      <p><code>$ <strong>cd gdb/doc</strong> /* Перейти о подкаталог doc */</code></p>
      <p><code>$ <strong>make refcard.ps</strong> /* Отформатировать справочную карточку */</code></p>
      <p>Предполагается, что справочная карточка будет распечатана с двух сторон листа бумаги 8,5&#215;11 дюймов<a l:href="#n168" type="note">[168]</a> (размер «letter») в горизонтальном (landscape) формате. В ней на шести колонках предоставлена сводка наиболее полезных команд GDB. Мы рекомендуем распечатать ее и поместить под своей клавиатурой при работе с GDB.</p>
     </section>
    </section>
    <section>
     <title>
      <p>15.4. Программирование для отладки</p>
     </title>
     <section>
      <p>Имеется множество методик для упрощения отладки исходного кода, от простых до сложных. В данном разделе мы рассмотрим ряд из них.</p>
     </section>
     <section>
      <title>
       <p>15.4.1. Код отладки времени компилирования</p>
      </title>
      <section>
       <p>Несколько методик относятся к самому исходному коду.</p>
      </section>
      <section>
       <title>
        <p>15.4.1.1. Использование отладочных макросов</p>
       </title>
       <p>Возможно, простейшей методикой времени компилирования является использование препроцессора для создания условно компилируемого кода. Например:</p>
       <p><code>#ifdef DEBUG</code></p>
       <p><code>fprintf(stderr, "myvar = %d\n", myvar);</code></p>
       <p><code>fflush(stderr);</code></p>
       <p><code>#endif /* DEBUG */</code></p>
       <p>Добавление <code>-DDEBUG</code> к командной строке компилятора вызывает <code>fprintf()</code> при выполнении программы.</p>
       <p><strong>Рекомендация</strong>: сообщения отладки посылайте в <code>stderr</code>, чтобы они не были потеряны в канале и чтобы их можно было перехватить при помощи перенаправления ввода/вывода. Убедитесь, что использовали <code>fflush()</code>, чтобы сообщения были выведены как можно скорее</p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. Идентификатор <code>DEBUG</code>, хотя он и очевидный, также часто злоупотребляется. Лучшей мыслью является использование специфического для вашей программы идентификатора, такого как <code>MYAPPDEBUG</code>. Можно даже использовать различные идентификаторы для отладки кода в различных частях программы, таких, как файловый ввод/вывод, верификация данных, управление памятью и т.д.</p>
       </cite>
       <p>Разбрасывание больших количеств операторов <code>#ifdef</code> по всему коду быстро становится утомительным. Большое количество <code>#ifdef</code> скрывают также логику программы. Должен быть лучший способ, и в самом деле, часто используется методика с условным определением специального макроса для вывода:</p>
       <p><code>/* МЕТОДИКА 1 --- обычно используемая, но не рекомендуемая, см. текст */</code></p>
       <p><code>/* В заголовочном файле приложения: */ #ifdef MYAPPDEBUG</code></p>
       <p><code>#define DPRINT0(msg) fprintf(stderr, msg)</code></p>
       <p><code>#define DPRINT1(msg, v1) fprintf(stderr, msg, v1)</code></p>
       <p><code>#define DPRINT2(msg, v1, v2) fprintf(stderr, msg, v1, v2)</code></p>
       <p><code>#define DPRINT3(msg, v1, v2, v3) fprintf(stderr, msg, v1, v2, v3)</code></p>
       <p><code>#else /* ! MYAPPDEBUG */</code></p>
       <p><code>#define DPRINT0(msg)</code></p>
       <p><code>#define DPRINT1(msg, v1)</code></p>
       <p><code>#define DPRINT2(msg, v1, v2)</code></p>
       <p><code>#define DPRINT3(msg, v1, v2, v3)</code></p>
       <p><code>#endif /* ! MYAPPDEBUG */</code></p>
       <empty-line/>
       <p><code>/* В исходном файле приложения: */</code></p>
       <p><code>DPRINT1("myvar = %d\n", myvar);</code></p>
       <p><code>...</code></p>
       <p><code>DPRINT2("v1 = %d, v2 = %f\n", v1, v2);</code></p>
       <p>Имеется несколько макросов, по одному на каждый имеющийся аргумент, число которых определяете вы сами. Когда определен <code>MYAPPDEBUG</code>, вызовы макросов <code>DPRINT<emphasis>x</emphasis>()</code> развертываются в вызовы <code>fprintf()</code>. Когда <code>MYAPPDEBUG</code> не определен, эти вызовы развертываются в ничто. (Так, в сущности, работает <code>assert()</code>; мы описали <code>assert()</code> в разделе 12.1 «Операторы проверки: <code>assert()</code>».)</p>
       <p>Эта методика работает; мы сами ее использовали и видели, как ее рекомендуют в учебниках. Однако, она может быть усовершенствована и дальше с уменьшением количества макросов до одного:</p>
       <p><code>/* МЕТОДИКА 2 --- наиболее переносима; рекомендуется */</code></p>
       <p><code>/* В заголовочном файле приложения: */</code></p>
       <p><code>#ifdef MYAPPDEBUG</code></p>
       <p><code>#define DPRINT(stuff) fprintf stuff</code></p>
       <p><code>#else</code></p>
       <p><code>#define DPRINT(stuff)</code></p>
       <p><code>#endif</code></p>
       <empty-line/>
       <p><code>/* В исходном файле приложения: */</code></p>
       <p><code>DPRINT((stderr, "myvar = %d\n", myvar));</code></p>
       <p><code> /* Обратите внимание на двойные скобки */</code></p>
       <p>Обратите внимание на то, как макрос извлекается с двумя наборами скобок! Поместив весь список аргументов для <code>fprintf()</code> в один аргумент, вам больше не нужно определять произвольное число отладочных макросов.</p>
       <p>Если вы используете компилятор, удовлетворяющий стандарту С 1999 г., у вас есть дополнительный выбор, который дает наиболее чистый отладочный код:</p>
       <p><code>/* МЕТОДИКА 3 --- самая чистая, но только для C99 */</code></p>
       <p><code>/* В заголовочном файле приложения: */</code></p>
       <p><code>#ifdef MYAPPDEBUG</code></p>
       <p><code>#define DPRINT(mesg, ...) fprintf(stderr, mesg, __VA_ARGS__)</code></p>
       <p><code>#else</code></p>
       <p><code>#define DPRINT(mesg, ...)</code></p>
       <p><code>#endif</code></p>
       <empty-line/>
       <p><code>/* В исходном файле приложения: */</code></p>
       <p><code>DPRINT("myvar = %d\n", myvar);</code></p>
       <p><code>DPRINT("v1 = %d, v2 = %f\n", v1, v2);</code></p>
       <p>Стандарт С 1999 г. предусматривает <emphasis>варьирующий макрос (variadic macros)</emphasis>; т.е. макрос, который может принимать переменное число аргументов. (Это похоже на варьирующую функцию, наподобие <code>printf()</code>). В макроопределении три точки '<code>...</code>' означают, что будет ноль или более аргументов. В теле макроса специальный идентификатор <code>__VA_ARGS__</code> замещается предусмотренными аргументами, сколько бы их ни было.</p>
       <p>Преимуществом этого механизма является то, что при извлечении отладочного макроса необходим лишь один набор скобок, что делает чтение кода значительно более естественным. Это также сохраняет возможность использовать всего одно имя макроса вместо нескольких, которые меняются в соответствии с числом аргументов. Недостатком является то, что компиляторы C99 пока еще доступны не так широко, что снижает переносимость этой конструкции. (Однако, эта ситуация будет со временем улучшаться.)</p>
       <p><strong>Рекомендация</strong>: Текущие версии GCC поддерживают варьирующие макросы. Таким образом, если вы знаете, что никогда не будете использовать для компилирования своих программ что-то, кроме GCC (или какого-нибудь другого компилятора C99), можете использовать механизм C99. Однако, на момент написания, компиляторы C99 все еще не являются обычным явлением. Поэтому, если ваш код должен компилироваться разными компиляторами, следует использовать макрос в стиле с двумя парами скобок.</p>
      </section>
      <section>
       <title>
        <p>15.4.1.2. По возможности избегайте макросов с выражениями</p>
       </title>
       <p>В общем, макросы препроцессора С являются довольно острой палкой с двумя концами. Они предоставляют вам большую мощь, но также и большую возможность пораниться самому.<a l:href="#n169" type="note">[169]</a></p>
       <p id="___temp_view_cursor_for_clear_format__1">Обычно для эффективности или ясности можно видеть такие макросы:</p>
       <p><code>#define RS_is_null (RS_node-&gt;var_value == Nnull_string)</code></p>
       <p><code>...</code></p>
       <p><code>if (RS_is_null || today == TUESDAY) ...</code></p>
       <p>На первый взгляд, он выглядит замечательно. Условие '<code>RS_is_null</code>' ясно и просто для понимания и абстрагирует внутренние детали проверки. Проблема возникает, когда вы пытаетесь вывести значение в GDB:</p>
       <p><code>(gdb) <strong>print RS_is_null</strong></code></p>
       <p><code>No symbol "RS_is_null" in current context.</code></p>
       <p>В таком случае нужно разыскать определение макроса и вывести развернутое значение.</p>
       <p><strong>Рекомендация</strong>: Для представления важных условий в своей программе используйте переменные, значения которых при изменении условий явным образом меняется в коде.</p>
       <p>Вот сокращенный пример из <code>io.c</code> в дистрибутиве <code>gawk</code>:</p>
       <p><code>void set_RS() {</code></p>
       <p><code> ...</code> </p>
       <p><code> RS_is_null = FALSE;</code></p>
       <p><code> if (RS-&gt;stlen == 0) {</code></p>
       <p><code>  ...</code> </p>
       <p><code>  RS_is_null = TRUE;</code></p>
       <p><code>  ...</code> </p>
       <p><code>  matchrec = rsnullscan;</code></p>
       <p><code> }</code></p>
       <p><code>}</code></p>
       <p>После установки и сохранения <code>RS_is_null</code> ее можно протестировать в коде и вывести из-под отладчика.</p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. Начиная с GCC 3.1 и версии 5 GDB, если вы компилируете свою программу с опциями <code>-gdwarf-2</code> и <code>-g3</code>, вы можете использовать макросы из-под GDB. В руководстве по GDB утверждается, что разработчики GDB надеются найти в конце концов более компактное представление для макросов, и что опция <code>-g3</code> будет отнесена к группе <code>-g</code>.</p>
        <p>Однако, использовать макросы таким способам позволяет лишь комбинация GCC, GDB и специальных опций: если вы не используете GCC (или если вы используете более старую версию), у вас все еще есть проблема. Мы придерживаемся своей рекомендации избегать по возможности таких макросов.</p>
       </cite>
       <p>Проблема с макросами распространяется также и на фрагменты кода. Если макрос определяет несколько операторов, вы не можете установить контрольную точку в середине макроса. Это верно также для inline-функций C99 и С++: если компилятор заменяет тело inline-функции сгенерированным кодом, снова невозможно или трудно установить внутри него контрольную точку. Это имеет связь с нашим советом компилировать лишь с одной опцией <code>-g</code>; в этом случае компиляторы обычно не используют inline-функции.</p>
       <p>Обычно с такими строками используется переменная, представляющая определенное состояние. Довольно просто, и это рекомендуется многими книгами по программированию на С, определять с помощью <code>#define</code> для таких состояний именованные константы. Например:</p>
       <p><code>/* Различные состояния, в которых можно</code></p>
       <p><code>   находиться при поиске конца записи. */</code></p>
       <p><code>#define NOSTATE  1 /* сканирование еще не началось (все) */</code></p>
       <p><code>#define INLEADER 2 /* пропуск начальных данных (RS = "") */</code></p>
       <p><code>#define INDATA   3 /* в теле записи (все) */</code></p>
       <p><code>#define INTERM   4 /* терминатор сканирования (RS = RS = regexp) */</code></p>
       <empty-line/>
       <p><code>int state;</code></p>
       <p><code>...</code></p>
       <p><code>state = NOSTATE;</code></p>
       <p><code>...</code></p>
       <p><code>state = INLEADER;</code></p>
       <p><code>...</code></p>
       <p><code>if (state != INTERM) ...</code></p>
       <p>На уровне исходного кода это выглядит замечательно. Но опять-таки, есть проблема, когда вы пытаетесь просмотреть код из GDB:</p>
       <p><code>(gdb) <strong>print state</strong></code></p>
       <p><code>$1 = 2</code></p>
       <p>Здесь вы также вынуждены возвращаться обратно и смотреть в заголовочный файл, чтобы выяснить, что означает 2. Какова же альтернатива?</p>
       <p><strong>Рекомендация</strong>: Для определения именованных констант используйте вместо макросов перечисления (enum). Использование исходного кода такое же, а значения enum может выводить также и отладчик.</p>
       <p>Пример, тоже из <code>io.c</code> в <code>gawk</code>:</p>
       <p><code>typedef enum scanstate {</code></p>
       <p><code> NOSTATE,  /* сканирование еще не начато (все) */</code></p>
       <p><code> INLEADER, /* пропуск начальных данных (RS = "") */</code></p>
       <p><code> INDATA,   /* в теле записи (все) */</code></p>
       <p><code> INTERM,   /* терминатор сканирования (RS = "", RS = regexp) */</code></p>
       <p><code>} SCANSTATE;</code></p>
       <p><code>SCANSTATE state;</code></p>
       <p><code>/* ... остальной код без изменений! ... */</code></p>
       <p>Теперь при просмотре state из GDB мы видим что-то полезное:</p>
       <p><code>(gdb) <strong>print state</strong></code></p>
       <p><code>$1 = NOSTATE</code></p>
      </section>
      <section>
       <title>
        <p>15.4.1.3. При необходимости переставляйте код</p>
       </title>
       <p>Довольно часто условие в <code>if</code> или <code>while</code> состоит из нескольких проверок, разделенных <code>&amp;&amp;</code> или <code>||</code>. Если эти проверки являются вызовами функций (или даже не являются ими), невозможно осуществить пошаговое прохождение каждой отдельной части условия. Команды GDB <code>step</code> и <code>next</code> работают на основе <emphasis>операторов (statements)</emphasis>, а не <emphasis>выражений (expressions)</emphasis>. (Разнесение их по нескольким строкам все равно не помогает).</p>
       <p><strong>Рекомендация</strong>: перепишите исходный код, явно используя временные переменные, в которых сохраняются значения или условные результаты, так что вы можете проверить их в отладчике. Первоначальный код должен быть сохранен в комментарии, чтобы вы (или программист после вас) могли сказать, что происходит.</p>
       <p>Вот конкретный пример: функция <code>do_input()</code> из файла <code>io.c gawk</code>:</p>
       <p><code>1  /* do_input --- главный цикл обработки ввода */</code></p>
       <p><code>2</code></p>
       <p><code>3  void</code></p>
       <p><code>4  do_input()</code></p>
       <p><code>5  {</code></p>
       <p><code>6   IOBUF *iop;</code></p>
       <p><code>7   extern int exiting;</code></p>
       <p><code>8   int rval1, rval2, rval3;</code></p>
       <p><code>9</code></p>
       <p><code>10  (void)setjmp(filebuf); /* for 'nextfile' */</code></p>
       <p><code>11</code></p>
       <p><code>12  while ((iop = nextfile(FALSE)) != NULL) {</code></p>
       <p><code>13   /*</code></p>
       <p><code>14    * Здесь было:</code></p>
       <p><code>15    if (inrec(iop) == 0)</code></p>
       <p><code>16     while (interpret(expression_value) &amp;&amp; inrec(iop) == 0)</code></p>
       <p><code>17      continue;</code></p>
       <p><code>18    * Теперь развернуто для простоты отладки.</code></p>
       <p><code>19    */</code></p>
       <p><code>20   rvall = inrec(iop);</code></p>
       <p><code>21   if (rvall == 0) {</code></p>
       <p><code>22    for (;;) {</code></p>
       <p><code>23     rval2 = rval3 = -1; /* для отладки */</code></p>
       <p><code>24     rval2 = interpret(expression_value);</code></p>
       <p><code>25     if (rval2 != 0)</code></p>
       <p><code>26      rval3 = inrec(iop);</code></p>
       <p><code>27     if (rval2 == 0 || rval3 != 0)</code></p>
       <p><code>28      break;</code></p>
       <p><code>29    }</code></p>
       <p><code>30   }</code></p>
       <p><code>31   if (exiting)</code></p>
       <p><code>32    break;</code></p>
       <p><code>33  }</code></p>
       <p><code>34 }</code></p>
       <p>(Номера строк приведены относительно начала этой процедуры, а не файла.) Эта функция является основой главного цикла обработки <code>gawk</code>. Внешний цикл (строки 12 и 33) проходит через файлы данных командной строки. Комментарий в строках 13–19 показывает оригинальный код, который читает из текущего файла каждую запись и обрабатывает ее</p>
       <p>Возвращаемое <code>inrec()</code> значение 0 означает, что все в порядке, тогда как ненулевое возвращаемое значение <code>interpret()</code> означает, что все в порядке. Когда мы попытались пройти через этот цикл, проверяя процесс чтения записей, возникла необходимость выполнить каждый шаг отдельно.</p>
       <p>Строки 20–30 представляют переписанный код, который вызывает каждую функцию отдельно, сохраняя возвращаемые значения в локальных переменных, чтобы их можно было напечатать из отладчика. Обратите внимание, как в строке 23 этим переменным каждый раз присваиваются известные, ошибочные значения: в противном случае они могли бы сохранить свои значения от предыдущих итераций цикла. Строка 27 является тестом завершения, поскольку код изменился, превратившись в бесконечный цикл (сравните строку 22 со строкой 16), тест завершения цикла является противоположным первоначальному.</p>
       <p>В качестве отступления, мы признаемся, что нам пришлось тщательно изучить переделку, когда мы ее сделали, чтобы убедиться, что она точно соответствует первоначальному коду; она соответствовала. Теперь нам кажется, что, возможно, вот эта версия цикла была бы ближе к оригиналу:</p>
       <p><code>/* Возможная замена для строк 22 - 29 */</code></p>
       <p><code>do {</code></p>
       <p><code> rval2 = rval3 = -1; /* для отладки */</code></p>
       <p><code> rval2 = interpret(expression_value);</code></p>
       <p><code> if (rval2 != 0)</code></p>
       <p><code>  rval3 = inrec(iop);</code></p>
       <p><code>} while (rval2 != 0 &amp;&amp; rval3 == 0);</code></p>
       <p>Правда в том, что обе версии труднее воспринимать, чем оригинал, и поэтому, возможно, содержат ошибки. Однако, поскольку текущий код работает, мы решили оставить как есть.</p>
       <p>Наконец, мы обращаем внимание, что не все программисты-эксперты согласились бы здесь с нашим советом. Когда каждый компонент условия является вызовом функции, можно установить на каждую контрольную точку, использовать <code>step</code> для входа в каждую функцию, а затем использовать <code>finish</code> для ее завершения. GDB сообщит вам возвращаемое функцией значение, и с этого места вы можете использовать для продолжения <code>cont</code> или <code>step</code>. Нам нравится наш подход, поскольку результаты сохраняются в переменных, которые можно проверить (и неоднократно) после вызова функции и даже спустя несколько операторов.</p>
      </section>
      <section>
       <title>
        <p>15.4.1.4. Используйте вспомогательные функции отладки</p>
       </title>
       <p>Типичной методикой, применимой во многих случаях, является использование набора значений <emphasis>флагов</emphasis>; когда флаг <emphasis>установлен</emphasis> (т.е. равен true), имеет место определенный факт или применяется определенное условие. Обычно это осуществляется при помощи именованных констант <code>#define</code> и битовых операторов С. (Использование битовых флагов и операторы работы с битами мы обсуждали во врезке к разделу 8.3.1 «Стиль POSIX: <code>statvfs()</code> и <code>fstatvfs()</code>».)</p>
       <p>Например, главная структура данных <code>gawk</code> называется <code>NODE</code>. У нее большое количество полей, последнее из которых является набором значений флагов. Из файла <code>awk.h</code>:</p>
       <p><code>typedef struct exp_node {</code></p>
       <p><code> /* ... Куча материала опущена */</code></p>
       <p><code> unsigned short flags;</code></p>
       <p><code>#define MALLOC       1 /* может быть освобожден */</code></p>
       <p><code>#define TEMP         2 /* должен быть освобожден */</code></p>
       <p><code>#define PERM         4 /* не может быть освобожден */</code></p>
       <p><code>#define STRING       8 /* назначен в виде строки */</code></p>
       <p><code>#define STRCUR      16 /* текущее значение строковое */</code></p>
       <p><code>#define NUMCUR      32 /* текущее значение числовое */</code></p>
       <p><code>#define NUMBER      64 /* назначен в виде числа */</code></p>
       <p><code>#define MAYBE_NUM  128 /* ввод пользователя: если NUMERIC, тогда</code></p>
       <p><code>                        * NUMBER */</code></p>
       <p><code>#define ARRAYMAXED 256 /* размер массива максимальный */</code></p>
       <p><code>#define FUNC       512 /* параметр представляет имя функции;</code></p>
       <p><code>                        * см. awkgram.y */</code></p>
       <p><code>#define FIELD     1024 /* это является полем */</code></p>
       <p><code>#define INTLSTR   2048 /* использовать локализованную версию */</code></p>
       <p><code>} NODE;</code></p>
       <p>Причина для использования значений флагов заключается в том, что они значительно экономят пространство данных. Если бы структура <code>NODE</code> для каждого флага использовала отдельное поле <code>char</code>, потребовалось бы 12 байтов вместо 2, используемых <code>unsigned short</code>. Текущий размер <code>NODE</code> (на Intel x86) 32 байта. Добавление лишних 10 байтов увеличило бы ее до 42 байтов. Поскольку <code>gawk</code> может потенциально выделять сотни и тысячи (или даже миллионы) <code>NODE</code><a l:href="#n170" type="note">[170]</a>, сохранение незначительного размера является важным.</p>
       <p>Что это должно делать с отладкой? Разве мы не рекомендовали только что использовать для именованных констант <code>enum</code>? Ну, в случае объединяемых побитовыми ИЛИ значений <code>enum</code> не помогают, поскольку они больше не являются индивидуально распознаваемыми!</p>
       <p><strong>Рекомендация</strong>: предусмотрите функцию для преобразования флагов в строки. Если у вас есть несколько независимых флагов, установите процедуру общего назначения.</p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. Необычность этих функций отладки заключается в том, что код приложения никогда их не вызывает. Они существуют лишь для того, чтобы их можно было вызывать из отладчика. Такие функции всегда должны быть откомпилированы с кодом, даже без окружающих <code>#ifdef</code>, чтобы их можно было использовать. не предпринимая никаких дополнительных шагов. Увеличение (обычно минимальное) размера кода оправдывается экономией времени разработчика</p>
       </cite>
       <p>Сначала мы покажем вам, как мы это делали первоначально. Вот (сокращенная версия) <code>flags2str()</code> из ранней версии <code>gawk</code> (3.0.6):</p>
       <p><code>1  /* flags2str --- делает значения флагов удобочитаемыми */</code></p>
       <p><code>2</code></p>
       <p><code>3  char *</code></p>
       <p><code>4  flags2str(flagval)</code></p>
       <p><code>5  int flagval;</code></p>
       <p><code>6  {</code></p>
       <p><code>7   static char buffer[BUFSIZ];</code></p>
       <p><code>8   char *sp;</code></p>
       <p><code>9</code></p>
       <p><code>10  sp = buffer;</code></p>
       <p><code>11</code></p>
       <p><code>12  if (flagval &amp; MALLOC) {</code></p>
       <p><code>13   strcpy(sp, "MALLOC");</code></p>
       <p><code>14   sp += strlen(sp);</code></p>
       <p><code>15  }</code></p>
       <p><code>16  if (flagval &amp; TEMP) {</code></p>
       <p><code>17   if (sp &gt;= buffer)</code></p>
       <p><code>18   *sp++ = '|';</code></p>
       <p><code>19   strcpy(sp, "TEMP");</code></p>
       <p><code>20   sp += strlen(sp);</code></p>
       <p><code>21  }</code></p>
       <p><code>22  if (flagval &amp; PERM) {</code></p>
       <p><code>23   if (sp != buffer)</code></p>
       <p><code>24    *sp++ = '|';</code></p>
       <p><code>25   strcpy(sp, "PERM");</code></p>
       <p><code>26   sp += strlen(sp);</code></p>
       <p><code>27  }</code></p>
       <p><code>    /* ...многое то же самое, опущено для краткости... */</code></p>
       <p><code>82</code></p>
       <p><code>83  return buffer;</code></p>
       <p><code>84 }</code></p>
       <p>(Номера строк даны относительно начала функции.) Результатом является строка, что- то наподобие "<code>MALLOC | PERM | NUMBER</code>". Каждый флаг тестируется отдельно, и если он присутствует, действие каждый раз одно и то же: проверка того, что он не в начале буфера и что можно добавить символ '<code>|</code>', скопировать строку на место и обновить указатель. Сходные функции существовали для форматирования и отображения других видов флагов в программе.</p>
       <p>Этот код является повторяющимся и склонным к ошибкам, и для <code>gawk</code> 3.1 мы смогли упростить и обобщить его. Вот как <code>gawk</code> делает это сейчас. Начиная с этого определения в <code>awk.h</code>:</p>
       <p><code>/* для целей отладки */</code></p>
       <p><code>struct flagtab {</code></p>
       <p><code> int val;          /* Целое значение флага */</code></p>
       <p><code> const char *name; /* Строковое имя */</code></p>
       <p><code>};</code></p>
       <p>Эту структуру можно использовать для представления любого набора флагов с соответствующими строковыми значениями. Каждая отдельная группа флагов имеет соответствующую функцию, которая возвращает печатное представление флагов, которые установлены в настоящее время. Из <code>eval.c</code>:</p>
       <p><code>/* flags2str --- делает значения флагов удобочитаемыми */</code></p>
       <empty-line/>
       <p><code>const char *flags2str(int flagval) {</code></p>
       <p><code> static const struct flagtab values[] = {</code></p>
       <p><code>  { MALLOC, "MALLOC" },</code></p>
       <p><code>  { TEMP, "TEMP" },</code></p>
       <p><code>  { PERM, "PERM" },</code></p>
       <p><code>  { STRING, "STRING" },</code></p>
       <p><code>  { STRCUR, "STRCUR" },</code></p>
       <p><code>  { NUMCUR, "NUMCUR" },</code></p>
       <p><code>  { NUMBER, "NUMBER" },</code></p>
       <p><code>  { MAYBE_NUM, "MAYBE_NUM" },</code></p>
       <p><code>  { ARRAYMAXED, "ARRAYMAXED" },</code></p>
       <p><code>  { FUNC, "FUNC" },</code></p>
       <p><code>  { FIELD, "FIELD" },</code></p>
       <p><code>  { INTLSTR, "INTLSTR" },</code></p>
       <p><code>  { 0, NULL },</code></p>
       <p><code> };</code></p>
       <empty-line/>
       <p><code> return genflags2str(flagval, values);</code></p>
       <p><code>}</code></p>
       <p><code>flags2str()</code> определяет массив сопоставлений флагов со строками. По соглашению, значение флага 0 означает конец массива. Код вызывает для осуществления работы <code>genflags2str()</code> («общий флаг в строку»). <code>getflags2str()</code> является процедурой общего назначения, которая преобразует значение флага в строку. Из <code>eval.c</code>:</p>
       <p><code>1  /* genflags2str --- общая процедура для преобразования значения флага в строковое представление */</code></p>
       <p><code>2</code></p>
       <p><code>3  const char *</code></p>
       <p><code>4  genflags2str(int flagval, const struct flagtab *tab)</code></p>
       <p><code>5  {</code></p>
       <p><code>6   static char buffer(BUFSIZ];</code></p>
       <p><code>7   char *sp;</code></p>
       <p><code>8   int i, space_left, space_needed;</code></p>
       <p><code>9</code></p>
       <p><code>10  sp = buffer;</code></p>
       <p><code>11  space_left = BUFSIZ;</code></p>
       <p><code>12  for (i = 0; tab[i].name != NULL; i++) {</code></p>
       <p><code>13   if ((flagval &amp; tab[i].val) != 0) {</code></p>
       <p><code>14    /*</code></p>
       <p><code>15     * обратите внимание на уловку, нам нужны 1 или 0, чтобы</code></p>
       <p><code>16     * определить, нужен ли нам символ '|'.</code></p>
       <p><code>17     */</code></p>
       <p><code>18    space_needed = (strlen(tab[i].name) + (sp != buffer));</code></p>
       <p><code>19    if (space_left &lt; space_needed)</code></p>
       <p><code>20     fatal(_("buffer overflow in genflags2str"));</code></p>
       <p><code>21</code></p>
       <p><code>22    if (sp &gt;= buffer) {</code></p>
       <p><code>23     *sp++ = '|';</code></p>
       <p><code>24     space_left--;</code></p>
       <p><code>25    }</code></p>
       <p><code>26    strcpy(sp, tab[i].name);</code></p>
       <p><code>27    /* обратите внимание на расположение! */</code></p>
       <p><code>28    space_left -= strlen(sp);</code></p>
       <p><code>29    sp += strlen(sp);</code></p>
       <p><code>30   }</code></p>
       <p><code>31  }</code></p>
       <p><code>32</code></p>
       <p><code>33  return buffer;</code></p>
       <p><code>34 }</code></p>
       <p>(Номера строк приведены относительно начала функции, а не файла.) Как и в предыдущей версии, идея заключалась в заполнении статического буфера строковыми значениями, такими, как "<code>MALLOC | PERM | STRING | MAYBE_NUM</code>", и возвращении адреса этого буфера. Мы вскоре обсудим причины использования статического буфера; сначала давайте исследуем код.</p>
       <p>Указатель <code>sp</code> отслеживает положение следующего пустого слота в буфере, тогда как <code>space_left</code> отслеживает количество оставшегося места; это уберегает нас от переполнения буфера.</p>
       <p>Основную часть функции составляет цикл (строка 12), проходящий через массив значений флагов. Когда флаг найден (строка 13), код вычисляет, сколько места требуется строке (строка 18) и проверяет, осталось ли столько места (строки 19–20).</p>
       <p>Тест '<code>sp ! = buffer</code>' для первого значения флага завершается неудачей, возвращая 0. Для последующих флагов тест дает значение 1. Это говорит нам, что между значениями должен быть вставлен разделительный символ '<code>|</code>'. Добавляя результат (1 или 0) к длине строки, мы получаем правильное значение <code>space_needed</code>. Тот же тест с той же целью проводится в строке 22 для проверки строк 23 и 24, которые вставляют символ '<code>|</code>'.</p>
       <p>В заключение строки 26–29 копируют значение строки, выверяют количество оставшегося места и обновляют указатель <code>sp</code>. Строка 33 возвращает адрес буфера, который содержит печатное представление строки.</p>
       <p>Теперь несколько слов относительно статического буфера. Обычно хорошая практика программирования не одобряет использование функций, возвращающих адреса статических буферов: множественные вызовы таких функций каждый раз переписывают буфер, вынуждая вызывающего копировать возвращенные данные.</p>
       <p>Более того, статический буфер по определению является буфером фиксированного размера. Что случилось с принципом GNU «никаких произвольных ограничений»?</p>
       <p>Для ответа на эти вопросы нужно вспомнить, что это <emphasis>отладочная</emphasis> функция. Обычный код никогда не вызывает <code>getflags2str()</code>; она вызывается лишь человеком, использующим отладчик. Ни у одного вызывающего нет указателя на буфер; как разработчику, осуществляющему отладку, нам нет дела до того, что буфер каждый раз переписывается при вызове функции.</p>
       <p>На практике фиксированный размер также не является проблемой; мы знаем, что размер <code>BUFSIZ</code> достаточен для представления всех флагов, которые мы используем. Тем не менее, поскольку мы опытные и знаем, что вещи могут измениться, в <code>getflags2str()</code> есть код, предохраняющий себя от переполнения буфера. (Переменная <code>space_left</code> и код в строках 18–20.)</p>
       <p>В качестве отступления, использование <code>BUFSIZ</code> спорно. Эта константа должна использоваться исключительно для буферов ввода/вывода, но часто она используется также для общих строковых буферов. Такой код лучше убрать, определив явные константы, такие, как <code>FLAGVALSIZE</code>, и использовав в строке 11 '<code>sizeof (buffer)</code>'.</p>
       <p>Вот сокращенный сеанс GDB, показывающий использование <code>flags2str()</code>:</p>
       <p><code>$ <strong>gdb gawk</strong> /* Запустить GDB с gawk */</code></p>
       <p><code>GNU gdb 5.3</code></p>
       <p><code>...</code></p>
       <p><code>(gdb) <strong>break do_print</strong> /* Установить контрольную точку */</code></p>
       <p><code>Breakpoint 1 at 0x805a584: file builtin.c, line 1547.</code></p>
       <p><code>(gdb) <strong>run 'BEGIN { print "hello, world" }'</strong> /* Запустить программу */</code></p>
       <p><code>Starting program: /home/arnold/Gnu/gawk/gawk-3.1.4/gawk 'BEGIN { print "hello, world" }'</code></p>
       <p><code>Breakpoint 1, do_print (tree=0x80955b8) at builtin.c: 1547 /* Останова в контрольной точке */</code></p>
       <p><code>1547 struct redirect *rp = NULL;</code></p>
       <p><code>(gdb) <strong>print *tree</strong> /* Вывести NODE */</code></p>
       <p><code>$1 = {sub = {nodep =</code></p>
       <p><code> {1 = {lptr = 0x8095598, param_name = 0x8095598 "xU\t\b",</code></p>
       <p><code> ll = 134629464}, r = {rptr = 0x0, pptr = 0, preg = 0x0, hd = 0x0,</code></p>
       <p><code> av = 0x0, r_ent =0}, x = {extra = 0x0, xl = 0, param_list = 0x0},</code></p>
       <p><code> name = 0x0, number = 1, reflags = 0), val = {</code></p>
       <p><code> fltnum = 6.6614606209589101e-316, sp = 0x0, slen = 0, sref = 1,</code></p>
       <p><code> idx = 0}, hash = {next = 0x8095598, name = 0x0, length = 0, value = 0x0,</code></p>
       <p><code> ref = 1}}, type = Node_K_print, flags = 1}</code></p>
       <p><code>(gdb) <strong>print flags2str(tree-&gt;flags)</strong> /* Вывести значение флага */</code></p>
       <p><code>$2 = 0x80918a0 "MALLOC"</code></p>
       <p><code>(gdb) <strong>next</strong> /* Продолжить */</code></p>
       <p><code>1553 fp = redirect_to_fp(tree-&gt;rnode, &amp;rp);</code></p>
       <p><code>...</code></p>
       <p><code>1588 efwrite(t[i]-&gt;stptr, sizeof(char), t[i]-&gt;stlen, fp, "print", rp, FALSE);</code></p>
       <p><code>(gdb) <strong>print *t[i]</strong> /* Снова вывести NODE */</code></p>
       <p><code>$4 = {sub = {nodep =</code></p>
       <p><code> {l = {lptr = 0x8095598, parm_name = 0x8095598 "xU\t\b",</code></p>
       <p><code> ll = 134829464}, r = {rptr = 0x0, pptr = 0, preg = 0x0, hd = 0x0,</code></p>
       <p><code> av = 0x0, r_ent =0), x = {extra = 0x8095ad8, xl = 134830808,</code></p>
       <p><code> param_list = 0x8095ad8}, name = 0xc &lt;Address 0xc out of bounds&gt;,</code></p>
       <p><code> number = 1, reflags = 4294967295}, val = {</code></p>
       <p><code> fltnum = 6.6614606209589101e-316, sp = 0x8095ad8 "hello, world",</code></p>
       <p><code> slen = 12, sref = 1, idx = -1}, hash = {next = 0x8095598, name = 0x0,</code></p>
       <p><code> length = 134830808, value = 0xc, ref = 1}}, type = Node_val, flags = 29}</code></p>
       <p><code>(gdb) <strong>print flags2str(t[i]-&gt;flags)</strong> /* Вывести значение флага */</code></p>
       <p><code>$5 = 0x80918a0 "MALLOC|PERM|STRING|STRCUR"</code></p>
       <p>Надеемся, вы согласитесь, что настоящий механизм общего назначения значительно более элегантный и более простой в использовании, чем первоначальный.</p>
       <p>Тщательное проектирование и использование массивов структур часто может заменить или слить воедино повторяющийся код.</p>
      </section>
      <section>
       <title>
        <p>15.4.1.5. По возможности избегайте объединений</p>
       </title>
       <epigraph>
        <p>«Не бывает бесплатных обедов»</p>
        <text-author>- Lazarus Long -</text-author>
       </epigraph>
       <p><code>union</code> С относительно эзотерическая возможность. Она помогает экономить память, сохраняя различные элементы в одном и том же физическом пространстве; как программа интерпретирует его, зависит от способа доступа:</p>
       <p><code>/* ch15-union.c --- краткая демонстрация использования union. */</code></p>
       <p><code>#include &lt;stdio.h&gt;</code></p>
       <empty-line/>
       <p><code>int main(void) {</code></p>
       <p><code> union i_f {</code></p>
       <p><code>  int i;</code></p>
       <p><code>  float f;</code></p>
       <p><code> } u;</code></p>
       <empty-line/>
       <p><code> u.f = 12.34; /* Присвоить значение с плавающей точкой */</code></p>
       <p><code> printf("%f also looks like %#x\n", u.f, u.i};</code></p>
       <p><code> exit(0);</code></p>
       <p><code>}</code></p>
       <p>Вот что происходит, когда программа запускается на системе Intel x86 GNU/Linux:</p>
       <p><code>$ <strong>ch15-union</strong></code></p>
       <p><code>12.340000 also looks like 0x414570a4</code></p>
       <p>Программа выводит битовый паттерн, который представляет число с плавающей точкой в виде шестнадцатеричного целого. Оба поля занимают одно и то же место в памяти; разница в том, как этот участок памяти интерпретируется: <code>u.f</code> действует, как число с плавающей точкой, тогда как эти же биты в <code>u.i</code> действуют, как целое число.</p>
       <p>Объединения особенно полезны в компиляторах и интерпретаторах, которые часто создают древовидные структуры, представляющие структуру файла с исходным кодом (которая называется деревом <emphasis>грамматического разбора (parse tree)</emphasis>). Это моделирует то, как формально описаны языки программирования: операторы <code>if</code>, операторы <code>while</code>, операторы присваивания и так далее для всех экземпляров более общего типа «оператора». Таким образом, в компиляторе могло бы быть нечто подобное этому:</p>
       <p><code>struct if_stmt { ... }; /* Структура для оператора IF */</code></p>
       <p><code>struct while_stmt { ... }; /* Структура для оператора WHILE */</code></p>
       <p><code>struct for_stmt { ... }; /* Структура для оператора */</code></p>
       <p><code>/* ...структуры для других типов операторов... */</code></p>
       <empty-line/>
       <p><code>typedef enum stmt_type {</code></p>
       <p><code> IF, WHILE, FOR, ...</code></p>
       <p><code>} TYPE; /* Что у нас есть в действительности */</code></p>
       <p><code>/* Здесь содержатся тип и объединения отдельных видов операторов. */</code></p>
       <p><code>struct statement {</code></p>
       <p><code> TYPE type;</code></p>
       <p><code> union stmt {</code></p>
       <p><code>  struct if_stmt if_st;</code></p>
       <p><code>  struct while_stmt while_st;</code></p>
       <p><code>  struct for_stmt for_st;</code></p>
       <p><code>  ...</code></p>
       <p><code> } u;</code></p>
       <p><code>};</code></p>
       <p>Вместе с объединением удобно использовать макрос, который представляет компоненты объединения, как если бы они были полями структуры. Например:</p>
       <p><code>#define if_s u.if_st /* Так что можно использовать s-&gt;if_s вместо s-&gt;u.if_st */</code></p>
       <p><code>#define while_s u.while_st /* И так далее... */</code></p>
       <p><code>#define for_s u.for_st</code></p>
       <p><code>...</code></p>
       <p>На только что представленном уровне это кажется разумным и выглядит осуществимым. В действительности, однако, все сложнее, и в реальных компиляторах и интерпретаторах часто есть несколько уровней вложенных структур и объединений. Сюда относится и <code>gawk</code>, в котором определение <code>NODE</code>, значение его флагов и макросов для доступа к компонентам объединения занимают свыше 120 строк!<a l:href="#n171" type="note">[171]</a> Здесь достаточно определений, чтобы дать вам представление о том, что происходит:</p>
       <p><code>typedef struct exp_node {</code></p>
       <p><code> union {</code></p>
       <p><code>  struct {</code></p>
       <p><code>   union {</code></p>
       <p><code>    struct exp_node *lptr;</code></p>
       <p><code>    char *param_name;</code></p>
       <p><code>    long ll;</code></p>
       <p><code>   } l;</code></p>
       <p><code>   union {</code></p>
       <p><code>    ...</code></p>
       <p><code>   } r;</code></p>
       <p><code>   union {</code></p>
       <p><code>    ...</code></p>
       <p><code>   } x;</code></p>
       <p><code>   char *name;</code></p>
       <p><code>   short number;</code></p>
       <p><code>   unsigned long reflags;</code></p>
       <p><code>   ...</code></p>
       <p><code>  } nodep;</code></p>
       <p><code>  struct {</code></p>
       <p><code>   AWKNUM fltnum;</code></p>
       <p><code>   char *sp;</code></p>
       <p><code>   size_t slen;</code></p>
       <p><code>   long sref;</code></p>
       <p><code>   int idx;</code></p>
       <p><code>  } val;</code></p>
       <p><code>  struct {</code></p>
       <p><code>   struct exp_node *next;</code></p>
       <p><code>   char *name;</code></p>
       <p><code>   size_t length;</code></p>
       <p><code>   struct exp_node *value;</code></p>
       <p><code>   long ref;</code></p>
       <p><code>  } hash;</code></p>
       <p><code>#define hnext sub.hash.next</code></p>
       <p><code>#define hname sub.hash.name</code></p>
       <p><code>#define hlength sub.hash.length</code></p>
       <p><code>#define hvalue sub.hash.value</code></p>
       <p><code>  ...</code></p>
       <p><code> } sub;</code></p>
       <p><code> NODETYPE type;</code></p>
       <p><code> unsigned short flags;</code></p>
       <p><code> ...</code></p>
       <p><code>} NODE;</code></p>
       <empty-line/>
       <p><code>#define vname sub.nodep.name</code></p>
       <p><code>#define exec_count sub.nodep.reflags</code></p>
       <empty-line/>
       <p><code>#define lnode sub.nodep.l.lptr</code></p>
       <p><code>#define nextp sub.nodep.l.lptr</code></p>
       <p><code>#define source_file sub.nodep.name</code></p>
       <p><code>#define source_line sub.nodep.number</code></p>
       <p><code>#define param_cnt sub.nodep.number</code></p>
       <p><code>#define param sub.nodep.l.param_name</code></p>
       <empty-line/>
       <p><code>#define stptr sub.val.sp</code></p>
       <p><code>#define stlen sub.val.slen</code></p>
       <p><code>#define stref sub.val.sref</code></p>
       <p><code>#define stfmt sub.val.idx</code></p>
       <p><code>#define var_value lnode</code></p>
       <p><code>...</code></p>
       <p>В <code>NODE</code> есть объединение внутри структуры внутри объединения внутри структуры! (Ой.) Поверх всего этого многочисленные «поля» макросов соответствуют одним и тем же компонентам <code>struct</code>/<code>union</code> в зависимости от того, что на самом деле хранится в <code>NODE</code>! (Снова ой.)</p>
       <p>Преимуществом такой сложности является то, что код С сравнительно ясный. Нечто вроде '<code>NF_node-&gt;var_value-&gt;slen</code>' читать просто.</p>
       <p>У такой гибкости, которую предоставляют объединения, конечно, есть своя цена. Когда отладчик находится глубоко во внутренностях вашего кода, вы не можете использовать симпатичные макросы, которые имеются в исходном коде. Вы <emphasis>должны</emphasis> использовать развернутое значение.<a l:href="#n172" type="note">[172]</a> (А для этого придется найти в заголовочном файле соответствующее определение.)</p>
       <p>Например, сравните '<code>NF_node-&gt;var_value-&gt;slen</code>' с развернутой формой: '<code>NF_node-&gt;sub.nodep.l.lptr-&gt;sub.val.slen</code>'! Чтобы увидеть значение данных, вы должны набрать последнее в GDB. Взгляните снова на это извлечение из приведенного ранее сеанса отладки GDB:</p>
       <p><code>(gdb) <strong>print *tree</strong> /* Вывести NODE */</code></p>
       <p><code>$1 = {sub = {nodep =</code></p>
       <p><code> {1 = {lptr = 0x8095598, param_name = 0x8095598 "xU\t\b",</code></p>
       <p><code> ll = 134829464}, r = {rptr = 0x0, pptr = 0, preg = 0x0,</code></p>
       <p><code> hd = 0x0, av = 0x0, r_ent =0), x = {extra = 0x0, xl = 0,</code></p>
       <p><code> param_list = 0x0}, name = 0x0, number = 1, reflags = 0},</code></p>
       <p><code> val = { fltnum = 6.6614606209589101e-316, sp = 0x0,</code></p>
       <p><code> slen = 0, sref = 1, idx = 0),</code></p>
       <p><code> hash = {next = 0x8095598, name = 0x0, length = 0,</code></p>
       <p><code> value = 0x0, ref = 1}}, type = Node_K_print, flags = 1}</code></p>
       <p>Это куча вязкой массы. Однако, GDB все же несколько упрощает ее обработку. Вы можете использовать выражения вроде '<code>($1).sub.val.slen</code>', чтобы пройти через дерево и перечислить структуры данных.</p>
       <p>Есть другие причины для избегания объединений. Прежде всего, объединения <emphasis>не проверяются</emphasis>. Ничто, кроме внимания программиста, не гарантирует, что когда вы получаете доступ к одной части объединения, вы получаете доступ к той части, которая была сохранена последней. Мы видели это в <code>ch15-union.c</code>, в котором доступ к обоим «элементам» объединения осуществлялся одновременно.</p>
       <p>Вторая причина, связанная с первой, заключается в осторожности с перекрытиями вложенных комбинаций <code>struct</code>/<code>union</code>. Например, в предыдущей версии <code>gawk</code><a l:href="#n173" type="note">[173]</a> был такой код.</p>
       <p><code>/* n-&gt;lnode перекрывает размер массива, не вызывайте unref, если это массив */</code></p>
       <p><code>if (n-&gt;type != Node_var_array &amp;&amp; n-&gt;type != Node_array_ref)</code></p>
       <p><code>unref(n-&gt;lnode);</code></p>
       <p>Первоначально <code>if</code> не было, был только вызов <code>unref()</code>, которая освобождает <code>NODE</code>, на которую указывает <code>n-&gt;lnode</code>. Однако, в этот момент <code>gawk</code> могла создать аварийную ситуацию. Можете себе представить, сколько времени потребовало отслеживание в отладчике того факта, что то, что рассматривалось как указатель, на самом деле было размером массива!</p>
       <p>В качестве отступления, объединения значительно менее полезны в С++. Наследование и объектно-ориентированные возможности создают при управлении структурами данных совсем другую ситуацию, которая значительно безопаснее.</p>
       <p><strong>Рекомендация</strong>: по возможности избегайте объединений (<code>union</code>). Если это невозможно, тщательно проектируйте и программируйте их!</p>
      </section>
     </section>
     <section>
      <title>
       <p>15.4.2. Отлаживаемый код времени исполнения</p>
      </title>
      <section>
       <p>Помимо тех вещей, которые вы добавляете к своему коду для времени компиляции, можно также добавить дополнительный код для обеспечения возможностей отладки времени исполнения. Это особенно полезно для приложений, которые устанавливаются в полевых условиях, когда в системе клиента не будет установленного исходного кода (а может быть, даже и компилятора!)</p>
       <p>В данном разделе представлены некоторые методики отладки, которые мы использовали в течение ряда лет, от простых до более сложных. Обратите внимание, что наше рассмотрение ни в коем случае не является исчерпывающим. Это область, в которой стоит иметь некоторое воображение и использовать его!</p>
      </section>
      <section>
       <title>
        <p>15.4.2.1. Добавляйте отладочные опции и переменные</p>
       </title>
       <p>Простейшей методикой является наличие опции командной строки, делающих возможным отладку. Такая опция может быть условно откомпилированной для отладки. Однако более гибким подходом является оставить опцию в <emphasis>готовой</emphasis> версии программы. (Вы можете также решить, оставлять или не оставлять эту опцию <emphasis>не документированной</emphasis>. Здесь есть различные компромиссы: ее документирование может дать возможность вашим покупателям или клиентам больше изучить внутренности вашей системы, чего вы можете не хотеть С другой стороны, не документирование ее кажется довольно подлым. Если вы пишете для Open Source или Free Software, лучше документировать опцию.)</p>
       <p>Если ваша программа большая, отладочная опция может принимать аргумент, указывающий, какую подсистему следует отлаживать. На основе этого аргумента можно установить различные флаговые переменные или, возможно, различные флаговые биты в одной отладочной переменной. Вот схема этой методики:</p>
       <p><code>struct option options[] = {</code></p>
       <p><code> ...</code></p>
       <p><code> { "debug", required_argument, NULL, 'D' },</code></p>
       <p><code> ...</code></p>
       <p><code>};</code></p>
       <empty-line/>
       <p><code>int main(int argc, char **argv) {</code></p>
       <p><code> int c;</code></p>
       <empty-line/>
       <p><code> while ((c = getopt_long(argc, argv, "...D:")) != -1) {</code></p>
       <p><code>  switch (c) {</code></p>
       <p><code>   ...</code></p>
       <p><code>  case 'D':</code></p>
       <p><code>   parse_debug(optarg);</code></p>
       <p><code>   break;</code></p>
       <p><code>   ...</code></p>
       <p><code>  }</code></p>
       <p><code> }</code></p>
       <p><code> ...</code></p>
       <p><code>}</code></p>
       <p>Функция <code>parse_debug()</code> считывает строку аргументов. Например, это может быть строка разделенных запятыми или пробелами подсистем, вроде "<code>file,memory,ipc</code>". Для каждого действительного имени подсистемы функция устанавливает бит в отладочной переменной:</p>
       <p><code>extern int debugging;</code></p>
       <p><code>void parse_debug(const char *subsystems) {</code></p>
       <p><code> char *sp;</code></p>
       <p><code> for (sp = subsystems; *sp != '\0';) {</code></p>
       <p><code>  if (strncmp(sp, "file", 4) == 0) {</code></p>
       <p><code>   debugging |= DEBUG_FILE;</code></p>
       <p><code>   sp += 4;</code></p>
       <p><code>  } else if (strncmp(sp, "memory", 6) == 0) {</code></p>
       <p><code>   debugging |= DEBUG_MEM;</code></p>
       <p><code>   sp += 6;</code></p>
       <p><code>  } else if (strncmp(sp, "ipc", 3) == 0) {</code></p>
       <p><code>   debugging |= DEBUG_IPC;</code></p>
       <p><code>   sp += 3;</code></p>
       <p><code>   ...</code></p>
       <p><code>  }</code></p>
       <p><code>  while (*sp == ' ' || *sp == ',') sp++;</code></p>
       <p><code> }</code></p>
       <p><code>}</code></p>
       <p>В конечном счете код приложения может затем проверить флаги:</p>
       <p><code>if ((debugging &amp; DEBUG_FILE) != 0) ...</code></p>
       <p><code> /* В части программы для ввода/вывода */</code></p>
       <empty-line/>
       <p><code>if ((debugging &amp; DEBUG_MEM) != 0) ... /* В менеджере памяти */</code></p>
       <p>Использовать ли одну переменную с флаговыми битами, различные переменные или даже отладочный массив, индексируемый именованными константами (желательно из <code>enum</code>), зависит от вас.</p>
       <p>Ценой оставления отладочного кода в исполняемом файле изделия является увеличение размера программы. В зависимости от размещения отладочного кода он может быть также более медленным, поскольку каждый раз осуществляются проверки, которые все время оказываются ложными, пока не будет включен режим отладки. И, как упоминалось, кто-нибудь может изучить вашу программу, что может быть неприемлемым для вас. Или еще хуже, недоброжелательный пользователь может включить столько отладочных возможностей, что программа замедлится до невозможности работать с ней! (Это называется <emphasis>атакой отказа в обслуживании (denial of service attack)</emphasis>.)</p>
       <p>Преимуществом, которое может быть большим, является то, что вашу уже установленную программу можно запустить с включенным режимом отладки без необходимости сначала построить, а затем загрузить специальную версию на сайт заказчика. Когда программное обеспечение установлено в удаленных местах, в которых может не быть людей и все, что вы можете сделать, это получить удаленный доступ к системе через Интернет (или, еще хуже, через медленное модемное соединение!), такая возможность может оказаться спасительным средством.</p>
       <p>Наконец, можно использовать смешанную методику: условно компилируемый отладочный код для детальной, точной отладки, а постоянно присутствующий код для более грубого вывода.</p>
      </section>
      <section>
       <title>
        <p>15.4.2.2. Используйте специальные переменные окружения</p>
       </title>
       <p>Другой полезной уловкой является проверка вашим приложением специальных переменных окружения (документированных или иных). Это может быть особенно полезным для тестирования. Вот другой пример из нашего опыта с <code>gawk</code>, но сначала немного основ.</p>
       <p><code>gawk</code> использует функцию с названием <code>optimal_bufsize()</code> для получения оптимального размера буфера для ввода/вывода. Для небольших файлов функция возвращает размер файла. В противном случае, если файловая система определяет размер для использования при вводе/выводе, возвращается это значение (член <code>st_blksize</code> структуры <code>struct stat</code>, см. раздел 5.4.2 «Получение информации о файле»). Если этот член недоступен, <code>optimal_bufsize()</code> возвращает константу <code>BUFSIZ</code> из <code>&lt;stdio.h&gt;</code>. Оригинальная функция (в <code>posix/gawkmisc.c</code>) выглядела следующим образом:</p>
       <p><code>1  /* optimal_bufsize --- определяет оптимальный размер буфера */</code></p>
       <p><code>2</code></p>
       <p><code>3  int</code></p>
       <p><code>4  optimal_bufsize(fd, stb) /* int optimal_bufsize(int fd, struct stat *stb); */</code></p>
       <p><code>5  int fd;</code></p>
       <p><code>6  struct stat *stb;</code></p>
       <p><code>7  {</code></p>
       <p><code>8   /* инициализировать все члены нулями на случай, если ОС не использует их все. */</code></p>
       <p><code>9   memset(stb, '\0', sizeof(struct stat));</code></p>
       <p><code>10</code></p>
       <p><code>11 /*</code></p>
       <p><code>12  * System V.n, n &lt; 4, не имеет в структуре stat размера</code></p>
       <p><code>13  * системного блока файла. Поэтому нам нужно сделать разумную</code></p>
       <p><code>14  * догадку. Мы используем BUFSIZ, поскольку именно это имелось</code></p>
       <p><code>15  * в виду на первом месте.</code></p>
       <p><code>16  */</code></p>
       <p><code>17 #ifdef HAVE_ST_BLKSIZE</code></p>
       <p><code>18 #define DEFBLKSIZE (stb-&gt;st_blksize ? stb-&gt;st_blksize : BUFSIZ)</code></p>
       <p><code>19 #else</code></p>
       <p><code>20 #define DEFBLKSIZE BUFSIZ</code></p>
       <p><code>21 #endif</code></p>
       <p><code>22</code></p>
       <p><code>23  if (isatty(fd))</code></p>
       <p><code>24   return BUFSIZ;</code></p>
       <p><code>25  if (fstat(fd, stb) == -1)</code></p>
       <p><code>26   fatal("can't stat fd %d (%s)", fd, strerror(errno));</code></p>
       <p><code>27  if (lseek(fd, (off_t)0, 0) == -1) /* не обычный файл */</code></p>
       <p><code>28   return DEFBLKSIZE;</code></p>
       <p><code>29  if (stb-&gt;st_size &gt; 0 &amp;&amp; stb-&gt;st_size &lt; DEFBLKSIZE) /* маленький файл */</code></p>
       <p><code>30   return stb-&gt;st_size;</code></p>
       <p><code>31  return DEFBLKSIZE;</code></p>
       <p><code>32 }</code></p>
       <p>Константа <code>DEFBLKSIZE</code> является «размером блока по умолчанию»; то есть значением из <code>struct stat</code> или <code>BUFSIZ</code>. Для терминалов (строка 23) или файлов, которые не являются обычными файлами (<code>lseek()</code> завершается неудачей, строка 27) возвращаемое значение также равно <code>BUFSIZ</code>. Для небольших обычных файлов используется размер файла. Во всех других случаях возвращается <code>DEFBLKSIZE</code>. Знание «оптимального» размера буфера особенно полезно в файловых системах, в которых размер блока <emphasis>больше</emphasis> <code>BUFSIZ</code>.</p>
       <p>У нас была проблема, когда один из наших контрольных примеров отлично работал на нашей рабочей системе GNU/Linux и на любой другой системе Unix, к которой у нас был доступ. Однако, этот тест последовательно терпел неудачу на других определенных системах.</p>
       <p>В течение длительного времени мы не могли получить непосредственный доступ к терпящей неудачу системе, чтобы запустить GDB. В конце концов, мы смогли, однако, ухитриться воспроизвести проблему. Она оказалась связана с размером буфера, который <code>gawk</code> использовал для чтения файлов данных: на терпящих неудачи системах размер буфера был больше, чем на нашей системе разработки.</p>
       <p>Нам был нужен способ воспроизведения проблемы на своей машине разработки, система с неудачей находилась в стороне за девять часовых поясов, а интерактивный запуск GDB через Атлантический океан мучителен. Мы воспроизвели проблему, заставив <code>optimal_bufsize()</code> проверять значение специальной переменной окружения <code>AWKBUFSIZE</code>. Когда ее значение равно <code>"exact"</code>, <code>optimal_bufsize()</code> всегда возвращает размер файла, каким бы он ни был. Если значением <code>AWKBUFSIZE</code> является какое-нибудь целое число, функция возвращает это число. В противном случае, функция возвращается к прежнему алгоритму. Это дает нам возможность запускать тесты, не требуя постоянной перекомпиляции <code>gawk</code>. Например,</p>
       <p><code>$ <strong>AWKBUFSIZE=42 make check</strong></code></p>
       <p>Это запускает тестовый набор <code>gawk</code> с использованием размера буфера в 42 байта. (Тестовый набор проходит.) Вот модифицированная версия <code>optimal_bufsize()</code>:</p>
       <p><code>1  /* optimal_bufsize --- определение оптимального размера буфера */</code></p>
       <p><code>2</code></p>
       <p><code>3  /*</code></p>
       <p><code>4   * В целях отладки усовершенствуйте это следующим образом:</code></p>
       <p><code>5   *</code></p>
       <p><code>6   * Всегда используйте stat для файла, буфер stat используется кодом</code></p>
       <p><code>7   * более высокого уровня.</code></p>
       <p><code>8   * if (AWKBUFSIZE == "exact")</code></p>
       <p><code>9   *  return the file size</code></p>
       <p><code>10  * else if (AWKBUFSIZE == число)</code></p>
       <p><code>11  *  всегда возвращать это число</code></p>
       <p><code>12  * else</code></p>
       <p><code>13  *  if размер &lt; default_blocksize</code></p>
       <p><code>14  *   return размер</code></p>
       <p><code>15  *  else</code></p>
       <p><code>16  *   return default_blocksize</code></p>
       <p><code>17  *  end if</code></p>
       <p><code>18  * end if</code></p>
       <p><code>19  *</code></p>
       <p><code>20  * Приходится повозиться, чтобы иметь дело с AWKBUFSIZE лишь</code></p>
       <p><code>21  * однажды, при первом вызове этой процедуры, а не при каждом</code></p>
       <p><code>22  * ее вызове. Производительность, знаете ли.</code></p>
       <p><code>23  */</code></p>
       <p><code>24</code></p>
       <p><code>25 size_t</code></p>
       <p><code>26 optimal_bufsize(fd, stb)</code></p>
       <p><code>27 int fd;</code></p>
       <p><code>28 struct stat *stb;</code></p>
       <p><code>29 {</code></p>
       <p><code>30  char *val;</code></p>
       <p><code>31  static size_t env_val = 0;</code></p>
       <p><code>32  static short first = TRUE;</code></p>
       <p><code>33  static short exact = FALSE;</code></p>
       <p><code>34</code></p>
       <p><code>35  /* обнулить все члены, на случай, если ОС их не использует. */</code></p>
       <p><code>36  memset(stb, '\0', sizeof(struct stat));</code></p>
       <p><code>37</code></p>
       <p><code>38  /* всегда использовать stat на случай, если stb используется кодом более высокого уровня */</code></p>
       <p><code>39  if (fstat(fd, stb) == -1)</code></p>
       <p><code>40   fatal("can't stat fd %d (%s)", fd, strerror(errno));</code></p>
       <p><code>41</code></p>
       <p><code>42  if (first) {</code></p>
       <p><code>43   first = FALSE;</code></p>
       <p><code>44</code></p>
       <p><code>45   if ((val = getenv("AWKBUFSIZE")) != NULL) {</code></p>
       <p><code>46    if (strcmp(val, "exact") == 0)</code></p>
       <p><code>47     exact = TRUE;</code></p>
       <p><code>48    else if (ISDIGIT(*val)) {</code></p>
       <p><code>49     for (; *val &amp;&amp; ISDIGIT(*val); val++)</code></p>
       <p><code>50     env_val = (env_val * 10) + *val - '0';</code></p>
       <p><code>51</code></p>
       <p><code>52     return env_val;</code></p>
       <p><code>53    }</code></p>
       <p><code>54   }</code></p>
       <p><code>55  } else if (!exact &amp;&amp; env_val &gt; 0)</code></p>
       <p><code>56   return env_val;</code></p>
       <p><code>57  /* else</code></p>
       <p><code>58     обрабатывать дальше */</code></p>
       <p><code>59</code></p>
       <p><code>60  /*</code></p>
       <p><code>61   * System V.n, n &lt; 4, не имеет в структуре stat размера системного</code></p>
       <p><code>62   * блока файла. Поэтому нам нужно осуществить разумную догадку.</code></p>
       <p><code>63   * Мы используем BUFSIZ из stdio, поскольку именно это имелось</code></p>
       <p><code>64   * в виду прежде всего.</code></p>
       <p><code>65   */</code></p>
       <p><code>66 #ifdef HAVE_ST_BLKSIZE</code></p>
       <p><code>67 #define DEFBLKSIZE (stb-&gt;st_blksize &gt; 0 ? stb-&gt;st_blksize : BUFSIZ)</code></p>
       <p><code>68 #else</code></p>
       <p><code>69 #define DEFBLKSIZE BUFSIZ</code></p>
       <p><code>70 #endif</code></p>
       <p><code>71</code></p>
       <p><code>72  if (S_ISREG(stb-&gt;st_mode) /* обычный файл */</code></p>
       <p><code>73   &amp;&amp; 0 &lt; stb-&gt;st_size /* ненулевой размер */</code></p>
       <p><code>74   &amp;&amp; (stb-&gt;st_size &lt; DEFBLKSIZE /* маленький файл */</code></p>
       <p><code>75   || exact)) /* или отладка */</code></p>
       <p><code>76   return stb-&gt;st_size; /* использовать размер файла*/</code></p>
       <p><code>77</code></p>
       <p><code>78  return DEFBLKSIZE;</code></p>
       <p><code>79 }</code></p>
       <p>Комментарий в строках 3–23 объясняет алгоритм. Поскольку поиск переменных окружения может быть затратным и его нужно осуществить лишь однажды, функция использует для сбора соответствующих сведений в первый раз несколько статических переменных.</p>
       <p>Строки 42–54 выполняются лишь при первом вызове функции. Строка 43 обеспечивает это условие, устанавливая в <code>first</code> значение <code>false</code>. Строки 45–54 обрабатывают переменную окружения, разыскивая либо строку <code>"exact"</code>, либо число. В последнем случае оно преобразуется из строкового значения в десятичное, сохраняясь в <code>env_val</code>. (Возможно, нам следовало бы использовать здесь <code>strtoul()</code>; в свое время это не пришло нам на ум.)</p>
       <p>Строка 55 выполняется каждый раз, кроме первого. Если было представлено числовое значение, условие будет истинным, и возвращается это значение (строка 56). В противном случае, исполнение переходит к оставшейся части функции.</p>
       <p>Строки 60–70 определяют <code>DEFBLKSIZE</code>; эта часть не изменилась. Наконец, строки 72–76 возвращают размер файла, если это приемлемо. Если нет (строка 78), возвращается <code>DEGBLKSIZE</code>.</p>
       <p>Мы действительно устранили проблему<a l:href="#n174" type="note">[174]</a>, но между тем оставили на месте новую версию <code>optimal_bufsize()</code>, чтобы можно было убедиться, что проблема не возникнет вновь.</p>
       <p>Незначительное увеличение размера кода и его сложности более чем компенсируется возросшей гибкостью, которая есть теперь у нас для тестирования. Более того, поскольку это код изделия, пользователь в полевых условиях может с легкостью использовать эту особенность для тестирования, чтобы определить, не появилась ли сходная проблема. (До сих пор нам не приходилось просить проделать этот тест, но приятно осознавать, что мы могли бы это сделать, если бы пришлось.)</p>
      </section>
      <section>
       <title>
        <p>15.4.2.3. Добавьте код журналирования</p>
       </title>
       <p>Часто бывает так, что программа вашего приложения работает на системе, на которой вы не можете использовать отладчик (как в случае сайта клиента). В таком случае вашей целью является возможность проверки внутреннего состояния программы, но извне. Единственным способом сделать это является заставить саму программу предоставить для вас эту информацию. Для этого существует множество способов.</p>
       <p>• Всегда записывайте сведения в специфический файл. Это простейший способ: программа всегда записывает регистрационную информацию. Затем вы можете при возможности просмотреть файл.</p>
       <p>Недостаток в том, что в какой-то момент регистрационный файл займет все дисковое пространство. Следовательно, у вас должны быть несколько файлов журналов, причем программа периодически должна переключаться между ними. Брайан Керниган рекомендует называть файлы журнала по дням недели: <code>myapp.log.sun</code>, <code>myapp.log.mon</code> и т.д. Преимуществом здесь является то, что вам не придется вручную удалять старые файлы; вы бесплатно получаете недельную стоимость файлов журналов.</p>
       <p>• Записывайте в файл журнала лишь тогда, когда он уже существует. При запуске ваша программа записывает сведения в файл журнала, если он существует. В противном случае записи не происходит. Чтобы включить журналирование, сначала создайте пустой файл журнала.</p>
       <p>• Используйте для сообщений фиксированный формат, который можно легко анализировать с помощью языков сценариев, таких, как <code>awk</code> или Perl, для создания сводок и отчетов.</p>
       <p>• В качестве альтернативы можно создать какую-нибудь разновидность XML, который является самоописывающимся и допускающим преобразование в другие форматы. (Мы не являемся большими поклонниками XML, но вас это не должно останавливать).</p>
       <p>• Для журналирования используйте <code>syslog()</code>; конечное расположение сообщений журналирования может контролироваться системным администратором, (<code>syslog()</code> является довольно продвинутым интерфейсом; см. справочную страницу <emphasis>syslog</emphasis>(3)).</p>
       <p>Выбор того, как регистрировать сведения, является, конечно, легкой частью. Трудной частью является выбор того, <emphasis>что</emphasis> регистрировать. Как и в остальных случаях разработки программ, стоит <emphasis>подумать, прежде чем программировать</emphasis>. Записывайте сведения о критических переменных. Проверьте их значения, чтобы убедиться, что они в приемлемом диапазоне или в других отношениях ведут себя, как ожидается. Записывайте исключительные условия; если появляется что-то, что не должно было, зарегистрируйте это и при возможности продолжайте исполнение.</p>
       <p>Ключом является регистрация лишь тех сведений, которые вам нужны для отслеживания проблем, не больше и не меньше.</p>
      </section>
      <section>
       <title>
        <p>15.4.2.4. Файлы отладки времени исполнения</p>
       </title>
       <p>В предыдущей жизни мы работали для начинающей компании с двоичными исполняемыми файлами продукта, установленными на сайтах клиентов. Подключить отладчик к запущенной копии программы или запустить ее из отладчика на системе клиента было невозможно. Главный компонент продукта запускался не непосредственно из командной строки, а опосредованно, через сценарии оболочки, которые проделывали значительную первоначальную настройку.</p>
       <p>Чтобы заставить программу выдавать при запуске журналируемые сведения, мы пришли к идее специальных отладочных файлов. Когда файл с определенным именем находился в определенном каталоге, программа выдавала бы информационные сообщения в файл журнала, который мы могли бы затем загрузить и проанализировать. Такой код выглядит следующим образом:</p>
       <p><code>struct stat sbuf;</code></p>
       <p><code>extern int do_logging; /* инициализировано нулями */</code></p>
       <empty-line/>
       <p><code>if (stat("/path/to/magic/.file", &amp;sbuf) == 0)</code></p>
       <p><code> do_logging = TRUE;</code></p>
       <p><code>...</code></p>
       <p><code>if (do_logging) {</code></p>
       <p><code> /* здесь код журналирования: открытие файла, запись, закрытие и</code></p>
       <p><code>  * т.д. * /</code></p>
       <p><code>}</code></p>
       <p>Вызов <code>stat()</code> происходил для каждого задания, которое выполняла программа. Таким образом, мы могли динамически включать и отключать журналирование без необходимости останавливать и повторно запускать приложение!</p>
       <p>Как и в случае с отладочными опциями и переменными, в этом предмете имеется множество вариаций: различные файлы, которые запускают журналирование информации о различных подсистемах, директивы отладки, добавляемые в сам отладочный файл и т.д. Как и со всеми возможностями, следует планировать схему того, что вам будет нужно, а затем чисто ее реализовывать, вместо того, чтобы набросать какой-нибудь быстрый и грязный код в 3 часа пополудни (к сожалению, довольно типичная возможность в начинающих компаниях).</p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. Не все то золото, что блестит. Специальные отладочные файлы являются лишь одним примером методик, известных как лазейки (back doors) — один или более способов выполнения разработчиками недокументированных вещей с программой, обычно с бесчестными намерениями. В нашем примере лазейка была исключительно доброкачественной. Но беспринципный разработчик легко мог бы устроить создание и загрузку скрытой копии списка клиентов, картотеки персонала или других важных данных. По одной этой причине вы должны серьезно подумать, применима ли эта методика в вашем приложении.</p>
       </cite>
      </section>
      <section>
       <title>
        <p>15.4.2.5. Добавьте специальные ловушки для контрольных точек</p>
       </title>
       <p>Часто проблема может быть воспроизводимой, но лишь после того, как программа сначала обработает многие мегабайты вводимых данных. Или, хотя вы и знаете, какая функция вызывает сбой, он возникает лишь после вызова этой функции сотни или даже тысячи раз.</p>
       <p>Это большая проблема, когда вы работаете в отладчике. Если вы установите контрольную точку на вызывающую сбой процедуру, вам придется набирать команду continue и нажимать ENTER сотни или тысячи раз, чтобы привести программу в состояние перед сбоем. Это по меньшей мере утомительно и способствует появлению ошибок! Это может оказаться даже таким трудным, что вы захотите отказаться от этого, даже не начав.</p>
       <p>Решение заключается в добавлении специальных отладочных функций «ловушек» («hook»), которые ваша программа может вызвать при приближении к интересующему вас состоянию.</p>
       <p>Например, предположим, что вы знаете, что функция <code>check_salary()</code> вызывает сбой, но лишь когда она вызвана 1427 раз. (Мы не смеемся над вами; в свое время нам пришлось наблюдать довольно странные вещи.)</p>
       <p>Чтобы перехватить <code>check_salary()</code> до того, как она завершится неудачей, создайте специальную фиктивную функцию, которая ничего не делает и просто возвращается, затем сделайте так, чтобы <code>check_salary()</code> вызывала ее как раз перед 1427-м своим вызовом:</p>
       <p><code>/* debug_dummy --- отладочная функция-ловушка */</code></p>
       <p><code>void debug_dummy(void) { return; }</code></p>
       <empty-line/>
       <p><code>struct salary *check_salary(void) {</code></p>
       <p><code> /* ...здесь описания настоящих переменных... */</code></p>
       <p><code> static int count = 0; /* для отладки */</code></p>
       <p><code> if (++count == 1426)</code></p>
       <p><code>  debug_dummy();</code></p>
       <p><code> /* ...оставшаяся часть кода... */</code></p>
       <p><code>}</code></p>
       <p>Теперь из GDB установите контрольную точку в <code>debug_dummy()</code>, а затем запустите программу обычным способом:</p>
       <p><code>(gdb) <strong>break debug_dummy</strong> /* Установить контрольную точку для фиктивной функции */</code></p>
       <p><code>Breakpoint 1 at 0x8055885: file whizprog.c, line 3137.</code></p>
       <p><code>(gdb) <strong>run</strong> /* Запуск программы */</code></p>
       <p>По достижении контрольной точки для <code>debug_dummy()</code> вы можете установить вторую контрольную точку для <code>check_salary()</code> и продолжить исполнение:</p>
       <p><code>(gdb) <strong>run</strong> /* Запуск программы */</code></p>
       <p><code>Starting program: /home/arnold/whizprog</code></p>
       <empty-line/>
       <p><code>Breakpoint 1, debug_dummy() at whizprog.c, line 3137</code></p>
       <p><code>3137 void debug_dummy(void) { return; } /* Достижение контрольной точки */</code></p>
       <p><code>(gdb) <strong>break check_salary</strong></code></p>
       <p><code> /* Установить контрольную точку для интересующей функции */</code></p>
       <p><code>Breakpoint 2 at 0x8057913: file whizprog.c, line 3140.</code></p>
       <p><code>(gdb) <strong>cont</strong></code></p>
       <p>По достижении второй контрольной точки программа готова завершиться неудачей, и вы можете пошагово ее пройти, делая все необходимое для отслеживания проблемы.</p>
       <p>Вместо использования фиксированной константы ('<code>++count == 1426</code>') можно использовать глобальную переменную, которая устанавливается отладчиком в любое нужное вам значение. Это дает возможность избежать перекомпилирования программы</p>
       <p>Для <code>gawk</code> мы пошли на один шаг дальше и внесли возможность отладочной ловушки в язык, так что функция ловушки могла быть вызвана из программы <code>awk</code>. При компилировании для отладки доступна специальная ничего не делающая функция <code>stopme()</code>. Эта функция, в свою очередь, вызывает функцию С с тем же названием. Это позволяет нам поместить вызовы <code>stopme()</code> в завершающуюся неудачей программу <code>awk</code> непосредственно перед сбойным участком. Например, если <code>gawk</code> выдает ошибочные результаты для программы <code>awk</code> в 1200-й вводимой записи, мы можем добавить в программу <code>awk</code> строку, подобную этой:</p>
       <p><code>NR == 1198 { stopme() } # Остановиться для отладки, когда число записей == 1198</code></p>
       <p><code>/* ...оставшаяся часть программы как ранее... */</code></p>
       <p>Затем из GDB мы можем установить контрольную точку на функции С <code>stopme()</code> и запустить программу <code>awk</code>. Когда контрольная точка срабатывает, мы можем затем установить контрольные точки на другие части <code>gawk</code>, где, как мы ожидаем, находится действительная проблема.</p>
       <p>Методика функции-ловушки полезна сама по себе. Однако, возможность переместить ее на уровень приложения умножает ее полезность, и она сохранила нам бесчисленное число часов отладки при отслеживании непонятных проблем.</p>
      </section>
     </section>
    </section>
    <section>
     <title>
      <p>15.5. Отладочные инструменты</p>
     </title>
     <section>
      <p>Помимо GDB и различных ловушек в исходном коде, которые вы используете для общей отладки, имеется ряд полезных пакетов, которые могут помочь обнаружить определенные разновидности проблем. Поскольку управление динамической памятью является в крупномасштабных программах такой трудной задачей, многие инструменты фокусируются на этой области, часто действуя в качестве замещающих <code>malloc()</code> и <code>free()</code> элементов</p>
      <p>Имеются коммерческие инструменты, которые делают множество (или все) из тех вещей, что и описываемые нами программы, но не все они доступны для GNU/Linux, а многие довольно дороги. Все пакеты, обсуждающиеся в данном разделе, являются свободно доступными.</p>
     </section>
     <section>
      <title>
       <p>15.5.1. Библиотека <code>dbug</code> — усовершенствованный <code>printf()</code></p>
      </title>
      <p>Первым пакетом, который мы исследуем, является библиотека <code>dbug</code>. Она основана на идее условно компилируемого отладочного кода, которую мы представили ранее в данной главе, но идет намного дальше, предоставляя сравнительно сложную трассировку времени исполнения и условный вывод отладки. Она реализует многие из описанных нами советов, избавляя вас от хлопот по собственной их реализации.</p>
      <p>Библиотека <code>dbug</code>, написанная Фредом Фишем (Fred Fish) в начале 1980-х, была с тех пор несколько усовершенствована. Теперь она явным образом является общим достоянием, поэтому ее можно использовать без всяких проблем как в свободном, так и частном программном обеспечении. Она доступна через архив FTP Фреда Фиша<a l:href="#n175" type="note">[175]</a> как в виде сжатого файла tar, так и в виде архива ZIP. Документация хорошо резюмирует <code>dbug</code>:</p>
      <cite>
       <p><code>dbug</code> является примером внутреннего отладчика. Поскольку она требует внутренней поддержки программы и ее использование не зависит от каких бы то ни было особых возможностей среды исполнения, она всегда доступна и будет выполняться в любом окружении, в котором будет выполняться сама программа. Вдобавок, поскольку это законченный пакет с особым интерфейсом пользователя, все программы, которые ее используют, будут иметь сходные возможности отладки. Это резко контрастирует с другими формами внутренней поддержки, где у каждого разработчика своя собственная, обычно менее квалифицированная, форма внутреннего отладчика...</p>
       <p>Пакет <code>dbug</code> лишь незначительно снижает скорость выполнения программ, обычно значительно менее 10%, и немного увеличивает их размеры, обычно от 10 до 20%. Определив особый идентификатор препроцессора С, можно снизить оба этих показателя до нуля без необходимости изменений в исходном коде.</p>
       <p>Следующий список является кратким изложением возможностей пакета <code>dbug</code>. Каждую возможность можно отдельно включать или отключать во время запуска программы, указав соответствующие аргументы командной строки.</p>
       <p>• Трассировка исполнения, отображающая уровень потока управления полуграфическим способом с использованием отступов, обозначающих глубину вложения</p>
       <p>• Вывод значений всех или любого набора ключевых внутренних переменных.</p>
       <p>• Ограничение действий определенным набором указанных функций.</p>
       <p>• Ограничение трассировки функций указанной глубиной вложения.</p>
       <p>• Пометку каждой выводимой строки названием исходного файла и номером строки.</p>
       <p>• Пометку каждой выводимой строки названием текущего процесса.</p>
       <p>• Сохранение в стеке или восстановление состояния отладки для обеспечения исполнения со встроенными значениями по умолчанию для отладки.</p>
       <p>• Перенаправление потока вывода отладки в стандартный вывод (<code>stdout</code>) или указанный файл. По умолчанию поток вывода направляется в стандартную ошибку (<code>stderr</code>). Механизм перенаправления полностью независим от обычного перенаправления командной строки, чтобы избежать конфликтов вывода.</p>
      </cite>
      <p>Пакет <code>dbug</code> требует от вас использования определенного порядка при написании своего кода. В частности, нужно использовать его макросы при возвращении из функции или вызове <code>setjmp()</code> и <code>longjmp()</code>. Нужно добавлять один вызов макроса в качестве <emphasis>первого</emphasis> исполняемого оператора каждой функции и вызвать несколько дополнительных макросов из <code>main()</code>. Наконец, нужно добавить отладочную опцию командной строки, по соглашению, это <code>-#</code>, которая редко используется в качестве действительной опции, если вообще используется. В обмен на дополнительную работу вы получаете все только что очерченные преимущества. Давайте взглянем на пример в руководстве:</p>
      <p><code>1  #include &lt;stdio.h&gt;</code></p>
      <p><code>2  #include "dbug.h"</code></p>
      <p><code>3</code></p>
      <p><code>4  int</code></p>
      <p><code>5  main(argc, argv)</code></p>
      <p><code>6  int argc;</code></p>
      <p><code>7  char *argv[];</code></p>
      <p><code>8  {</code></p>
      <p><code>9   register int result, ix;</code></p>
      <p><code>10  extern int factorial(), atoi();</code></p>
      <p><code>11</code></p>
      <p><code>12  DBUG_ENTER("main");</code></p>
      <p><code>13  DBUG_PROCESS(argv[0]);</code></p>
      <p><code>14  DBUG_PUSH_ENV("DBUG");</code></p>
      <p><code>15  for (ix = 1; ix &lt; argc &amp;&amp; argv[ix][0] == '-'; ix++) {</code></p>
      <p><code>16   switch (argv[ix][1]) {</code></p>
      <p><code>17   case '#':</code></p>
      <p><code>18    DBUG_PUSH(&amp;(argv[ix][2]));</code></p>
      <p><code>19    break;</code></p>
      <p><code>20   }</code></p>
      <p><code>21  }</code></p>
      <p><code>22  for (; ix &lt; argc; ix++) {</code></p>
      <p><code>23   DBUG_PRINT("args", ("argv[%d] = %s", ix, argv[ix]));</code></p>
      <p><code>24   result = factorial(atoi(argv(ixj));</code></p>
      <p><code>25   printf("%d\n", result);</code></p>
      <p><code>26   fflush(stdout);</code></p>
      <p><code>27  }</code></p>
      <p><code>28  DBUG_RETURN(0);</code></p>
      <p><code>29 }</code></p>
      <p>Эта программа иллюстрирует большинство важных моментов. Макрос <code>DBUG_ENTER()</code> (строка 12) должен быть вызван после объявлений переменных и перед любым другим кодом. (Это потому, что он сам объявляет несколько частных переменных.<a l:href="#n176" type="note">[176]</a>)</p>
      <p>Макрос <code>DBUG_PROCESS()</code> (строка 13) устанавливает имя программы, главным образом, для использования в выводимых библиотекой сообщениях. Этот макрос должен вызываться лишь однажды, из <code>main()</code>.</p>
      <p>Макрос <code>DBUG_PUSH_ENV()</code> (строка 14) заставляет библиотеку проверить указанную переменную окружения (в данном случае <code>DBUG</code>) на предмет управляющей строки (Управляющие строки <code>dbug</code> вскоре будут рассмотрены.) Библиотека может, сохранив свое текущее состояние и использовав новое, создавать стек сохраненных состояний. Таким образом, этот макрос помещает в стек сохраненных состояний полученное от данной переменной окружения состояние. В данном примере использован случай, когда макрос создает первоначальное состояние. Если такой переменной окружения нет, ничего не происходит. (В качестве отступления, <code>DBUG</code> является довольно общей переменной, возможно, <code>GAWK_DBUG</code> было бы лучше [для <code>gawk</code>].)</p>
      <p>Макрос <code>DBUG_PUSH</code> (строка 18) передает значение управляющей строки, полученной из опции командной строки <code>-#</code>. (Новый код должен использовать <code>getopt()</code> или <code>getopt_long()</code> вместо ручного анализа аргументов.) Таким образом обычно включается режим отладки, но использование переменной окружения предоставляет также дополнительную гибкость.</p>
      <p>Макрос <code>DBUG_PRINT()</code> (строка 23) осуществляет вывод. Второй аргумент использует методику, которую мы описали ранее (см. раздел 15.4.1.1 «Используйте отладочные макросы»), по включению в скобки всего списка аргументов <code>printf()</code>, делая его простым аргументом, насколько это касается препроцессора С. Обратите внимание, что завершающий символ конца строки в форматирующей строке не указывается; библиотека <code>dbug</code> вставляет его за вас.</p>
      <p>При печати <code>dbug</code> по умолчанию выводит все операторы <code>DBUG_PRINT()</code>. Первый аргумент является строкой, которая может использоваться для ограничения вывода лишь теми макросами <code>DBUG_PRINT()</code>, которые используют эту строку.</p>
      <p>Наконец, макрос <code>DBUG_RETURN()</code> (строка 28) используется вместо обычного оператора <code>return</code> для возврата значения. Для использования с функциями <code>void</code> имеется соответствующий макрос <code>DBUG_VOID_RETURN</code>.</p>
      <p>Оставшаяся часть программы заполнена функцией <code>factorial()</code>:</p>
      <p><code>1  #include &lt;stdio.h&gt;</code></p>
      <p><code>2  #include "dbug.h"</code></p>
      <p><code>3</code></p>
      <p><code>4  int factorial (value)</code></p>
      <p><code>5  register int value;</code></p>
      <p><code>6  {</code></p>
      <p><code>7   DBUG_ENTER("factorial");</code></p>
      <p><code>8   DBUG_PRINT("find", ("find %d factorial", value));</code></p>
      <p><code>9   if (value &gt; 1) {</code></p>
      <p><code>10   value *= factorial(value — 1);</code></p>
      <p><code>11  }</code></p>
      <p><code>12  DBUG_PRINT("result", ("result is %d", value));</code></p>
      <p><code>13  DBUG_RETURN(value);</code></p>
      <p><code>14 }</code></p>
      <p>Когда программа откомпилирована и скомпонована вместе с библиотекой <code>dbug</code>, ее можно запустить обычным способом. По умолчанию, программа не создает вывод отладки. Но со включенной отладкой доступны различные виды вывода:</p>
      <p><code>$ <strong>factorial 1 2 3</strong> /* Обычный запуск, без отладки */</code></p>
      <p><code>1</code></p>
      <p><code>2</code></p>
      <p><code>6</code></p>
      <p><code>$ <strong>factorial -#t 1 2 3</strong>/* Вывести трассировку вызовов функций, обратите внимание на вложенность */</code></p>
      <p><code>| &gt;factorial</code></p>
      <p><code>| &lt;factorial</code></p>
      <p><code>1 /* Обычный вывод в stdout */</code></p>
      <p><code>| &gt;factorial</code></p>
      <p><code>| | &gt;factorial</code></p>
      <p><code>| | &lt;factorial /* Вывод отладки в stderr */</code></p>
      <p><code>| &lt;factorial</code></p>
      <p><code>2</code></p>
      <p><code>| &gt;factorial</code></p>
      <p><code>| | &gt;factorial</code></p>
      <p><code>| | | &gt;factorial</code></p>
      <p><code>| | | &lt;factorial</code></p>
      <p><code>| | &lt;factorial</code></p>
      <p><code>| &lt;factorial</code></p>
      <p><code>6</code></p>
      <p><code>&lt;?func?</code></p>
      <p><code>$ <strong>factorial -#d 1 2</strong>/* Показать отладочные сообщения DBUG_PRINT() */</code></p>
      <p><code>?func?: args: argv[2] = 1</code></p>
      <p><code>factorial: find: find 1 factorial</code></p>
      <p><code>factorial: result: result is 1</code></p>
      <p><code>1</code></p>
      <p><code>?func?: args: argv[3] = 2</code></p>
      <p><code>factorial: find: find 2 factorial</code></p>
      <p><code>factorial: find: find 1 factorial</code></p>
      <p><code>factorial: result: result is 1</code></p>
      <p><code>factorial: result: result is 2</code></p>
      <p><code>2</code></p>
      <p>Опция <code>-#</code> управляет библиотекой <code>dbug</code>. Она «особая» в том смысле, что <code>DBUG_PUSH()</code> будет принимать всю строку, игнорируя ведущие символы '<code>-#</code>', хотя вы могли бы использовать при желании другую опцию, передав <code>DBUG_PUSH()</code> лишь строку аргументов опций (если вы используете <code>getopt()</code>, это <code>optarg</code>).</p>
      <p>Управляющая строка состоит из набора опций и аргументов. Каждая группа опций и аргументов отделяется от других символом двоеточия. Каждая опция представлена одной буквой, а аргументы этой опции отделяются от нее запятыми. Например:</p>
      <p><code>$ myprog -#d,mem,ipc:f,check_salary,check_start_date -f infile -o outfile</code></p>
      <p>Опция <code>d</code> включает вывод <code>DBUG_PRINT()</code>, но лишь если первая строка аргумента является "<code>mem</code>" или "<code>ipc</code>". (Если аргументов нет, выводятся все сообщения <code>DBUG_PRINT()</code>.) Сходным образом опция <code>f</code> ограничивает трассировку вызовов функций лишь указанными функциями, <code>check_salary()</code> и <code>check_start_date()</code>.</p>
      <p>Следующий список опций и аргументов воспроизведен из руководства библиотеки <code>dbug</code>. Квадратные скобки заключают необязательные аргументы. Мы включаем здесь лишь те, которые находим полезными; полный список см. в документации.</p>
      <p><code>d [,ключевые слова]</code></p>
      <p>Разрешает вывод от макросов с указанными <emphasis>ключевыми словами</emphasis>. Пустой список ключевых слов предполагает, что выбраны все ключевые слова.</p>
      <p><code>F</code></p>
      <p>Помечает каждую строку вывода отладки именем исходного файла, содержащего макрос, осуществляющий вывод.</p>
      <p><code>i</code></p>
      <p>Идентифицирует процесс, выводящий каждую отладочную или трассировочную строку номером ID для этого процесса.</p>
      <p><code>L</code></p>
      <p>Помечает каждую строку вывода отладчика номером строки исходного файла, в котором находится осуществляющий вывод макрос.</p>
      <p><code>о[,файл]</code></p>
      <p>Перенаправляет поток вывода отладчика в указанный файл. Потоком вывода по умолчанию является <code>stderr</code>. Пустой список аргументов перенаправляет вывод в <code>stdout</code>.</p>
      <p><code>t[,N]</code></p>
      <p>Включает трассировку потока управления функций. Максимальная глубина вложения определяется <code>N</code>, по умолчанию используется 200.</p>
      <p>Для завершения нашего обсуждения вот остальные макросы, определенные библиотекой <code>dbug</code>.</p>
      <p><code>DBUG_EXECUTE(строка, код)</code></p>
      <p>Этот макрос похож на <code>DBUG_PRINT()</code>: первый аргумент является строкой, выбранной с помощью опции <code>d</code>, а второй — код для исполнения:</p>
      <p><code>DBUG_EXECUTE("abort", abort());</code></p>
      <p><code>DBUG_FILE</code></p>
      <p>Это значение типа <code>FILE*</code> для использования с процедурами <code>&lt;stdio.h&gt;</code>. Оно позволяет осуществлять собственный вывод в поток файла отладки.</p>
      <p><code>DBUG_LONGJMP(jmp_buf env, int val)</code></p>
      <p>Этот макрос заключает в оболочку вызов <code>longjmp()</code>, принимая те же самые аргументы, так что библиотека <code>dbug</code> будет знать, когда вы сделали нелокальный переход.</p>
      <p><code>DBUG_POP()</code></p>
      <p>Этот макрос выталкивает из стека один уровень сохраненного состояния отладки, созданный макросом <code>DBUG_PUSH()</code>. Он довольно эзотерический; вы скорее всего не будете его использовать.</p>
      <p><code>DBUG_SETJMP(jmp_buf env)</code></p>
      <p>Этот макрос заключает в оболочку вызов <code>setjmp()</code>, принимая те же самые аргументы. Он позволяет библиотеке <code>dbug</code> обрабатывать нелокальные переходы.</p>
      <p>В другом воплощении, в первой начинающей компании, для которой мы работали<a l:href="#n177" type="note">[177]</a>, мы использовали в своем продукте библиотеку <code>dbug</code>. Она была неоценимой при разработке, а опустив <code>-DDBUG</code> в конечной сборке, мы смогли построить готовую версию без других изменений исходного кода.</p>
      <p>Чтобы извлечь максимальную выгоду от библиотеки <code>dbug</code>, нужно использовать ее последовательно, по всей программе. Это проще, если вы используете ее с начала проекта, но в качестве эксперимента мы обнаружили, что с помощью простого сценария <code>awk</code> мы смогли включить библиотеку в программу с 30 000 строк кода за несколько часов работы. Если вы можете позволить себе накладные расходы, лучше всего оставить ее в конечной сборке вашей программы, чтобы можно было ее отлаживать без необходимости предварительной перекомпиляции.</p>
      <p>Мы нашли, что библиотека <code>dbug</code> является удачным дополнением к внешним отладчикам, таким, как GDB; она обеспечивает <emphasis>организованный</emphasis> и <emphasis>последовательный</emphasis> способ применения поддержки к коду С. Она также довольно элегантно сочетает многие из методик, которые мы ранее в данной главе очертили отдельно. Особенно полезна особенность динамической трассировки вызовов функций, и она доказывает свою бесценность в качестве помощи в изучении поведения программы, если вы незнакомы с ней.</p>
     </section>
     <section>
      <title>
       <p>15.5.2. Отладчики выделения памяти</p>
      </title>
      <section>
       <p>Игнорируя такие проблемы, как плохой дизайн программы, для любого крупномасштабного практического приложения единственной сложной задачей программиста на С является управление динамической памятью (посредством <code>malloc()</code>, <code>realloc()</code> и <code>free()</code>).</p>
       <p>Этот факт подкреплен большим количеством инструментов, доступных для отладки динамической памяти. Имеется значительное перекрывание того, что предлагают данные утилиты. Например:</p>
       <p>• Обнаружение утечек памяти: память, которая выделяется, а затем становится недоступной.</p>
       <p>• Обнаружение не освобождаемой памяти: память, которая выделяется, но никогда не освобождается. Не освобождаемая память не всегда является ошибкой, но определение таких случаев дает вам возможность проверить, что с ними все в порядке.</p>
       <p>• Обнаружение неправильных освобождений: память, которая освобождается дважды, или функции <code>free()</code> передаются указатели, которые не были получены с помощью <code>malloc()</code>.</p>
       <p>• Обнаружение использования уже освобожденной памяти: память, которая освобождена, используется через висячий указатель.</p>
       <p>• Обнаружение выхода за границы выделенной памяти: получение доступа или сохранение в память за пределами выделенной границы.</p>
       <p>• Предупреждение об использовании неинициализированной памяти. (Многие компиляторы могут выдавать такие предупреждения.)</p>
       <p>• Динамическая трассировка функций: когда появляется ошибочный доступ к памяти, вы получаете трассировку от того места, где память используется, до того места, где она была выделена.</p>
       <p>• Управление инструментами посредством использования переменных окружения.</p>
       <p>• Файлы журналов для необработанной отладочной информации, которая может быть обработана позже для создания полезных отчетов.</p>
       <p>Некоторые утилиты просто записывают эти события. Другие организуют жуткое завершение программы приложения (посредством <code>SIGSEGV</code>), чтобы на код-нарушитель можно было точно указать из отладчика. Вдобавок, большинство спроектированы для работы вместе с GDB.</p>
       <p>Некоторые инструменты требуют изменения исходного кода, такого, как вызов специальных функций или использование особого заголовочного файла, дополнительных <code>#define</code> и статической библиотеки. Другие работают посредством использования специального механизма библиотек общего пользования Linux/Unix для прозрачной установки себя в качестве заместителя стандартных библиотечных версий <code>malloc()</code> и <code>free()</code>.</p>
       <p>В данном разделе мы рассмотрим три отладчика динамической памяти, а затем предоставим ссылки на несколько других.</p>
      </section>
      <section>
       <title>
        <p>15.5.2.1. GNU/Linux <code>mtrace</code></p>
       </title>
       <p>Системы GNU/Linux, использующие GLIBC, предоставляют две функции для включения и отключения трассировки памяти <emphasis>во время исполнения</emphasis>.</p>
       <p><code>#include &lt;mcheck.h&gt; /* GLIBC */</code></p>
       <empty-line/>
       <p><code>void mtrace(void);</code></p>
       <p><code>void muntrace(void);</code></p>
       <p>Когда вызывается <code>mtrace()</code>, библиотека проверяет переменную окружения <code>MALLOC_TRACE</code>. Ожидается, что она указывает на записываемый файл (существующий или нет). Библиотека открывает файл и начинает записывать сведения о выделениях и освобождениях памяти (Если файл не может быть открыт, запись не производится. Файл урезается каждый раз при запуске программы.) Когда вызывается <code>muntrace()</code>, библиотека закрывает файл и больше не регистрирует выделения и освобождения.</p>
       <p>Использование отдельных функций дает возможность проводить трассировку памяти для определенных частей программы; необязательно отслеживать все. (Мы нашли наиболее полезным включить журналирование в начале программы и все, но эта схема предоставляет гибкость, которую хорошо иметь.)</p>
       <p>Когда приложение завершается, вы используете программу <code>mtrace</code> для анализа файла журнала. (Файл журнала в формате ASCII, но информацию нельзя использовать непосредственно.) Например, <code>gawk</code> включает трассировку, если определена <code>TIDYMEM</code>:</p>
       <p><code>$ <strong>export TIDYMEM=1 MALLOC_TRACE=trace.out</strong> /* Экспортировать переменные окружения */</code></p>
       <p><code>$ <strong>./gawk 'BEGIN { print "hello, world" }'</strong> /* Запустить программу */</code></p>
       <p><code>hello, world</code></p>
       <p><code>$ <strong>mtrace ./gawk mtrace.out</strong> /* Создать отчет */</code></p>
       <p><code>Memory not freed:</code></p>
       <p><code>-----------------</code></p>
       <p><code>Address Size Caller</code></p>
       <p><code>0x08085858 0x20  at /home/arnold/Gnu/gawk/gawk-3.1.3/main.c:1102</code></p>
       <p><code>0x08085880 0xc80 at /home/arnold/Gnu/gawk/gawk-3.1.3/node.c:398</code></p>
       <p><code>0x08086508 0x2   at /home/arnold/Gnu/gawk/gawk-3.1.3/node.c:337</code></p>
       <p><code>0x08086518 0x6   at /home/arnold/Gnu/gawk/gawk-3.1.3/node.c:337</code></p>
       <p><code>0x08086528 0x10  at /home/arnold/Gnu/gawk/gawk-3.1.3/eval.c:2082</code></p>
       <p><code>0x08086550 0x3   at /home/arnold/Gnu/gawk/gawk-3.1.3/node.с:337</code></p>
       <p><code>0x08086560 0x3   at /home/arnold/Gnu/gawk/gawk-3.1.3/node.c:337</code></p>
       <p><code>0x080865e0 0x4   at /home/arnold/Gnu/gawk/gawk-3.1.3/field.c:76</code></p>
       <p><code>0x08086670 0x78  at /home/arnold/Gnu/gawk/gawk-3.1.3/awkgram.y:1369</code></p>
       <p><code>0x08086700 0xe   at /home/arnold/Gnu/gawk/gawk-3.1.3/node.c:337</code></p>
       <p><code>0x08086718 0x1f  at /home/arnold/Gnu/gawk/gawk-3.1.3/awkgram.y:1259</code></p>
       <p>Вывод представляет собой список мест, в которых <code>gawk</code> выделяет память, которая в дальнейшем не освобождается. Обратите внимание, что постоянное подвешивание к динамической памяти является замечательным, если это сделано намеренно. Все показанные здесь случаи являются выделениями такого рода.</p>
      </section>
      <section>
       <title>
        <p>15.5.2.2. Electric Fence</p>
       </title>
       <p>В разделе 3.1 «Адресное пространство Linux/Unix» мы описали, как динамическая память выделяется из кучи, которая может расти и сокращаться (с помощью вызовов <code>brk()</code> или <code>sbrk()</code>, описанных в разделе 3.2.3 «Системные вызовы: <code>brk()</code> и <code>sbrk()</code>»).</p>
       <p>Ну, картина, которую мы там представили, является упрощением действительности. Более развитые системные вызовы (не рассматриваемые в данной книге) позволяют добавлять в адресное пространство процесса дополнительные, необязательно смежные сегменты памяти. Многие отладчики <code>malloc()</code> работают с использованием этих системных вызовов для добавления новых областей адресного пространства при каждом выделении. Преимуществом этой схемы является то, что операционная система и аппаратное обеспечение защиты памяти компьютера взаимодействуют для обеспечения недействительности доступа к памяти за пределами этих изолированных сегментов, генерируя сигнал <code>SIGSEGV</code>. Эта схема изображена на рис. 15.1.</p>
       <image l:href="#img_29.jpeg"/>
       <p><strong>Рис. 15.1</strong>. Адресное пространство Linux/Unix, включая специальные области</p>
       <p>Первым пакетом отладки, реализовавшим эту схему, был Electric Fence. Electric Fence является вставляемым заместителем для <code>malloc()</code> и др. Он работает на многих системах Unix и GNU/Linux; он доступен с FTP архива его авторов.<a l:href="#n178" type="note">[178]</a> Он поставляется также со многими дистрибутивами GNU/Linux, хотя, возможно, вам придется выбрать ею явным образом при установке системы.</p>
       <p>После компоновки программы с Electric Fence любой доступ за пределами выделенной памяти генерирует <code>SIGSEGV</code>. Electric Fence также перехватывает попытки использования уже освобожденной памяти. Вот простая программа, которая иллюстрирует обе проблемы.</p>
       <p><code>1  /* ch15-badmem1.с --- плохо обращается с памятью */</code></p>
       <p><code>2</code></p>
       <p><code>3  #include &lt;stdio.h&gt;</code></p>
       <p><code>4  #include &lt;stdlib.h&gt;</code></p>
       <p><code>5</code></p>
       <p><code>6  int main(int argc, char **argv)</code></p>
       <p><code>7  {</code></p>
       <p><code>8   char *p;</code></p>
       <p><code>9   int i;</code></p>
       <p><code>10</code></p>
       <p><code>11  p = malloc(30);</code></p>
       <p><code>12</code></p>
       <p><code>13  strcpy(p, "not 30 bytes");</code></p>
       <p><code>14  printf("p = &lt;%s&gt;\n", p);</code></p>
       <p><code>15</code></p>
       <p><code>16  if (argc ==2) {</code></p>
       <p><code>17   if (strcmp(argv[1], "-b") == 0)</code></p>
       <p><code>18    p[42] = 'a'; /* коснуться за пределами границы */</code></p>
       <p><code>19   else if (strcmp(argv[1], "-f") == 0) {</code></p>
       <p><code>20    free(p); /* освободить память, затем использовать ее */</code></p>
       <p><code>21    p[0] = 'b';</code></p>
       <p><code>22   }</code></p>
       <p><code>23  }</code></p>
       <p><code>24</code></p>
       <p><code>25  /* освобождение (p); */</code></p>
       <p><code>26</code></p>
       <p><code>27  return 0;</code></p>
       <p><code>28 }</code></p>
       <p>Эта программа осуществляет простую проверку опций командной строки, чтобы решить, как вести себя плохо: <code>-b</code> вызывает доступ к памяти за ее выделенными страницами, а <code>-f</code> пытается использовать освобожденную память. (Строки 18 и 21 являются соответственно опасными.) Обратите внимание, что без опций указатель никогда не освобождается (строка 25), Electric Fence не перехватывает этот случай.</p>
       <p>Одним из способов использования Electric Fence, способом, который гарантированно работает на различных системах Unix и GNU/Linux, является статическая компоновка с ним вашей программы. Затем программа должна быть <emphasis>запущена из отладчика</emphasis>. (Документация Electric Fence явно указывает, что Electric Fence не следует компоновать с двоичным файлом готового изделия.) Следующий сеанс демонстрирует эту процедуру и показывает, что происходит для обеих опций командной строки:</p>
       <p><code>$ <strong>cc -g ch15-badmem1.c -lefence -о ch15-badmem1</strong> /* Откомпилировать; компоновка статическая */</code></p>
       <p><code>$ <strong>gdb ch15-badmem1</strong> /* Запустить из отладчика */</code></p>
       <p><code>GNU gdb 5.3</code></p>
       <p><code>...</code></p>
       <p><code>(gdb) <strong>run -b</strong> /* Попробовать опцию -b */</code></p>
       <p><code>Starting program: /home/arnold/progex/code/ch15/ch15-badmem1 -b</code></p>
       <p><code>[New Thread 8192 (LWP 28021)]</code></p>
       <p><code>Electric Fence 2.2.0 Copyright (C) 1987-1999 Bruce Perens &lt;bruce@perens.com&gt;</code></p>
       <p><code>p = &lt;not 30 bytes&gt;</code></p>
       <p><code>Program received signal SIGSBGV, Segmentation fault.</code></p>
       <p><code>SIGSBGV: GDB prints where</code></p>
       <p><code>[Switching to Thread 8192 (LWP 28021)]</code></p>
       <p><code>0x080485b6 in main (argc=2, argv=0xbffff8a4) at ch15-badmem1.c:18</code></p>
       <p><code>18 p[42] = 'a'; /* коснуться за пределами границы */</code></p>
       <p><code>(gdb) <strong>run -f</strong> /* Теперь попробовать опцию -f */</code></p>
       <p><code>The program being debugged has been started already.</code></p>
       <p><code>Start it from the beginning? (y or n) <strong>y</strong> /* Да */</code></p>
       <p><code>Starting program: /home/arnold/progex/code/ch15/ch15-badmem1 -f</code></p>
       <p><code>[New Thread 8192 (LWP 28024)]</code></p>
       <p><code>Electric Fence 2.2.0 Copyright (C) 1987-1999 Bruce Perens &lt;bruce@perens.com&gt;</code></p>
       <p><code>p = &lt;not 30 bytes&gt;</code></p>
       <p><code>Program received signal SIGSEGV, Segmentation fault. /* Снова SIGSEGV */</code></p>
       <p><code>[Switching to Thread 8192 (LWP 28024)]</code></p>
       <p><code>0x080485e8 in main (argc=2, argv=0xbffff8a4) at ch15-badmem1.c:21</code></p>
       <p><code>21 p[0] = 'b';</code></p>
       <p>На системах, которые поддерживают разделяемые библиотеки и переменную окружения <code>LD_PRELOAD</code> (в том числе и на GNU/Linux), вам не нужно явным образом компоновать библиотеку <code>efence</code>. Вместо этого сценарий оболочки <code>ef</code> организует запуск программы с соответствующей настройкой.</p>
       <p>Хотя мы не описали механизмы подробно, GNU/Linux (и другие системы Unix) поддерживают <emphasis>разделяемые (shared) библиотеки</emphasis>, особые версии библиотечных процедур, которые хранятся в одном файле на диске, вместо того, чтобы копироваться в каждый отдельный двоичный исполняемый файл программы. Разделяемые библиотеки экономят дисковое пространство и могут сохранить системную память, поскольку все программы, использующие разделяемые библиотеки, используют одну и ту же копию библиотеки в памяти. Платой за это является замедление загрузки программы, поскольку программу и разделяемую библиотеку нужно подключить друг к другу прежде, чем программа сможет начать выполнение. (Обычно это прозрачно для вас, пользователя.)</p>
       <p>Переменная окружения <code>LD_PRELOAD</code> заставляет системный загрузчик программ (который загружает исполняемые файлы в память) связаться со специальной библиотекой до стандартных библиотек. Сценарий <code>ef</code> использует эту особенность для связывания набора функций <code>malloc()</code> в Electric Fence.<a l:href="#n179" type="note">[179]</a> Таким образом, повторная компоновка даже не нужна. Этот пример демонстрирует <code>ef</code>:</p>
       <p><code>$ <strong>cc -g ch15-badmem1.c -о ch15-badmem1</strong> /* Компилировать как обычно */</code></p>
       <p><code>$ <strong>ef ch15-badmem1 -b</strong> /* Запустить с использованием ef, создает дамп ядра */</code></p>
       <empty-line/>
       <p><code>Electric Fence 2.2.0 Copyright (С) 1987-1999 Bruce Perens &lt;bruce@perens.com&gt;</code></p>
       <p><code>p = &lt;not 30 bytes&gt;</code></p>
       <p><code>/usr/bin/ef: line 20: 28005 Segmentation fault (core dumped)</code></p>
       <p><code>( export LD_PRELOAD=libefence.so.0.0; exec $* )</code></p>
       <p><code>$ <strong>ef ch15-badmem1 -f</strong> /* Запустить с использованием ef, снова создает дамп ядра */</code></p>
       <p><code>Electric Fence 2.2.0 Copyright (С) 1987-1999 Bruce Perens &lt;bruce@perens.com&gt;</code></p>
       <p><code>p = &lt;not 30 bytes&gt;</code></p>
       <p><code>/usr/bin/ef: line 20: 28007 Segmentation fault (core dumped)</code></p>
       <p><code>( export LD_PRELOAD=libefence.so.0.0; exec $* )</code></p>
       <p><code>$ <strong>ls -l core*</strong> /* Linux создает для нас разные файлы core */</code></p>
       <p><code>-rw------- 1 arnold devel 217088 Aug 28 15:40 core.28005</code></p>
       <p><code>-rw------- 1 arnold devel 212992 Aug 28 15:40 core.28007</code></p>
       <p>GNU/Linux создает файлы <code>core</code>, которые включают в свое имя ID процесса. В данном случае такое поведение полезно, поскольку мы можем отдельно отлаживать каждый файл <code>core</code>:</p>
       <p><code>$ <strong>gdb ch15-badmem1 core.28005</strong> /* От опции -b */</code></p>
       <p><code>GNU gdb 5.3</code></p>
       <p><code>...</code></p>
       <p><code>Core was generated by 'ch15-badmem1 -b'.</code></p>
       <p><code>Program terminated with signal 11, Segmentation fault.</code></p>
       <p><code>...</code></p>
       <p><code>#0 0x08048466 in main (argc=2, argv=0xbffff8c4) at ch15-badmem1.c:18</code></p>
       <p><code>18 p[42] = 'a'; /* touch outside the bounds */</code></p>
       <p><code>(gdb) <strong>quit</strong></code></p>
       <empty-line/>
       <p><code>$ <strong>gdb ch15-badmem1 core.28007</strong> /* От опции -f */</code></p>
       <p><code>GNU gdb 5.3</code></p>
       <p><code>...</code></p>
       <p><code>Core was generated by 'ch15-badmem1 -f'.</code></p>
       <p><code>Program terminated with signal 11, Segmentation fault.</code></p>
       <p><code>...</code></p>
       <p><code>#0 0x08048498 in main (argc=2, argv=0xbffff8c4) at ch15-badmem1.с:21</code></p>
       <p><code>21 p[0] = 'b';</code></p>
       <p>Справочная страница <emphasis>efence</emphasis>(3) описывает несколько переменных окружения, которые должны быть установлены, чтобы настроить поведение Electric Fence. Следующие три наиболее примечательны.</p>
       <p><code>EF_PROTECT_BELOW</code></p>
       <p>Установка этой переменной в 1 заставляет Electric Fence проверять <emphasis>«недоборы» (underruns)</emphasis> вместо «переборов» (overruns) при выходе за пределы отведенной памяти. «Перебор», т.е. доступ к памяти в области за выделенной, был продемонстрирован ранее. «Недобор» является доступом к памяти, расположенной перед выделенной областью памяти.</p>
       <p><code>EF_PROTECT_FREE</code></p>
       <p>Установка этой переменной в 1 предотвращает повторное использование Electric Fence памяти, которая была корректно освобождена. Это полезно, когда вы думаете, что программа может получать доступ к освобожденной памяти; если освобожденная память впоследствии была выделена заново, доступ к ней через предыдущий висячий указатель остался бы в противном случае незамеченным.</p>
       <p><code>EF_ALLOW_MALLOC_0</code></p>
       <p>При наличии ненулевого значения Electric Fence допускает вызовы '<code>malloc(0)</code>'. Такие вызовы в стандартном С технически действительны, но могут представлять программную ошибку. Соответственно Electric Fence по умолчанию их запрещает.</p>
       <p>Вдобавок к переменным окружения Electric Fence предоставляет глобальные переменные с такими же названиями. Вы можете изменить их значения из отладчика, так что можно динамически изменять поведение программы, которая уже начала выполнение. Подробности см. в <emphasis>efence</emphasis>(3).</p>
      </section>
      <section>
       <title>
        <p>15.5.2.3. Отладка Malloc: <code>dmalloc</code></p>
       </title>
       <p>Библиотека <code>dmalloc</code> предоставляет большое число опций отладки. Ее автором является Грей Ватсон (Gray Watson), есть также и свой веб-сайт.<a l:href="#n180" type="note">[180]</a> Как и в случае с Electric Fence, она может быть уже установленной на вашей системе, или же вы можете ее извлечь и построить самостоятельно.</p>
       <p>Библиотека <code>dmalloc</code> проверяет наличие в переменной окружения <code>DMALLOC_OPTIONS</code> управляющей информации. Например, она может выглядеть следующим образом:</p>
       <p><code>$ <strong>echo $DMALLOC_OPTIONS</strong></code></p>
       <p><code>debug=0x4e40503,inter=100,log=dm-log</code></p>
       <p>Компонент '<code>debug</code>' этой переменной содержит набор битовых флагов, которыми для большинства людей почти невозможно непосредственно управлять. Поэтому документация описывает двухэтапный процесс для облегчения их использования.</p>
       <p>Первый шаг заключается в определении функции оболочки с названием <code>dmalloc</code>, которая вызывает программу драйвера <code>dmalloc</code>:</p>
       <p><code>$ <strong>dmalloc() {</strong></code></p>
       <p><code>&gt; <strong>eval 'command dmalloc -b $*'</strong> /* Команда 'command' обходит функции оболочки */</code></p>
       <p><code>&gt; <strong>}</strong></code></p>
       <p>После того, как это сделано, вы можете передать функции опции для установки файла журнала (-1), указать число итераций, после которых <code>dmalloc</code> должна проверить свои внутренние структуры данных (-1), и указать уровень отладки или другой тэг ('<code>low</code>').</p>
       <p><code>$ <strong>dmalloc -1 dm-log -i 100 low</strong></code></p>
       <p>Как и Electric Fence, библиотека <code>dmalloc</code> может быть скомпонована с приложением статически или связана динамически при помощи <code>LD_PRELOAD</code>. Последнее демонстрирует следующий пример:</p>
       <p><code>$ <strong>LD_PRELOAD=libdmalloc.so ch15-badmem1 -b</strong> /* Запустить с проверкой */</code></p>
       <p><code>p = &lt;not 30 bytes&gt; /* Показан нормальный вывод */</code></p>
       <cite>
        <p><strong>ЗАМЕЧАНИЕ</strong>. Не используйте '<code>export LD_PRELOAD=libdmalloc.so</code>'! Если вы это сделаете, каждая программа, которую вы запустите, такая как <code>ls</code>, будет выполняться со включенной проверкой <code>malloc()</code>. Ваша система быстро станет непригодной. Если вы сделали это случайно, можете использовать '<code>unset LD_PRELOAD</code>', чтобы восстановить обычное поведение.</p>
       </cite>
       <p>Результаты записываются в файл <code>dm-log</code> следующим образом:</p>
       <p><code>$ <strong>cat dm-log</strong></code></p>
       <p><code>1062078174: 1: Dmalloc version '4.8.1' from 'http://dmalloc.com/'</code></p>
       <p><code>1062078174: 1: flags = 0x4e40503, logfile 'dm-log'</code></p>
       <p><code>1062078174: 1: interval = 100, addr = 0, seen # = 0</code></p>
       <p><code>1062078174: 1: starting time = 1062078174</code></p>
       <p><code>1062078174: 1: free bucket count/bits: 63/6</code></p>
       <p><code>1062078174: 1: basic-block 4096 bytes, alignment 8 bytes, heap grows up</code></p>
       <p><code>1062078174: 1: heap: 0x804a000 to 0x804d000, size 12288 bytes (3 blocks)</code></p>
       <p><code>1062078174: 1: heap checked 0</code></p>
       <p><code>1062078174: 1: alloc calls: malloc 1, calloc 0, realloc 0, free 0</code></p>
       <p><code>1062078174: 1: alloc calls: recalloc 0, memalign 0, valloc 0</code></p>
       <p><code>1062078174: 1: total memory allocated: 30 bytes (1 pnts)</code></p>
       <p><code>1062078174: 1: max in use at one time: 30 bytes (1 pnts)</code></p>
       <p><code>1062078174: 1: max alloced with 1 call: 30 bytes</code></p>
       <p><code>1062078174: 1: max alloc rounding loss: 34 bytes (53%)</code></p>
       <p><code>1062078174: 1: max memory space wasted: 3998 bytes (98%)</code></p>
       <p><code>1062078174: 1: final user memory space: basic 0, divided 1, 4062 bytes</code></p>
       <p><code>1062078174: 1: final admin overhead: basic 1, divided 1, 8192 bytes (66%)</code></p>
       <p><code>1062078174: 1: final external space: 0 bytes (0 blocks)</code></p>
       <p><code>1062078174: 1: top 10 allocations:</code></p>
       <p><code>1062078174: 1: total-size count in-use-size count source</code></p>
       <p><code>1062078174: 1:         30     1          30     1 ra=0x8048412</code></p>
       <p><code>1062078174: 1:         30     1          30     1 Total of 1</code></p>
       <p><code>1062078174: 1: dumping not-freed pointers changed since 0:</code></p>
       <p><code>1062078174: 1: not freed: '0x804c008|s1' (30 bytes) from 'ra=0x8048412'</code></p>
       <p><code>1062078174: 1: total-size count source</code></p>
       <p><code>1062078174: 1:         30     1 ra=0x8048412 /* Выделение здесь */</code></p>
       <p><code>1062078174: 1:         30     1 Total of 1</code></p>
       <p><code>1062078174: 1: unknown memory: 1 pointer, 30 bytes</code></p>
       <p><code>1062078174: 1: ending time = 1062078174, elapsed since start = 0:00:00</code></p>
       <p>Вывод содержит много статистических данных, которые нам пока не интересны. Интересна строка, в которой указывается не освобожденная память, с адресом возврата, указывающим на выделившую память функцию ('<code>ra=0х8048412</code>'). Документация <code>dmalloc</code> объясняет, как получить расположение в исходном коде этого адреса с использованием GDB.</p>
       <p><code>$ <strong>gdb ch15-badmem1</strong> /* Запустить GDB */</code></p>
       <p><code>GNU gdb 5.3</code></p>
       <p><code>...</code></p>
       <p><code>(gdb) <strong>x 0x8048412</strong> /* Проверить адрес */</code></p>
       <p><code>0x8048412 &lt;main+26&gt;: 0х8910с483</code></p>
       <p><code>(gdb) <strong>info line *(0x8048412)</strong> /* Получить сведения о строке */</code></p>
       <p><code>Line 11 of "ch15-badmem1.с" starts at address 0x8048408 &lt;main+16&gt;</code></p>
       <p><code>and ends at 0x8048418 &lt;main+32&gt;.</code></p>
       <p>Это трудно, но выполнимо, если нет другого выбора. Однако, если вы включите в свою программу заголовочный файл "<code>dmalloc.h</code>" (после всех остальных операторов <code>#include</code>), вы можете получить сведения из исходного кода непосредственно в отчете.</p>
       <p><code>...</code></p>
       <p><code>1062080258: 1: top 10 allocations:</code></p>
       <p><code>1062080258: 1: total-size count in-use-size count source</code></p>
       <p><code>1062080258: 1:        30      1          30     1 ch15-badmem2.c:13</code></p>
       <p><code>1062080258: 1:        30      1          30     1 Total of 1</code></p>
       <p><code>1062080258: 1: dumping not-freed pointers changed since 0:</code></p>
       <p><code>1062080258: 1: not freed: '0x804c008|s1' (30 bytes) from 'ch15-badmem2.c:13'</code></p>
       <p><code>1062080258: 1: total-size count source</code></p>
       <p><code>1062080258: 1:         30     1 ch15-badmem2.с:13</code></p>
       <p><code>1062080258: 1:         30     1 Total of 1</code></p>
       <p><code>...</code></p>
       <p>(Файл <code>ch15-badmem2.c</code> является аналогичным <code>ch15-badmem1.с</code>, за исключением того, что он включает <code>"dmalloc.h"</code>, поэтому мы не стали беспокоиться с его отображением).</p>
       <p>Отдельные возможности отладки включаются или выключаются посредством использования <emphasis>лексем (tokens)</emphasis> — специально распознаваемых идентификаторов — и опций <code>-р</code> для добавления лексем (свойств) или <code>-m</code> для их удаления. Имеются предопределенные комбинации, '<code>low</code>', '<code>med</code>' и '<code>high</code>'. Чем являются эти комбинации, вы можете увидеть с помощью '<code>dmalloc -Lv</code>'.</p>
       <p><code>$ <strong>dmalloc low</strong> /* Установить low */</code></p>
       <p><code>$ <strong>dmalloc -Lv</strong> /* Показать установки */</code></p>
       <p><code>Debug Malloc Utility: http://dmalloc.com/</code></p>
       <p><code>For a list of the command-line options enter: dmalloc --usage</code></p>
       <p><code>Debug-Flags 0x4e40503 (82052355) (low) /* Текущие лексемы */</code></p>
       <p><code>log-stats, log-non-free, log-bad-space, log-elapsed-time, check-fence,</code></p>
       <p><code>free-blank, error-abort, alloc-blank, catch-null</code></p>
       <p><code>Address not-set</code></p>
       <p><code>Interval 100</code></p>
       <p><code>Lock-On not-set</code></p>
       <p><code>Logpath 'log2'</code></p>
       <p><code>Start-File not-set</code></p>
       <p>Полный список лексем вместе с кратким объяснением и соответствующим каждой лексеме числовым значением можно получить с помощью '<code>dmalloc -DV</code>':</p>
       <p><code>$ <strong>dmalloc -DV</strong></code></p>
       <p><code>Debug Tokens:</code></p>
       <p><code>none (nil) -- no functionality (0)</code></p>
       <p><code>log-stats (lst) -- log general statistics (0x1)</code></p>
       <p><code>log-non-free (lnf) -- log non-freed pointers (0x2)</code></p>
       <p><code>log-known (lkn) -- log only known non-freed (0x4)</code></p>
       <p><code>log-trans (ltr) -- log memory transactions (0x8)</code></p>
       <p><code>log-admin (lad) -- log administrative info (0x20)</code></p>
       <p><code>log-blocks (lbl) -- log blocks when heap-map (0x40)</code></p>
       <p><code>log-bad-space (lbs) -- dump space from bad pnt (0x100)</code></p>
       <p><code>log-nonfree-space (lns) -- dump space from non-freed pointers (0x200)</code></p>
       <p><code>log-elapsed-time (let) -- log elapsed-time for allocated pointer (0x40000)</code></p>
       <p><code>log-current-time (let) -- log current-time for allocated pointer (0x80000)</code></p>
       <p><code>check-fence (cfe) -- check fence-post errors (0x400)</code></p>
       <p><code>check-heap (che) -- check heap adm structs (0x800)</code></p>
       <p><code>check-lists (cli) -- check free lists (0x1000)</code></p>
       <p><code>check-blank (cbl) -- check mem overwritten by alloc-blank, free-blank (0x2000)</code></p>
       <p><code>check-funcs (cfu) -- check functions (0x4000)</code></p>
       <p><code>force-linear (fli) -- force heap space to be linear (0x10000)</code></p>
       <p><code>catch-signals (csi) -- shutdown program on SIGHUP, SIGINT, SIGTERM (0x20000)</code></p>
       <p><code>realloc-copy (rco) -- copy all re-allocations (0x100000)</code></p>
       <p><code>free-blank (fbl) -- overwrite freed memory space with BLANK_CHAR (0x200000)</code></p>
       <p><code>error-abort (eab) -- abort immediately on error (0x400000)</code></p>
       <p><code>alloc-blank (abl) -- overwrite newly alloced memory with BLANK_CHAR (0x800000)</code></p>
       <p><code>heap-check-map (hem) -- log heap-map on heap-check (0x1000000)</code></p>
       <p><code>print-messages (pme) -- write messages to stderr (0x2000000)</code></p>
       <p><code>catch-null (cnu) -- abort if no memory available (0x4000000)</code></p>
       <p><code>never-reuse (nre) -- never re-use freed memory (0x8000000)</code></p>
       <p><code>allow-free-null (afn) -- allow the frees of NULL pointers (0x20000000)</code></p>
       <p><code>error-dump (edu) -- dump core on error and then continue (0x40000000)</code></p>
       <p>К этому времени у вас должно быть ощущение того, как использовать <code>dmalloc</code>, и его гибкости, <code>dmalloc</code> является избыточным для нашей простой демонстрационной программы, но он неоценим для более крупномасштабного, реального приложения.</p>
      </section>
      <section>
       <title>
        <p>15.5.2.4. Valgrind: многосторонний инструмент</p>
       </title>
       <p>Инструменты, описанные в предыдущем разделе, все фокусируются на отладке динамической памяти, и это в самом деле является значительной проблемной областью для многих программ. Однако, проблемы динамической памяти не являются единственной разновидностью. Программа Valgrind под лицензией GPL охватывает большое разнообразие проблем, включая те, которые происходят от динамической памяти.</p>
       <p>Руководство по Valgrind описывает программу также или лучше, чем можем мы, поэтому мы будем цитировать (и сокращать) его по мере продвижения вперед.</p>
       <cite>
        <p>Valgrind является гибким инструментом для отладки и профилирования исполняемых файлов Linux-x86. Инструмент состоит из ядра, которое программно обеспечивает искусственный процессор x86, и ряда «оболочек», каждая из которых является отладочным или профилирующим инструментом. Архитектура модульная, так что можно легко создавать новые «оболочки», не нарушая существующую структуру.</p>
        <p>Наиболее полезной «оболочкой» является <code>memcheck</code>.</p>
        <p>«Оболочка» <code>memcheck</code> обнаруживает в ваших программах проблемы с управлением памятью. Проверяются все чтения и записи памяти, а вызовы <code>malloc/new/free/delete</code> перехватываются. В результате <code>memcheck</code> может обнаружить следующие проблемы</p>
        <p>• Использование неинициализированной памяти.</p>
        <p>• Чтение/запись в память после ее освобождения.</p>
        <p>• Чтение/запись за границей выделенного <code>malloc</code> блока.</p>
        <p>• Чтение/запись в ненадлежащие области стека.</p>
        <p>• Утечки памяти, когда указатели на выделенные <code>malloc</code> теряются навсегда.</p>
        <p>• Несоответствующее использование <code>malloc/new/new[]</code> против <code>free/delete/delete[]</code>.</p>
        <p>• Некоторые неправильные употребления <code>pthreads</code> API POSIX.</p>
        <p>Проблемы, подобные этим, могут быть трудно обнаруживаемыми другими средствами, часто остающимися необнаруженными в течение длительного времени и вызывающими редкие, трудные для обнаружения отказы.</p>
        <p>Другие «оболочки» более специализированы:</p>
        <p>• <code>cachegrind</code> осуществляет обстоятельную имитацию кэшей I1, D1 и L2 процессора, поэтому может точно указать источники осечек кэшей в вашем коде.</p>
        <p>• <code>addrcheck</code> идентична <code>memcheck</code> за исключением одной детали — она не проверяет неинициализированные данные. Все остальные проверки — главным образом, точная проверка адресов — по-прежнему проводится. Обратной стороной этого является то, что вы не перехватываете ошибки неинициализированных данных, которые может найти <code>memcheck</code>.</p>
        <p>Но положительная сторона значительна: программы работают почти в два раза быстрее, чем с <code>memcheck</code>, используя значительно меньше памяти. Утилита по-прежнему находит чтения/записи освобожденной памяти, памяти за пределами выделенных блоков и в других недействительных местах, ошибки, которые вы действительно хотите обнаружить до выпуска программы в свет!</p>
        <p>• <code>helgrind</code> является отладочной оболочкой, предназначенной для обнаружения состязания данных в многопоточных программах.</p>
       </cite>
       <p>Наконец, руководство отмечает:</p>
       <cite>
        <p>Valgrind тесно связан с особенностями процессора, операционной системы и, в меньшей степени, компилятора и основных библиотек С. Это затрудняет его переносимость, поэтому мы с самого начала сконцентрировались на том, что мы считаем широко использующейся платформой: Linux на x86. Valgrind использует стандартный механизм Unix '<code>./configure</code>', '<code>make</code>', '<code>make install</code>', и мы попытались обеспечить его работу на машинах с ядром 2.2 или 2.4 и glibc 2.1.X, 2.2.X или 2.3.1. Это должно охватить значительное большинство современных установок Linux. Обратите внимание, что glibc-2.3.2+ с пакетом NPTL (Native POSIX Thread Library — собственная библиотека потоков POSIX) не будет работать. Мы надеемся исправить это, но это будет нелегко.</p>
       </cite>
       <p>Если вы используете GNU/Linux на другой платформе или используете коммерческую систему Unix, Valgrind не окажет вам большой помощи. Однако, поскольку системы GNU/Linux на x86 довольно обычны (и вполне доступны), вполне вероятно, что вы сможете приобрести ее с умеренным бюджетом, или по крайней мере, занять на время! Что еще, когда Valgrind нашел для вас проблему, она исправляется для <emphasis>любой</emphasis> платформы, для которой компилируется ваша программа. Таким образом, разумно использовать систему x86 GNU/Linux для разработки, а какую-нибудь другую коммерческую систему Unix для развертывания высококачественного продукта.<a l:href="#n181" type="note">[181]</a></p>
       <p>Хотя из руководства Valgrind у вас могло сложиться впечатление, что существуют отдельные команды <code>memcheck</code>, <code>addrcheck</code> и т.д., это не так. Вместо этого программа оболочки драйвера с именем <code>valgrind</code> запускает отладочное ядро с соответствующей «оболочкой», указанной в опции <code>--skin=</code>. Оболочкой по умолчанию является <code>memcheck</code>; таким образом, запуск просто <code>valgrind</code> равносильно '<code>valgrind --skin=memcheck</code>' (Это обеспечивает совместимость с более ранними версиями Valgrind, которые осуществляли лишь проверку памяти, это имеет также больший смысл, поскольку оболочка <code>memcheck</code> предоставляет большую часть сведений.)</p>
       <p>Valgrind предусматривает ряд опций. За всеми подробностями мы отсылаем вас к его документации. Опции поделены на две группы; из тех, которые используются с ядром (т. е. работают для всех оболочек), наиболее полезными могут быть следующие:</p>
       <p><code>--gdb-attach=no/yes</code></p>
       <p>Запускается с подключенным к процессу GDB для интерактивной отладки. По умолчанию используется <code>no</code>.</p>
       <p><code>--help</code></p>
       <p>Перечисляет опции.</p>
       <p><code>--logfile=<emphasis>файл</emphasis></code></p>
       <p>Записывает сообщения в <code><emphasis>файл.pid</emphasis></code>.</p>
       <p><code>--num-callers=<emphasis>число</emphasis></code></p>
       <p>Выводит <emphasis>число</emphasis> вызывающих в трассировке стека. По умолчанию 4.</p>
       <p><code>--skin=<emphasis>оболочка</emphasis></code></p>
       <p>Использует соответствующую <emphasis>оболочку</emphasis>. По умолчанию <code>memcheck</code>.</p>
       <p><code>--trace-children=no|yes</code></p>
       <p>Запускает трассировку также в порожденных процессах. По умолчанию используется <code>no</code>.</p>
       <p><code>-V</code>, <code>--verbose</code></p>
       <p>Использует более полный вывод. Это включает перечисление загруженных библиотек, а также подсчеты всех различных видов ошибок.</p>
       <p>Из опций для оболочки <code>memcheck</code> мы полагаем, что эти являются наиболее полезными.</p>
       <p><code>--leak-check=no|yes</code></p>
       <p>Искать утечки памяти после завершения программы. По умолчанию используется <code>no</code>.</p>
       <p><code>--show-reachable=no|yes</code></p>
       <p>Показать доступные блоки после завершения программы. Если используется <code>--show-reachable=yes</code>, Valgrind ищет динамически выделенную память, на которую все еще есть указывающий на нее указатель. Такая память не является утечкой, но о ней все равно следует знать. По умолчанию используется <code>no</code>.</p>
       <p>Давайте посмотрим на Valgrind в действии. Помните <code>ch15-badmem.c</code>? (См. раздел 15.5.2.2 «Electric Fence».) Опция <code>-b</code> записывает в память, находящуюся вне выделенного <code>malloc()</code> блока. Вот что сообщает Valgrind:</p>
       <p><code>$ <strong>valgrind ch15-badmem1 -b</strong></code></p>
       <p><code>1  ==8716== Memcheck, a.k.a. Valgrind, a memory error detector for x86-linux.</code></p>
       <p><code>2  ==8716== Copyright (C) 2002-2003, and GNU GPL'd, by Julian Seward.</code></p>
       <p><code>3  ==8716== Using valgrind-20030725, a program supervision framework for x86-linux.</code></p>
       <p><code>4  ==8716== Copyright (C) 2000-2003, and GNU GPL'd, by Julian Seward.</code></p>
       <p><code>5  ==8716== Estimated CPU clock rate is 2400 MHz</code></p>
       <p><code>6  ==8716== For more details, rerun with: -v</code></p>
       <p><code>7  ==8716==</code></p>
       <p><code>8  p = &lt;not 30 bytes&gt;</code></p>
       <p><code>9  ==8716== Invalid write of size 1</code></p>
       <p><code>10 ==8716== at 0x8048466: main (ch15-badmem1.c:18)</code></p>
       <p><code>11 ==8716== by 0x420158D3: __libc_start_main (in /lib/i686/libc-2.2.93.so)</code></p>
       <p><code>12 ==8716== by 0x8048368: (within /home/arnold/progex/code/ch15/ch15-badmem1)</code></p>
       <p><code>13 ==8716== Address 0x4104804E is 12 bytes after a block of size 30 alloc'd</code></p>
       <p><code>14 ==8716== at 0x40025488: malloc (vg_replace_malloc.с:153)</code></p>
       <p><code>15 ==8716== by 0x8048411: main (ch15-badmem1.c:11)</code></p>
       <p><code>16 ==8716== by 0x420158D3: __libc_start_main (in /lib/i686/libc-2.2.93.so)</code></p>
       <p><code>17 ==8716== by 0x8048368: (within /home/arnold/progex/code/ch15/ch15-badmem1)</code></p>
       <p><code>18 ==8716==</code></p>
       <p><code>19 ==8716== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</code></p>
       <p><code>20 ==8716== malloc/free: in use at exit: 30 bytes in 1 blocks.</code></p>
       <p><code>21 ==8716== malloc/free: 1 allocs, 0 frees, 30 bytes allocated.</code></p>
       <p><code>22 ==8716== For a detailed leak analysis, rerun with: --leak-check=yes</code></p>
       <p><code>23 ==8716== For counts of detected errors, rerun with: -v</code></p>
       <p>(Были добавлены номера строк в выводе, чтобы облегчить обсуждение.) Строка 8 является выводом программы; остальные от Valgrind в стандартную ошибку. Сообщение об ошибке находится в строках 9–17. Она указывает, сколько байтов было записано неверно (строка 9), где это случилось (строка 10), и показывает трассировку стека. Строки 13–17 описывают, откуда была выделена память. Строки 19–23 подводят итоги.</p>
       <p>Опция <code>-f</code> программы <code>ch15-badmem1</code> освобождает выделенную память, а затем записывает в нее через висячий указатель. Вот что сообщает Valgrind в этом случае:</p>
       <p><code>$ <strong>valgrind ch15-badmem1 -f</strong></code></p>
       <p><code>==8719== Memcheck, a.k.a. Valgrind, a memory error detector for x86-linux.</code></p>
       <p><code>...</code></p>
       <p><code>p = &lt;not 30 bytes&gt;</code></p>
       <p><code>==8719== Invalid write of size 1</code></p>
       <p><code>==8719== at 0x8048498: main (ch15-badmem1.с:21)</code></p>
       <p><code>==8719== by 0x420158D3: __libc_start_main (in /lib/i686/libc-2.2.93.so)</code></p>
       <p><code>==8719== by 0x8048368: (within /home/arnold/progex/code/ch15/ch15-badmem1)</code></p>
       <p><code>==8719== Address 0x41048024 is 0 bytes inside a block of size 30 free'd</code></p>
       <p><code>==8719== at 0x40025722: free (vg_replace_malloc.с:220)</code></p>
       <p><code>==8719== by 0x8048491: main (ch15-badmem1.c:20)</code></p>
       <p><code>==8719== by 0x420158D3: __libc_start_main (in /lib/i686/libc-2.2.93.so)</code></p>
       <p><code>==8719== by 0x8048368: (within /home/arnold/progex/code/ch15/ch15-badmem1)</code></p>
       <p><code>...</code></p>
       <p>На этот раз в отчете указано, что запись была осуществлена в освобожденную память и что вызов <code>free()</code> находится в строке 20 <code>ch15-badmem1.c</code>.</p>
       <p>При вызове без опций <code>ch15-badmem1.c</code> выделяет и использует память, но не освобождает ее. О таком случае сообщает опция —<code>leak-check=yes</code>:</p>
       <p><code>$ <strong>valgrind --leak-check=yes ch15-badmem1</strong></code></p>
       <p><code>1  ==8720== Memcheck, a.k.a. Valgrind, a memory error detector for x86-linux.</code></p>
       <p><code>...</code></p>
       <p><code>8  p = &lt;not 30 bytes&gt;</code></p>
       <p><code>9  ==8720==</code></p>
       <p><code>10 ==8720== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</code></p>
       <p><code>11 ==8720== malloc/free: in use at exit: 30 bytes in 1 blocks.</code></p>
       <p><code>12 ==8720== malloc/free: 1 allocs, 0 frees, 30 bytes allocated.</code></p>
       <p><code>...</code></p>
       <p><code>16 ==8720==</code></p>
       <p><code>17 ==8720== 30 bytes in 1 blocks are definitely lost in loss record 1 of 1</code></p>
       <p><code>18 ==8720== at 0x40025488: malloc (vg_replace_malloc.c:153)</code></p>
       <p><code>19 ==8720== by 0x8048411: main (ch15-badmem1.c:11)</code></p>
       <p><code>20 ==8720== by 0x420158D3: __libc_start_main (in /lib/i686/libc-2.2.93.so)</code></p>
       <p><code>21 ==8720== by 0x8048368: (within /home/arnold/progex/code/ch15/ch15-badmem1)</code></p>
       <p><code>22 ==8720==</code></p>
       <p><code>23 ==8720== LEAK SUMMARY:</code></p>
       <p><code>24 ==8720== definitely lost: 30 bytes in 1 blocks.</code></p>
       <p><code>25 ==8720== possibly lost: 0 bytes in 0 blocks.</code></p>
       <p><code>26 ==8720== still reachable: 0 bytes in 0 blocks.</code></p>
       <p><code>27 ==8720== suppressed: 0 bytes in 0 blocks.</code></p>
       <p><code>28 ==8720== Reachable blocks (those to which a pointer was found) are not shown.</code></p>
       <p><code>29 ==8720== To see them, rerun with: --show-reachable=yes</code></p>
       <p>Строки 17–29 предоставляют отчет об утечке; эта память была выделена в строке 11 <code>ch15-badmem1.с</code>.</p>
       <p>Помимо отчетов о неправильном использовании динамической памяти, Valgrind может диагностировать использование <emphasis>неинициализированной</emphasis> памяти. Рассмотрим следующую программу, <code>ch15-badmem3.c</code>:</p>
       <p><code>1  /* ch15-badmem3.c --- плохое обращение с нединамической памятью */</code></p>
       <p><code>2</code> </p>
       <p><code>3  #include &lt;stdio.h&gt;</code></p>
       <p><code>4  #include &lt;stdlib.h&gt;</code></p>
       <p><code>5</code></p>
       <p><code>6  int main(int argc, char **argv)</code></p>
       <p><code>7  {</code></p>
       <p><code>8   int a_var; /* Обе не инициализированы */</code></p>
       <p><code>9   int b_var;</code></p>
       <p><code>10</code></p>
       <p><code>11  /* Valgrind не отметит это; см. текст. */</code></p>
       <p><code>12  a_var = b_var;</code></p>
       <p><code>13</code></p>
       <p><code>14  /* Использование неинициализированной памяти; это отмечается. */</code></p>
       <p><code>15  printf("a_var = %d\n", a_var);</code></p>
       <p><code>16</code></p>
       <p><code>17  return 0;</code></p>
       <p><code>18 }</code></p>
       <p>При запуске Valgrind выдает этот (сокращенный) отчет:</p>
       <p><code>==29650== Memcheck, a.k.a. Valgrind, a memory error detector for x86-linux.</code></p>
       <p><code>...</code></p>
       <p><code>==29650== Use of uninitialised value of size 4</code></p>
       <p><code>==29650== at 0x42049D2A: _IO_vfprintf_internal (in /lib/i686/libc-2.2.93.so)</code></p>
       <p><code>==29650== by 0x420523C1: _IO_printf (in /lib/1686/libc-2.2.93.so)</code></p>
       <p><code>==29650== by 0x804834D: main (ch15-badmem3.с:15)</code></p>
       <p><code>==29650== by 0x420158D3: __libc_start_main (in /lib/i686/libc-2.2.93.so)</code></p>
       <p><code>==29650==</code></p>
       <p><code>==29650== Conditional jump or move depends on uninitialised value(s)</code></p>
       <p><code>==29650== at 0X42049D32: _IO_vfprintf_internal (in /lib/i686/libc-2.2.93.so)</code></p>
       <p><code>==29650== by 0x420523C1: _IO_printf (in / lib/i686/libc-2.2.93.so)</code></p>
       <p><code>==29650== by 0x804834D: main (ch15-badmem3.c:15)</code></p>
       <p><code>==29650== by 0x420158D3: __libc_start_main (in /lib/i686/libc-2.2.93.so)</code></p>
       <p><code>...</code></p>
       <p><code>a_var = 1107341000</code></p>
       <p><code>==29650==</code></p>
       <p><code>==29650== ERROR SUMMARY: 25 errors from 7 contexts (suppressed: 0 from 0)</code></p>
       <p><code>==29650== malloc/free: in use at exit: 0 bytes in 0 blocks.</code></p>
       <p><code>==29650== malloc/free: 0 allocs, 0 frees, 0 bytes allocated.</code></p>
       <p><code>==29650== For a detailed leak analysis, rerun with: --leak-check=yes</code></p>
       <p><code>==29650== For counts of detected errors, rerun with: -v</code></p>
       <p>В документации Valgrind объясняется, что копирование неинициализированных данных не выдает сообщений об ошибках. Оболочка memcheck отмечает состояние данных (неинициализированные) и отслеживает его при перемещениях данных. Таким образом, <code>a_var</code> считается неинициализированной, поскольку это значение было получено от <code>b_var</code>, которая была неинициализированной.</p>
       <p><code>memcheck</code> сообщает о проблеме лишь тогда, когда неинициализированное значение <emphasis>используется</emphasis>. Здесь это происходит в библиотеке С (<code>_IO_vfprintf_internal()</code>), которая должна преобразовать значение в строку, для этого, она проводит с этим значением вычисления.</p>
       <p>К сожалению, хотя Valgrind может обнаружить использование неинициализированной памяти вплоть до уровня битов, он не может осуществлять проверки границ массивов для локальных и глобальных переменных. (Valgrind может осуществлять проверку границ для динамической памяти, поскольку он сам обрабатывает такую память, поэтому знает о начале и конце каждой области.)</p>
       <p>В заключение, Valgrind является мощным инструментом отладки памяти. Он использовался в таких крупномасштабных, многопоточных производственных программах, как KDE 3, OpenOffice и веб-браузер Konqueror. Он конкурирует с несколькими коммерческими предложениями, а другая его версия была даже использована (совместно с эмулятором WINE<a l:href="#n182" type="note">[182]</a>) для отладки программ, написанных для Microsoft Windows с использованием Visual С++! Вы можете получить Valgrind с его веб-сайта<a l:href="#n183" type="note">[183]</a>.</p>
      </section>
      <section>
       <title>
        <p>15.5.2.5. Другие отладчики malloc</p>
       </title>
       <p>Две статьи Cal Ericson в Linux Journal описывают <code>mtrace</code> и <code>dmalloc</code>, а также большинство других перечисленных ниже инструментов. Эти статьи <emphasis>Memory Leak Detection in Embedded Systems</emphasis>, выпуск 101<a l:href="#n184" type="note">[184]</a>, сентябрь 2002 г., и <emphasis>Memory Leak Detection in C++</emphasis>, выпуск 110<a l:href="#n185" type="note">[185]</a>, июнь 2003 г. Обе статьи доступны на веб-сайте Linux Journal.</p>
       <p>Другие инструменты сходны по природе с описанными ранее.</p>
       <p><code>ccmalloc</code></p>
       <p>Замещающая <code>malloc()</code> библиотека, которая не нуждается в особой компиляции и может использоваться с С++. См. <code>http://www.inf.ethz.ch/personal/biere/projects/ccmalloc</code>. </p>
       <p><code>malloc</code> Марка Мораеса (Mark Moraes)</p>
       <p>Старинная, но полнофункциональная библиотека замещения <code>malloc()</code>, предоставляющая возможности профилирования, трассировки и отладки. Вы можете получить ее с <code>ftp://ftp.cs.toronto.edu/pub/moraes/malloc-1.18.tar.gz</code>.</p>
       <p><code>mpatrol</code></p>
       <p>Пакет с большими возможностями настройки для отладки памяти и тестирования. См <code>http://www.cbmamiga.demon.со.uk/mpatrol</code>.</p>
       <p><code>memwatch</code></p>
       <p>Пакет, требующий использования специального заголовочного файла и опций времени компилирования. См. <code>http://www.linkdata.se/sourcecode.html</code>.</p>
       <p><code>njamd</code></p>
       <p>«Не просто еще один отладчик malloc» (Not Just Another Malloc Debugger). Эта библиотека не требует специальной компоновки с приложением; вместо этого она использует <code>LD_PRELOAD</code> для замены стандартных процедур. См. <code>http://sourceforge.net/projects/njamd</code>.</p>
       <p><code>yamd</code></p>
       <p>Похож на Electric Fence, но со многими дополнительными опциями. См. <code>http://www3.hmc.edu/~neldredge/yamd</code>.</p>
       <p>Почти все из этих пакетов используют для точной настройки своего поведения переменные окружения. В таблице 15.1 на основе статей из <emphasis>Linux Journal</emphasis> сделана сводка различных пакетов.</p>
       <empty-line/>
       <p><strong>Таблица 15.1</strong>. Сводка особенностей инструментов памяти</p>
       <table>
        <tr align="left">
         <th align="left" valign="top">Инструмент</th>
         <th align="left" valign="top">ОС</th>
         <th align="left" valign="top">Заголовочный файл</th>
         <th align="left" valign="top">Модуль/ программа</th>
         <th align="left" valign="top">Многопоточность</th>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>ccmalloc</code></td>
         <td align="left" valign="top">Многотипная</td>
         <td align="left" valign="top">Нет</td>
         <td align="left" valign="top">Программа</td>
         <td align="left" valign="top">Нет</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>dmalloc</code></td>
         <td align="left" valign="top">Многотипная</td>
         <td align="left" valign="top">Необязательно</td>
         <td align="left" valign="top">Программа</td>
         <td align="left" valign="top">Да</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>efence</code></td>
         <td align="left" valign="top">Многотипная</td>
         <td align="left" valign="top">Нет</td>
         <td align="left" valign="top">Программа</td>
         <td align="left" valign="top">Нет</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>memwatch</code></td>
         <td align="left" valign="top">Многотипная</td>
         <td align="left" valign="top">Да</td>
         <td align="left" valign="top">Программа</td>
         <td align="left" valign="top">Нет</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>Moraes</code></td>
         <td align="left" valign="top">Многотипная</td>
         <td align="left" valign="top">Необязательно</td>
         <td align="left" valign="top">Программа</td>
         <td align="left" valign="top">Нет</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>mpatrol</code></td>
         <td align="left" valign="top">Многотипная</td>
         <td align="left" valign="top">Нет</td>
         <td align="left" valign="top">Программа</td>
         <td align="left" valign="top">Да</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>mtrace</code></td>
         <td align="left" valign="top">Linux (GLIBC)</td>
         <td align="left" valign="top">Да</td>
         <td align="left" valign="top">Модуль</td>
         <td align="left" valign="top">Нет</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>njamd</code></td>
         <td align="left" valign="top">Многотипная</td>
         <td align="left" valign="top">Нет</td>
         <td align="left" valign="top">Программа</td>
         <td align="left" valign="top">Нет</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>valgrind</code></td>
         <td align="left" valign="top">Linux (GLIBC)</td>
         <td align="left" valign="top">Нет</td>
         <td align="left" valign="top">Программа</td>
         <td align="left" valign="top">Да</td>
        </tr>
        <tr align="left">
         <td align="left" valign="top"><code>yamd</code></td>
         <td align="left" valign="top">Linux, DJGPP</td>
         <td align="left" valign="top">Нет</td>
         <td align="left" valign="top">Программа</td>
         <td align="left" valign="top">Нет</td>
        </tr>
       </table>
       <p>Как видно, для отладки проблем динамической памяти доступен ряд выборов. На системах GNU/Linux и BSD один или более из этих инструментов, возможно, уже установлены, что избавляет вас от хлопот по их загрузке и построению.</p>
       <p>Полезно также использовать для своей программы несколько инструментов подряд. Например, <code>mtrace</code> для обнаружения не освобождаемой памяти, a Electric Fence для перехвата доступа к недействительной памяти.</p>
      </section>
     </section>
     <section>
      <title>
       <p>15.5.3. Современная <code>lint</code></p>
      </title>
      <p>В оригинальном С компилятор не мог проверить, соответствуют ли параметры, переданные в вызове функции, списку параметров в определении функции; прототипов не было. Это часто вело к неуловимым ошибкам, поскольку ошибочный вызов функции мог вызывать лишь частично ошибочные результаты, которые проходили незамеченными во время тестирования, или мог даже вообще не появиться во время тестирования. Например:</p>
      <p><code>if (argc &lt; 2)</code></p>
      <p><code> fprintf ("usage: %s [ options ] files\n", argv[0]);</code></p>
      <p><code>  /* отсутствует stderr */</code></p>
      <p>Если программа, содержащая этот фрагмент, никогда не вызывается с ошибочным числом аргументов, <code>fprintf()</code>, в которой отсутствует первый аргумент <code>FILE*</code>, также никогда не вызывается.</p>
      <p>Программа V7 <code>lint</code> была предназначена для решения таких проблем. Она делала два прохода через все файлы программы, сначала собирая сведения об аргументах функций, а затем сравнивая вызовы функций с собранной информацией. Особые файлы «библиотеки <code>lint</code>» предоставляли сведения о функциях стандартных библиотек, так что их также можно было проверить, lint проверяла также другие сомнительные конструкции.</p>
      <p>С появлением в стандартном С прототипов необходимость в <code>lint</code> уменьшилась, но не исчезла совсем, поскольку C89 все еще допускает объявления функций в старом стиле.</p>
      <p><code>extern int some_func(); /* Список аргументов неизвестен */</code></p>
      <p>Вдобавок, многие другие аспекты программы можно проверять <emphasis>статически</emphasis>, т.е. путем анализа исходных текстов.</p>
      <p>Программа <code>splint</code> (Secure Programming Lint — Lint для безопасного программирования)<a l:href="#n186" type="note">[186]</a> является современным обновлением <code>lint</code>. Она предусматривает слишком много опций и возможностей, чтобы перечислять их здесь, но ее стоит исследовать.</p>
      <p>Следует знать об одной особенности подобных <code>lint</code> программ, которая заключается в том, что они выводят целый поток предупреждающих сообщений. Многие из сообщаемых предупреждений в действительности безвредны. В таких случаях инструменты допускают использование специальных комментариев, сообщающих. «Да, я знаю об этом, это не проблема», <code>splint</code> лучше всего работает, когда вы предоставляете в своем коде большое количество подобных примечаний.</p>
      <p><code>splint</code> является мощным, но сложным инструментом; выделение некоторого времени на изучение его использования, а затем частое его использование поможет сохранить ваш код ясным.</p>
     </section>
    </section>
    <section>
     <title>
      <p>15.6. Тестирование программ</p>
     </title>
     <p>Разработка программного обеспечения содержит элементы и искусства, и науки, это одна сторона того, что делает ее такой восхищающей и стимулирующей профессией. Данный раздел вводит в тему тестирования программного обеспечения, которая также включает в себя и искусство, и науку; таким образом, это несколько более общий и высокий уровень (читай: «на который можно махнуть рукой»), чем остальная часть данной главы.</p>
     <p>Тестирование программ является неотъемлемой частью процесса разработки программного обеспечения. Весьма маловероятно, что программа заработает правильно на 100 процентов при первой компиляции. Программа не несет ответственности за свою правильность; за это отвечает <emphasis>автор</emphasis> программы. Одним из самых важных способов проверки того, что программа работает так, как предполагалось, является ее тестирование.</p>
     <p>Один из способов классификации различных видов тестов следующий:</p>
     <p><emphasis>Тесты модулей (Unit tests)</emphasis></p>
     <p>Это тесты, которые вы пишете для каждого модуля или функционального компонента своей программы. В качестве части работы может потребоваться также создать <emphasis>окружение (scaffolding)</emphasis> — код, предназначенный для предоставления поддерживающего каркаса, чтобы запустить модуль в виде отдельной программы.</p>
     <p>Важно спроектировать тесты для каждого функционального компонента <emphasis>во время его разработки</emphasis>. Это помогает прояснить проектирование особенностей; знание того, как это тестировать, помогает определить, что следует и что не следует делать в первую очередь.</p>
     <p><emphasis>Комплексные тесты (Integration tests)</emphasis></p>
     <p>Это тесты, которые применяются, когда все функциональные компоненты были написаны, протестированы и отлажены по отдельности. Идея в том, что все затем помешается на свое место в каркасе и тестируется все в целом, чтобы убедиться, что взаимодействия между компонентами работают.</p>
     <p><emphasis>Возвратные тесты (Regression tests)</emphasis></p>
     <p>Неизбежно вы (или ваши пользователи!) обнаружат проблемы. Это могут быть действительные ошибки, или ограничения дизайна, или неизбежные отказы в «пограничных случаях». Когда вы смогли воспроизвести и исправить проблему, сохраните первоначальные условия отказа в качестве возвратного теста.</p>
     <p>Возвратный тест позволяет вам убедиться, что при проведении изменений не была повторена старая проблема. (Это случается довольно легко.) Пропустив программу после проделанных изменений через набор тестов, вы можете быть (более) уверены, что все работает таким образом, как предполагалось.</p>
     <p>Тестирование следует по возможности автоматизировать. Это особенно легко сделать для программ, не содержащих графического пользовательского интерфейса (GUI), написанных в стиле инструментов Linux/Unix: читающих стандартный ввод или указанные файлы и записывающих в стандартный вывод и стандартную ошибку. По меньшей мере, тестирование можно осуществить с помощью простых сценариев оболочки. Более сложное тестирование осуществляется обычно с помощью отдельного подкаталога <code>test</code> и программы <code>make</code>.</p>
     <p>Тестирование программного обеспечения само по себе является отдельной областью, и мы не предполагаем отдавать ей здесь должное; скорее, наше намерение дать вам знание, что тестирование является неотъемлемой частью разработки и часто движущей силой для использования ваших навыков в отладке! Вот <emphasis>очень</emphasis> короткий резюмирующий список.</p>
     <p>• Проектируйте тест вместе с функциональностью</p>
     <p>• Тестируйте пограничные условия: убедитесь, что функция работает внутри и на действительных границах и что она корректно выдает ошибку за их пределами. (Например, функция <code>sqrt()</code> должна потерпеть неудачу с отрицательным аргументом). </p>
     <p>• Используйте в своем коде операторы проверки (см. раздел 12.1 «Операторы проверки <code>assert()</code>») и проведите свои тесты с разрешенными операторами проверки.</p>
     <p>• Создайте и используйте повторно тестовое окружение.</p>
     <p>• Сохраняйте условия сбоев для возвратного тестирования</p>
     <p>• Как можно больше автоматизируйте тестирование.</p>
     <p>• Печатайте число потерпевших неудачу тестов, чтобы легко можно было определить успех или неудачу, а также степень неудачи.</p>
     <p>• Используйте инструменты обзора кода, такие, как <code>gcov</code>, чтобы удостовериться, что ваш набор тестов охватывает весь ваш код.</p>
     <p>• Тестируйте с самого начала и тестируйте часто.</p>
     <p>• Изучите литературу по тестированию программного обеспечения, чтобы совершенствовать свою способность разрабатывать и тестировать программное обеспечение.</p>
    </section>
    <section>
     <title>
      <p>15.7. Правила отладки</p>
     </title>
     <p>Отладка не является «черной магией». Ее принципы и методики могут быть изучены и последовательно применены каждым. С этой целью мы рекомендуем книгу <emphasis>Debugging</emphasis> Дэвида Эганса (David J. Agans; ISBN: 0-8144-7168-4). У книги есть веб-сайт<a l:href="#n187" type="note">[187]</a>, на котором обобщены правила и представлен плакат для загрузки, чтобы вы могли его распечатать и повесить на стену в своем офисе.</p>
     <p>Чтобы завершить наше обсуждение, мы представляем следующий материал. Он был адаптирован Дэвидом Эгансом по разрешению из <emphasis>Debugging</emphasis>, Copyright © 2002 David J. Agans, опубликованной AMACOM<a l:href="#n188" type="note">[188]</a>, отделением American Management Association, New York. Мы благодарим его.</p>
     <p>1. <strong>Поймите систему</strong>. Когда ничто не помогает, прочтите руководство. Вам необходимо узнать, что должна делать проблемная система и все ее части, если хотите выяснить, почему она не работает. Поэтому прочтите всю документацию, которую можете получить в свои руки (и в свой браузер).</p>
     <p>Знание того, где находятся функциональные блоки и размещаются данные, и как они взаимодействуют, дает вам схему для изоляции ошибки. Конечно, вам нужно знать также соответствующую область (язык, операционную систему, приложение) и свои инструменты (компилятор, отладчик исходного кода).</p>
     <p>2. <strong>Вызовите сбой</strong>. Для того, чтобы увидеть ошибку, вы должны быть способны постоянно воспроизводить сбой. Задокументируйте свои процедуры и начните с известного состояния, чтобы вы всегда могли снова вызвать сбой. Ищите ошибку в системе, которая дает сбой, не старайтесь имитировать проблему на другой системе. Не доверяйте статистике непостоянных проблем; они скорее скроют ошибку, чем проявят ее. Вместо этого постарайтесь сделать ее устойчивой, изменяя вводимые данные, начальные условия и координацию действий.</p>
     <p>Если ошибка все еще непостоянна, вам придется сделать так, чтобы она выглядела постоянной. При каждом запуске фиксируйте в журнале каждый бит информации, какой только сможете; затем, когда есть успешные запуски и сбои, сравните их друг с другом. Если вы собрали достаточно данных, вы сможете нацелиться на проблему, как если бы смогли вызывать ошибку все время. Способность вызывать каждый раз ошибку означает также, что вы сможете сказать, когда вы ее исправили.</p>
     <p>3. <strong>Прекратите думать и смотрите</strong>. Имеется больше способов появления ошибок, чем вы можете себе представить. Поэтому не представляйте, что могло бы случиться, смотрите на это — оснастите систему инструментарием, чтобы вы действительно смогли увидеть механизм ошибки. Используйте любой инструментарий, который можете — отладчики, <code>printf()</code>, <code>assert()</code>, анализаторы логики и даже светодиоды и звуковые сигнализаторы. Проверяйте достаточно глубоко, пока ошибка не станет очевидной для глаз, а не только для мозга.</p>
     <p>Если вы все же догадались, используйте догадку, чтобы сфокусировать поиск — не старайтесь исправить, пока вы ее не увидите. Если вам приходится добавлять код инструментария, сделайте это, но убедитесь, что начинаете с той же самой базы кода, как на проблемной системе, и убедитесь, что ошибка все еще возникает при работе вашего добавленного кода. Часто добавление отладчика вызывает исчезновение ошибки (вот почему его называют отладчиком).</p>
     <p>4. <strong>Разделяй и властвуй</strong>. Каждый это знает. Вы делаете последовательное приближение — начинаете с одного конца, перескакиваете полпути, смотрите, с какой стороны ошибка, затем перескакиваете оставшиеся полпути в направлении ошибки. Бинарный поиск, вы оказываетесь так за несколько прыжков. Трудной частью является определение того, прошли вы ошибку или нет. Одной из полезных уловок является помещение в систему известных, простых данных, так чтобы можно было легче узнать мусор. Начните также с плохого конца и работайте по направлению к хорошему: если вы начнете с хорошего конца, имеется слишком много хороших путей для исследования. Известные ошибки исправляйте сразу, поскольку иногда две ошибки взаимодействуют (хотя вы могли бы поклясться, что они не должны этого делать), и последовательное приближение не работает с двумя целевыми значениями.</p>
     <p>5. <strong>Каждый раз изменяйте лишь что-то одно</strong>. Если вы стараетесь усовершенствовать модуль обработки потоков и одновременно переходите на следующую версию операционной системы, не имеет значения, видите ли вы улучшение, ухудшение или отсутствие изменений — у вас не будет мыслей по поводу того, каким был результат ваших отдельных изменений. Взаимодействие нескольких изменений может быть непредсказуемым и сбивающим с толку. Не делайте этого. Изменяйте за один раз только что-то одно, чтобы вы могли поручиться, что любое отличие, которые вы видите, возникло из-за этого изменения.</p>
     <p>Если вы делаете изменение, а результата не видно, немедленно вернитесь обратно. Возможно, оно имело результат, который вы не увидели, и он может проявиться в сочетании с другими изменениями. Это относится к изменениям как в тестировании, так и в кодировании.</p>
     <p>6. <strong>Сохраняйте контрольные журналы</strong>. Многое в эффективности приведенных выше правил зависит от сохранения хороших записей. Во всех отношениях тестирования и отладки записывайте, что вы делали, когда вы это делали, как вы это делали и что случилось в результате. По возможности делайте это в электронном виде, чтобы записи можно было послать по электронной почте и прикрепить к базе данных ошибок. Многие ключи можно найти в паттернах событий, которые были бы не замечены, если бы все они не записывались для просмотра и сравнения. Ключ может находиться также в деталях, о которых вы думали, что они неважны, поэтому запишите их все.</p>
     <p>7. <strong>Проверьте подключение</strong>. У каждого есть история о какой-нибудь проблеме, оказавшейся в том, что «это не было подключено». Иногда что-то оказывается буквально не подключенным, но для программного обеспечения «не подключено» может означать отсутствующий драйвер или старую версию кода, о которой вы думали, что заменили ее. Или плохое оборудование, когда вы клянетесь, что это проблема программного обеспечения. В одной истории инженеры-программисты и электронщики показывали пальцами друг на друга, и никто не был прав: тестирующее устройство, которое они использовали, не соответствовало спецификации. Основной момент в том, что иногда вы ищете проблему внутри системы, тогда как на самом деле она вне системы, или лежит в основе системы, или в инициализации системы, или вы смотрите не на ту систему.</p>
     <p>Не следует также непременно доверять своим инструментам. Производители инструментов также являются инженерами; у них есть ошибки, и вы можете оказаться тем, кто их обнаружит.</p>
     <p>8. <strong>Оцените свежим взглядом</strong>. Есть три причины попросить помощи при отладке.</p>
     <p>Первая причина в получении свежего взгляда — другие люди часто видят что-то лишь потому, что они не вовлечены в это так, как вы. Вторая причина заключается в получении экспертной оценки — они знают о системе больше, чем вы. Третья причина заключается в получении опыта — они видели это раньше.</p>
     <p>Когда вы описываете ситуацию кому-либо, сообщите о симптомах, которые вы видели, а не о своих предположениях, почему это происходит так. Вы пришли к ним, потому что ваши предположения не ведут вас никуда — не тяните их в ту же колею, в которую попали сами.</p>
     <p>9. <strong>Если вы не исправили это, это не исправлено</strong>. Так вы думаете, это исправлено? Испытайте. Раз вы могли заставить ошибку повторяться постоянно, создайте ту же самую ситуацию и убедитесь, что ошибки нет. Не думайте, что все исправлено лишь потому, что проблема была очевидной. Может, она не была такой очевидной. Может, ваше исправление не было сделано правильно. Может, ваше исправление даже не находится в новом выпуске! Проверьте! Заставьте ошибку исчезнуть.</p>
     <p>Вы уверены, что именно ваш код исправил проблему? Или это произошло из-за изменения теста, или туда был внесен какой-то другой код? Когда вы видите, что ваше исправление работает, уберите его и заставьте ошибку появиться снова. Затем верните исправление на место и убедитесь, что ошибки нет. Этот шаг гарантирует, что именно ваше исправление решило проблему.</p>
     <p>Дополнительные сведения о книге <emphasis>Debugging</emphasis> и плакат с правилами отладки можно найти для свободной загрузки по адресу <code>http://www.debuggingrules.com</code>.</p>
    </section>
    <section>
     <title>
      <p>15.8. Рекомендуемая литература</p>
     </title>
     <p>Следующие книги отличные, с множеством сведений как в отношении тестирования, так и отладки. Все, кроме первой, относятся к программированию вообще. Их все стоит прочесть.</p>
     <p>1. <emphasis>Debugging</emphasis>, David J. Agans. AMACOM, New York, New York. USA 2003. ISBN: 0-8144-7168-4.</p>
     <p>Настоятельно рекомендуем эту книгу. У нее легкий стиль, удивительное звучание, чтение — одно удовольствие!</p>
     <p>2. <emphasis>Programming Pearls</emphasis>, 2nd edition, by Jon Louis Bentley. Addison-Wesley, Reading, Massachusetts, USA, 2000, ISBN: 0-201-63788-0. См. также веб-сайт этой книги.<a l:href="#n189" type="note">[189]</a></p>
     <p>В главе 5 этой книги приведено хорошее обсуждение тестирования элементов и построения тестовой среды.</p>
     <p>3. <emphasis>Literate Programming</emphasis>, by Donald E. Knuth. Center for the Study of Language and Information (CSLI), Stanford University, USA, 1992. ISBN: 0-9370-7380-6.</p>
     <p>Эта восхитительная книга содержит ряд статей Дональда Кнута по <emphasis>грамотному программированию (literate programming)</emphasis> — методике программирования, которую он изобрел и использовал для создания ТеХ и Metafont. Особый интерес представляет статья, озаглавленная «Ошибки ТеХ», которая описывает, как он разрабатывал и отлаживал ТеХ, включая его журнал всех найденных и исправленных ошибок.</p>
     <p>4. <emphasis>Writing Solid Code</emphasis>, by Steve Maguire. Microsoft Press, Redmond, Washington, USA, 1993. ISBN 1-55615-551-4.</p>
     <p>5. <emphasis>Code Complete: A Practical Handbook of Software Construction</emphasis>, by Steve McConnell Microsoft Press, Redmond, Washington, USA, 1994. ISBN: 1-55615-484-4.</p>
     <p>6. <emphasis>The Practice of Programming</emphasis>, by Brian W. Kernighan and Rob Pike. Addison-Wesley, Reading. Massachusetts, USA, 1999. ISBN: 0-201-61585-X.</p>
    </section>
    <section>
     <title>
      <p>15.9. Резюме</p>
     </title>
     <p>• Отладка является важной частью разработки программного обеспечения. Для минимизации ошибок должны использоваться хорошие проектирование и практика разработки, но отладка всегда будет с нами.</p>
     <p>• Программы должны компилироваться без оптимизации и с включенными идентификаторами отладки, чтобы упростить отладку под отладчиком. На многих системах компиляция с оптимизацией и компиляция с идентификаторами отладки несовместимы. Это не относится к GCC, вот почему разработчикам GNU/Linux нужно знать об этой проблеме.</p>
     <p>• Отладчик GNU GDB является стандартом на системах GNU/Linux и может использоваться также почти на любой коммерческой системе Unix. (Также доступны и легко переносимы графические отладчики на основе GDB.) Контрольные точки, отслеживаемые точки и пошаговое исполнение с посредством <code>next</code>, <code>step</code> и <code>cont</code> предоставляют базовый контроль над программой при ее работе. GDB позволяет также проверять данные и вызывать функции внутри отлаживаемой программы.</p>
     <p> • Имеется множество вещей, которые вы можете сделать при написании программы для ее упрощения, когда неизбежно придется ее отлаживать. Мы рассмотрели следующие темы:</p>
     <p> • Отладочные макросы для вывода состояния.</p>
     <p> • Избегание макросов с выражениями.</p>
     <p> • Перестановку кода для облегчения пошагового выполнения.</p>
     <p> • Написание вспомогательных функций для использования их из отладчика.</p>
     <p> • Избегание объединений.</p>
     <p> • Помещение отладочного кода времени исполнения в готовую версию программы и обеспечение различных способов включения вывода этого кода.</p>
     <p> • Добавление фиктивных функций для упрощения установки контрольных точек.</p>
     <p>• Для помощи при отладке помимо простых отладчиков общего назначения существует ряд инструментов и библиотек. Библиотека <code>dbug</code> предоставляет элегантный внутренний отладчик, который использует многие из описанных нами методик последовательным, связанным образом.</p>
     <p>• Существует множество отладочных библиотек для динамической памяти, имеющие сходные свойства. Мы рассмотрели три из них (<code>mtrace</code>, Electric Fence и <code>dmalloc</code>) и предоставили ссылки на несколько других. Программа Valgrind идет еще дальше, обнаруживая проблемы, относящиеся к неинициализированной памяти, а не только к динамической памяти.</p>
     <p>• <code>splint</code> является современной альтернативой многоуважаемой программе V7 <code>lint</code>. Она доступна по крайней мере на системе одного из поставщиков GNU/Linux и легко может быть загружена и построена из исходных кодов.</p>
     <p>• Помимо инструментов отладки, неотъемлемой частью процесса разработки программного обеспечения является также тестирование программ. Ее следует понять, запланировать и управлять ею с самого начала любого проекта разработки программного обеспечения, даже индивидуального.</p>
     <p>• Отладка является умением, которому можно научиться. Мы рекомендуем прочесть книгу <emphasis>Debugging</emphasis> Дэвида Дж. Эганса и научиться применять его правила.</p>
    </section>
    <section>
     <title>
      <p>Упражнения</p>
     </title>
     <p>1. Откомпилируйте одну из ваших программ с помощью GCC, используя как <code>-g</code>, так и <code>-O</code>. Запустите ее под GDB, установив контрольную точку в <code>main()</code>. Выполните программу пошагово и посмотрите, насколько близко соответствует (или не соответствует) исполнение оригинальному исходному коду. Это особенно хорошо делать с кодом, использующим циклы <code>while</code> или <code>for</code>.</p>
     <p>2. Прочитайте об особенности GDB <emphasis>условной контрольной точки</emphasis>. Насколько это упрощает работу с проблемами, которые появляются лишь после того, как будет сделано определенное число операций?</p>
     <p>3. Перепишите функцию <code>parse_debug()</code> из раздела 15.4.2.1 «Добавляйте отладочные опции и переменные», чтобы использовать таблицу строк опций отладки, значений флагов и длин строк</p>
     <p>4. (Трудное.) Изучите исходный код <code>gawk</code>; в частности, структуру <code>NODE</code> в <code>awk.h</code>. Напишите вспомогательную отладочную функцию, которая выводит содержимое <code>NODE</code>, основываясь на значении в поле <code>type</code>.</p>
     <p>5. Возьмите одну из своих программ и измените ее так, чтобы использовать библиотеку <code>dbug</code>. Откомпилируйте ее сначала без <code>-DDBUG</code>, чтобы убедиться, что она компилируется и работает нормально. (Есть ли у вас для нее набор возвратных тестов? Прошла ли ваша программа все тесты?)</p>
     <p>Убедившись, что добавление библиотеки <code>dbug</code> не нарушает работу вашей программы, перекомпилируйте ее с <code>-DDBUG</code>. По-прежнему ли проходит ваша программа все свои тесты? Какова разница в производительности при включенной и отключенной библиотеке? Запустите ваш тестовый набор с опцией <code>-#t</code>, чтобы увидеть трассировку вызовов функций. Как вы думаете, это поможет вам в будущем, когда придется иметь дело с отладкой? Почему да или почему нет?</p>
     <p>6. Запустите одну из своих программ, использующих динамическую память, с Electric Fence или одним из других тестеров динамической памяти. Опишите проблемы, которые вы обнаружили, если они есть.</p>
     <p>7. Перезапустите ту же самую программу, используя Valgrind с включенным режимом проверки утечек. Опишите найденные вами проблемы, если они есть.</p>
     <p>8. Разработайте набор тестов для программы <code>mv</code>. (Прочтите <emphasis>mv</emphasis>(1): убедитесь, что охватили все ее опции.)</p>
     <p>9. Поищите в Интернете ресурсы по тестированию программного обеспечения. Какие интересные вещи вы нашли?</p>
    </section>
   </section>
   <section>
    <title>
     <p>Глава 16</p>
     <p>Проект, связывающий все воедино</p>
    </title>
    <section>
     <p>В первой половине этой книги мы довольно аккуратно связали все, что было представлено, рассмотрев V7 <code>ls.c</code>. Однако, нет достаточно небольшой программы, насколько бы это нам хотелось, чтобы связать воедино все концепции и API, представленные начиная с главы 8 «Файловые системы и обходы каталогов».</p>
    </section>
    <section>
     <title>
      <p>16.1. Описание проекта</p>
     </title>
     <p>В повседневном использовании единственной программой, которая действительно использует почти все в этой книге, является оболочка. И на самом деле есть книги по программированию на Unix, в которых пишется небольшая, но работающая оболочка для иллюстрации использованных принципов.</p>
     <p>Настоящие оболочки являются большими и беспорядочными творениями. Они должны иметь дело со многими проблемами переносимости, такими, которые мы обрисовывали по всей книге, а помимо этого, они часто должны обходить различные ошибки в различных версиях Unix Более того, чтобы быть полезными, оболочки делают множество вещей, которые не затрагивают API системных вызовов, такие, как хранение переменных оболочки, историю сохраненных команд и т.д. Предоставление завершенного обзора полноценной оболочки, такой как Bash, <code>ksh93</code> или <code>zsh</code>, потребовало бы отдельной книги.</p>
     <p>Вместо этого мы рекомендуем следующий список шагов по написанию своей собственной оболочки либо в качестве (большого) упражнения для закрепления вашего понимания, либо, возможно, в качестве совместного проекта, если вы обучаетесь в учебном заведении.</p>
     <p>1. Спроектируйте свой командный «язык», чтобы его было легко интерпретировать с помощью простого кода. Хотя технология компиляторов и интерпретаторов полезна при написании оболочки как изделия, для вас на данный момент это, вероятно, излишне.</p>
     <p>Рассмотрите следующие моменты:</p>
     <p> • Собираетесь ли вы использовать возможности интернационализации?</p>
     <p> • Какие команды должны быть встроены в оболочку?</p>
     <p> • Чтобы быть полезной, в вашей оболочке должен быть механизм пути поиска команд, аналогичный <code>$PATH</code> в обычной оболочке. Как вы его установите?</p>
     <p> • Какие перенаправления ввода/вывода вы хотите поддержать? Только файлы? Также и каналы? Хотите ли вы иметь возможность перенаправлять нет только дескрипторы файлов 0, 1 и 2?</p>
     <p> • Решите, как будут работать кавычки: одинарные и двойные? Или лишь одна разновидность? Как вы поместите в кавычки сами кавычки? Как кавычки будут взаимодействовать с перенаправлениями ввода/вывода?</p>
     <p> • Как вы обработаете вызов команд в фоновом режиме? Что насчет ожидания завершения работы команды в фоновом режиме?</p>
     <p> • Решите, будут ли у вас переменные оболочки.</p>
     <p> • Какую разновидность символов подстановки или других расширений будете вы поддерживать? Как это взаимодействует с кавычками? С переменными оболочки?</p>
     <p> • Вы должны запланировать по крайней мере операторы <code>if</code> и <code>while</code>. Спроектируйте синтаксис. Мы будем называть их <emphasis>блочными операторами</emphasis>.</p>
     <p> • Решите, хотите ли вы разрешить перенаправления ввода/вывода для блочных операторов. Если да, как будет выглядеть синтаксис?</p>
     <p> • Решите, как язык вашей оболочки должен обрабатывать сигналы, если он вообще это делает.</p>
     <p> • Разработайте шаблон тестирования и отладки до того, как вы начнете программировать.</p>
     <p>2. Если вы собираетесь использовать возможности интернационализации, делайте это с самого начала. Последующая ее вставка тяжела.</p>
     <p>3. Для настоящей работы начните просто. Начальная версия должна читать одну строку за раз и разделять ее на слова для использования в качестве отдельных аргументов. Не используйте кавычек, перенаправления ввода-вывода или что-нибудь еще. Не старайтесь даже создать новый процесс для запуска введенной программы. Как вы собираетесь тестировать то, что у вас пока есть?</p>
     <p>4. Добавьте кавычки так, чтобы отдельные «слова» могли содержать разделители. Реализует ли код для кавычек ваш проект?</p>
     <p>5. Заставьте работать ваши встроенные команды. (По крайней мере две нужные встроенные команды см. в разделах 4.6 «Создание файлов» и 8.4.1 «Смена каталога: <code>chdir()</code> и <code>fchdir()</code>».) Как вы собираетесь их тестировать?</p>
     <p>6. Первоначально используйте фиксированный путь поиска, такой как "<code>/bin:/usr/bin:/usr/local/bin</code>". Добавьте создание процесса при помощи <code>fork()</code> и его исполнение при помощи <code>exec()</code>. (См. главу 9 «Управление процессами и каналы».) Запустив новую программу, оболочка должна ждать ее завершения.</p>
     <p>7. Добавьте фоновое исполнение и, в качестве отдельной команды, ожидание завершения выполнения процесса (см. главу 9 «Управление процессами и каналы»).</p>
     <p>8. Добавьте устанавливаемый пользователем путь поиска (см. раздел 2.4 «Переменные окружения»).</p>
     <p>9. Добавьте перенаправление ввода/вывода для файлов (см. раздел 9.4 «Управление дескрипторами файлов»).</p>
     <p>10. Добавьте переменные оболочки. Протестируйте их взаимодействие с кавычками.</p>
     <p>11. Добавьте символы подстановки и другие расширения (см. раздел 12.7 «Расширения метасимволов»). Протестируйте их взаимодействие с переменными оболочки. Протестируйте их взаимодействие с кавычками.</p>
     <p>12. Добавьте конвейеры (см. раздел 9.3 «Базовое межпроцессное взаимодействие: каналы и очереди FIFO»). С этого момента начинаются настоящие сложности. Вам может потребоваться тщательно рассмотреть то, как вы управляете данными, представляющими запускаемые команды.</p>
     <p>Здесь можно было бы остановиться с законным чувством достижения, если вы получили работающую оболочку, которая может делать все, упомянутое до сих пор.</p>
     <p>13. Если вы принимаете дальнейший вызов, добавьте операторы <code>if</code> и/или <code>while</code>.</p>
     <p>14. Добавьте обработку сигналов (см. главу 10 «Сигналы»).</p>
     <p>15. Если вы хотели бы использовать свою оболочку для настоящей работы, изучите библиотеку GNU Readline (наберите в системе GNU/Linux '<code>info readline</code>' или посмотрите исходный код для оболочки Bash). Эта библиотека дает вам возможность добавлять к интерактивным программам возможность редактирования командной строки в стиле Emacs или <code>vi</code>.</p>
     <p>Постоянно держите в уме две вещи- всегда имейте возможность протестировать то, что вы делаете; и «никаких произвольных ограничений»!</p>
     <p>Когда все это сделано, проделайте анализ сделанного проекта. Как вы сделали бы его по-другому во второй раз? Удачи!</p>
    </section>
    <section>
     <title>
      <p>16.2. Рекомендуемая литература</p>
     </title>
     <p>1. <emphasis>The UNIX Programming Environment</emphasis>, by Brian W. Kernighan and Rob Pike. Prentice-Hall, Englewood Cliffs, New Jersey, USA, 1984. ISBN: 0-13-937699-2.<a l:href="#n190" type="note">[190]</a></p>
     <p>Эта классическая книга по программированию на Unix, описывающая целостную структуру окружения Unix, от интерактивного использования до программирования оболочки, программирования с помощью функций <code>&lt;stdio.h&gt;</code> и низкоуровневых системных вызовов, разработки программ с помощью <code>make</code>, <code>yacc</code> и <code>lex</code>, и документирования с помощью <code>nroff</code> и <code>troff</code>.</p>
     <p>Хотя возраст книги приличный, ее в высшей степени стоит прочесть, и мы ее чрезвычайно рекомендуем.</p>
     <p>2. <emphasis>The Art of UNIX Programming</emphasis>, by Eric S. Raymond. Addison-Wesley, Reading, Massachusetts, USA, 2004. ISBN: 0-13-142901-9.</p>
     <p>Это книга на более высоком уровне фокусируется на проблемах проектирования при программировании в Unix: как работают программы Unix и как разрабатывать свои собственные программы, чтобы уютно вписаться в окружение Linux/Unix. Хотя мы не всегда согласны со многим из того, что хочет сказать автор, книга действительно содержит значительное количество важного материала, и ее стоит прочесть.</p>
    </section>
   </section>
  </section>
  <section>
   <title>
    <p>Часть 4</p>
    <p>Приложения</p>
   </title>
   <section>
    <title>
     <p>Приложение А</p>
     <p>Научитесь программированию за десять лет</p>
    </title>
    <epigraph>
     <p>«Опыт, сущ.: Нечто, что вы не получаете до тех пор, пока это вам не понадобится».</p>
     <text-author>- Оливер -</text-author>
    </epigraph>
    <section>
     <p>Данная глава написана Петером Норвигом (Peter Norvig, © 2001 г.). Воспроизводится по разрешению. Оригинальную статью, включая гиперссылки, можно найти по адресу <code>http://www.norvig.com/21-days.html</code>. Мы включили ее, поскольку полагаем, что она содержит важную идею. Приведенная цитата является одной из наших давних любимых, и поскольку она применима к сути нашего приложения, мы ее также включили.</p>
    </section>
    <section>
     <title>
      <p>Почему каждый в такой спешке?</p>
     </title>
     <p>Зайдите в любой книжный магазин, и вы увидите «<emphasis>Научитесь Java за 7 дней</emphasis>» наряду с бесконечными вариациями, предлагающими научиться Visual Basic, Windows, Internet и т.д. за несколько дней или часов. Я произвел следующий расширенный поиск на <code>Amazon.com</code>:</p>
     <p><code>pubdate: after 1992 and title: days and</code></p>
     <p><code>(title: learn or title: teach yourself)</code></p>
     <p>и получил 248 попаданий. Первые 78 были компьютерными книгами (номер 79 был «<emphasis>Изучите Бенгали за 30 дней</emphasis>»). Я заменил «дни» ('days') на «часы» ('hours') и получил замечательным образом сходные результаты: еще 253 книг, из них 77 компьютерных, за которыми следовала под номером 78 «<emphasis>Научитесь грамматике и стилистике за 24 часа</emphasis>». Всего из верхних 200 книг 96% были компьютерные.</p>
     <p>Вывод таков, что либо люди очень торопятся изучить компьютеры, либо эти компьютеры каким-то образом фантастически легче изучить, чем что-то еще. Книг о том, как изучить Бетховена, или квантовую физику, или даже научиться ухаживать за собакой за несколько дней, нет.</p>
     <p>Давайте проанализируем, что может означать название наподобие «<emphasis>Изучите Паскаль за три дня</emphasis>»:</p>
     <p>• <strong>Изучите</strong>: за 3 дня у вас не будет времени написать несколько значительных программ и научиться из них на своих успехах и неудачах. У вас не будет времени поработать с опытным программистом и понять, на что похожа жизнь в этом окружении. Короче, у вас не будет времени научиться многому. Поэтому можно говорить лишь о поверхностном знакомстве, а не глубоком понимании. Как сказал римский папа Александр, неглубокое знание является опасной вещью.</p>
     <p>• <strong>Паскаль</strong>: за 3 дня вы смогли бы изучить синтаксис Паскаля (если вы уже знаете сходный язык), но не смогли бы много узнать о том, как использовать этот синтаксис. Короче, если бы вы были программистом на Бейсике, вы смогли бы писать программы в стиле Бейсика на Паскале, но не смогли бы изучить, для чего Паскаль в действительности подходит (или не подходит). В чем же суть? Алан Перлис (Alan Perlis) сказал однажды: «Язык, который не влияет на способ вашего мышления о программировании, не стоит того, чтобы его знали». Другими словами, вам приходится изучить крошечный кусок Паскаля (или, более вероятно, чего-то наподобие Visual Basic или JavaScript), поскольку вам нужно взаимодействовать с существующим инструментом для выполнения определенной задачи. Но тогда вы не обучаетесь программированию; вы учитесь выполнять эту задачу.</p>
     <p>• <strong>За три дня</strong>: к сожалению, этого недостаточно, как показывает следующий раздел.</p>
    </section>
    <section>
     <title>
      <p>Научитесь программированию за десять лет</p>
     </title>
     <p>Ученые (Hayes, Bloom) показали, что развитие высокой квалификации в любой из широкого разнообразия областей, включая шахматы, сочинение музыки, рисование, игра на фортепьяно, плавание, теннис, исследования в нейропсихологии и топологии, занимают около десяти лет. По-видимому, в действительности не может быть сокращения: даже Моцарту, который был музыкально одаренным уже в 4 года, потребовалось еще 13 лет, прежде чем он начал создавать мировую классическую музыку. В другом жанре Битлз, казалось, вырвались на сцену, появившись в шоу Эда Салливана в 1964 г. Но они играли с 1957 года, и хотя они рано завоевали широкую популярность, их первый переломный успех, <emphasis>Сержант Пепперс</emphasis>, был выпущен в 1967 г. Сэмюэл Джонсон (Samuel Johnson) считал, что требуется более десяти лет: «Мастерство в любой отрасли достигается лишь работой в течение жизни; его нельзя купить по меньшей цене». А Чосер (Chaucer) жаловался: «Жизнь так коротка, а ремеслу так долго учиться».</p>
     <p>Вот мой рецепт для успеха в программировании:</p>
     <p>• Заинтересуйтесь программированием и сделайте что-нибудь, потому что это забавно. Убедитесь, что оно продолжает оставаться достаточно интересным, чтобы вы хотели прилагать усилия в течение десяти лет.</p>
     <p>• Говорите с другими программистами; читайте другие программы. Это важнее, чем любая книга или учебный курс.</p>
     <p>• Программируйте. Лучшей разновидностью обучения является обучение деланием. Говоря более технически, «максимальный уровень производительности индивидуума в данной области не достигается автоматически как функция расширения опыта, но его могут повысить даже очень опытные индивидуумы в результате обдуманных усилий по совершенствованию» и «наиболее эффективное обучение требует хорошо определенной задачи с соответствующим уровнем трудности для данного конкретного индивидуума, информационной обратной связи и возможностей повторения и исправления ошибок». Книга <emphasis>Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life (Практическое познание мышление, математика и совершенствование способностей в повседневной жизни)</emphasis> является интересным справочным пособием для этой точки зрения.</p>
     <p>• Если хотите, проведите четыре года в колледже (или еще больше в аспирантуре). Это даст вам доступ к некоторым видам работ, требующим диплома, и это даст более глубокое понимание области, но если вам не нравится школа, вы можете (с некоторым упорством) получить аналогичный опыт на работе В любом случае, одного лишь изучения книг недостаточно. «Образование в компьютерных науках может сделать кого-нибудь искусным программистом не в большей степени, чем изучение кистей и красок может сделать кого-то искусным художником», — говорит Эрик Реймонд (Eric Raymond), автор <emphasis>The New Hacker's Dictionary (Словаря новых хакеров)</emphasis>. Один из лучших программистов, которых я когда-либо принимал на работу, имел лишь среднее образование, он создал массу превосходных программ, у него есть своя группа новостей и через фондовые опционы, без сомнения, намного богаче, чем буду я когда-либо.</p>
     <p>• Работайте над проектами с другими программистами. Будьте лучшим программистом в некоторых проектах; будьте худшим в некоторых других. Когда вы лучший, вы принимаетесь проверять свои способности возглавлять проект и вдохновлять других своим видением. Когда вы худший, вы изучаете то, что делают мастера, и вы изучаете, что они не любят делать (поскольку они заставляют делать это за себя вас).</p>
     <p>• Работайте над проектами <emphasis>после</emphasis> других программистов. Погрузитесь в понимание программы, написанной кем-то еще. Посмотрите, чего стоит понять и исправить ее, когда рядом нет авторов программы. Подумайте над тем, как спроектировать свои программы, чтобы сделать их проще для тех, кто будет их сопровождать после вас.</p>
     <p>• Изучите по крайней мере полдюжины языков программирования. Включите один язык, поддерживающий абстракции классов (подобно Java или С++), один, поддерживающий функциональные абстракции (подобно Lisp или ML), один, поддерживающий синтаксические абстракции (подобно Lisp), один, поддерживающий декларативные спецификации (подобно Prolog или шаблонам C++), один, поддерживающий сопрограммы (подобно Icon или Scheme), и одни, поддерживающий параллелизм (подобно Sisal).</p>
     <p>• Помните, что в «компьютерных науках» есть «компьютер». Знайте, сколько времени ваш компьютер тратит на исполнение инструкции, получение слова из памяти (с попаданием в кэш и без попадания), чтение последовательных слов с диска и поиск нового положения на диске (Ответы ниже.)</p>
     <p>• Погрузитесь в работу по стандартизации языка. Это может быть комитет ANSI С++, или это может быть принятием решения, должен ли ваш местный стиль программирования использовать 2 или 4 пробела в отступах. В любом случае, вы узнаете, что любят в языке другие люди, насколько глубоко они это чувствуют и, возможно, даже немного о том, почему они это чувствуют.</p>
     <p>• Имейте здравый смысл, чтобы отделаться от работы по стандартизации языка как можно скорее.</p>
     <p>Держа все это в уме, сомнительно, насколько далеко вы сможете уйти, обучаясь лишь по книгам. До рождения моего первого ребенка я прочел все книги <emphasis>How To (Как…)</emphasis>, и до сих пор чувствую себя необразованным новичком. 30 месяцев спустя, когда ожидался мой второй ребенок, вернулся ли я к книгам, чтобы освежить их в памяти? Нет. Вместо этого я полагался на свой собственный опыт, который оказался для меня намного более полезным и обнадеживающим, чем тысячи страниц, написанных экспертами.</p>
     <p>Фред Брукс (Fred Brooks) в своем эссе <emphasis>Никаких серебряных пуль (No Silver Bullets)</emphasis> определил план из трех частей для обнаружения великих проектировщиков программного обеспечения:</p>
     <p>1. Систематически как можно раньше распознавать ведущих проектировщиков.</p>
     <p>2. Назначить наставников по достижениям, ответственных за разработку перспективы и тщательно хранить архивы достижений.</p>
     <p>3. Предоставлять растущим проектировщикам возможности для взаимодействия и стимулирования ими друг друга.</p>
     <p>Это предполагает, что у некоторых людей уже есть качества, необходимые, чтобы стать великими проектировщиками; задача заключается в том, чтобы соответствующим образом их выманить. Алан Перлис (Alan Perlis) выразился более лаконично- «Каждого можно научить ваять: Микеланджело пришлось бы учить, как не делать это. Так же и с великими программистами».</p>
     <p>Поэтому вперед, купите эту книгу по Java; возможно, вы получите от нее какую- нибудь пользу. Но вы не измените свою жизнь или свою действительную общую квалификацию как программиста за 24 часа, дня или даже месяцев.</p>
    </section>
    <section>
     <title>
      <p>Ссылки</p>
     </title>
     <p>Bloom, Benjamin (ed.) <emphasis>Developing Talent in Young People</emphasis>, Ballantine, 1985.</p>
     <p>Brooks, Fred, <emphasis>No Silver Bullets</emphasis>, IEEE Computer, vol. 20, no 4, 1987, p. 10-19.</p>
     <p>Hayes, John R., <emphasis>Complete Problem Solver</emphasis>, Lawrence Erlbaum, 1989.</p>
     <p>Lave, Jean, <emphasis>Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life</emphasis>, Cambridge University Press, 1988.</p>
    </section>
    <section>
     <title>
      <p>Ответы</p>
     </title>
     <p>Время выполнения различных операций на типичном ПК 1 ГГц летом 2001 г.:</p>
     <p>исполнение одной инструкции  1 нс = (1/1000 000 000) сек</p>
     <p>выборка слова из кэша L1  2 нс</p>
     <p>выборка слова из основной памяти  10 нс</p>
     <p>выборка смежного слова с диска  200 нс</p>
     <p>выборка слова из нового места на диске (поиск) 8 000 000 нс = 8 мс</p>
    </section>
    <section>
     <title>
      <p>Сноски</p>
     </title>
     <p>Эта страница<a l:href="#n191" type="note">[191]</a> доступна также в переводе на японский язык<a l:href="#n192" type="note">[192]</a> благодаря Yasushi Murakawa и в переводе на испанский язык<a l:href="#n193" type="note">[193]</a> благодаря Carlos Rueda.</p>
     <p>T. Capey указывает, что страница <emphasis>Complete Problem Solver</emphasis> на Amazon теперь содержит книги <emphasis>Teach Yourself Bengali in 21 days</emphasis> и <emphasis>Teach Yourself Grammar and Style</emphasis> под рубрикой «Клиенты, которые купили эту книгу, купили также и эти книги». Я догадываюсь, что большая часть людей, посмотревших на ту книгу, пришли с этой страницы.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Приложение В</p>
     <p>Лицензия Caldera для старой Unix<a l:href="#n194" type="note">[194]</a></p>
    </title>
    <p><strong>CALDERA</strong></p>
    <p>240 West Center Street</p>
    <p>Orem, Utah 84057</p>
    <p>801-765-4999 Fax 801-765-4481</p>
    <p>23 января 2002 г.</p>
    <p>Дорогие энтузиасты UNIX®,</p>
    <p>Caldera International, Inc. настоящим предоставляет безвозмездную лицензию, которая включает права на использование, модификацию и распространение этого названного исходного кода, включая создание производных двоичных изделий из исходного кода. Исходный код, для которого Caldera International, Inc. передает права, ограничены следующими операционными системами UNIX, которые работают на 16-разрядном процессоре PDP-11 и ранних версиях 32-разрядной операционной системы UNIX, со специальным исключением UNIX System III и UNIX System V и операционных систем-наследников:</p>
    <p>32-разрядной 32V UNIX,</p>
    <p>16-разрядной UNIX версий 1, 2, 3, 4, 5, 6, 7.</p>
    <p>Caldera International, Inc. не дает никаких гарантий или поручительств, что какой-нибудь исходный код доступен от Caldera International, Inc.</p>
    <p>Следующее уведомление об авторских правах применяется к файлам исходного кода, для которых предоставляется данная лицензия.</p>
    <p>Copyright © Caldera International Inc. 2001–2002. Все права сохранены. Разрешается распространение и использование в исходной и двоичной форме, с модификациями или без них, при соблюдении следующих условий:</p>
    <p>При распространении исходного кода и документации должно быть сохранено вышеприведенное уведомление об авторских правах, данный список условий и следующий отказ от ответственности. При распространении в двоичном виде вышеприведенное уведомление об авторских правах, данный список условий и следующий отказ от ответственности должны быть воспроизведены в документации и/или в других материалах, предоставляемых при распространении.</p>
    <p>Все рекламные материалы, упоминающие особенности или использование данного программного обеспечения, должны отображать следующее признание:</p>
    <p>Этот продукт включает программное обеспечение, разработанное или принадлежащее Caldera International, Inc.</p>
    <p>Ни название Caldera International, Inc., ни названия других внесших вклад участников не могут использоваться для поддержки или продвижения продуктов, производных отданного программного обеспечения, без особого предварительного письменного разрешения.</p>
    <p>ИСПОЛЬЗОВАНИЕ ЭТОГО ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ ПРЕДУСМОТРЕНО ПО ЛИЦЕНЗИИ CALDERA INTERNATIONAL, INC. И ДРУГИХ ВНЕСШИХ ВКЛАД УЧАСТНИКОВ «КАК ЕСТЬ» И БЕЗ ВСЯКИХ ЯВНЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ ГАРАНТИЙ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ НЕЯВНЫМИ ГАРАНТИЯМИ ПРИГОДНОСТИ ДЛЯ ПРОДАЖИ ИЛИ ПРИМЕНИМОСТИ ДЛЯ ОПРЕДЕЛЕННЫХ ЦЕЛЕЙ. НИ В КОЕМ СЛУЧАЕ CALDERA INTERNATIONAL, INC. НЕ НЕСЕТ ОТВЕТСТВЕННОСТИ ЗА ЛЮБОЙ ПРЯМОЙ, КОСВЕННЫЙ, СЛУЧАЙНЫЙ, СПЕЦИАЛЬНЫЙ, ШТРАФНОЙ ИЛИ ЯВЛЯЮЩИЙСЯ СЛЕДСТВИЕМ УЩЕРБ (ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ ПРИОБРЕТЕНИЕМ ИЛИ ЗАМЕНОЙ ТОВАРОВ; ПОТЕРЮ ЦЕННОСТИ, ДАННЫХ, УПУЩЕННУЮ ВЫГОДУ ИЛИ ПРИОСТАНОВКУ БИЗНЕСА), КАК БЫ ОН НИ БЫЛ ВЫЗВАН И В СООТВЕТСТВИИ С КАКИМИ БЫ ТО НИ БЫЛО ПРЕДПОЛОЖЕНИЯМИ, БУДЬ ТО В КОНТРАКТЕ, НЕПОСРЕДСТВЕННОЙ ОТВЕТСТВЕННОСТИ ИЛИ ГРАЖДАНСКОМ ПРАВОНАРУШЕНИИ (ВКЛЮЧАЯ НЕБРЕЖНОСТЬ ИЛИ ДРУГОЕ), ВОЗНИКШИЕ ЛЮБЫМ СПОСОБОМ ВСЛЕДСТВИЕ ИСПОЛЬЗОВАНИЯ ДАННОГО ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ, ДАЖЕ В СЛУЧАЕ ПРЕДУПРЕЖДЕНИЯ О ВОЗМОЖНОСТИ ТАКОГО УЩЕРБА.</p>
    <cite>
     <text-author>Искренне ваш,</text-author>
     <text-author>(подпись) Bill Broderick</text-author>
     <text-author>Bill Broderick</text-author>
     <text-author>Директор, Служба лицензирования</text-author>
     <text-author>UNIX является зарегистрированной торговой маркой Open Group в США и других странах.</text-author>
    </cite>
   </section>
   <section>
    <title>
     <p>Приложение С</p>
     <p>Общедоступная лицензия GNU<a l:href="#n195" type="note">[195]</a></p>
    </title>
    <section>
     <p>Версия 2, июнь 1991 г.</p>
     <p>Copyright © 1989, 1991 Free Software Foundation, Inc.</p>
     <p>59 Temple Place, Suite 330, Boston, MA 02111, USA</p>
     <p>Разрешается копировать и распространять дословные копии данного лицензионного документа, но не разрешается его изменять.</p>
     <subtitle>Преамбула</subtitle>
     <p>Лицензии большинства программных продуктов составлены так, чтобы отобрать у вас право совместно использовать и изменять продукт. По контрасту, Общедоступная лицензия GNU (GNU General Public License), напротив, подразумевает вашу свободу в совместном использовании и изменении свободного программного обеспечения — чтобы гарантировать, что программное обеспечение является свободным для всех своих пользователей. Данная Общедоступная лицензия применяется к большей части программного обеспечения Фонда независимых программ (Free Software Foundation) и к любой другой программе, авторы которой передают ее на использование с данной лицензией. (Некоторое другое программное обеспечение Фонду независимых программ защищается вместо этого Общедоступной библиотечной лицензией GNU (GNU Library General Public License).) Вы также можете использовать ее для своих программ.</p>
     <p>Когда мы говорим о независимом программном обеспечении, мы имеем в виду свободу, а не цену. Наши Общедоступные лицензии разработаны так, чтобы гарантировать вам свободу распространять копии независимого программного обеспечения (и назначать за это цену, если хотите), получать исходный код, если хотите, изменять программное обеспечение или его части в новых независимых программах; а также гарантировать, что вы будете знать обо всех этих вещах.</p>
     <p>Чтобы защитить ваши права, нам необходимо предусмотреть ограничения, которые запрещают кому бы то ни было отказывать вам в этих правах или просить вас от них отказаться. Эти ограничения преобразуются а определенные ваши обязанности, если вы распространяете копии программного обеспечения или модифицируете его.</p>
     <p>Например, если вы распространяете копии таких программ, вне зависимости от того, бесплатно или за плату, вы обязаны дать получателям все права, которые есть у вас. Вы должны также обеспечить для них получение или возможность получения исходного кода. И вы должны довести до их сведения эти положения, чтобы они знали о своих правах.</p>
     <p>Мы защищаем ваши права а два этапа: (1) обеспечивая авторское право на программное обеспечение и (2) предоставляя вам эту лицензию, которая дает вам законное разрешение копировать, распространять и/или модифицировать программное обеспечение.</p>
     <p>Также, для защиты каждого автора и нашей собственной, мы хотим удостовериться в том, что каждый понимает, что на это независимое программное обеспечение нет гарантий. Если программное обеспечение модифицируется кем-либо еще и распространяется дальше, мы хотим, чтобы его получатели знали, что то, что они получают, не является оригиналом, поэтому любые проблемы, привнесенные другими, не должны отражаться на репутации автора оригинального продукта.</p>
     <p>Наконец, любая независимая программа постоянно подвергается угрозе со стороны патентов на программное обеспечение. Мы хотим избежать опасности, когда распространители независимой программы получают отдельные патентные права, фактически превращая программу в патентованную. Чтобы предотвратить это, мы ясно дали понять, что любой патент должен предусматривать свободное его использование всеми или не регистрироваться вообще.</p>
     <p>Далее следуют точные праве и обязанности при копировании, распространении и модификации.</p>
     <subtitle>Права и обязанности при копировании, распространении и модификации</subtitle>
     <p>0. Данная лицензия распространяется на любую программу или другой продукт, который содержит размещенное владельцем авторских прав уведомление, заявляющее, что этот продукт может распространяться в соответствии с условиями данной Общедоступной лицензии. Используемый далее термин «Программа» относится к любым таким программе или продукту, а «продукт, основанный на Программе» означает либо саму Программу, либо любой производный продукт, защищаемый законом об авторском праве: то есть продукт, содержащий Программу или часть ее, воспроизведенный точно или с модификациями и/или переведенный на другой язык. (В дальнейшем перевод без ограничений включается в термин «модификация».) К каждому обладателю лицензии обращение следует как «вы».</p>
     <p>Другая деятельность, отличная от копирования, распространения и модификации, не охватывается данной Лицензией; она выходит за рамки ее действия. Акт запуска Программы на выполнение не ограничивается, а результаты работы Программы попадают под действие Лицензии лишь в том случае, если их содержание составляет продукт на основе Программы (независимо от того, было ли это сделано путем запуска Программы). Правомочность этого положения зависит от того, что делает Программа.</p>
     <p>1. Вы можете копировать и распространять дословные копии исходного кода Программы в том виде, как вы его получили, с помощью любого средства при условии, что вы открыто и соответствующим образом опубликуете в каждой копни соответствующее заявление об авторских правах и отказе от гарантий; сохраните без изменений все заявления, ссылающиеся на данную Лицензию и на отсутствие каких-либо гарантий, и предоставите всем остальным получателям Программы вместе с самой Программой копию данной Лицензии.</p>
     <p>Вы можете назначить плату за акт физического копирования, вы можете также по своему усмотрению предоставить гарантию на платной основе.</p>
     <p>2. Вы вправе модифицировать свою копию или копии Программы или любую их часть, создавая тем самым продукт, основанный на Программе, и копировать и распространять такие модификации или продукты на условиях Параграфа 1, приведенного выше, при условии, что вы будете также следовать всем нижеприведенным требованиям:</p>
     <p> a. Модифицированные файлы должны иметь заметные предупреждения о том, что вы изменили файлы, с указанием даты изменений.</p>
     <p> b. Любой продукт, который вы распространяете или публикуете, который целиком или частично является производным от Программы или любой ее части, должен быть целиком бесплатно лицензирован для всех третьих сторон в соответствии с условиями данной Лицензии.</p>
     <p> c. Если модифицированная программа обычно интерактивно принимает команды при работе, вы должны обеспечить при ее запуске стандартным способом для такого интерактивного использования выведение на печать или отображение на экране сообщения, включающего соответствующее заявление об авторских правах и заявление об отсутствии гарантий (либо, в противном случае, заявляющее о предоставлении гарантии вами) и о том, что пользователи могут далее распространять программу на данных условиях, и сообщающее пользователю, как можно просмотреть копню данной Лицензии. (Исключение: если сама Программа интерактивная, но обычно не выводит подобного сообщения, от вашего продукта, основанного на Программе, не требуется выводить это сообщение).</p>
     <p>Эти требования применяются к модифицированному продукту в целом. Если идентифицируемые разделы этого продукта не являются производными от Программы и могут с основанием рассматриваться независимыми и отдельными продуктами сами по себе, тогда данная лицензия и ее условия неприменимы к этим разделам при распространении их в качестве отдельных продуктов. Но когда вы распространяете те же разделы в виде целого, являющегося продуктом, основанным на Программе, распространение этого целого должно соответствовать положениям данной Лицензии, положения которой для обладателей лицензии распространяется на все целое и, таким образом, на каждую отдельную часть независимо от того, кто ее написал.</p>
     <p>Таким образом, цель данного раздела состоит не в том, чтобы заявить свои права или оспорить ваши права на продукт, написанный исключительно вами; целью скорее является использование права контролировать распространение производных или совместных продуктов, основанных на Программе.</p>
     <p>В дополнение, простое объединение другого продукта, не основанного на Программе, с Программой (или продуктом, основанным на Программе) на одном носителе информации или среде передачи данных не включает другой продукт в сферу применения данной Лицензии.</p>
     <p>3. Вы вправе копировать и распространять Программу (или продукт, основанный на ней, в соответствии с Параграфом 2) в виде объектного кода или исполняемой программы, при выполнении условий, оговоренных в Параграфах 1 и 2, обеспечив также соблюдение одного из следующих требований:</p>
     <p> a. Сопроводив ее соответствующим полным исходным кодом в электронной форме, который должен распространяться в соответствии с вышеприведенными условиями Параграфов 1 и 2, на носителях, обычно используемых для обмена программами; или</p>
     <p> b. Сопроводив ее письменным предложением, действительным по крайней мере в течение трех лет, на предоставление любой третьей стороне по цене, не превышающей стоимость затрат на физическое распространение исходного кода, полной копии соответствующего исходного кода в электронном виде для распространения в соответствии с вышеприведенными условиями Параграфов 1 и 2, на носителях, обычно используемых для обмена программами; или</p>
     <p> c. Сопроводив ее сведениями, которые вы получили в качестве предложения распространения соответствующего исходного кода. (Данный вариант допустим лишь для некоммерческого распространения и лишь в том случае, если вы получили программу в виде объектного кода или исполняемого модуля с данным предложением, в соответствии с вышеприведенным Подпунктом b.)</p>
     <p>Исходный код для продукта означает предпочтительную форму продукта для внесения изменений. Для продукта исполняемого модуля полный исходный код означает весь исходный код для всех модулей, который в нем содержится, плюс любые связанные с ним файлы определения интерфейсов, плюс сценарии, используемые для управления компиляцией и установки исполняемого файла. Однако, в виде особого исключения, распространяемый исходный код не нуждается во включении чего-либо, что обычно распространяется (либо в виде исходного кода, либо в бинарной форме) с главными компонентами (компилятором, ядром и т.д.) операционной системы, на которой исполняемый модуль запускается, если только этот компонент сам не сопровождает исполняемый модуль.</p>
     <p>Если распространение исполняемого или объектного кода осуществляется путем предложения доступа к копированию из определенного места, в таком случае предложение эквивалентного доступа для копирования исходного кода из того же источника рассматривается как распространение исходного кода, даже если третья сторона не принуждается к копированию исходного кода вместе с объектным кодом.</p>
     <p>4. Вы не вправе копировать, изменять, выдавать сублицензии или распространять Программу на иных условиях, чем предусмотрено настоящей Лицензией. Любая попытка копировать, изменять, выдавать сублицензии или распространять Программу иным способом является не имеющей юридической силы и ведет к автоматическому прекращению ваших прав, предусмотренных данной Лицензией. Однако стороны, получившие от вас копии или права на условиях данной Лицензии, сохранят свои лицензии до тех пор, пока эти стороны будут полностью соблюдать условия данной Лицензии.</p>
     <p>5. От вас не требуется признавать данную Лицензию, поскольку вы не подписывали ее. Однако, ничто иное не дает вам прав на изменение или распространение Программы или производных от нее продуктов. Подобные действия запрещены законом, если вы не признаете данную Лицензию. Следовательно, фактом изменения или распространения Программы (или любого продукта на основе Программы) вы заявляете о своем признании данной Лицензии и всех содержащихся в ней требований и условий по копированию, распространению или изменению Программы или продуктов, основанных на ней.</p>
     <p>6. Каждый раз при распространении Программы (или любого продукта, основанного на Программе), получатель автоматически становится обладателем лицензии от оригинального владельца авторских прав на копирование, распространение или изменение Программы в соответствии с данными требованиями и условиями. Вы не вправе налагать дополнительные ограничения на реализации предоставляемых здесь прав получателя. Вы не несете ответственности за обеспечение соблюдения третьей стороной данной Лицензии.</p>
     <p>7. Если в результате судебного разбирательства или заявления о нарушении патентных прав, или по любой иной причине (не ограничиваясь вопросами патентов) на вас наложены ограничения (по предписанию суда, по соглашению или иные), которые противоречат условиям настоящей Лицензии, они не освобождают вас от условий данной Лицензии. Если вы не можете распространять Программу таким образом, чтобы одновременно выполнять свои обязательства в соответствии с настоящей Лицензией и с любыми другими относящимися к делу обязательствами, вы, как следствие, вовсе лишаетесь права распространять Программу. Например, если патентная лицензия не допускает безвозмездное распространение Программы всеми теми, кто прямо или косвенно получит от вас копии, единственным способом, с помощью которого вы можете удовлетворить и патентную лицензию, и данную Лицензию, будет полное воздержание от распространения Программы.</p>
     <p>Если любая часть данного параграфа считается недействительной или не могущей быть выполненной в каких-либо конкретных обстоятельствах, должна применяться оставшаяся часть параграфа, а параграф в целом должен применяться в других условиях.</p>
     <p>Целью данного параграфа не является склонить вас к нарушению каких-либо заявлений о патентных или иных правах собственности или оспорить любые такие заявления; единственная цель данного параграфа заключается в защите целостности системы распространения свободного программного обеспечения, которая реализуется практикой общедоступной лицензии. Многие люди сделали щедрый вклад в широкий спектр программного обеспечения, распространяемого посредством этой системы, в надежде на последовательное применение этой системы; делом автора/дарителя является решение, нужно ли распространять программу через любую другую систему, а обладатель лицензии не может повлиять на этот выбор.</p>
     <p>Этот параграф нацелен на прояснение того, что подразумевается выводом оставшейся части настоящей Лицензии.</p>
     <p>8. Если распространение и/или использование Программы в определенных странах ограничено либо патентами, либо охраняемыми авторским правом интерфейсами, ординальный владелец авторских прав, помещающий Программу под сферу влияния данной Лицензии, может добавить явные географические ограничения на распространение, исключающие эти страны, таким образом, чтобы распространение было разрешено лишь в не исключенных странах. В таком случае, данная Лицензия включает в себя это ограничение, как если бы оно было написано в тексте самой данной Лицензии.</p>
     <p>9. Фонд свободного программного обеспечения время от времени может публиковать пересмотренные и/или новые версии Общедоступной Лицензии. Такие новые версии будут сходны по духу с настоящей версией, но могут отличаться в деталях для учета новых проблем или интересов.</p>
     <p>Каждая версия получает отличительный номер версии. Если в Программе указан номер версии данной Лицензии, которая применяется к ней, и «любая последующая версия», вы имеете возможность соблюдать условия либо данной версии, либо любой последующей версии, опубликованной Фондом свободного программного обеспечения. Если в Программе не указан номер версии данной Лицензии, вы вправе выбрать любую версию, когда-либо публиковавшуюся Фондом свободного программного обеспечения.</p>
     <p>10. Если вы хотите включить части Программы в другие свободные программы с иными условиями их распространения, напишите автору с просьбой о разрешении. Для программного обеспечения, авторским правом на которое обладает Фонд свободного программного обеспечения, напишите в Фонд свободного программного обеспечения, для этого мы иногда делаем исключения. Наше решение будет определяться двумя целями, сохранение свободного статуса всех производных от нашего свободного программного обеспечения и продвижение совместного и повторного использования программного обеспечения вообще.</p>
     <subtitle>Отказ от гарантий</subtitle>
     <p>11. ПОСКОЛЬКУ ДАННАЯ ПРОГРАММА ЛИЦЕНЗИРУЕТСЯ БЕСПЛАТНО, ДЛЯ НЕЕ НЕ ПРЕДОСТАВЛЯЕТСЯ НИКАКИХ ГАРАНТИЙ, В ТОЙ СТЕПЕНИ, НАСКОЛЬКО ЭТО ПРИМЕНИМО ПО ЗАКОНУ. ЕСЛИ ПИСЬМЕННО НЕ УКАЗАНО ИНОЕ, ВЛАДЕЛЬЦЫ АВТОРСКОГО ПРАВА И/ИЛИ ДРУГИЕ СТОРОНЫ ПРЕДОСТАВЛЯЮТ ПРОГРАММУ «КАК ЕСТЬ», БЕЗ ГАРАНТИЙ КАКОГО-ЛИБО РОДА, ВЫРАЖЕННЫХ ЯВНО ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЛ, НО НЕ ОГРАНИЧИВАЯСЬ ТОЛЬКО ЭТИМ, ПОДРАЗУМЕВАЕМЫМИ ГАРАНТИЯМИ ПОЛЕЗНОСТИ И ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННЫХ ЦЕЛЕЙ. ВЕСЬ РИСК, КАСАЮЩИЙСЯ КАЧЕСТВА И ПРОИЗВОДИТЕЛЬНОСТИ ПРОГРАММЫ, ЛОЖИТСЯ НА ВАС. ЕСЛИ ПРОГРАММА ОКАЖЕТСЯ С НЕДОСТАТКАМИ, ВЫ БЕРЕТЕ НА СЕБЯ РАСХОДЫ ПО ВСЕМУ НЕОБХОДИМОМУ ОБСЛУЖИВАНИЮ, ВОССТАНОВЛЕНИЮ ИЛИ ИСПРАВЛЕНИЮ.</p>
     <p>12. НИ ПРИ КАКИХ ОБСТОЯТЕЛЬСТВАХ, ЕСЛИ ТОЛЬКО ЭТО НЕ ТРЕБУЕТСЯ ПО СООТВЕТСТВУЮЩЕМУ ЗАКОНУ ИЛИ НЕ ОГОВОРЕНО ПО ПИСЬМЕННОМУ СОГЛАШЕНИЮ, НИ ОДИН ИЗ ВЛАДЕЛЬЦЕВ АВТОРСКИХ ПРАВ ИЛИ ЛЮБАЯ ДРУГАЯ СТОРОНА, КОТОРАЯ МОЖЕТ МОДИФИЦИРОВАТЬ И/ИЛИ РАСПРОСТРАНИТЬ ПРОГРАММУ НА ОГОВОРЕННЫХ ВЫШЕ УСЛОВИЯХ, НЕ БУДЕТ ОТВЕЧАТЬ ЗА ПРИЧИНЕННЫЙ ВАМ УЩЕРБ, ВКЛЮЧАЯ ЛЮБОЙ ОБЩИЙ, ОСОБЫЙ, СЛУЧАЙНЫЙ ИЛИ КОСВЕННЫЙ УЩЕРБ, ПОНЕСЕННЫЙ ОТ ИСПОЛЬЗОВАНИЯ ИЛИ НЕВОЗМОЖНОСТИ ИСПОЛЬЗОВАНИЯ ПРОГРАММЫ (ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ ТОЛЬКО ЭТИМ, ПОТЕРИ ДАННЫХ ИЛИ НЕТОЧНЫЕ ОБРАБОТКИ ДАННЫХ ИЛИ ПОТЕРИ, КОТОРЫЕ ПОНЕСЛИ ВЫ ИЛИ ТРЕТЬИ ЛИЦА; ИЛИ НЕСПОСОБНОСТЬ ПРОГРАММЫ РАБОТАТЬ С ЛЮБЫМИ ДРУГИМИ ПРОГРАММАМИ), ДАЖЕ ЕСЛИ ВЛАДЕЛЕЦ АВТОРСКИХ ПРАВ ИЛИ ИНАЯ СТОРОНА БЫЛИ ПРЕДУПРЕЖДЕНЫ О ВОЗМОЖНОСТИ ТАКОГО УЩЕРБА.</p>
     <subtitle>КОНЕЦ ОПИСАНИЯ ПРАВ И ОБЯЗАННОСТЕЙ</subtitle>
    </section>
    <section>
     <title>
      <p>Как применить эти условия договора к своим новым программам</p>
     </title>
     <p>Если вы разрабатываете новую программу и хотите, чтобы она принесла максимально большую пользу широкому кругу людей, лучшим способом достижения этого является включение ее в состав свободного программного обеспечения, которое каждый может распространять и изменять в соответствии с данными условиями.</p>
     <p>Чтобы это сделать, добавьте к программе следующие уведомления. Надежнее всего добавить их в начало каждого исходного файла, чтобы наиболее эффективно сообщить об отказе от гарантий; и в каждом файле должна быть по крайней мере строка с «авторскими правами» и указанием на то, где можно найти полное уведомление.</p>
     <p><code>одна строка с названием программы и описанием того, что она делает</code></p>
     <p><code>Copyright (С) <emphasis>год имя автора</emphasis></code></p>
     <p><code>Эта программа является свободным программным продуктом; вы можете</code></p>
     <p><code>распространять и/или изменять ее на условиях Общедоступной</code></p>
     <p><code>лицензии GNU в том виде, как это опубликовано Фондом свободного</code></p>
     <p><code>программного обеспечения; либо версии 2 Лицензии, либо</code></p>
     <p><code>(по вашему выбору) любой последующей версии.</code></p>
     <p><code>Данная программа распространяется в надежде, что она будет полезной,</code></p>
     <p><code>но БЕЗ ВСЯКИХ ГАРАНТИЙ; в том числе без подразумеваемых гарантий</code></p>
     <p><code>ПОЛЕЗНОСТИ или ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННОЙ ЦЕЛИ. Дополнительные</code></p>
     <p><code>подробности см. в Общедоступной лицензии GNU.</code></p>
     <p><code>Вместе с данной программой вы должны были получить копию</code></p>
     <p><code>Общедоступной лицензии GNU; если вы ее не получили, напишите</code></p>
     <p><code>в Фонд свободного программного обеспечения:</code></p>
     <p><code>Free Software Foundation, Inc., 59 Temple Place,</code></p>
     <p><code>Suite 330, Boston, MA 20111, USA.</code></p>
     <p>Добавьте также сведения о том, как связаться с вами по электронной или обычной почте.</p>
     <p>Если программа интерактивная, вставьте в ее вывод при запуске краткое уведомление, подобное данному:</p>
     <p><code>Gnomovision version 69, Copyright (С) <emphasis>год имя_автора</emphasis></code></p>
     <p><code>Gnomovision поставляется БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ; чтобы получить</code></p>
     <p><code>подробности, наберите 'show w'. Это свободный программный продукт,</code></p>
     <p><code>и вы можете распространять его при определенных условиях;</code></p>
     <p><code>наберите 'show c', чтобы получить дополнительные сведения.</code></p>
     <p>Гипотетические команды '<code>show w</code>' и '<code>show c</code>' должны отображать соответствующие части Общедоступной лицензии. Конечно, используемые вами команды могут называться как-нибудь иначе, а не '<code>show w</code>' и '<code>show c</code>'; они могут быть даже щелчками мышью или пунктами меню — всем, что лучше подходит вашей программе.</p>
     <p>Вам следует также получить от вашего нанимателя (если вы работаете программистом) или учебного заведения, если оно имеется, заявление об «отказе от авторских прав» для программы, если это необходимо. Вот образец; измените имена:</p>
     <p><code>Yoyodyne, Inc., настоящим отказывается от всех авторских прав</code></p>
     <p><code>на программу 'Gnomovision' (которая работает с компиляторами),</code></p>
     <p><code>написанной James Hacker.</code></p>
     <p><code><emphasis>подпись</emphasis> Ty Coon, 1 апреля 1989</code></p>
     <p><code>Ty Coon, вице-президент</code></p>
     <p>Данная Общедоступная лицензия не разрешает включать вашу программу в частные программы. Если ваша программа представляет собой библиотеку процедур, вы можете счесть более полезным разрешить компоновку частных приложений с данной библиотекой. Если это то, что вам нужно, используйте вместо данной Лицензии Малую общедоступную библиотечную лицензию GNU.</p>
    </section>
    <section>
     <title>
      <p>Пример использования</p>
     </title>
     <p>Данный раздел <emphasis>не</emphasis> является частью GPL. Здесь мы показываем комментарий с заявлением об авторских правах из программы GNU <code>env</code>:</p>
     <p><code>/* env - run a program in a modified environment</code></p>
     <p><code>Copyright (C) 1986, 1991-2002 Free Software Foundation, Inc.</code></p>
     <p><code>This program is free software; you can redistribute it and/or modify</code></p>
     <p><code>it under the terms of the GNU General Public License as published by</code></p>
     <p><code>the Free Software Foundation; either version 2, or (at your option)</code></p>
     <p><code>any later version.</code></p>
     <p><code>This program is distributed in the hope that it will be useful,</code></p>
     <p><code>but WITHOUT ANY WARRANTY; without even the implied warranty of</code></p>
     <p><code>MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</code></p>
     <p><code>GNU General Public License for more details.</code></p>
     <p><code>You should have received a copy of the GNU General Public License</code></p>
     <p><code>along with this program; if not, write to the Free Software Foundation,</code></p>
     <p><code>inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */</code></p>
     <p>Это обычное использование. Оно содержит следующие, в сущности, стереотипные элементы:</p>
     <p>• Одну строку комментария с названием и описанием программы. В более крупных программах здесь может быть название и описание файла внутри программы.</p>
     <p>• Заявление об авторских правах.</p>
     <p>• Два параграфа с объяснением и отказом от гарантий.</p>
     <p>• Где получить копию GPL.</p>
    </section>
   </section>
  </section>
 </body>
 <body name="notes">
  <title>
   <p>Примечания</p>
  </title>
  <section id="n1">
   <title>
    <p>1</p>
   </title>
   <p>Это знаменитое высказывание было сделано на Международном симпозиуме по эффективному производству больших программ в Jablonna, Польша, 10-14 августа 1970 г. — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n2">
   <title>
    <p>2</p>
   </title>
   <p><code>http://www.ansi.org</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n3">
   <title>
    <p>3</p>
   </title>
   <p><code>http://www.iso.ch</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n4">
   <title>
    <p>4</p>
   </title>
   <p><code>http://www.opengroup.org</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n5">
   <title>
    <p>5</p>
   </title>
   <p><code>http://www.gnu.org</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n6">
   <title>
    <p>6</p>
   </title>
   <p>Игра слов: free — свободный, бесплатный — <emphasis>Примеч. перев</emphasis>.</p>
  </section>
  <section id="n7">
   <title>
    <p>7</p>
   </title>
   <p>В оригинале: «Rome wasn't built in a day» — <emphasis>Примеч. перев.</emphasis></p>
  </section>
  <section id="n8">
   <title>
    <p>8</p>
   </title>
   <p>См. справочные страницы <emphasis>csh</emphasis>(1) и <emphasis>tcsh</emphasis>(1) и книгу <emphasis>Using csh &amp; tcsh</emphasis>, by Paul DuBois, O'Reilly &amp; Associates. Sebastopol, CA. USA, 1995. ISBN 1-56592-132-1 — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n9">
   <title>
    <p>9</p>
   </title>
   <p>Соответствующие справочные страницы можно посмотреть с помощью man 1 awk и man 3 printf — <emphasis>Примеч. науч. ред</emphasis>.</p>
  </section>
  <section id="n10">
   <title>
    <p>10</p>
   </title>
   <p><code>http://www.southern-storm.com.au/v7upgrade.html</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n11">
   <title>
    <p>11</p>
   </title>
   <p>Некоторые системы позволяют рядовым пользователям назначать владельцем их файла кого-нибудь еще, таким образом «отдавая его». Детали определяются стандартом POSIX, но они несколько запутаны. Обычная конфигурация GNU/Linux не допускает этого — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n12">
   <title>
    <p>12</p>
   </title>
   <p>Конечно, владелец всегда может изменить права доступа. Большинство пользователей не отменяют для себя нрава на запись — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n13">
   <title>
    <p>13</p>
   </title>
   <p>Для этого правила есть несколько редких исключений, но все они выходят за рамки данной книги — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n14">
   <title>
    <p>14</p>
   </title>
   <p>Эта особенность впервые появилась в Multics, но Multics никогда широко не использовался — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n15">
   <title>
    <p>15</p>
   </title>
   <p>Процесс может быть приостановлен, в этом случае он не «работающий»; но он и не завершён. В любом случае, на ранних этапах восхождения по кривой обучения не стоит быть слишком педантичным — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n16">
   <title>
    <p>16</p>
   </title>
   <p>Так называемые переменные окружения — <emphasis>Примеч. науч. ред.</emphasis></p>
  </section>
  <section id="n17">
   <title>
    <p>17</p>
   </title>
   <p>Между народный стандарт ISO/IEC 9899-1990 описывает разновидность языка С известную также как C89 или C90 — <emphasis>Примеч. науч. ред</emphasis>.</p>
  </section>
  <section id="n18">
   <title>
    <p>18</p>
   </title>
   <p>Стандарт C99 (ISO/IЕС 9899-1999) — Примеч. науч. ред.</p>
  </section>
  <section id="n19">
   <title>
    <p>19</p>
   </title>
   <p>Этот раздел адаптирован из статьи автора, который издавался в выпуске 16 <emphasis>Linux Journal</emphasis> (См. <code>http://www.linuxjournal.com/article.php?sid=1135</code>) Перепечатано и адаптировано по разрешению — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n20">
   <title>
    <p>20</p>
   </title>
   <p>Это утверждение относится к ядру HURD, которое все еще находится в стадии разработки (в начале 2004 г.) Разработка на основе GCC и библиотеки GNU С (GLIBC) сегодня имеет место большей частью на Linux-системах — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n21">
   <title>
    <p>21</p>
   </title>
   <p>Стиль расположения кода, рекомендуемый фондом свободного программного обеспечения (Free Software Foundation) — <emphasis>Примеч. науч. ред.</emphasis></p>
  </section>
  <section id="n22">
   <title>
    <p>22</p>
   </title>
   <p>Эта ситуация имела место примерно в 1993 г; трюизм даже более очевиден сегодня, когда пользователи обрабатывают с помощью <code>gawk</code> гигабайты протокольных файлов — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n23">
   <title>
    <p>23</p>
   </title>
   <p>Раздел 13.4, «Не могли бы вы произнести это для меня по буквам?», с. 521, дает обзор многобайтных символов и кодировок — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n24">
   <title>
    <p>24</p>
   </title>
   <p>Механика проверки ошибок и сообщений о них обсуждаются в разделе 4.3, «Обнаружение неправильной работы» — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n25">
   <title>
    <p>25</p>
   </title>
   <p>Русский перевод Брайан Керниган, Денис Ритчи. Язык программирования Си (изд. 3-е, исправленное) Санкт- Петербург. Невский диалект, 2001 — <emphasis>Примеч. науч. ред</emphasis>.</p>
  </section>
  <section id="n26">
   <title>
    <p>26</p>
   </title>
   <p><code>http://www.gnu.org/gnu/thegnuproject.html</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n27">
   <title>
    <p>27</p>
   </title>
   <p>Имя команды — <code>ls</code> в данном примере, так же доступно программе в качестве аргумента — <emphasis>Примеч. науч. ред</emphasis>.</p>
  </section>
  <section id="n28">
   <title>
    <p>28</p>
   </title>
   <p>См. <code>/usr/src/cmd/echo.c</code> в дистрибутиве V7 — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n29">
   <title>
    <p>29</p>
   </title>
   <p>Когда мы спросили Джима Мейеринга (Jim Meyering), сопроводителя Coreulils, о наличии <code>register</code> в GNU Coreutils, он дал нам интересный ответ. Он удаляет эти слова при изменении кода, но в остальных случаях оставляет их на месте, чтобы облегчить интеграцию сделанных изменений с существующими версиями — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n30">
   <title>
    <p>30</p>
   </title>
   <p>См. <code>http://sources.redhat.com</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n31">
   <title>
    <p>31</p>
   </title>
   <p><code>http://plan9.bell-labs.com/magic/man2html/2/arg</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n32">
   <title>
    <p>32</p>
   </title>
   <p><code>http://www.gnu.org/manual/glibc/html_node/Argp.html</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n33">
   <title>
    <p>33</p>
   </title>
   <p><code>http://256.com/sources/argv</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n34">
   <title>
    <p>34</p>
   </title>
   <p><code>http://autogen.sourceforge.net/autoopts.html</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n35">
   <title>
    <p>35</p>
   </title>
   <p><code>ftp://ftp.gnu.org/gnu/gengetopt/</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n36">
   <title>
    <p>36</p>
   </title>
   <p><code>http://nis-www.lanl.gov/~jt/Software/opt/opt-3.19.tar.gz</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n37">
   <title>
    <p>37</p>
   </title>
   <p><code>http://freshmeat.net/projects/popt/?topic_id=809</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n38">
   <title>
    <p>38</p>
   </title>
   <p>Существует также другое название для этой области данных — Неинициализированные данные — <emphasis>Примеч. науч. ред</emphasis>.</p>
  </section>
  <section id="n39">
   <title>
    <p>39</p>
   </title>
   <p>BSS означает 'Block Started by Symbol', мнемоника из ассемблера IBM 7094 — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n40">
   <title>
    <p>40</p>
   </title>
   <p><emphasis>Дамп ядра (core dump)</emphasis> является образом запущенного процесса в памяти, который создаётся при неожиданном завершении процесса. Позже этот дамп может быть использован для отладки Unix-системы, называют это файл <code>core</code>, а системы GNU/Linux — <code>core.<emphasis>pid</emphasis></code>, где <code><emphasis>pid</emphasis></code> — ID потерпевшего крушения процесса — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n41">
   <title>
    <p>41</p>
   </title>
   <p>Описание здесь намеренно упрощено. Запущенные программы занимают значительно больше места, чем указывает программа <code>size</code>, поскольку разделяемые библиотеки включены в адресное пространство. Также сегмент данных будет расти по мере выделения программной памяти — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n42">
   <title>
    <p>42</p>
   </title>
   <p>Он получен от реальной практики работы с <code>gawk</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n43">
   <title>
    <p>43</p>
   </title>
   <p>Этот код несет с собой аромат практического опыта, не удивительно было узнать, что более ранние версии просто проверяли наличие обратного слеша перед символом конца строки, пока кто-то не пожаловался, что он не работает, когда в конце строки есть несколько обратных слешей — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n44">
   <title>
    <p>44</p>
   </title>
   <p>Эта функция завершает выполнение программы — <emphasis>Примеч. науч. ред</emphasis>.</p>
  </section>
  <section id="n45">
   <title>
    <p>45</p>
   </title>
   <p><emphasis>alloca</emphasis>(3) — <emphasis>Примеч. науч. ред</emphasis>.</p>
  </section>
  <section id="n46">
   <title>
    <p>46</p>
   </title>
   <p><code>open()</code> является одним из немногих варьирующих (variadic) системных вызовов — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n47">
   <title>
    <p>47</p>
   </title>
   <p>См. <code>/usr/src/cmd/cat.c</code> в дистрибутиве V7. Программа без изменений компилируется для GNU/Linux. — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n48">
   <title>
    <p>48</p>
   </title>
   <p>По крайней мере, три из этих блоков содержат данные, которые мы записали, другие для использования операционной системой при отслеживании размещения этих данных — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n49">
   <title>
    <p>49</p>
   </title>
   <p>Да, это пишется так. Кена Томпсона (Ken Thompson), одного из двух «отцов» Unix, однажды спросили, что бы он сделал по-другому, если бы ему пришлось переделать Unix. Он ответил, что написал бы <code>creat()</code> с «e» на конце. И в самом деле, именно это он сделал для операционной системы <emphasis>Plan 9 From Bell Labs</emphasis> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n50">
   <title>
    <p>50</p>
   </title>
   <p>Если у вас нет UPS и вы используете систему для критической работы, мы настоятельно рекомендуем вам обзавестись им. Следует также регулярно делать резервные копии. — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n51">
   <title>
    <p>51</p>
   </title>
   <p><emphasis>Состояние .гонки (race condition)</emphasis> является ситуацией, при которой детали временных соотношений могут вызывать непреднамеренные побочные эффекты или ошибки. В данном случае, каталог в течение короткого периода времени находится в противоречивом состоянии, и именно эта противоречивость и создаёт уязвимость — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n52">
   <title>
    <p>52</p>
   </title>
   <p>Конечно, меняются служебные данные файла (число ссылок), но это не влияет ни на какой другой атрибут файла, также, как не влияет на содержимое файла. Обновление счетчика ссылок на файл является единственной операцией над файлом, при которой не проверяются права доступа к файлу — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n53">
   <title>
    <p>53</p>
   </title>
   <p>См <code>/usr/src/cmd/rmdir</code> с в дистрибутиве V7 — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n54">
   <title>
    <p>54</p>
   </title>
   <p>То есть прочитаны все элементы каталога — <emphasis>Примеч. науч. ред.</emphasis></p>
  </section>
  <section id="n55">
   <title>
    <p>55</p>
   </title>
   <p>В системах GNU/Linux могут монтироваться файловые системы многих операционных систем, не относящихся к Unix. Во многих коммерческих системах Unix также можно смонтировать файловые системы MS-DOS. В таких случаях предположения относительно файловых систем Unix неприменимы — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n56">
   <title>
    <p>56</p>
   </title>
   <p>Стоит внимательно подумать прежде чем использовать эти функции — <emphasis>Примеч. науч. ред.</emphasis></p>
  </section>
  <section id="n57">
   <title>
    <p>57</p>
   </title>
   <p>Linux использует блочные устройства исключительно для дисков. Другие системы используют оба типа — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n58">
   <title>
    <p>58</p>
   </title>
   <p>Именованные каналы и сокеты были разработаны независимо группами Unix System V и BSD соответственно. Когда системы Unix вновь сошлись, обе разновидности файлов стали доступными универсально —- <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n59">
   <title>
    <p>59</p>
   </title>
   <p>Технический термин <emphasis>warm fuzzy</emphasis> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n60">
   <title>
    <p>60</p>
   </title>
   <p>Это утверждение было верно для V7, на современных системах больше нет таких гарантий — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n61">
   <title>
    <p>61</p>
   </title>
   <p>Спасибо Джиму Мейерингу (Jim Meyering) за объяснение проблем — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n62">
   <title>
    <p>62</p>
   </title>
   <p>UTC представляет собой независимое от языка сокращение для Coordinated Universal Time (универсальное скоординированное время). Старый код (а иногда и люди постарше) называют это Гринвичским временем (Greenwich Mean Time, GMT), которое является временем в Гринвиче, Великобритания. Когда стали широко использоваться часовые пояса, в качестве точки отсчета, относительно которого все остальные часовые пояса отсчитывались либо вперед, либо назад, был выбран Гринвич — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n63">
   <title>
    <p>63</p>
   </title>
   <p><code>fchown()</code> и <code>fchmod()</code> были введены в 4 2 BSD, но не включались в System V до выпуска 4 — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n64">
   <title>
    <p>64</p>
   </title>
   <p>a.m. — от ante meridiem (до полудня), p.m. — от post meridiem (пополудни), американская система обозначения 12-часового цикла времени суток. — <emphasis>Примеч. перев</emphasis>.</p>
  </section>
  <section id="n65">
   <title>
    <p>65</p>
   </title>
   <p>Хотя POSIX стандартизует формат TZ, он не представляет интереса, поэтому мы не стали возиться здесь с его документированием. В конце концов, именно <code>tzset()</code> должна понимать формат, а не код пользователя. Реализации могут использовать и используют форматы, которые расширяют POSIX — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n66">
   <title>
    <p>66</p>
   </title>
   <p>Вывод, показанный здесь, относится к US Eastern Standard Time. Вы получите различные результаты для одних и тех же программ и данных, если используете другой часовой пояс — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n67">
   <title>
    <p>67</p>
   </title>
   <p>STL (Standard Template Library, стандартная библиотека шаблонов). — <emphasis>Примеч. науч. ред</emphasis>.</p>
  </section>
  <section id="n68">
   <title>
    <p>68</p>
   </title>
   <p>Заметным исключением является лишь Sun Solaris, где эти две функции существуют лишь в трудной для использования библиотеке совместимости с BSD — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n69">
   <title>
    <p>69</p>
   </title>
   <p>Типичные сетевые базы данных включают Network Information Service (NIS) и NIS+ от Sun Microsystems, Kerberos (Hesiod), MacOS X NetInfo (версии вплоть до и включая 10.2) и LDAP, Lightweight Directory Access Protocol. Системы BSD хранят сведения в базах данных на диске и автоматически создают файлы <code>/etc/passwd</code> и <code>/etc/group</code> — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n70">
   <title>
    <p>70</p>
   </title>
   <p>К сожалению, если производительность является проблемой, нет стандартных способов узнать, как ваша библиотека осуществляет работу, а на самом деле способ ее работы может варьировать во время исполнения! (См. справочную страницу <emphasis>nsswitchconf</emphasis>(5) в системе GNU/Linux.) С другой стороны, назначением API помимо всего прочего является сокрытие деталей — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n71">
   <title>
    <p>71</p>
   </title>
   <p>Русский перевод Дональд E. Кнут. Искусство программирования Том 3. Сортировка и поиск (2-е издание). Москва • Санкт-Петербург • Киев, Вильямс, 2000 — <emphasis>Примеч. науч. ред.</emphasis></p>
  </section>
  <section id="n72">
   <title>
    <p>72</p>
   </title>
   <p><code>http://www/gtk.org</code> — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n73">
   <title>
    <p>73</p>
   </title>
   <p><code>http://www.gnome.org</code> — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n74">
   <title>
    <p>74</p>
   </title>
   <p><code>http://www/gtk.org/rdp</code> — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n75">
   <title>
    <p>75</p>
   </title>
   <p>В C++ это по-другому: там символьные константы действительно имеют тип char. Это различие не влияет на данный конкретный код — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n76">
   <title>
    <p>76</p>
   </title>
   <p>GNU/Linux и Solaris дают возможность монтировать один файл поверх другого; это продвинутое использование, которое мы не будем обсуждать — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n77">
   <title>
    <p>77</p>
   </title>
   <p>Например, при обновлении VAX 11/780 с 4.1 BSD до 4.2 BSD — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n78">
   <title>
    <p>78</p>
   </title>
   <p>System V Release 3 поддерживала два различных размера блоков: 512 байтов и 1024 байта, но в остальном организация диска была той же самой — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n79">
   <title>
    <p>79</p>
   </title>
   <p>Университет Карнеги-Меллона — <emphasis>Примеч. перев</emphasis>.</p>
  </section>
  <section id="n80">
   <title>
    <p>80</p>
   </title>
   <p>Источник: <code>http://www.ife.ee.ethz.ch/music/software/sag/subsection2_5_4_3.html</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n81">
   <title>
    <p>81</p>
   </title>
   <p>Ha GNU/Linux и большинстве систем Solaris и некоторые системы на основе System V Release 4 используют <code>/etc/vfstab</code>, возможно, с другим форматом — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n82">
   <title>
    <p>82</p>
   </title>
   <p>См. <code>/usr/include/bits/statvfs.h</code> на системе GNU/Linux — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n83">
   <title>
    <p>83</p>
   </title>
   <p>На системах GNU/Linux и BSD для получения нижележащего дескриптора файла можно применить функцию <code>dirfd()</code> к указателю <code>DIR*</code>, см. справочную страницу GNU/Linux <emphasis>dirfd</emphasis>(3) — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n84">
   <title>
    <p>84</p>
   </title>
   <p>POSIX стандартизировал <code>ftw()</code> для поддержки существующего кода, а GNU/Linux b коммерческие системы Unix продолжают её поддерживать. Однако, поскольку она недостаточно функциональна, мы не будем больше ее обсуждать. Если интересуетесь, см. <emphasis>ftw</emphasis>(3). — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n85">
   <title>
    <p>85</p>
   </title>
   <p>У некоторых старых версий GLIBC были проблемы с FTW_CHDIR. Это не относится к GLIBC 2.3.2 и более поздним, и маловероятно, что вы столкнетесь с проблемами — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n86">
   <title>
    <p>86</p>
   </title>
   <p>Мы не знаем, почему кому-нибудь может понадобиться делать такое изменение, но философия «что вы просили, то и получили» применяется и здесь! — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n87">
   <title>
    <p>87</p>
   </title>
   <p>Хэш-таблица является структурой данных, позволяющей быстрое получение сохраненной информации, подробности выходят за рамки данной книги — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n88">
   <title>
    <p>88</p>
   </title>
   <p>Fork <emphasis>(англ.)</emphasis> — «<emphasis>n</emphasis> вилка, развилка, <emphasis>v</emphasis> разветвлять, ответвлять» — <emphasis>Примеч. перев.</emphasis></p>
  </section>
  <section id="n89">
   <title>
    <p>89</p>
   </title>
   <p>Такие процессы часто демонстрируют детское поведение. — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n90">
   <title>
    <p>90</p>
   </title>
   <p>См. 9.1.4.3 Имена программ и <code>argv[0]</code> — <emphasis>Примеч. науч. ред.</emphasis></p>
  </section>
  <section id="n91">
   <title>
    <p>91</p>
   </title>
   <p>Мы это не придумываем. Терминология, конечно, не совсем правильна, но таким было чувство юмора разработчиков оригинальной Unix — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n92">
   <title>
    <p>92</p>
   </title>
   <p>Дважды проверьте справочную страницу <emphasis>getrusage</emphasis>(2), если у вас более новое ядро, поскольку это поведение, возможно, изменилось — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n93">
   <title>
    <p>93</p>
   </title>
   <p><code>csh</code> и <code>tcsh</code> также могут быть включены в эту категорию, но мы предпочитаем оболочки в стиле оболочки Борна — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n94">
   <title>
    <p>94</p>
   </title>
   <p>Такая операция часто обозначается <emphasis>no-op</emphasis> — «no operation» (нет операции) — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n95">
   <title>
    <p>95</p>
   </title>
   <p>Мы уверены, что вы не волновались. В конце концов, вы, возможно, используете конвейеры из оболочки десятки раз в день — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n96">
   <title>
    <p>96</p>
   </title>
   <p>Что они ели на обед, остается не указанным. — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n97">
   <title>
    <p>97</p>
   </title>
   <p>FIFO означает «first in, first out» — «первым вошел, первым вышел». Так работают каналы. — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n98">
   <title>
    <p>98</p>
   </title>
   <p>На системах GNU/Linux <code>/dev/fd</code> является символической ссылкой на <code>/proc/self/fd</code>, но поскольку <code>/dev/fd</code> является общеизвестным, в своем коде следует использовать именно его — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n99">
   <title>
    <p>99</p>
   </title>
   <p>Хотя мы показали простые команды, допустимы произвольные конвейеры — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n100">
   <title>
    <p>100</p>
   </title>
   <p>Стандарт POSIX умышленно не приписывает ей значение. Однако, чтобы старый код продолжал работать, единственным значением, которое могла бы разумно использовать любая реализация, является 1 — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n101">
   <title>
    <p>101</p>
   </title>
   <p>Ну, мы игнорируем мысль, что два супруга могли бы хотеть поговорить друг с другом и насладиться компанией — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n102">
   <title>
    <p>102</p>
   </title>
   <p>В одно и то же время есть только один сопроцесс по умолчанию (доступный посредством '<code>read -p</code>' и '<code>print -p</code>'). Сценарии оболочки могут использовать команду <code>exec</code> со специальной записью перенаправления для назначения дескрипторов файла сопроцесса определенным номерам. После этого можно запустить другой сопроцесс — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n103">
   <title>
    <p>103</p>
   </title>
   <p>Очевидно, вы можете их закрыть. Но если вы не знаете, что они открыты, они теряются с таким же успехом, как и память через утечку памяти — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n104">
   <title>
    <p>104</p>
   </title>
   <p>Игра слов kill-overkill (избыточно — overkill) — <emphasis>Примеч. перев</emphasis>.</p>
  </section>
  <section id="n105">
   <title>
    <p>105</p>
   </title>
   <p>По крайней мере один поставщик дистрибутивов GNU/Linux отменяет сознание файлов <code>core</code> «с иголочки». Для повторного подключения этой возможности поместите в свой файл <code>~/.profile</code> строку '<code>ulimit -S -с unlimited</code>' — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n106">
   <title>
    <p>106</p>
   </title>
   <p>Handler (англ.) — обработчик — <emphasis>Примеч. перев</emphasis>.</p>
  </section>
  <section id="n107">
   <title>
    <p>107</p>
   </title>
   <p>Изменение поведения было плохой мыслью, сильно критиковавшейся в свое время, но было слишком поздно. Изменение семантики определенного интерфейса всегда ведет к проблеме, как было в этом случае. Хотя это особенно относится к проектировщикам операционных систем, <emphasis>любой</emphasis>, кто разрабатывает библиотеки общего назначения, также должен помнить этот урок. — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n108">
   <title>
    <p>108</p>
   </title>
   <p>Хотя мы описываем <code>read()</code>, эти правила применяются ко всем системным вызовам, которые могут завершиться с ошибкой <code>EINTR</code>, как, например, семейство функций <code>wait()</code> — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n109">
   <title>
    <p>109</p>
   </title>
   <p>Для использования API требуется компоновка с отдельной библиотекой, — <code>ljobs</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n110">
   <title>
    <p>110</p>
   </title>
   <p>Насколько мы смогли определить, имена <code>SA_NOMASK</code> и <code>SA_ONESHOT</code> являются специфическими для GNU/Linux. Если кому-нибудь известно иное, пожалуйста, сообщите нам!</p>
  </section>
  <section id="n111">
   <title>
    <p>111</p>
   </title>
   <p>Наша благодарность Ульриху Дрепперу (Ulrich Drepper) за помощь в разъяснении, связанных с этим проблем — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n112">
   <title>
    <p>112</p>
   </title>
   <p>Исторически системы BSD использовали имя <code>SIGCHLD</code>, которое используется и POSIX. В System V есть сходный сигнал с именем <code>SIGCLD</code>. GNU/Linux определяет последний через <code>#define</code> как первый — см. табл. 10.1 — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n113">
   <title>
    <p>113</p>
   </title>
   <p>Возможно, лучшим именем для функции было бы <code>child_at_school()</code> [ребенок_в_школе] — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n114">
   <title>
    <p>114</p>
   </title>
   <p>MacOS X и Windows XP обе являются многопользовательскими системами, но это довольно недавние разработки — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n115">
   <title>
    <p>115</p>
   </title>
   <p>Хотя в Соединенных Штатах нет официальных удостоверений личности, во многих странах они имеются — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n116">
   <title>
    <p>116</p>
   </title>
   <p>Денис Ричи (Dennis Ritchie), создатель С и соавтор Unix, получил патент для бита setuid: <emphasis>Protection of Data File Contents (Защита содержимого файла данных)</emphasis>, номер патента США 4135240. См. <code><a l:href="">http</a>://www.delphion.com/details?pn=US04135240__</code>, а также <code>http://www.uspco.gov</code>. AT&amp;T передала патент общественности, разрешив всем использовать свою технологию — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n117">
   <title>
    <p>117</p>
   </title>
   <p>Безопасность для систем GNU/Linux и Unix является глубокой темой сама по себе. Это просто пример. см. раздел 11.9 «Рекомендуемая литература» — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n118">
   <title>
    <p>118</p>
   </title>
   <p>Одной из программ, разработанных с этой целью, является GNU userv (<code>ftp://ftp.gnu.org/gnu/userv/</code>) — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n119">
   <title>
    <p>119</p>
   </title>
   <p>На ум приходят образы счастливых юных программ их лица и руки, запачканные шоколадом — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n120">
   <title>
    <p>120</p>
   </title>
   <p>E (Effective) эффективный ID, R (Real) действительный ID и S (Saved) сохраненный ID — <emphasis>Примеч. науч. ред.</emphasis></p>
  </section>
  <section id="n121">
   <title>
    <p>121</p>
   </title>
   <p>Однако, в своей лекции в честь присуждения премии Тьюринга Ассоциации по вычислительной технике в 1981 г. д-р Хоар утверждает, что эту идею выдвинул сам Алан Тьюринг — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n122">
   <title>
    <p>122</p>
   </title>
   <p>Как упоминалось в разделе 10.2 «Действия сигналов», некоторые дистрибутивы GNU/Linux запрещают создание файлов <code>core</code>. Чтобы снова разрешить их, поместите в свой файл <code>~/.profile</code> строку '<code>ulimit -S -с unlimited</code>' — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n123">
   <title>
    <p>123</p>
   </title>
   <p>Hints On Programming Language Design, C.A.R. Hoare Stanford University Computer Science Technical Report CS-73-403 (<code>ftp://reports.stanford.edu/pub/cstr/reports/cs/tr/73/403/CS-TR-73-403.pdf</code>). December, 1973 — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n124">
   <title>
    <p>124</p>
   </title>
   <p>См. <emphasis>wс</emphasis>(1). <code>wc</code> подсчитывает строки, слова и символы — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n125">
   <title>
    <p>125</p>
   </title>
   <p>Такое использование <code>/dev/shm</code> на самом деле является <emphasis>злоупотреблением,</emphasis>, он предназначен для использования в реализации разделяемой памяти, а не в качестве электронного диска. Тем не менее, это полезно для иллюстрации нашей мысли — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n126">
   <title>
    <p>126</p>
   </title>
   <p>На нашей системе 512 мегабайтов оперативной памяти, что для старых чудаков вроде автора кажется порядочным. Однако цены на память упали, и вполне обычны системы с одним или более гигабайтами оперативной памяти, по крайней мере, для разработчиков программного обеспечения — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n127">
   <title>
    <p>127</p>
   </title>
   <p>Пространство для подкачки состоит из одного или более выделенных участков диска, используемых для хранения частей исполняющегося процесса, который не находится в настоящее время в памяти — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n128">
   <title>
    <p>128</p>
   </title>
   <p>Такая утечка была у нас в <code>gawk</code> К счастью, она исправлена — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n129">
   <title>
    <p>129</p>
   </title>
   <p><emphasis>Numerical Recipes in С. The Art of Scientific Computing</emphasis>,<emphasis>,</emphasis> 2nd edition, by William H. Press, Brian P. Plannery, Saul A. Teukolsky, and William T. Vetterling. Cambridge University Press, USA, 1993, ISBN 0-521-43108-5 — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n130">
   <title>
    <p>130</p>
   </title>
   <p>См <code>/usr/source/s1/glob.c</code> в дистрибутиве V6</p>
  </section>
  <section id="n131">
   <title>
    <p>131</p>
   </title>
   <p><code>http://www.cs.bell-labs.com/cm/cs/pearls/</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n132">
   <title>
    <p>132</p>
   </title>
   <p>Русский перевод: Дональд E. Кнут. Искусство программирования. Том 2. Получисленные алгоритмы (3-е издание). Москва - Санкт-Петербург - Киев. Вильямс. 2000 — <emphasis>Примеч. науч. ред</emphasis>.</p>
  </section>
  <section id="n133">
   <title>
    <p>133</p>
   </title>
   <p><code>http://www-cs-faculty.stanford.edu/~knuth/taocp.html</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n134">
   <title>
    <p>134</p>
   </title>
   <p>Русский перевод — Дж. Фридл. Регулярные выражения (2-е издание). C.-Петербург, Питер, 2003 — <emphasis>Прим. науч. ред</emphasis>.</p>
  </section>
  <section id="n135">
   <title>
    <p>135</p>
   </title>
   <p><code>http://www.gnu.org/software/grep/doc/grep.html</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n136">
   <title>
    <p>136</p>
   </title>
   <p>От английских слов i(nternationalizatio)n и l(ocalizatio)n —<emphasis>Примеч. перев</emphasis>.</p>
  </section>
  <section id="n137">
   <title>
    <p>137</p>
   </title>
   <p>NLS — native language support — <emphasis>Примеч. перев.</emphasis></p>
  </section>
  <section id="n138">
   <title>
    <p>138</p>
   </title>
   <p>Существует более ранний дизайн, известный как <code>catgets()</code>. Хотя он стандартизован POSIX, его гораздо сложнее использовать, и мы его не рекомендуем — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n139">
   <title>
    <p>139</p>
   </title>
   <p>Программисты, долгое время работавшие на С и Unix, могут предпочесть использовать локаль '<code>С</code>', даже если их родной язык английский, английские локали дают другой результат по сравнению с тем, что ожидают эти седые, понюхавшие пороху ветераны Unix — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n140">
   <title>
    <p>140</p>
   </title>
   <p>Мы так же счастливы, как и вы, поскольку нам не нужно представлять код, использующий эту полнофункциональную структуру — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n141">
   <title>
    <p>141</p>
   </title>
   <p>В стандарте используется технический термин <emphasis>radix point (позиционный разделитель)</emphasis>, поскольку числа с другим основанием счисления также могут иметь дробные части. Однако, для денежных значений можно довольно безопасно использовать термин 'decimal point' (десятичный разделитель) — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n142">
   <title>
    <p>142</p>
   </title>
   <p>Нам, вероятно, следовало выбрать более осмысленные имена вместо простых <code>ii</code> и <code>jj</code>, поскольку использующий их код короткий, отсутствие у нас воображения не представляет значительной проблемы — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n143">
   <title>
    <p>143</p>
   </title>
   <p>Это устанавливается механизмом Autoconf и Automake. Autoconf и Automake являются мощными программными наборами, дающими возможность поддержки широкого круга Unix-систем систематическим образом — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n144">
   <title>
    <p>144</p>
   </title>
   <p>Хотя американцы часто ссылаются на эры определенных президентов, они не являются частью национального календаря в том же смысле, как в Японии до Второй мировой войны или в докоммунистическом Китае — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n145">
   <title>
    <p>145</p>
   </title>
   <p>Подробности приведены в документации GNU <code>gettext</code>. Здесь мы концентрируемся на потребностях разработчика, а не переводчика — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n146">
   <title>
    <p>146</p>
   </title>
   <p>Этот макрос обычно определяется автоматически программой <code>configure</code>, либо в специальном заголовке, либо в командной строке компилятора <code>configure</code> создается с помощью Autoconf и Automake — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n147">
   <title>
    <p>147</p>
   </title>
   <p>Pig — свинья, поросенок (<emphasis>англ</emphasis>.) — <emphasis>Примеч. перев</emphasis>.</p>
  </section>
  <section id="n148">
   <title>
    <p>148</p>
   </title>
   <p>Мы тщетно потратили 30 или 45 минут, пытаясь использовать каталог <code>piglat/LC_MESSAGES</code> и установку <code>LC_ALL=piglat</code>' без всякого успеха, пока не выяснили это — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n149">
   <title>
    <p>149</p>
   </title>
   <p><code>ftp://ftp.gnu.org/gnu/gettext</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n150">
   <title>
    <p>150</p>
   </title>
   <p><code>http://www.unicode.org</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n151">
   <title>
    <p>151</p>
   </title>
   <p>GNU/Linux ее поддерживает, но лишь для совместимости — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n152">
   <title>
    <p>152</p>
   </title>
   <p>Справочная страница GNU/Linux <emphasis>fcntl</emphasis>(3) указывает, что этих сведений может быть недостаточно, процесс может находиться на другой машине! При блокировках по сети есть и другие проблемы, в общем, использование блокировки в файловых системах, смонтированных для удаленных компьютеров, не является удачной мыслью — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n153">
   <title>
    <p>153</p>
   </title>
   <p>В системе GNU/Linux <code>lockf()</code> реализована в виде «оболочки» вокруг <code>fcntl()</code> — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n154">
   <title>
    <p>154</p>
   </title>
   <p><emphasis>Тупик (deadlock)</emphasis> является ситуацией, при которой оба процесса блокируются, причем каждый из них ждёт, пока другой освободит определенный ресурс — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n155">
   <title>
    <p>155</p>
   </title>
   <p>Удачно, что название <code>flock()</code> отличается от <code>lockf()</code>, поскольку их семантика различна. Это также страшно сбивает с толку. Держите свое руководство под рукой. — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n156">
   <title>
    <p>156</p>
   </title>
   <p>В справочной странице <emphasis>gettimeofday</emphasis>(2) документирована соответствующая функция <code>settimeofday()</code> для использования суперпользователем (<code>root</code>) для установки времени дня всей системы — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n157">
   <title>
    <p>157</p>
   </title>
   <p>К сожалению, по-видимому, в настоящее время нет стандарта для названий членов <code>struct stat</code>, что делает такую операцию непереносимой — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n158">
   <title>
    <p>158</p>
   </title>
   <p>Корректное выполнение профилировки нетривиальная задача, если вы думаете о написании интерпретатора, стоит сначала провести свои исследования — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n159">
   <title>
    <p>159</p>
   </title>
   <p>В голову приходят образы, как маленькие двоичные структуры данных сидят друг рядом с другом за чаем и пирожными. По крайней мере, такое бывает, если вы проводите слишком много времени перед своим компьютером. — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n160">
   <title>
    <p>160</p>
   </title>
   <p>Этот вывод для часового пояса U.S. Eastern Time zone — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n161">
   <title>
    <p>161</p>
   </title>
   <p>Оптимизации компилятора являются общеизвестным козлом отпущения для логических ошибок. В прошлом обвинения компиляторов были более оправданы. Судя по нашему опыту, используя современные системы и компиляторы, <emphasis>очень</emphasis> редко можно обнаружить случаи, в которых оптимизации компилятора привносят ошибки в работающий код — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n162">
   <title>
    <p>162</p>
   </title>
   <p>Мы говорим об оригинальном BSD <code>dbx</code>. В течение десяти лет мы использовали исключительно GDB — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n163">
   <title>
    <p>163</p>
   </title>
   <p><code>ddd</code> поставляется со многими системами GNU/Linux. Исходный код доступен на FTP-сайте проекта GNU <code>ddd</code> (<code>ftp://ftp.gnu.org/gnu/ddd/</code>) — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n164">
   <title>
    <p>164</p>
   </title>
   <p><code>http.//sources.redhat.com/insight/</code> <emphasis>— Примеч. автора.</emphasis></p>
  </section>
  <section id="n165">
   <title>
    <p>165</p>
   </title>
   <p><code>ftp://ftp.gnu.org/gnu/gdb/</code> — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n166">
   <title>
    <p>166</p>
   </title>
   <p><code>http://www.gnu.org</code> — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n167">
   <title>
    <p>167</p>
   </title>
   <p>Если вы хотите изменить такое поведение, см. <emphasis>sysctl</emphasis>(8) — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n168">
   <title>
    <p>168</p>
   </title>
   <p>Примерно 213&#215;275 мм — <emphasis>Примеч. перев.</emphasis></p>
  </section>
  <section id="n169">
   <title>
    <p>169</p>
   </title>
   <p>Bjarne Stroustrup, создатель С++, настойчиво работал над тем, чтобы сделать использование препроцессора С совершенно ненужным в С++. По нашему мнению, он не вполне добился успеха: <code>#include</code> нужен до сих пор, но не обычные макросы. Для С препроцессор остается ценным и инструментом, но он должен использоваться благоразумно — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n170">
   <title>
    <p>170</p>
   </title>
   <p>Серьезно! Часто люди пропускают через <code>gawk</code> мегабайты данных. Помните, <emphasis>никаких произвольных ограничений</emphasis>! — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n171">
   <title>
    <p>171</p>
   </title>
   <p>Мы унаследовали эту схему. В общем, она работает, но все же есть проблемы. Целью данного раздела является передача накопленного нами в ходе работы с объединениями опыта — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n172">
   <title>
    <p>172</p>
   </title>
   <p>Опять-таки, GCC 3.1 или более новый и GDB 5 дают возможность непосредственного использования макросов, но только лишь если вы используете их совместно, с определенными опциями. Это было описано ранее в разделе 15.4.1.2 «По возможности избегайте макросов с выражениями». — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n173">
   <title>
    <p>173</p>
   </title>
   <p>Эта часть кода была с тех пор пересмотрена, поэтому там больше нет этих строк из примера. — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n174">
   <title>
    <p>174</p>
   </title>
   <p>Переписав код управления буфером! — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n175">
   <title>
    <p>175</p>
   </title>
   <p><code>ftp://ftp.ninemoons.corn/pub/dbug/</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n176">
   <title>
    <p>176</p>
   </title>
   <p>В C99, который допускает смешивание объявлений переменных с исполняемым кодом, это составляет меньшую проблему, но помните, что этот пакет был разработан для K&amp;R С — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n177">
   <title>
    <p>177</p>
   </title>
   <p>Хотя нам следовало бы усвоить свой урок после первой компании, мы перешли ко второй. С тех пор, как мы это выяснили, мы обычно избегаем начинающие компании. Ваша выгода, конечно, может меняться — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n178">
   <title>
    <p>178</p>
   </title>
   <p><code>ftp://ftp.perens.com/pub/ElectricFence</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n179">
   <title>
    <p>179</p>
   </title>
   <p>GDB также позволяет определить переменную окружения <code>LD_PRELOAD</code>: <code>set environment LD_PRELOAD=PATH_TO_YOUR_LIBRARY</code> — <emphasis>Примеч. науч. ред</emphasis>.</p>
  </section>
  <section id="n180">
   <title>
    <p>180</p>
   </title>
   <p><code>http://www.dmalloc.com</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n181">
   <title>
    <p>181</p>
   </title>
   <p>Все в большей степени для разработки высококачественных продуктов используется также GNU/Linux! — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n182">
   <title>
    <p>182</p>
   </title>
   <p><code>http://www.winehq.com</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n183">
   <title>
    <p>183</p>
   </title>
   <p><code>http://valgrind.kde.org</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n184">
   <title>
    <p>184</p>
   </title>
   <p><code>http://www.linuxjournal.com/article.php?sid=6059</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n185">
   <title>
    <p>185</p>
   </title>
   <p><code>http://www.linuxjournal.com/article.php?sid=6556</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n186">
   <title>
    <p>186</p>
   </title>
   <p><code>http://www.splint.org</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n187">
   <title>
    <p>187</p>
   </title>
   <p><code>http://www.debuggingrules.com</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n188">
   <title>
    <p>188</p>
   </title>
   <p><code>http://www.amacombooks.org</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n189">
   <title>
    <p>189</p>
   </title>
   <p><code>http://www.cs.bell-labs.com/cm/cs/pearls/</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n190">
   <title>
    <p>190</p>
   </title>
   <p>Русский перевод Брайан Керниган, Роб Пайк. UNIX: Программное окружение. Санкт-Петербург. Символ-Плюс, 2003 — <emphasis>Примеч. науч. ред</emphasis>.</p>
  </section>
  <section id="n191">
   <title>
    <p>191</p>
   </title>
   <p>Это приложение приведено в буквальном виде с веб-страницы, указанной вначале — <emphasis>Примеч. автора.</emphasis></p>
  </section>
  <section id="n192">
   <title>
    <p>192</p>
   </title>
   <p><code>http://www1.neweb.ne.jp/wa/yamdas/column/technique/21-daysj.html</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n193">
   <title>
    <p>193</p>
   </title>
   <p><code>http://loro.sf.net/notes/21-dias.html</code> — <emphasis>Примеч. автора</emphasis>.</p>
  </section>
  <section id="n194">
   <title>
    <p>194</p>
   </title>
   <p>Это — неофициальный перевод Лицензии Caldera для старой Unix на русский язык. Он не был опубликован Caldera International, Inc и не может легально определять условия распространения программных продуктов, использующих Лицензию Caldera — только оригинальный английский текст Лицензии Caldera для старой Unix имеет законную силу.</p>
  </section>
  <section id="n195">
   <title>
    <p>195</p>
   </title>
   <p>Это — неофициальный перевал Общедоступной лицензии GNU на русский язык. Он не был опубликован Фондом Свободного Программного Обеспечения и не может легально определять условия распространения программных продуктов, использующих Общедоступную лицензию GNU — только оригинальный английский текст Общедоступной лицензии GNU имеет законную силу.</p>
  </section>
 </body>
 <binary id="img_0.jpeg" content-type="image/jpeg">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</binary>
 <binary id="img_1.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAXEAAACbAQMAAACu4Tm3AAAACXBIWXMAAA7EAAAOxAGVKw4b
AAAABlBMVEUAAAD///+l2Z/dAAADGUlEQVR4nO3ZS2sTQRwA8K2CbZGyRU8SZSvWWxWtUuul
600qSMEPUPoJVPBgSB+TPqBgDxWUYi2agkJvNaRFkWq3ULDWQCN48FDMJgjGXjQlh2SY3Yw7
s3ns6uxL0trKzmEyJL+d+e9kd/afCYc9lTC3Ax7JHv2kNw8bH4VW2wNZifoU51BE2D0VmmmP
t76lnnfsv9DdHHx9qqF1jPgicPbvm4PTB+JtUepdxP/hRujItXjbfeJVZ4+Ln9FaUlgZJx66
8HpJYm8eU49873vf/0tfFLx5xbh+uvDwexfizd5u/RRg+mzslskrDn5+xOxz9vFszU+Y48nY
enW9bcLc/09bXwzMBsw+Yeu1IwA2ednBV8ou+Yjvfe97qwK8eUOK58orwTS+syx0AiwbPcR3
7yWlJRzuehi++XUObNRx0avPvk1Lauz6wumOrs2mxYTRh63yVXXhRKzl4EC8qXXS6AWreApH
j7fXEX+IN3jrxBV96r195oLmp3oMXrE8X/Sxd/Dkq6HAlQ7j+dokrjl9bMU0nzaJaL4ytjtf
LXvYu0oMfO/7fe8VwZuHiUqCx/DJjcFlgPhj77i+Pq6zjzvHw9T5B43RN2y/8sf6ycP085n1
RQtPY1UAqctpM0zPzjRcDDO9vpLp975Y9usvHm+9jLI9rfU2KM9PY8vI4Vl2//rKl68eShoi
jIgrPUyvMrwOgI3PVIcyl7/0ci36Zz1Aaun3ezw74uH/413N/17zOqK/Vz2cr3u/i9dzba7/
3A73n9LqYr1WpQB5I0vrYdoUmR6YfMrRY+8eU4+r8YxWm0xPdkeyuqf1KqkKTJ/16LfJC3kS
0gYuuPKR37zN/MOy169k9/e7Lh2/X8abNsX3vrfwqsMupdGLuHR9GjYSJQufiGi+IAeD/SiD
1yYTWCgO5LQMbu4H458ozT+RMC+qsjYE+oLlobyKkdSvRbeUkZl+WBtYUjeJH8ZyiHgtaZUx
Go+w49d8qX+55DHxUkZkejhK/NPLCOe2sXwJL4NCth+lcaSeHT+dCJXerPqEApKo5tl7tBXP
+rAW/hcwKbaSuGicrgAAAABJRU5ErkJggg==</binary>
 <binary id="img_2.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAZ4AAAB+AQMAAAAugeV6AAAACXBIWXMAAA7EAAAOxAGVKw4b
AAAABlBMVEUAAAD///+l2Z/dAAAECElEQVR4nO3Xf2gTVxwA8JNGW2m7RBiasc1ONvBPM6ZW
Tdar9R+l1DIGY2AZFlz77/xZakKvRUEHg/4zHLJs98/AfwT/cT9gs6fNRhXtrihoWTsu2TWm
IvZSo0u63N1376V3uR+9rO8OCQ7y4H59e5++l3ff9+4dBe6LTFURcQB5QbtUXKAcr1+ijSVA
qa8itKij79ijRIjnDoKkN+/E7HGi5glj3xiXQzMMEVLGZo3LyB+tRCjHBY3//sV0jggR3FRD
NVRDNVRD/wMke0Eq46UmzhzjHe9ciWhzbIIMKRaUIayJKe3NqFzdKNpUegVSIM8I6FDwL8dE
tDHD+OwftNWhrdBiiCKwMYSyWUorKMbq5y1pULIocDogQlHIXBQFaGsD8dtBuBJBNxbMaLSM
nt+O7UEtGwrs/ygK4w2dzVcv/HC3syEM/bgmRd61ayAxOdqEm8eeeYUqvLckDTPA3cE/h9nZ
82oUcrfaT15dc//u3igN/eY0Wu4OrZwD4Joxirb2hKLC0waEAven9sZoyGtdzpk7p7wUm8S7
8M6eDweF6dv+T798duGD7vfpomTucr3c0bt+Aff0udD1fbHweENv07qNobrez7ki75TlkvUy
V+pn9BRAzzAClNeOTPlPTs1btTihVdektkE4FRvxdRNmebmmB0k21kLaPNpL8yyoSIaKnDm2
SIaylpqWyNBfrtFCgFrHmGNPCNAcRUUs6DcClKSo9ZZYKSuF/0aFdspvBDjtOAIiK+Gh6Iys
pUWfI2iRlkrzlxvkl94EuEKGQEcMXKv0VeQ0CEufGwmUg2qYHKXwTgCIZyo8Zid0QzvGJReI
cBBaS8ILurEy9JKgqcMjPr9blJe4oZf4N3lHqarV5AndwjuctWpllLunsEaAK4/clKQyqUsV
UD5xxISMOSI9McQojtMRQosLEmcEjGUO8GPHopWa98SCBO39NIImzbHPBiqh5ISftsT+xDse
owHnpR/+TbxtDTCvHSc2tx2ohMA+j5YzQq6wyHxhaSRWDXloXl5KukRZPLG4rSkvsYy3GdYT
8vScPKHr1UDKzNu8FcnLOZvZ1k2XTvAHjg3JGM2bI+ryuBFLiHOsST40wFs7Qj2wL9gR3JZC
KDve2PRuOn6zN2Jr3goEwejvfZ1b0wj9/fHj5h3pN+512dHXP07aUeJ8X+OWOYza59/yrY1s
6mqyoYunJm0z7E+vJfoGLz/citAnj77fMRx/0PWOFRVmk2esSA23B/pe35IJ9dY/7Fj/y3Zf
fLrLt2pGMNJu+DkDS+mzyX4Of0bLQpw8jRSJ0c5eWBp5etUMV62mNR6QusEDkhs9oGf1LtFS
/WGf6BYV6jrWoheny+YFQ79StFuUA6GbWRX9C49BIvhERPeKAAAAAElFTkSuQmCC</binary>
 <binary id="img_3.png" content-type="image/png">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
ou0N5ZF5yycAAAAASUVORK5CYII=</binary>
 <binary id="img_4.png" content-type="image/png">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
v66rKaWdamL6AAAAAElFTkSuQmCC</binary>
 <binary id="img_5.jpeg" content-type="image/jpeg">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
KeeJNH2Yj//Z</binary>
 <binary id="img_6.png" content-type="image/png">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
AABJRU5ErkJggg==</binary>
 <binary id="img_7.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAfIAAADEAQMAAABeCzGXAAAACXBIWXMAAA7EAAAOxAGVKw4b
AAAABlBMVEUAAAD///+l2Z/dAAAGp0lEQVR4nO2aX4gbRRjAN8n1coV4iVYh0qObgnr4ZKBi
qy1sCgUJCH2tL0rx6j32FEotLU76hx59uVYqlFJpEIq+Kn2oWmtynngeHE3Vh7ZI3JyV3svR
7HWxu9tsZpyZze4ls7vZ3fzpHfQ+uMxubn77fft933wzk10OdSVFzvn7KP1UgXF21oOHgP1+
G/2UkT++IrDfp397d2j0W2n/6Sm04fYHh27fsWkwTKQ85BiJo/SZcHb0ipxJXwEbLmTH/jyH
+RzTqx0/cfLXytacHEunwIEEt+fWOWwh20uw7GevzMOJyM+VVIryY4ndA4mEg35g8RJ7/3Ag
G85eeenhO+kT742dzz7/x3P2+4+s+M/mfz08n41tTavlU6f/Hruw//Vb++w8v8LbRJetQ9Gx
gykuPKy1pTx537LO95GPD+6Y+eLFbvjE7liiYx7Gt03te/kE6Fh/NB1Lbsh1zo+nbyYPnO6c
jw9woY3n2uEe8RPqb+b1bnhUb0uv8fxb59f5p4QvdMkLjfNSo11stMuNVmNaoyOw8SLDm/N4
t7zZWvWo5Gw/y5vrENaOXvOmiK2n/u2f0VBchkKVOAWXbMWLR068LpQkBGZ0FGftt/l/luEV
DeVlCEoaAos6yrvxlv6qMy8afMHTfza+jvJKg6/74Fn/YcjSD4PzqOE/1PAf8hLWfmTEj/j/
Hubd9Lr6j/SQqVkt8XeNny1/6xQSCV+38975b1hGeejOu+bvRQ2Oy1pefACE73VYdfO/Gw8w
P6pg/j4AF3U4HpRHZwiviuifT8EZHY4in2LZf1yDUUV9X6wAwr/mlv+WsPf/GYJvyxov/gsA
PtzrOf7s/kPjcp3e/++6nfeMH/W/inlE/HcwqP/M/BMb+RfY/y48W8fceStpAQogLfnbNH7u
Mfbbxp9D/T2Lx6+o0vHPY1MmG/xMgzdbyDvxOH5RWefFCvV/HPNXdYP/i+yu8f3PkRbrh3tr
rTyxSbihQUWpiXj8gBs6XMT+uz6yg/LlqV2A8PNTI3Row6WJhSZe1nTYxFcJr1N+Hisk/H0g
EP4maQlf3VmnfA1pdcLXiaGEl00ekvD9EJNoKO4Of0L58uQxg1/auUADrWmabq0/LuH8w+O3
hPP3Es4//NVX84+o3ec/PEqza277kQLpCrPX79rjR+qv0jJ/DQ6nqf0nB5OUn5mM8VT/SHK3
a/6WPPK3bf2TV+pn8PHTWj+f+Pibbp6/oOv8ZfFiK18oa2hU1vOiAsCcjmz11zZ+EGM/5g/L
dZHwZR0dDlz/yggdRoQXQBkFr/9Uv4L5R0S/O++qH+dfVCHjF4Bp7L+gPJg18ldchsT/fFC+
QP5D6x+k8fcrDutX0KyX9b91aY/8Czz/k4VXNzyZf2XV9P9o4PhR/Tj+izT+IDA/W0e8rANx
AYcSxy+o/YXbBo8ID1d4L7H036Xzv1gyxo+Vv+z+yzV+xvqFFyXqv6jb/svV/yXyg64qiBKd
6OIs36v9V794U8TW047tZ9ctNv8jZ57dP/tefzD6A9efLvlOZZ2nzSNwFG/pAF514r0nAsp/
xP8QMVVg0Y2XOC4cykU4jhvCfyn6dCdsPORJpLnwFm5g89UtsY8i+w4qIH9tey6WPxZt5lVu
4BcuQ7tTPmzwKXqpoYGhDDeyHBvOvDUSkvdsvvZwaGP5x8TBFp5jHy4RSSU5LsRxgxkudPmb
y+HMd89or8x/fE1Sn73z04TQzA8KC2V0SBo6ciqSSXLFE5QOSdzxO5uLn8cW9DfQl2h7btcL
6Ouz+WVV3LQMZwu99H9feD81vB3vWcMC8rY1lAfP7oHMuUR14pv2XuZ9m/xCj3gpID/N8BXz
OiAYX2FaL970u8kXO+SPszxobb14s3WLg1++3Rr+SfK2OWiVeC/7zfwJdP9yl3y3+nvCw57w
7G8/ayX/epW//ebd/L9avOtveAF5v/437e2UN+2sMtfxy5v9zLW8eR2/vLlHyDPX8ctDfg7N
qoLE52lnnW/mFW+efVEIBOVdxK/9buI3f9Y67zX/9Jtfrfitfd7+HmGzrLb/fOgX+smbdbVT
3qzDbfh8O56tww58CbWRWW++Iqpw8rEwXas+Jt0emLW7oJDXwbztVx12wS3va3roN6SKRPKc
CB9N6oUlFK+TWzffhW2r35es808375l/63xwXnbq2R++1nRs8bYXDNylWVUnfLOrLB4KvvlJ
J972dru78I58TarmljZV+MhSpAIiarw4HJJeze2KpKJchStu4ZLR3CChRyLIke9Miv8DoY7p
KjMWAxUAAAAASUVORK5CYII=</binary>
 <binary id="img_8.png" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAPEAAACOAQMAAADacXxeAAAACXBIWXMAAA7EAAAOxQGMMD9a
AAAABlBMVEUAAAD///+l2Z/dAAAEpUlEQVR4nKWXz2sbRxTHZUfUNoismkIiUaMVjqmPXqSD
0tB2VTC0huD8CzI4Sk1NY5JDWlLYuDaxRUNceqnVutrcemsPPTVQJNUYu3itvRaaeiUiWAIJ
a0vB8sbrnc7+0s6uxp7IfhfBfnhv3rz3nTejAADgCBxr9wNvwFXkA0fgOH/UaAJnCfn1EdYf
IXCSP+RV1sPP0yinAHjFoVy/JaIc+mq1JzNsmwNFRBeE8bXS1U9pl4u8b3+acJXmXc6LKIeO
2k5vBPFnFdXv/83brr/+BcxP8/LGx66/buzP5Z8Y+b/+DInvrc8i8FhHf3D1J/Wvm/7i1vf1
x8sXgqH+/kgkEmYYJp7hRv38oRBaif7xPpO8fTuTrXf6+/LDrY/aMsEfxw+QD6epD8px+Xej
/2W//vUYjToUoT44j3/Bo2/R1r82CIq0xRVf/Uz9a+HQ95TFKV9/tYqh/2ToV9HS/6hf3zu9
gzE2FXhE2eejQ/9/RQtsKr5w3eQUD/WtorzUGKdB8oMFy/886+e11zM0mP3azs9ruPppBN7l
/DkT79Dng7b+42w1w234+WpoKace7oWTjZHqzTp3kr4UXHxAPh+k/En67WY+nOL8FIGXN3kA
ZHsjkFcoo7+Hmo+LDn9k6Vu3+DnIBwS6Zy31Fm1xCs7vg/fuVGsmvwRAY3wpFswPDVMWvyUd
gWbqnvCfE393M1fI1oZuiibXqeIRaKW+2rnv8lAs29M7ZftTnMHvVcoO3zN4/kJGdPKHLsxs
qdTOf3O8EJhLOP4V6ghoVzKNyTb/93O+Z/vJPoXUj3PqY/dX9tZX83Oli/oT9YPyuwQu+vmD
YDAUggcgDC+A2TjXEb8wpi0dRKPRdxqJ+EidU/wcid9CNnbc+tIZOSDwIoajxmI4Op9oeN2w
Xs6i8SHbhY3X2TbXoT4O21nA9Zuwxh9xLof6V80DIlnxm2uPewf4UCTJTMzbfHc2nS6tzS9a
fGtYeF4Y+/byxWui4y9PT/yjirDAPOR/j26/pNdLlwNpxeHV6YnBstRn6qMpXN+uQx63OUxH
bT2fWM1Ld22eFV7Ebmw9vnTN5LQGDpjpdGluCx7ODYNnKoP8wObwdyYHrAa0L1+K9fW1nyx9
PlWVD6X8031VV9z62cL6DXjua7c/9mCF+aPzqOv+tzActSKGo/3t0PdC0LwAwlD/cfj+6eCr
gvBQzb/bTCYS2ampE+c/Nj4g67Ob/dMYjhouvgaOtTc4XzHa4qrMW99avGf+z9jvk5rzkG/R
Rrfb818x3h9whMuiPRv2o0tsTzkRpC0uSpBXM5O1DaXPnB/70VxsLDd0g3c4/JXvVGRZSZoy
erWSi2VrvVl7/srG/wM5uQP5OWu+r/Sj81+G94Nm+bMuj16YXAb2/QHfN9VMtVye77Pm+4/G
/Gcc/6KhV3mv+ezZomjevy3psDi3ruucUz/VnffO/PbMfww/9fzveJ8Ab38lgj9G/1D+/eb4
N/Tf+f4RhLyazycZJpHNpgn6V4j/b3Dve9Rw5+fE8+uL/wOB0wTOE/jvGP4z8uEXDP8T+UDa
P46j+yflVyRwkr9E4KT64+7/E+zM/H+q7Ss6FM+8egAAAABJRU5ErkJggg==</binary>
 <binary id="img_9.jpeg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRof
Hh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/wgALCAA7AfoBAREA/8QAGgAA
AgMBAQAAAAAAAAAAAAAAAAUBAgQDBv/aAAgBAQAAAAH36joylTLQWyyFXRiLOu4RMNomcgkd
xKtoCV0ChuQqbFVzM5ZGBh13FuzsGHpqMXTSYOuoXaNJh6aZXaNJj2Bg3hx7Bh3Bi2kZNZXh
qM9dRmv2MemxIKmoK2gK2gKmcykdSKmpChwC1kCxmCtoCtnIrZgramausWMbRQ6BEhWxFbkJ
HYInpKF9AifBz6BS4I3hFLhS4InxFbTS8Qj6uQPOZ26uOdvUyCPLSvahz0Ug1ZSvfh29Ei5b
J5vEmS0371yQ/VO/Ka7Yn3Fb3tGxmEETm0BYgSt62Ut4FLcE7eed5penXlZQ755O3UAkTOMn
btW1QFZr52SvK88DAFTa1VTHrVS0tK5kWVM5qsa1lW0LqmkCltWyZ1Eq2kcOG66lqQs09+cW
KhaKEzbkRMF5isB15Z+/Sk5abOXPty0R2TtcmmeWemzMxw5e1eGurb//xAAnEAACAgEEAwAC
AQUAAAAAAAACBAEDAAUQERQSExUgMSEiIyUwNf/aAAgBAQABBQLPfdJK3FcGwszBpMEzTtVd
bZKt83xsF9pGrdN9e1d1pmrdN6u0uWDTQZHG17c0sbm54u7lbcLe9DfvY3XZOy7dRvtHtP6W
vm0tjkoBa6bw2atKhYZ5HZi8qiA4sr36tUFVUFUbCvUFlVQVRsKtQ5XUFQ7dKicqqGodoWqE
qqQXDaE6IGuoag2KgDt361c3b+sfZuK1YW7guAWbhRXUe0x5RVSFW9lY2101DSG11I31APgG
11AXZEQMfjfedbu915Vu73MFW9vcwVb29rNgvb23kD+5MH9Pc2JB7elibHN12CtZ3UYlj8EW
CZV309g2k9rrPXQvb7ltn7yVTj9bSURHkM/7OImd2C41Ldgv8pvcc/W3Ip+1vxHO/Ec7p89r
fiI/COIjaf1pJeWm7/qNpiCjfWP+WmBdL8GrLYc+qXrVvO0nXbKW51SfOluwAt1M6wj+fwYn
jU5Ys7oMmVEMT6/aRNk1YLItf2oaLx9hlqHuustNm41LGLK7ZKfti4UN/SPwLVZikdS5YjU7
fVGpfxM/00vGadrpqZNxEwk3LYqFy3hFYTgahaYE9ZJC9YVqj3aucZJfJsssZq1PzE2rlaAn
yq0k5s07AeKIJ4xzt3RZ9Q/Utd76RZKXO7YAdk7ql3Zua1jn5aXMI/jxE7HTVYfEZxnEfiwX
GpTHOQAxHiOXnxqXEc+A54xl5+Op8RGcROcRhlxq/jGcRnrCZ8BzxjJrCY4iI9YbQAxkDEYr
M97PGOerV1/XEB4xkCMZIxOeIxMjBRxE5+h0o5s04hgxNSkwKmsy8YzxGYiIGPAZmAgR8B8v
Ac1MfPT1V65TJqiuZeWiO4vjF1Vz0tURncX5+grjJhL30FOYfVnO8t43XAep95XJcXjO8tzc
1XLw6inOdxfxnUFYy5kD1D6SefQV47yuW3Vk/Lqw5Dqsx215wmB+h3lfGXFozvq5ZdWepw4u
Wd9XO8rlNtdeo91bJdVjJbXjF2ghqGl5zuLZ3VsRvqrjuLc95XO6rzpzNNKXcW8e4tnao8kb
hXS7i2d1bGGapXUbpBPuq52181C4L9OhpfiW1xzuLeLzC9yKtM9SUlzLoKjnzVMnT1SydPVm
fmqcxpicZOmJ581TPnK8/LT4jS0+S0tOZLTVCwkVZGdLT8Y0lGM+apk6apJ/JSydLT4+apMf
NUz5ifE6crMRpSUZ8tPI0pLPnKxk6cri+nK+r5qnl8xSM+YnGTpafi2ivCfQWm4UViMNOV91
yCxSGmKFXOnre4tNUiudNUnPmJxjSK1Unpich81T0Dp6sz89USp09XxTToPGkVwwNNUkBQWK
w9NULLtNUjB05X3VJ0RRZp6vuhFcrqNMT8Z09X2plMo//8QAPBAAAQMDAQUGBAQEBQUAAAAA
AQACEQMSITEEEyAiQRAjM1FhkTJCcYFSoaKxFGKS0TA0Q3LwBSSCweH/2gAIAQEABj8CW1Ns
F1L4I64R3mKjfiERHbtO9ta2j1CL3tDeaBB7a7bWXU3QM+iqXRLH29u0NsZNM4zrhFxA+KAR
o717doZayaZgZ1wqdVwguE47a7yxt1N9gg66f3Tg8C5pgxoe0MtwbfvJjg3FuMD34GU7WWOn
6xwPaIDASBrJjgfTqtsObRnIngqw2GN+E+fbjVVGOHNTMHtJaJPQJxgCHRI0Pa+q1odYLomE
D2sYxoLnTqfJNeNHCeB7rTL/AIuY5RsGusme19RoNzteY5TgxsSbj9e18B3efFzlENGuTJme
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</binary>
 <binary id="img_10.jpeg" content-type="image/jpeg">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</binary>
 <binary id="img_11.jpeg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRof
Hh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/wgALCABvAZ4BAREA/8QAGgAB
AAMBAQEAAAAAAAAAAAAAAAIDBAEFBv/aAAgBAQAAAAH7/wAu2mNvo9cADuXLbmv13AMdFF/p
gAMMKpU+0AAZsUuQ9SwBhzueuADnTxvZc64AHTzPQmADxvZAAD5D67vOuAB0+f8AR3gBm8L6
YADnXPA9/vOuAAPI26wAr8H6IABwdK59HIzOKbJ8EOzEeTCuwAISqt5Xb4/r12xhHPrjdynD
6WXVOqfm+nXNXCrZCSHm+tMAR83ytuSfuYc8sd3fWhhy2tMtXj6KI+3hqlkst9Ovza7NE4+p
VG6uVuGd8bceHvNmrBLHPUueZOv3fO56Hzt9vosNuaOvtjzb8n0fnZfXw+bp5l+j82lb6tWX
Q0PL1xjouxShKG7vlejmn3Q8vXCVt2WCUtLwfasAGfJ2E4you5CXYRl2yrmTbySddV0odnVP
k+1y8D66wAZcsJdjyyHe1Jytq5LtFvZVrOoWRl1FZyMtoA58nb61PmejTCvRXDVOiq/V3zMv
PoOtVvxvu25K4t9HqZO+VV9UAOeVr11Ye0zq5ZzXDLZd6DPm06BzO72HLVWrqjL6IAf/xAAo
EAACAgEDAwQDAQEBAAAAAAACAwEEAAURFBITFRAgMDQhMkAzNTH/2gAIAQEAAQUCyxalJw6J
sReTKCvBAzcUJ/O5wIWVr8TaUNnyCuzNsBgDhgfBLJ5UXUyRXx6DtgBfMxEMZxo5I1VLXwld
MUt7HztVDgmiqRmqkWRRT0nT6jABAfg44zYGgoIimmQikPf/AILP3/49Q/50fr8mm/U/h1C+
uvqH8erWBr0ajxs1vjc2Ep0i0t6f4blLk3f49SrzaooV2K/xlEEOk05p1/5YIZn3RMFHtM4A
Y/Me3qjq/PuiYKPbJCPyb7enWMFv6SwI9Kf+u8ZBiU51RnWPW7/Gltwusd1tBo5vgNBmXNs3
zkrGeofQ2CoImJhW3kN9s6xk+oZzqjbuhDH/AF6kxNOSiMBgsCTEc6h3W0GjqP1o/X4tstpK
xX8efa4hFqA6e3tsoExa46V1fydqmb3Kqyq4vTiGrw2YNKQtWJ2rU/pJpyuxGnsjTzpntFNn
cq1ZrtuZYX3a40JiuymTHcJvc4JFVQMgtEz5K5VOyc1S58adPYmm2TinItsfXqfSTRIXFSPg
toycDWKG0q5VlahATWj/AMJoAYOWweoeoXKPOsfQbK2HDwlEmIyLAKctGa6p2HRYC91lUZYa
20bwTHV01d+49hBZRabOc0jRT7s12FZ5Vn6tb6rXsGIulGPtPkB3gUzZl9vfC/ULTST5Ccg3
nqT5YKEd3sp/6NgjAosshw3iNdKWlWaVjksGQr1fqtsMCJuELDstd6VpsSOphDKwfgLFfkHG
ns34U4dRpizTJPBjYU12Kzhsmi2mbXrrmlu2MUDg4dac7KutaVL9am3WddLSCslZxVrxAAC4
yztxK/1uLX346eiadeR9LmEMFE1kTEoUWdhUM9E7c5iFOyVIE+OnAAFxlj69X6nFRExXRAdl
XrqkdVMP0+JrloDyFTOfVzyNTJvVRnyFTeb9WMC7SjPIVc8jT38lT28hVzyNTCuUzjn01R5K
nnkakTz6ueSp55OnuzUKZZOo1IzydPPI1OmL9WZ51ac8lUnBvUoZ5GpsV+qMRqVQs8hU2G7W
KCv1OgbdWFxqFUsm7XiYuImJ1CtE86ttfvJesI2D4p7bxnT6sx42pkafU28fUnPHVN/G09uB
Vzx1TJ06pM+Pq4WnVugNPrbeOqZwKuw1K4TNCqUxQrRk0KszNKsUlSpDnAq7Tp9Qs4VbPH1c
8fV2ijVjOHWyaVeRijWjOHWyaNWc4iM4tffh1silWiYpV4LsK6SqoIop14CRSE/HF5NFtXWV
Wc5yMdcHshqDWGOoBNLyQzEasqc8sG/khLPKqydTLoXdjhFbaOFqXRh6pCWhqSyZ5CvnNVl3
VYqrnUk3FP19K55gZy1Zy1YBQY4i48103m8bL5RHMOH+SwbThsrsl0BYI7JPZ21l1rm2EFyx
y9qnFWu+q8746obMXXUksMIMOGiVcNPHnT68zwK2Rp1WMPTlG9VBK1xp1bpmuolhVUGJ08AX
4+ti6qVeppW3LKyIGIU6Pb2VdKkqQJqWzJUsiFCgnjp27YRnaCDlCi9hqBmNVJN+P//EAEEQ
AAIBAwIDBAYGBwcFAAAAAAECEQADEiExEyJRBDIzQRAjMGFxkSBAQlJywRRic4GTodE0Q5Kx
svDxU4KDouH/2gAIAQEABj8Cq0i2y7XDTWvugGje58B541aYK5FwxoKKHMEb8h0+oZ3Nqssq
Stx8NdIoWCTmau3FDHhidqWRclthgZoMu3sRbgQULT/v41cWTNsS2lW2RHbJ8NPhRUq/KuTa
bD26vm4K7QaN/iXMiMYnSuBxH5tufWgoLAhspB1mrjO5NsxpPTr9QxJYfAxSLLgKZEN50bxJ
GuXe0phzNkuGp8qs+sYhCScmM0FUQB7HjZPl+LSoUvtHe2qNTzZTlrNF3OS4hYM/z6/Uexfi
b/T9U7T+zah7X/vf/UfqXZw9t5SW085H1RwwY8QFBFJdUEA9faNdaYUSYp0QNKsSZ95P1Lsl
2NLbc31S5bUS24q3b+6I9oQdjTq3eLn5fViARI3+nIMj6Un6eMielH6UgyPpCTvoPbBZEnb0
iWGpgejtf7b8h6GAIJBg+jesJGUTFP8AhNWI2wFEZCRuJrJGDD0nBgYMGuzz/wBYUfdWpgTE
+Vbj0F3aFHnWmtdoPnig/wA/RhkMt4rQit64eQziYq7+E1ZjbAUZO29BkIKmtSBUSJrK2wYG
gPMsI12oe0NtQNT9quzyllzbLSp21/dRvuloriB7/jWGSCLZtgj4zXhdnDBw2I2NKIAjyGwr
tOket/IUrrhoIk1ducO1DmcvtDTaimNkXMpVh8ZigxFludm4Z7utW7otWjCBfw/Crp/UNWP2
a/5UbhZIM6AdafsoFrUQG6++k4duyORldZ01qWFp+7q26x0q7pbxZi0ga12f9stPbEcwjWsP
VyLgcL5aVYuFbMW1grFHFkVc2cMNxIirlo27SFlAlTMmoKovuTau1DyhKUrhoI1r9I4dpuUC
TuK7Qh4WVwkggbVmRZbnywO2wFWbgS1ypiRG2vlV38Bqx+AVcZ+HDg7e+ksBbIZSuvWK9Xw7
c2jbKxprRJFtgWykrrQtthAESoiah+7kNelCKRGMF9qDI4Ibb31Eia5biH4Gu8Pn6HRJYpvA
pbvk0RQBYAnYTRhhoYPou3EjJFLa0ioFYG1mVJigMABmF73UTV5rjDFXKqo/4qezoHfoaGwP
nXaZafW9dtBXZ1B5XYgj91Q65DiOgaek0biIAeDxRJpWvNkx1q2EQGz9tqux9w1a1nkHnNdu
GccNJUxtpSh7aycO6071a4SgM10odek/0oSZNXeMqi39gjzqxzR60TrFd6PfXY2Dgs5IYHQH
Sm9WoxAPe/Wj8qa3mBaQAwPP+VObQyuRoKXj48TzxrtWukJAqyVaAbkMOoq8pAZFuBZnXWKy
CLJts8ZdDSvdbJmE1bW2im19smrsMdmMk1Z1nkGtds5h6qCtIjWwCWA7/Wf6V2fB0t55Za9P
Q36SqgzpjSz98UPhVuTyiZ60CXUw2QEbc006nDFixyjm1pQXthgw1W35CgJSBn5HzoAmauH1
UuZBC0Ozm4mnnh/9oXMk8vLpV1k4fO2Uka+jC4oZehoeoQxoNKz4a5dYom3bRJ+6PT2n9t+Q
oM9pGYeZFZpaQN1AogWbcHfl3qEUKOgHovTtgatx9wUx4NuW35d6KcJMTuMaANm3A2Eens/7
YVDAEdDUGzbj8NCbaHHQcu1cThpn96NfT2neeWflQ4lpHj7wmhcNu2GnRopvVJzb8u9QihV6
Aei7+A1Z/AKY8G3Lb8u9cPhJidcYoerTTbT08olsxFD4ezyuuFXqa/tCfOvHT51461BvLUcd
K8dPnRK3VGWp99eOtRx0qf0ha8Za/tCU1s3lMiDrQHGWBpXjj5VHGWvHSvHWo46zSzcmGkaG
tb6144rLjrFeOvXWh65da8X+RpitznbeAdanjrWt9K0u/wDqanjrUi8sTE1rcBB0iKGNwBBy
/CtLy0s3Iy7uh1qQ+nWNK1vLU8URQtWS7GcpC0Ad49m9s4uNmFRwRXhfzNeAteAtTwFqOCK8
Ba8AVPBFeAtELZSfKaBawmUa14IqOCtStpQfhUm0CYivCFSbCfKpNlZ61zWU1Ma1HBWtbCV4
K14I+dRwRFaWE+VeCnyorwlgmaPqxrXgp8q8C3/hoeqXTaj6lNf1a8C3/hqeCk/CgwspI91B
TbBA2msmsoW6xRUWUAO8CrawAe6mn7/y9p2vi5a3fIe4U8oyKsRoWn5V3m/wGrhti5kEJBNp
oqzgmaFeaPtNHlT9qxMIYIolbLsAuZ27vWjytPF4cfnTTb0HnlOkx+deqtl+YgaxsJrVYJKQ
PjFKeHhxBKMTOkga/Om7QwJxMaCJpQeytLNj3xUtYfHUKZGpFcK7ZK3OgM/CgmJylgY1iP8A
it7n8Jv6VoLp+Fpv6UrLadpMHJStJit0Fbinuz51ilp2b9bSu5e/hNW13+C/9K2u/wAF/wCl
BhMHqI9HZny5ByuzfbMGnzUBkbHTzpIUHJsdTEVwzaGmORnr0q4eHKqpZWB71G2wQsxGIy0G
nWuym468zkE5fGrlrFYTzyrtjAgcLu/KaVuomowun/xGvCv/AMI0jiy5BMHIFa7LgtwEP5jT
un2na8hvd/IUxt21UtviPQUbUEQaW3hyKIFNZxJR9Wk71PMJ3AbcdK8If7M0OVvdznTWaa6S
4nyDkVgQW2Mk9NqxwkdCxNPbK8lzcUIyPNlJYnWiLvrGMzO2teHO+5JrJFiGLfv9I4lsNGok
VbFsf3ik/Ca9ZbVviPpBeGuI2EVFpFQe4UM7atG0igxRSw2MbUcbSj4CseEkdMa0QfKswi5d
Yp5QHid73/QGaK8dRXZ8YxtvJ+R9p//EACkQAQEAAgIBAwIHAQEBAAAAAAERACExQVFhcYGR
oRAgMECx0fDB8eH/2gAIAQEAAT8hxkwA5gHKwcNxHhWtvGons+cNYDqkdyfXEg5NVEF4746x
uYFMK4rIfsHbIUNF2sM22qNly3JvjAKOPWll/gxYEqjSz+PnIylTeEK6mPFV5I/ojXKF7ohJ
iFhRK4OXIyJwN7TTp4yqOE+ddv0eP13X0VB63WewKCDxJ63A8oqF0jWfy5BxIy0Iv0cQGEhd
Y+r9hCYo1llqZWjbvXe8V5bawMi/TCPbaXWuriIoo5EhESZ0NkfopmmIFaapPgyeUWd9FHX0
yVPV2Q1yfJiKQKydK7Xs9n7E7O/+r9p/heHPtD9UyTgIPH7IWJ4QcgJvzhs4n7O5swCCjLg4
/wBB3rX6gaJwCsMvGDDW8fb9lMdgv0Nn3Pv+01FMGzY4QvXp3D9QU6CJ5MFWOdWNH9/P7FvX
5UINAHZ7/mdG8ACThGj+akfQKVfB64oJdl3+Uyq0JWthhtSTqH5VAVQDlcACTYjR/M4CFbHl
8fqI5IVm8txeiqDzOcgYpcpZS8zKoRYvL4y4Qndqs14MQQUF49ckTEHTLH4TKec0WJZblWJQ
q3Hv7YRNYO7xrAS4panXjBSt0Cnvgd54R/BAgpXgzdxQB4Rjhe10oBa7wDpapjAugPkvV84l
yWrz1lKFK4UDmLgyiQHsbgZlQzXHLn5xEVC6LgiIAV7B4fs4IivZxBMQ1biIgUE7SzJSWG5+
HGMpp0moYMgAXbjCioIjzcsawrWYlf0l3hcpURzgAgJivJ65ey2Fv6aPFxiGCiQQbyX+EzUc
RtZXZ09jFADC7o30l69jA3HSdRAvppJ64Z7h4IIizv2xUngPshnEgWau3kzQQHZpu8RHrw+u
GtolygGJxS895p9Kw8bmtHWsd8AitQb45I9duEG3rRQ86N1rnrNXWJPhyikPB7MS82U7r1Wf
HOAwsCI7Wtc4R1NsC03Zvjvzgjdl0UBfZS9c4ma0SOtj6GOaAqBb64+6E5J9t5phMQo0JZdz
mZZ8DWm5x7TWT0wkd3E40t56xvH9ABtRD/rgt0LpgzQYBL2qP9ZrQLy0vwifHzhAAqNKi1NN
0+esjKy7Utj6ccZRYW7XfE51eO3FJdwU0N5cdZ4V6PhwoDPT44M0IBYtq9mvauPahRSI3xay
fPOaJIqsUNJO7jvq7gqSD6fxrK8QClHbhLSv7jJ8Saw4KkL2mX0ZQ9GM+mbms6u88gM0u8mz
fZI5/BzafQvgeLgjs4PLeM5qkAF9sPXOoeE6y7xiQEimi4rhegUTdj54ycIbu0EMnrJlkODE
I/L5vxjOlgJNecTdExFoec7k3DaNB6d4OkYx60fqYohQnCqRqcQlyzI+tdOsZ5GUIhrqB/33
wD+Gx2Pp9Pvlb29LZ094QEhycmvPeccKMLSfnjF2iizA0F15MAG0mp4Nd1gAkG3y4cjnzB9d
f/cPAD66N69fbOfw+GvXeLO8A2DtmpDRgBbFLq7Oa9U86wVJcxavNXjpMmDOVy5fWRrwuJbW
NxZpvtkzaSES+fjjCbgogiCTcX/3AAdM4MkdcbwBYmiIUPAf998G7Jtce2EG4DgLXnoM852D
bo77zpuKhoSo/wAYmO6lABDZ9GJQi0GtJpR18Y2M59cTQTnseeX6fzhgoCcLeSa98AEsAb5y
rLjNm0iJwiYQDFXDZPO+ZvjK78Vx2+/Sy+MQqKTIjxV3v2MlptA0jNrdusa4ABZLjJShHpfO
9mNhUAVwN47euNMkCo7teLHfF4zQYeq7BrXWs5Y0SOeBxIER2FhbPu4sEokndcbxVE5Il+n4
8WMqq8uAFkgNTOSFaI753gqQwA09c9M/oPt+HIU20KhHEMSGgSPGeYTcWub5zv8AtERfKYm0
qwwXnDRD8JNq8IHe8TsXIUcAIB0In+0Zw1mwMeDxgqSfIP3fjwJosycuMeSOgjH1zp8ERrrn
zmxb64uXN856J+Qfb8I3WbJ7Oba51/BgIFyJ7XfnFINqjF8zNA0eDrvX4uBoQ3lswIbyC/p7
JNOAuJzt4wOLOc2MTQd/GGB1Kb5PPtg/JeLiSNws8M3NTiSmF/jNN0/ODSt74nwPy4OgUUAj
3n1Sc4aOQDp3syagAAFhiRWHu/rEBWSmniXPgOd8Zul30riPVLw/1gSBluI+f99MCo+POI2z
PR/rBFoO9+n9mTkddgSeXBQORPXA1Cz/AFxhQFQpKNHWCcP836Y2Ygum/wAYxLwr0H0ziEPQ
XNOlVMLL37Yh+chX0kxWSAaYtQ9OTBtp5kb9MJbOJD+Hpi+k+by7k6chwcee/wDfcxIoFwx3
6cc+mQUsFynG2dze8RJQB/T1yL34yx+2UqfzmuTvnu++CBWErtnvjJVnFuKBIm9riyU1Hl6+
cDaU+cWJp8V/vACqN5efrnLUvmuPIoeVB+vGGKnEqmzcwAhPxXf3zTThQpZf/cAFl3y2R+2G
BiCqw+uUpB2m97u/POJqaSkY+VTWNu7z74aJQB5K6MCGhvW+8NB0JxlrVpOOgD/hi4GgaREf
rl26ulf7wGDPTCwXUQkTvGpuANVzQpRRVGfOLCLDpuERdXgGAsiuoNn+uBNt0dP91mifbZG9
SXAcFInkRy6C1AsXa7xeyco1wcxQQpbiKuQa60Pu+P1FK7YHfm4++Mc/ARV6GuMFnb/vjAHG
wQAptJm+wKijc6Qe/wCsTxuBFozX1xYP7COSArux1nDIDgrWfDTnUEGBwVZwkM3ncVnCgE79
80HehqhV46v2xiJkMFUDU4MvzijSnqXUF1ac4uXgnbLrfv8ATAolPMEkl174BadQhYcvWz0z
6vcp8zzUxDnJXsbyvAzaJq48KYtun3Gjdl85G6MYn+/tiPMHj/y/GxY8JAovo7x4dzNDj0oL
ovghXz7Z5V1E0Gl3N/OIMX4qh2641ixsIJ8+xs953nrqIQCHYeergjUx79eF64mV5MuFhPUT
XpuYVSUvIiXRM2X5AnEKX3uaLko8UxIVF4j/ABn+R/5gSDJrI8Kc4uKtfvvj9RhaHdxEylWa
gLP/AH8A0rB5HNZhRi6Ej8+uGxv2KrW1W9GKyBQgCNo8Vdeub12L5f8ANwWImjpEQF0UMhHr
doeXT2AT0znc2Rt9zqGBV1kEANArovWEAUVl2v8AHGaETnQxLV8axiebp5KwuvjAWJraw0B2
vgMT2SLXkRfp+PMz6Jj5zVUBBCAL/GECbxJn5pGB6Ihz18v1xw0NSVc5FOxs9rnO/EC+xy8G
2olvOBsX8wj/AK4GAIOgGCgD5Ir85dSAB4ji5x+JYMVAmPneNhCA41Iny/qf/9oACAEBAAAA
EO//APgf/f8A/j//AP3+X/8A/wD/AP7/APv/AP8Af/8A7/8A/wD/AP8A/wD+/wD/AP8A/e/f
/wD99/8Ay7jcfGG/8pbTjrRdMYzFDNxwRGbo/U6ue/8ARz/sg5C/80psztxv/wCi663e7X/z
3F4+1P8A/wD/xAAqEAACAQMACAcBAQAAAAAAAAAAAREQITFBUWFxgZGh8CAwQLHB4fHRUP/a
AAgBAQABPxAV1IigCacjv2wBvB9uhAxD3UOWiQhAA/QY4jJlegAhTpI+pCkgEkZoLnvDtgPs
3H4BjDB4h5Sl4Jwxy3xEMueGxAgbQ9kOGmefIfG7AM/ZL91CgNulCGubmOaehM1e+1CmgMXy
JhVNfvBfE2gDClaR4hKJ247IcJY2CPJcRDqMRgB0+63aBDUPZCQJLuST/TgwgBl5WK9EQOfM
tvSZQE5UJg8Oz4slz+PMnVlSASmbX4dr9EiUbg+ksa/0jP2Dt01P+YCZ4AHZjYJ0ehG8JaUo
DxBl411QAZxRAGrQHiIw9VQBgDSAPsBBidAOAEEosyYHGBQZFc1CUI2pHLKGWIk2XXfeA41j
AEyFhgMhdSg4CHG5HntuMaSzgDR4R1zPQCOaBE4gUIA0Aqq0hVQGCIAJtdTn+QKwCVCLADZH
S2AuwwToGQdVDJBtGcKE5nQAEBv4U4R5kFhQN6oRgACC64oaRouD9snmiCDnYpXqGEHYQQvq
DeKuBFcU3/qAIA0KqqJxAoWUiYJJwuTAeeIQaICqs3mgBcNboBAA4KSOgZBl38cEQhIfV/Si
VwDX7006KkwKVUWqdJCZoATDICY5MfCnAoITna83rAbiQiCNmGwRn5Q8MYJKzZsdtbRzI7QK
fhgSe/gZHsXUKhof6CLSeV5jyYrMHDm5PAkPD99CgbpI/wDMrCUGOlVpC6h0MVeA06Lg25hr
EZA6S0IMF2VCEjTt8shjCgATnpbTUO4PDRkZBj96AEyxrwTcMYQCJnSiAvyaUC6Mc6BpGnvL
2kan2pYSBFKyoyMJcAwitQKNXMw02agQ9jjkFWIBa3UAvBoi44oKQQRUwBLXGDuCBid7IpOZ
f0HtsOD2IElkvCw+UIKMlHRZVan6XJsFIThrPP8AIqCZgBdyXOrggHT8NZFRR/dgbcDANhin
8q5vQJ/yabyjIK/tz4BMFDku3gKpjgF6QH6+w3GgIWBSfbKAS4hdsAkYkkoEmODiTIBCIuaI
Kmd0gEO8HbASCuKmNbv1FioKJgMKiic7ciAWVgAi0JVbkAYFiA4khIOTMVDqcdECuVhwQb0H
6RDTuQQyZF4CjBHkpdAYngWgH14OoEdNeKMmwspZdLEQ9BsF2DMeEEtEgzlKQLWoQPBCemX/
AI5G386yI1jS03o1RPZA0gKkKAclOGBCio/EG422GQIqA86YcCep/IAb3g4G4dkUrhwBAcP1
VX46gBQV6Syrbi7VsgO4gUxkfnTOqP4ISlArDWi+0FI1WUNKp8/CYyyC8ITFcwXB16cCiEbz
RiNX6dAJ9Rklpjfl0AF1WUDvhd2ywYfcEAoJmTaqAdLUAgDNkFSCt4ORlGoIdUA2JgJud3Hq
h4gkZHM7XMIppbufcaERn0oDbOUqExl+XsAgrItP9Bl4gOdknswhq7hhge2VvO+IYzwRZzAa
FbPACJjAPpA0obGXULnHS2245AWx89gHF5rOu6WRREIwyCgBJ51dIvLAsZdqz6BdQt9CMEyX
BcAI/GwJLEDeu9iORtNAJKjugGo4xC/AiHwWMyyEGkkgsPwA3B22wEc0tXNHMoZsFMdsSJD4
0gBZrfkDl0sRvpFV2iBEyZuoN+/TSNnRE0FMIQ8RuCmVfZpBYbZrAkwNhQDUSQmG/QHaH0IW
RG1JeYDMmocBmx47iESpxUwHMailwC8wJdsD8MWjRmGMsgHTQp64CCGelZfuU2YSDcZNAAWG
geEMAtW+vAITlS1Y/wBKCxQXFPCJDjkPROF55hFY0NyX9jnEFpEIQiBE3ZwmA9lL92gEDFrh
dbhCaTGb8qKTIyYtbCPpHDeHPG0t7hvYjLXdu27Z8OA+YDSqUYWoCZmib6KgA3hlZAO1skXn
JEJb7BrOECE6tLvsTmLoRr2XQQSG8WZMmBBM9Cm+B4Iq1VWE6o5gD7EGfk8yWiqKQI7G536l
vdSb0i7Axo5B8HrACeJh+/YisJS2w7j/AGIDWkLfZaYvrC2SFyRW1COG8q9Z4GLUCoQczB9V
7+UjQARXUKCC9VmHLbWJZM241AhSM63F1RSHKHAgwfi53w11e3b3cRHRgLohZ4PFr+WkgoBB
uI5AvA8wPoH0m5sgYN61AETP8PBO1wgH7edlCJhUWdWDC1YPBFuoD8TxPOPmf//Z</binary>
 <binary id="img_12.jpeg" content-type="image/jpeg">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
</binary>
 <binary id="img_13.jpeg" content-type="image/jpeg">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</binary>
 <binary id="img_14.jpeg" content-type="image/jpeg">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
Fo//2Q==</binary>
 <binary id="img_15.png" content-type="image/png">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</binary>
 <binary id="img_16.jpeg" content-type="image/jpeg">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
BoXKqQhwASIF2R4Y/wAgKer4RALR22oA6vIf/9k=</binary>
 <binary id="img_17.jpeg" content-type="image/jpeg">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
2Q==</binary>
 <binary id="img_18.jpeg" content-type="image/jpeg">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
rgWEjEbP/9k=</binary>
 <binary id="img_19.jpeg" content-type="image/jpeg">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
B//Z</binary>
 <binary id="img_20.jpeg" content-type="image/jpeg">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
ZG+R5bd//9k=</binary>
 <binary id="img_21.jpeg" content-type="image/jpeg">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
Q7LDRCECtFiU+YwuWuPvP//Z</binary>
 <binary id="img_22.jpeg" content-type="image/jpeg">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
FIHAUf3KQAbBnIyJxuUJ5wh0RujgdU//2Q==</binary>
 <binary id="img_23.jpeg" content-type="image/jpeg">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</binary>
 <binary id="img_24.jpeg" content-type="image/jpeg">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
9CCTycekKwUgMKR6GTI6UIfPKWYwICRH4zdRlKxSvgw+AWUcsR+AwGgwgJOjgYLSmHzMXROT
Cg+WSovQVrFk2UTDNavNwQ8psr5cBEAAHAeAAQUfcnvpk5WT8H/gGWCAw1Csz6/fhjJERSlI
ezhBjNQXQK9uBhRGqVidjSO+TkhICGWztOMChF8umE+T5++PmsUKAu4982xJyd3Zu2ed4HIl
FSERTxWBkpgiUpG93kgU2iallfWvb782WxA0qH8H/gHAeb3RJ+T3/YVIIE3Lr4N9tA0JvDsn
kNJ4E5oe5qIua3hZhs4BXywQSrHw8CO6xnIOLMhSbxHygillqMCfXxRtXRkK8gFcSS6xiI94
QYcppZMoTB3jJw6dorop65ZpRWVEZYEtJQFd6hMiLKSIwcSOkHu6Y2DwhRCWelYfdIQ0yTTz
pxIkUyXz8sqSFAyEFXNp9hulcr8zzO2UB3F/rAxp/Ly1goEJ5OjkY9e8/wC+uShIWLYjwlOD
KAlqST3GsACCQAZ0TdTvLEAUJOmCHy8NZeQgysgI3usr+NabTNL4QFMkTtenT/maI6Yu5KE9
zBAhjNuGINY1g5NAyDJzeP1QcNph83nGbCRBWpuOsdcRFbdGW+T3wULTIEJn84reOkTCmSC6
90ACKyI5JRMS1Ub3nHqIESB4n4jGEDIh+TzgDjYiGomiffGWrQiwAV1iMhAUDWBp1/nH4iM9
XIz145nJyUTpIGI/Pb7PvXisYI6Z8B6A7uDlQQlk351hgBwfeJS+4c9uh2wkZBVdws2zgUSy
ZPJ116ZCkuj/ANY2S0obDjeTKUsjY9ZwymSCoX55cyiEhY551mvov//aAAgBAQAAABD/APX/
AP8A/wD/AA//AP43wv8A/wD/AK//AP8A2b7/AP8A/wD/AP8A++G//wD/AP8A/wD/AKc/2Yf/
AP8A/wD/AI+f28f/AP8A/wD/APv/AP8A/wD/AP8A/wD/APv/AP8A/wD/AP8A/wD/AP8A/wD+
/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AL//AO//AP8A/wD/AOn1fr//AP5aq+P2e3//
AP8A5bPk/wDmH/8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD+/wD/AP8A/wD/AP8A/wD3
v/8A/wD/AP8A/wD/APN//wD/AP8A/wD/AP8A/wD/AH//AP8A/wD/AP8A/wD/APf+JO//AP8A
/wDO1/5IMf8A/wD/AP8AZ/8A/wD/AP8A/wD/APzv/wD/AP8A/wD/AP8A/wB//wD/AP8A/wD/
AP8A59f/AP8A/wD/AP8A/wDpk/8A/wD/AP8A/wD9yGhV/wD/AP8A/wD8BRJl/wD/AP8A/wD/
AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wDf/wD/AP8A/wD/AP8A/wAf/wD/
AP8A/wD/AP8A/wB//wD/AP8A/wD/AP8A/wD/AP8AEUD/AP8A/wD/ADI4EHP/AP8A/wD/AP8A
3f8A/wD/AP8A/wD/APxb/wD/AP/EACsQAAIBAgMGBgMBAAAAAAAAAAABERAhMUFRIFBhgaHw
MEBxkcHRYLHx4f/aAAgBAQABPxDxHTXgxHSE087aTjITmsDSRNgqirhyA64eS2d9Bl51AwZO
ZNfjAUTTQaAfl1SE4HR3AjySLSlQZ5ogxGRzXHA5DQAEz6AB0dLKgKWZDDpADBSEQT2JAU4c
2CRLhGW77IAufLt0f4E1nKxBF5YUNKEDCzKW9wgp31AAEqtW8AO2OoQD8laNjazC0MHepM0D
l/Cn6tD4NkG2fsHAQo5VfrTIWyAM8N3McnttPC8VHjuy6v6GhQBeielkHODybTAFjl8G6QCC
kgAQhOQQL/di50Bf3UdMOAWBudAHuHaeQ7KQ4Dtpx6BiwYETqEnKmHQ4PVi2Q8ALmOtvYCca
NNDtbTpKH+lWGEAf2HQlLU4Wv9QA+0DCA2MDAcARBYgOP0yAASBVldyA1J0zpFB1g+DJdQwR
JhA73S6yS4iDr0xixf6bhQQSXzT5AYOzrMTWHBRqmoKISEkuEmA2nKS+AKDjLF+YwiCGce9E
jDRG0Rs7BNBCIwr4iC6xd4jED7J5gYUiMNDBGSd6Ebbi0EyQ1BYEygIEAxnul2Gn8mx8QM5+
Si/5cBA4YBUA1hg2FuoeR5pLAD3cdfWkEEXR5EGlWpgCzi/d5MPdFC8vJdSFuW6CYMi2EDDf
sJq0ATpNf6hD/QWzL/UwB7EsiLwoRatbOKwTwBSGAC64YACdgFt8A211Rd4rUckWRgS64gNM
AJnW68u6HPBATL18ePNIiC8NFnMfKR16mnSnAgu1y8TMroArAzXj4BaMXqJgFvC1cI0LH7ID
JbJdSBzUWMEQMFEiyAPA3MiZmZMu8DLaqoIDAsisAcUWaj/75EZwoNkYwHVmnWvAQFXTjC6h
I8eV/wChRECTw2ftZQEx2DPkP7AgI6qRXkbLDyEOQkiRl0pc8scLggS8AESroIR2dwdRTOYA
abEDpFFBQwR7/KVDBlotC8UIcrGBlVqRgzRWXSTrMBE6e0IGwJ/fhSzY1zQwTb8mqDU/gVnK
No+5CwGqhpE4go9HAkOLrEEsk2BgQDpXjQjwwhNeYuRt07GrkuSqO7aARaocr/jxJyZW10Dw
MIdoA+fvcgR4+ePmRD+eJ4ac5JTsCd+mALIoCAouBySARx5NU+kEegTIPLpLSucCwiSegfBE
GAP533qCPnougJX7GVBo6SpmBFW82UyAItE9RAYGmVzPoKb+XQ/AFSf5L/aWmjbTQNpdUR6w
h0nW4OjwxNAwDmmi99ABF3qFcdgMlLtyAO8vY8OJnIwTIHAp79JyBFN26cUgvjgcqbgjydMc
AG1ZCISONXmoJ5mB9cgS4cf1ASFJlq6mmoTCHBwkbYeS11NrojfowCZ59dK04RaNfJxyE3Da
8rfF41qoR+AUlxcMAb9O2qxEBpyYo9cfXwgpvF+/70AA1x4KUDKp0mRB2orDQmcCAzCQDb+Z
iYPmjBC8ASiRxIITloKT5qDeSQEoOIPlZMAbDL6JNzKMiFxMoZEgnIQb3iZ0agqv68ED7v0s
AkahsK0E+sTuGuJuDRjzwwSb79puL4KBuN+f07y0g7VrTeZBzGgtCohGSxKzGyAaISugoBdE
RiBY9VWnCBcCiq+IRsHsEdbCYgBi6vSQIQ5grhG9uOTJhVJQiXnWYwLVDkHQ/QHzumE+oaRF
9ciLrSA2DdhnSOeYgi9dNREGL7MRCMqe8jeXHeDlDgRW2/EwAcWN6BY0C5SU9aYyBGGDJaCU
vAuC/qxLE4J1lh6ehuZpQBAl9M/8/SFCVB3lJwXvFBLmRB9dFbAI3sWuiSlvihZXpH2T+IQH
FTFq0AAVfXgI2SIwTvhgN2jCYyzR8dAgpfPAwEkxTQYIpk/wweysWEVKmZW/swMx58lBRluc
L7AY8LAGJ2nBGUknyJYAf88+DOi6aNyYAex5qhU9pNIQykxCUTP5Adz2BI+v6YF7FLRDoXHl
BAT+oj8Mz0uX4B+hHnfaABBjnF4gHI160hifGdPUXGyP0jQOUiKuxaMkCmzioAWDQO6ghZvI
aPWnIf4ACRBJ3/UaFbqhZ1BGEBfeJrrBYHqXBMoPmBq/MYg35hI5udQUgbF0cMQQ08aPGwHL
IBr0J2WTJJ/PkrwpBlP/AMCrhd06ONkh6/CT+/CkiTqgGFhXEATEfiJaWgOJfXkiOWvIxyB6
SYXcwtFm7Caz7AnJHOnbYAvoEZdO3RQDQMggp3z4qJgV9YSoE6JJWNmYFBWrMDkkAZ4SXhgh
0bPdDiCHPcMOvaOaACd1CBN8xtO0mtnv1squVEUHt6ybUGkIFLE0EoqrxvGgURvBRemEaqU9
ATnPBhUMbXwW1DLdFAQlE6wm2isOAOntbtMBgmm68uxcwyn8nEChpBnHq+nBfkAWXsyleZkE
L+tkxwE9uEmODaQfCQBjXDFZoC0VYU4CrGuftIu7SBb1rEW0DHc5g8AFSCCp2NARvjw8xG0X
YYLE6MKMeXMr2JFuAX/ww7scYaTcUEPQcAa0JVB3DUIKBKxHkylwXkn/2Q==</binary>
 <binary id="img_25.jpeg" content-type="image/jpeg">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
jDr/AIXGmyFH7ZMUkoDc1kryi2IfoBkgFXASg/IGT+oX80mgN3/GXLY1QLOeMiyl+c9T84g5
Q++eh+ciWk+c0WJ856H5wbx9LOIAHuZweUTT2d9BgCG3Fg4dN3Q7ZzMIGJHRZ7edw4xUJLUK
75/7fqg5Qz1PznqfnPU/Oep+c9T856n5zWWjC7j4+MiyL84ZAFAimw/n+glptUonrMSzwgD2
Zvu7zOf+LxeVp5LihP2+app8TnxHic0Tn9MBcEAgYXghDAEnn5yUiYbVgNq8hZLm1CKhQGLZ
d4FujG6VgS31eLm/CRFw0vKhrAFaCMH0nrvDCI3GtUALedji9Mtijs9mnBZSgioZ/wCSz/xW
KNfws/8AFYoBx+maJr+GHEwKY9WYq9IaShz1/Qo3m05/4rA/hDl/GBgEIANhDvxnJ0N9bA/g
yUi07AB36y+KDeZL4yY1zmrXbK2LJVojbzsYnI8w8vP/AAgdJf8Al//aAAgBAQAAABCmH+x/
/wD/AP8A8S1Vr/8A/wD/AP8AXqjd6b0f/wD18rRPwf3/AP8A/wDh/wD/AP8A/wD/AP8A/f8A
/wD/AP8A/wD/AGngyB893/8A/NFtGxf1/wD/AP8A/wD/AP8A/wD/AP8A/hR0f/8A/wD/AP8A
OHS/PP8A/wD/AP8Ah+e/33//AP8A/wD/AP8A/wD/AP8A/wD/AP8A5/8A/wD/AP8A/wD/AP7/
AP8A/wD/AP8A+6xFrp9//wD/AGpsFibX/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A
/wDO/wB/+ff/AP8A/wDv/wD/AP8A/wD/AP8A/wD/AP8A3/5/++//AMkJ3/ntljP9qNfoVeSx
X+dtajT18+f/AG7bv3+7/wD/AJ8b7Tq3fDn+vpKGOkjlv7/IXX//AP8A/wDx/hf+d/8A/wD/
AP8A/wD9E+4Cf/8A/wD/ANYj4B//AP8A/wD/AP5v/wD/AP8A/8QALBAAAgEDAQYGAwEBAQAA
AAAAAAERECExQSBRYXGB8DCRobHB0UBQ8eFgcP/aAAgBAQABPxBTf6uNZAP+cTYwgyh2rSIg
unA5hU3gUM/O8PKFqLcuwcwGXKfMHGCYhqhqHJtRgakJYMZ+WGyB/LBOBAJBZN0EVeHhB7Qs
8sAOJ44l9Co0XzKOk0TxEYEhibAJrpV/SdwM8/ZQ5IgjKkixMIYZm4gi3O5sihV3zNjlIhuX
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
Pi//2Q==</binary>
 <binary id="img_26.jpeg" content-type="image/jpeg">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
xOg+Uo5jIYXvpZa9xPCzl5nwfZ+B/9k=</binary>
 <binary id="img_27.jpeg" content-type="image/jpeg">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
Ay9LY//Z</binary>
 <binary id="img_28.jpeg" content-type="image/jpeg">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
r17hWgK5LHY//9k=</binary>
 <binary id="img_29.jpeg" content-type="image/jpeg">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</binary>
</FictionBook>
