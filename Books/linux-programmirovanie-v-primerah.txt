Linux программирование в примерах
Арнольд Роббинс


В книге рассмотрены вопросы, связанные с программированием под Linux: файловый ввод/вывод, метаданные файлов, основы управления памятью, процессы и сигналы, пользователи и группы, вопросы интернационализации и локализации, сортировка, поиск и многие другие. Много внимания уделено средствам отладки, доступным под GNU Linux. Все темы иллюстрируются примерами кода, взятого из V7 UNIX и GNU. Эта книга может быть полезна любому, кто интересуется программированием под Linux.





Linux

программирование в примерах





Предисловие


Одним из лучших способов научиться программированию является чтение хорошо написанных программ. Данная книга обучает фундаментальному API системных вызовов Linux — тех, которые образуют ядро любой значительной программы — представляя код из программных изделий, которые вы используете каждый день.

Рассматривая конкретные программы, вы не только видите, как использовать Linux API, но можете также исследовать реальные проблемы (производительности, переносимости, устойчивости), которые возникают при написании программного обеспечения.

Хотя книга называется Программирование под Linux на примерах, все, что мы рассматриваем, относится также к современным системам Unix, если не отмечено противное. Обычно мы используем термин «Linux» для обозначения ядра Linux, a «GNU/Linux» для обозначения всей системы (ядра, библиотек, инструментов). Часто также мы говорим «Linux», когда имеем в виду и Linux, GNU/Linux и Unix; если что-то является специфичным для той или иной системы, мы отмечаем это явным образом.


Аудитория

Данная книга предназначена для лиц, разбирающихся в программировании и знакомых с основами С, по крайней мере на уровне книги Кернигана и Ричи Программирование на языке С. (Программисты Java, желающие прочесть эту книгу, должны разбираться в указателях С, поскольку С активно их использует.) В примерах используются как версия Стандартного С 1990 года, так и Оригинальный С.

В частности, вам следует быть знакомыми со всеми операторами С, структурами управления потоком исполнения, использованием объявлений переменных и указателей, функциями работы со строками, использованием 


 и набором функций 


 для файлового ввода/вывода.

Вы должны понимать базовые концепции стандартного ввода, стандартного вывода и стандартной ошибки, а также знать тот факт, что все программы на С получают массив символьных строк, представляющих вызываемые опции и аргументы. Вы должны также быть знакомы с основными инструментами командной строки, такими, как 


, 


, 


, 


, 


, 


 (и 


, если он у вас имеется), 


 и 


, с использованием длинных и коротких опций командной строки, переменных окружения и перенаправления ввода/вывода, включая каналы.

Мы предполагаем, что вы хотите писать программы, которые работают не только под GNU/Linux, но и на множестве различных систем Unix. С этой целью мы помечаем каждый интерфейс с точки зрения его доступности (лишь для систем GLIBC или определен в POSIX и т.д.), а в тексте приведены также советы по переносимости.

Программирование, которое здесь приводится, может быть на более низком уровне, чем вы обычно использовали; это нормально. Системные вызовы являются основными строительными блоками для операций более высокого уровня и поэтому они низкоуровневые по своей природе. Это, в свою очередь, определяет использование нами С: функции API были спроектированы для использования из С, и код, связывающий их с языками более высокого уровня, такими как C++ и Java, неизбежно будет на более низком уровне и вероятнее всего, написанным на С. «Низкий уровень» не означает «плохой», это просто значит «более стимулирующий».


Что вы изучите

Данная книга фокусируется на базовых API, образующих ядро программирования под Linux:

• Управление памятью

• Файловый ввод/вывод

• Метаданные файлов

• Процессы и сигналы

• Пользователи и группы

• Поддержка программирования (сортировка, анализ аргументов и т.д.)

• Интернационализация

• Отладка

Мы намеренно сохранили список тем коротким. Мы считаем, что попытка научить а одной книге «всему, что можно узнать», пугает. Большинство читателей предпочитают книжки поменьше, более сфокусированные, и лучшие книги по Unix написаны таким способом

Поэтому вместо одного гигантского тома мы планируем несколько книг: одну по межпроцессному взаимодействию (IPC) и сетям, другую по разработке программного обеспечения и переносимости кода. Мы также положили глаз а направлении дополнительных томов в серии Программирование под Linux на примерах, которые будут раскрывать такие темы, как многопоточное программирование и программирование графических интерфейсов пользователя (GUI).

Рассматриваемые нами API включают как системные вызовы, так и библиотечные функции. Действительно, на уровне С оба вида выступают в виде простых вызовов функций. Системный вызов является непосредственным запросом системной службы, такой, как чтение или запись файла или создание процесса. Библиотечная функция, с другой стороны, работает на уровне пользователя, возможно, никогда не запрашивая какие-либо сервисы у операционной системы. Системные вызовы документированы в разделе 2 справочного руководства (которое можно просмотреть с помощью команды man), а библиотечные функции документированы в разделе 3.

Нашей целью является научить вас использовать Linux API на примерах: в частности, посредством использования, где это возможно, как оригинальных исходных кодов Unix, так и инструментов GNU. К сожалению, самодостаточных примеров не так много, как должно было бы быть. Поэтому мы также написали большое число небольших демонстрационных программ. Был сделан акцент на принципах программирования: особенно на таких аспектах программирования для GNU, как «никаких произвольных ограничений», которые превращают инструменты GNU в незаурядные программы.

Выбор для изучения повседневных программ намеренный. Если вы уже использовали GNU/Linux в течение какого-либо периода времени, вы уже понимаете, что делают такие программы, как 


 и 


; после этого просто погрузиться прямо в то, как работают программы, не тратя много времени на изучение того, что они делают.

Иногда мы представляем как высокоуровневый, так и низкоуровневый способы выполнения задачи. Обычно стандарт интерфейса более высокого уровня реализуется посредством более низкоуровневого интерфейса или конструкции. Мы надеемся, что такой взгляд на то, что происходит «под капотом», поможет вам понять, как это работает; для всего кода, который вы пишете сами, нужно всегда использовать более высокоуровневый, стандартный интерфейс.

Таким же образом иногда мы представляем функции, которые предоставляют определенные возможности, а затем рекомендуем (по указанной причине) избегать этих функций! Главной причиной такого подхода является то, что вы получаете возможность узнавать эти функции при встрече и понимать код с их использованием. Всеобъемлющее знание темы требует понимания не только того, что вы можете сделать, но и того, что должны или не должны делать.

Наконец, каждая глава завершается упражнениями. Некоторые из них требуют модификации или написания кода. Другие больше относятся к категориям «Мысленных экспериментов» или «как вы думаете, почему…». Мы рекомендуем выполнить их все — они помогут закрепить понимание материала.


Небольшой — значит красивый: программы Unix



Закон Хоара: «Внутри каждой большой программы есть старающаяся пробиться маленькая программа»

    - C.A.R. Hoare -

Вначале мы планировали обучать Linux API, используя код инструментов GNU. Однако, современные версии даже простых программ командной строки (подобно 


 и 


) большие и многофункциональные. Это особенно верно в отношении GNU вариантов стандартных утилит, которые допускают длинные и короткие опции, делают все, требуемое POSIX и часто имеют также дополнительные, внешне не связанные опции (подобно выделению вывода).

Поэтому возник разумный вопрос: «Как мы можем в этом большом и запутывающем лесу сконцентрироваться на одном или двух важных деревьях?» Другими словами, если мы представим современные полнофункциональные программы, будет ли возможно увидеть лежащую в основе работу программы?

Вот когда закон Хоара[1 - Это знаменитое высказывание было сделано на Международном симпозиуме по эффективному производству больших программ в Jablonna, Польша, 10-14 августа 1970 г. — Примеч. автора.] вдохновил нас на рассмотрение в качестве примера кода оригинальных программ Unix. Оригинальные утилиты V7 Unix маленькие и простые, что упрощает наблюдение происходящего и понимание использования системных вызовов (V7 был выпущен около 1979 г.; это общий предок всех современных систем Unix, включая системы GNU/Linux и BSD.)

В течение многих лет исходный код Unix был защищен авторскими правами и лицензионными соглашениями коммерческой тайны, что затрудняло его использование для обучения и делало невозможным опубликование. Это до сих пор верно в отношении исходного кода всех коммерческих систем Unix. Однако в 2002 г. Caldera (в настоящее время работающая под именем SCO) сделала оригинальный код Unix (вплоть до V7 и 32V Unix) доступным на условиях лицензии в стиле Open Source (см. приложение В «Лицензия Caldera для старой Unix»). Это дает нам возможность включить в эту книгу код из ранних систем Unix.


Стандарты

По всей книге мы ссылаемся на несколько различных официальных стандартов. Стандарт является документом, описывающим, как что-либо работает. Официальные стандарты существуют для многих вещей, например, форма, размещение и назначение отверстий в электрической розетке на вашей стене определяется официальным стандартом, так что все сетевые шнуры в вашей стране работают со всеми розетками.

Таким же образом официальные стандарты для вычислительных систем определяют, как они должны работать; это дает возможность пользователям и разработчикам знать, чего ожидать от своего программного обеспечения, и дает им возможность жаловаться своему поставщику, когда программное обеспечение не работает.

Здесь интерес для нас представляют:

1. ISO/IEC International Standard 9899 Programming Languages — С (Международный стандарт ISO/IEC 9899. Языки программирования - С), 1990. Первый официальный стандарт для языка программирования С.

2. ISO/IEC International Standard 9899. Programming Languages — С, Second edition, 1999 (Международный стандарт ISO/IEC 9899. Языки программирования С, второе издание). Второй (текущий) официальный стандарт для языка программирования C.

3. ISO/IEC International Standard 14882. Programming Languages — С++, 1998 (Международный стандарт ISO/IEC 14882. Языки программирования - С++). Первый официальный стандарт для языка программирования С++.

4. ISO/IEC International Standard 14882. Programming Languages — С++, 2003 (Международный стандарт 14882. Языки программирования — С++). Второй (текущий) официальный стандарт для языка программирования С++.

5. IEEE Standard 1003 1-2001 Standard for Information Technology — Portable Operating System Interface (POSIX®) (Стандарт IEEE 1003.1-2001. Стандарт информационных технологий — переносимый интерфейс операционной системы). Текущая версия стандарта POSIX; описывает поведение, ожидаемое от Unix и Unix-подобных систем. Данное издание освещает как системные вызовы, так и библиотечные интерфейсы с точки зрения программиста C/C++, и интерфейс оболочки и инструментов с точки зрения пользователя. Он состоит из нескольких томов:

 • Базовые определения (Base Definitions). Определения терминов, средств и заголовочных файлов.

 • Базовые определения — Обоснование (Base Definitions — Rationale). Объяснения и обоснования выбора средств как включенных, так и невключенных в стандарт.

 • Системные интерфейсы (System Interfaces). Системные вызовы и библиотечные функции. POSIX называет обе разновидности просто «функции».

 • Оболочка и инструменты (Shell and Utilities). Язык оболочки и доступные для интерактивного использования и использования сценариями оболочки инструменты.

Хотя стандарты языков не являются захватывающим чтением, можно рассмотреть покупку экземпляра стандарта С, он дает окончательное определение языка. Книги можно приобрести в ANSI[2 - 


 — Примеч. автора.] и в ISO[3 - 


 — Примеч. автора.]. (PDF-версия стандарта С вполне доступна.)

Стандарт POSIX можно заказать в The Open Group[4 - 


 — Примеч. автора.]. Исследуя в каталоге их изданий элементы, перечисленные а «Спецификациях CAE» («CAE Specifications»), вы можете найти отдельные страницы для каждой части стандарта (озаглавленные с «C031» по «C034»). Каждая такая страница предоставляет свободный доступ к HTML версии определенного тома

Стандарт POSIX предназначен для реализации как Unix и Unix-подобных систем, так и не-Unix систем. Таким образом, базовые возможности, которые он предоставляет, составляют лишь часть возможностей, которые есть на системах Unix. Однако, стандарт POSIX определяет также расширения — дополнительные возможности, например, для многопоточности или поддержки реального времени. Для нас важнее всего расширение X/Open System Interface (XSI), описывающее возможности исторических систем Unix.

По всей книге мы помечаем каждый API в отношении его доступности: ISO С, POSIX, XSI, только GLIBC или как нестандартный, но широко доступный.


Возможности и мощь: программы GNU

Ограничив себя лишь оригинальным кодом Unix, можно было бы получить интересную историческую книгу, но она была бы не очень полезна в XXI веке. Современные программы не имеют тех же ограничений (памяти, мощности процессора, дискового пространства и скорости), которые были у ранних систем Unix. Более того, они должны работать в многоязычном мире — ASCII и американского английского недостаточно.

Что еще важнее, одной из главных свобод, выдвинутых явным образом Фондом бесплатных программ (Free Software Foundation) и проектом GNU[5 - 


 — Примеч. автора.], является «свобода обучения». Программы GNU предназначены для обеспечения большого собрания хорошо написанных программ, которые программисты среднего уровня могут использовать а качестве источника для своего обучения.

Используя программы GNU, мы преследуем две цели: показать вам хорошо написанный современный код, на котором вы будете учиться писать хорошие программы, а также использовать API.

Мы считаем, что программное обеспечение GNU лучше, поскольку оно свободно (в смысле «свободы», а не «бесплатного пива»)[6 - Игра слов: free — свободный, бесплатный — Примеч. перев.]. Но признается также, что программное обеспечение GNU часто также технически лучше соответствующих двойников в Unix, и мы уделили место в разделе 1.4 «Почему программы GNU лучше», чтобы это объяснить

Часть примеров кода GNU происходит из 


 (GNU 


). Главной причиной этого является то, что это программа, с которой мы очень знакомы, поэтому было просто отобрать оттуда примеры. У нас нет относительно нее других притязаний.


Обзор глав

Вождение автомобиля целостный процесс, включающий множество одновременных задач. Во многих отношениях программирование по Linux похоже на это, требуя понимания многих аспектов API, таких, как файловый ввод/вывод, метаданные файлов, каталоги, хранение сведений о времени и т.д.

В первой части книги рассматривается достаточное количество этих отдельных элементов, чтобы дать возможность изучить первую значительную программу, V7 ls. Затем мы завершим наше обсуждение файлов и пользователей, рассмотрев иерархии файлов и принципы работы файловых систем и их использование.

Глава 1, «Введение»,

описывает модели файлов и процессов Unix и Linux, рассматривает отличия оригинального С от стандартного С 1990 г., а также предоставляет обзор принципов, которые делают программы GNU в целом лучшими по сравнению со стандартными программами Unix.

Глава 2, «Аргументы, опции и переменные окружения»,

описывает, как С программа получает доступ к аргументам и опциям командной строки и обрабатывает их, а также объясняет, как работать с переменными окружения.

Глава 3, «Управление памятью на уровне пользователя»,

предоставляет обзор различных видов используемой памяти, доступной работающему процессу. Управление памятью на уровне пользователя является основным для каждого нетривиального приложения, поэтому важно понять это с самого начала.

Глава 4, «Файлы и файловый ввод/вывод»,

обсуждает базовый файловый ввод/вывод, показывая, как создавать и использовать файлы. Понимание этого важно для всего последующего материала.

Глава 5, «Каталоги и служебные данные файлов»,

описывает, как работают каталоги, прямые и символические ссылки. Затем описываются служебные данные файлов, такие, как владелец, права доступа и т.д., а также освещается работа с каталогами

Глава 6, «Общие библиотечные интерфейсы — часть 1»,

рассматривает первый набор интерфейсов общего программирования, которые будут нам нужны для эффективного использования служебных данных файлов.

Глава 7, «Соединяя все вместе:


»,

связывает воедино все рассмотренное до сих пор, рассматривая программу V7 


.

Глава 8, «Файловые системы и обходы каталогов»,

описывает, как монтируются и демонтируются файловые системы и как программа может получить сведения о том, что смонтировано в системе. В главе описывается также, как программа может легко «обойти» всю иерархию файлов, предпринимая а отношении каждого встреченного объекта необходимые действия.

Вторая часть книги имеет дело с созданием и управлением процессами, межпроцессным взаимодействием посредством каналов и сигнала, ID пользователей и групп и дополнительными интерфейсами общего программирования. Далее в книге сначала описываются интернационализация с использованием GNU 


, а затем несколько расширенных API.

Глава 9, «Управление процессами и каналы»,

рассматривает создание процесса, исполнение программы, межпроцессное взаимодействие (IPC) с использованием каналов и управление дескрипторами файлов, включая неблокирующий ввод/вывод.

Глава 10, «Сигналы»,

обсуждает сигналы, упрощенную форму межпроцессного взаимодействия. Сигналы играют также важную роль а управлении родительским процессом порожденных процессов.

Глава 11, «Права доступа и ID пользователей и групп»,

рассматривает, как идентифицируются процессы и файлы, как работает проверка прав доступа и как работают механизмы 


 и 


.

Глава 12, «Общие библиотечные интерфейсы — часть 2»,

рассматривает оставшуюся часть общих API; многие из них более специализированы, чем первый общий набор API.

Глава 13, «Интернационализация и локализация»,

объясняет, как почти без усилий обеспечить работу ваших программ на нескольких языках.

Глава 14, «Расширенные интерфейсы»,

описывает несколько расширенных версий интерфейсов, освещенных в предыдущих главах, а также более подробно освещает блокировку файлов.

Мы завершаем книгу главой об отладке, поскольку (почти) никто не может сделать все правильно с первого раза, и рекомендуем финальный проект для закрепления ваших знаний по рассмотренным в данной книге API.

Глава 15, «Отладка»,

описывает основы отладчика GDB, передает как можно больше нашего опыта в этой области и рассматривает несколько полезных инструментов для осуществления различных видов отладки.

Глава 16, «Проект, связывающий все воедино»,

представляет значительный проект по программированию, который использует почти все, рассмотренное в книге.

Несколько приложений освещают представляющие интерес темы, включая лицензии для использованного в данной книге исходного коде.

Приложение А, «Научитесь программированию за десять лет»,

ссылается на знаменитое высказывание: «Москва не сразу строилась»[7 - В оригинале: «Rome wasn't built in a day» — Примеч. перев.]. Также и квалификация в Linux/Unix и понимание этих систем приходит лишь со временем и практикой. С этой целью мы включили это эссе Петера Норвига, которое мы горячо рекомендуем.

Приложение В, «Лицензия Caldera для старой Unix»,

охватывает исходный код Unix, использованный в данной книге.

Приложение С, «Общедоступная лицензия GNU»,

охватывает исходный код GNU, использованный в данной книге.


Соглашения об обозначениях

Как и в любой книге на компьютерную тему, для передачи информации мы используем определенные соглашения об обозначениях. Определения или первое использование термина выделяется курсивом, как слово «Определения» в начале этого предложения. Курсив используется также для выделения, для цитирования других работ и комментариев в примерах. Переменные элементы, такие, как аргументы или имена файлов, выглядят таким образом. Иногда мы используем жирный шрифт, когда нужно усилить мысль.

Вещи, находящиеся на компьютере, обозначаются моноширинными шрифтом, как в случае имен файлов (


) и названий команд (


, 


). Короткие фрагменты, которые вы вводите, дополнительно заключаются в одинарные кавычки: '


'




 и 


 являются первичным и вторичным приглашениями оболочки Борна и используются при отображении интерактивных примеров. Ввод пользователя выделяется другим шрифтом от обычного вывода компьютера в примерах. Примеры выглядят следующим образом:





















Мы предпочитаем оболочку Борна и ее варианты (ksh93, Bash) по сравнению с оболочкой С; соответственно на всех наших примерах показана лишь оболочка Борна. Знайте, что правила применения кавычек и переноса на следующую строку в оболочке С другие; если вы используете ее, то на свой страх и риск![8 - См. справочные страницы csh(1) и tcsh(1) и книгу Using csh & tcsh, by Paul DuBois, O'Reilly & Associates. Sebastopol, CA. USA, 1995. ISBN 1-56592-132-1 — Примеч. автора.]

При ссылках на функции в программах мы добавляем к имени функции пустую пару скобок: 


, 


. При ссылке на справочную страницу (доступную по команде man), мы следуем стандартному соглашению Unix по написанию имени команды или функции курсивом, а раздела — в скобках после имени обычным шрифтом: awk(1), printf(3)[9 - Соответствующие справочные страницы можно посмотреть с помощью man 1 awk и man 3 printf — Примеч. науч. ред.].


Где получить исходные коды Unix и GNU

Вы можете захотеть получить копни программ, которые мы использовали в данной книге, для своих собственных экспериментов и просмотра. Весь исходный код доступен через Интернет, а ваш дистрибутив GNU/Linux содержит исходный код для инструментов GNU.


Код Unix

Архивы различных «древних» версий Unix поддерживаются Обществом наследства UNIX (The UNIX Heritage Society — TUHS), 


.

Наибольший интерес представляет возможность просматривать архив старых исходных кодов Unix через веб. Начните с 


. Все примеры кода в данной книге из седьмого издания исследовательской системы UNIX, известной также как «V7».

Сайт TUHS физически расположен в Австралии, хотя имеются зеркала архива по всему миру — см. 


. Эта страница также указывает, что архив доступен для зеркала через 


. (Если у вас нет 


, см. 


: это стандартная утилита на системах GNU/Linux.)

Чтобы скопировать весь архив, потребуется примерно 2-3 гигабайта дискового пространства. Для копирования архива создайте пустой каталог, а в нем выполните следующие команды:









































Вы можете пропустить копирование каталога 


, который содержит извлечения из нескольких версий Unix и занимает на диске около 700 мегабайт.

В рассылке TUHS можно также поинтересоваться, нет ли поблизости от вас кого-нибудь, кто мог бы предоставить вам архив на CD-ROM, чтобы избежать пересылки по Интернету такого большого количества данных.

Группа в Southern Storm Software, Pty. Ltd. в Австралии «модернизировала» часть кода уровня пользователя V7, так что его можно откомпилировать и запустить на современных системах, особенно на GNU/Linux. Этот код можно загрузить с их веб-сайта[10 - 


 — Примеч. автора.].

Интересно отметить, что код V7 не содержит в себе каких-либо уведомлений об авторских правах или разрешениях. Авторы писали код главным образом для себя и своего исследования, оставив проблемы разрешений отделу корпоративного лицензирования AT&T.


Код GNU

Если вы используете GNU/Linux, ваш дистрибутив поступит с исходным кодом, предположительно в формате, используемом для упаковки (файлы RPM Red Hat, файлы DEB Debian, файлы 


 Slackware и т.д.) Многие примеры в книге взяты из GNU Coreutils, версия 5.0. Найдите соответствующий CD-ROM для своего дистрибутива GNU/Linux и используйте для извлечения кода соответствующий инструмент. Или следуйте для получения кода инструкциям в следующих нескольких абзацах.

Если вы предпочитаете самостоятельно получать файлы из ftp-сайта GNU, вы найдете его по адресу: 


.

Для получения файла можно использовать утилиту 


:
















В качестве альтернативы можно использовать для получения файла старый добрый 


:























































































































































Получив файл, извлеките его следующим образом:











Системы, использующие GNU tar, могут использовать следующее заклинание:











В соответствии с общедоступной лицензией GNU, вот сведения об авторских правах для всех GNU программ, процитированных в данной книге. Все программы являются «свободным программным обеспечением; вы можете распространять их и/или модифицировать на условиях общедоступной лицензии GNU в изданном Фондом бесплатных программ виде; либо версии 2 лицензии, либо (по вашему выбору) любой последующей версии». Текст общедоступной лицензии GNU см. в приложении С «Общедоступная лицензия GNU».





Где получить примеры программ, использованные в данной книге

Примеры программ, использованные в данной книге, можно найти по адресу: 


.


Об обложке



«Это оружие Джедая …, элегантное оружие для более цивилизованной эпохи. На протяжении тысяч поколений Рыцари Джедай были защитниками мира и справедливости в Старой Республике. От мрачных времен, до Империи».

    - Оби-Ван Кеноби -

Возможно, вы удивляетесь, почему мы поместили на обложке легкую саблю и использовали ее во внутреннем оформлении книги. Что она представляет и какое она имеет отношение к программированию под Linux?

В руках Рыцаря Джедай легкая сабля является и мощным оружием, и предметом красоты. Ее использование демонстрирует мощь, знание, контроль над Силой и напряженное обучение для владеющего им Джедая.

Элегантность легкой сабли отражает элегантность оригинального дизайна Unix API. Там также обдуманное, точное использование API и программных инструментов и принципов проектирования GNU привело к сегодняшним мощным, гибким, развитым системам GNU/Linux. Эта система демонстрирует знание и понимание программистов, создавших все их компоненты.

И конечно, легкие сабли — это просто круто!


Благодарности

Написание книги требует большого количества работы, а чтобы сделать это хорошо, нужна помощь от многих людей. Д-р Brian W. Kernighan, д-р Doug McIlroy, Peter Memishian и Peter van der Linden сделали рецензию первоначального предложения. David J. Agans, Fred Fish, Don Marti, Jim Meyering, Peter Norvig и Julian Seward достали разрешения на воспроизведение различных элементов, процитированных по всей книге. Спасибо Geoff Collyer, Ulrich Drepper, Yosef Gold, д-ру C.A.R. (Tony) Hoare, д-ру Manny Lehman, Jim Meyering, д-ру Dennis M. Ritchie, Julian Seward, Henry Spencer и д-ру Wladyslaw M. Turski за предоставление множества полезной общей информации. Спасибо также другим членам группы GNITS. Karl Berry, Akim DeMaille, Ulrich Drepper, Greg McGary, Jim Meyering, Francois Pinard и Tom Tromey, которые предоставили полезную обратную связь относительно хорошей практики программирования. Karl Berry, Alper Ersoy и д-р Nelson H.F. Beebe предоставили ценную техническую помощь по Texinfo и DocBook/XML.

Хорошие технические обзоры не только гарантируют, что автор использует правильные факты, они также гарантируют, что он тщательно обдумывает свое представление. Д-р Nelson H.F. Beebe, Geoff Collyer, Russ Cox, Ulrich Drepper, Randy Lechlitner, д-р Brian W. Kernighan, Peter Memishian, Jim Meyering, Chet Ramey и Louis Taber работали в качестве технических рецензентов для всей книги. Д-р Michael Brennan предоставил полезные комментарии для главы 15. Их рецензии принесли пользу как содержанию, так и многим примерам программ. Настоящим я благодарю их всех. Как обычно говорят в таких случаях большинство авторов, «все оставшиеся ошибки мои».

Я особенно хотел бы поблагодарить Mark Taub из Pearson Education за инициирование этого проекта, за его энтузиазм для этой серии и за его помощь и советы по мере прохождения книги через различные ее стадии. Anthony Gemmellaro сделал феноменальную работу по реализации моей идеи для обложки, а внутренний дизайн Gail Cocker великолепен. Faye Gemmellaro сделал процесс производства вместо рутины приятным. Dmitry Kirsanov и Alina Kirsanova сделали рисунки, макеты страниц и предметный указатель; работать с ними было одно удовольствие.

Наконец, моя глубочайшая благодарность жене Мириам за ее поддержку и ободрение во время написания книги.



    Арнольд Роббинс
    Nof Ayalon
    ИЗРАИЛЬ




Часть 1

Файлы и пользователи





Глава 1

Введение



Если есть одна фраза, резюмирующая важнейшие понятия GNU/Linux (а следовательно, и Unix), это «файлы и процессы». В данной главе мы рассмотрим модели файлов и процессов в Linux. Их важно понять, потому что почти все системные вызовы имеют отношение к изменению какого-либо атрибута или части состояния файла или процесса.

Далее, поскольку мы будем изучать код в обеих стилях, мы кратко рассмотрим главные различия между стандартным С 1990 г. и первоначальным С. Наконец, мы довольно подробно обсудим то, что делает GNU-программы «лучше» — принципы программирования, использование которых в коде мы увидим.

В данной главе содержится ряд умышленных упрощений. Детали в подробностях будут освещены по мере продвижения по книге. Если вы уже являетесь специалистом в Linux, пожалуйста, простите нас




1.1. Модель файловой системы Linux/Unix



Одной из движущих целей первоначального проекта Unix была простота. Простые понятия легко изучать и использовать. Когда понятия переведены в простые API, легко проектировать, писать и отлаживать простые программы. Вдобавок, простой код часто занимает меньше места и он более эффективен, чем более усложненные проекты.

Поиск простоты направлялся двумя факторами. С технической точки зрения, первоначальные мини-компьютеры PDP-11, на которых разрабатывалась Unix, имели маленькое адресное пространство: 64 килобайта на меньших системах, 64 Кб кода и 64 Кб данных на больших. Эти ограничения относились не только к обычным программам (так называемому коду уровня пользователя), но и к самой операционной системе (коду уровня ядра). Поэтому не только «Маленький — значит красивый» в эстетическом смысле, но «Маленький — значит красивый», потому что не было другого выбора!

Вторым фактором была отрицательная реакция на современные коммерческие операционные системы, которые были без надобности усложнены, со сложными командными языками, множеством разновидностей файлового ввода-вывода и слабой общностью или гармонией. (Стив Джонсон однажды заметил: «Использование TSO подобно пинанию мертвого кита на побережье». TSO — это как раз одна из только что описанных бестолковых систем с разделением времени «для мэйнфреймов.)




1.1.1. Файлы и права доступа


Файловая модель Unix проста, как фраза: файл — это линейный поток байтов. Точка. Операционная система не накладывает на файлы никаких предопределенных структур, ни фиксированных или переменных размеров записей, ни индексированных файлов, ничего. Интерпретация содержимого файла целиком оставлена приложению. (Это не совсем верно, как мы вскоре увидим, но для начала достаточно близко к истине.)

Если у вас есть файл, вы можете сделать с данными в файле три вещи: прочитать, записать или исполнить их.

Unix разрабатывался для мини-компьютеров с разделением времени; это предполагает наличие с самого начала многопользовательского окружения. Раз есть множество пользователей, должно быть возможным указание прав доступа к файлам: возможно, пользователь 


 является начальником пользователя 


, и 


 не хочет, чтобы 


 прочел последние результаты аттестации.

В целях создания прав доступа пользователи подразделяются на три различные категории: владелец файла; группа пользователей, связанная с данным файлом (вскоре будет пояснено); и остальные пользователи. Для каждой из этих категорий каждый файл имеет отдельные, связанные с этим файлом, биты прав доступа, разрешающие чтение, запись и исполнение. Эти разрешения отображаются в первом поле вывода команды '


':











Здесь arnold и devel являются соответственно владельцем и группой файла 


, a 


 является строкой типа файла и прав доступа. Для обычного файла первым символом будет дефис, для каталогов - 


, а для других видов файлов - небольшой набор других символов, которые пока не имеют значения. Каждая последующая тройка символов представляют права на чтение, запись и исполнение для владельца, группы и «остальных» соответственно.

В данном примере файл 


 может читать и записывать владелец файла, а группа и остальные пользователи могут только читать. Дефисы означают отсутствие разрешений, поэтому этот файл никто не может исполнить, а группа и остальные пользователи не могут в него записывать.

Владелец и группа файла хранятся в виде числовых значений, известных как идентификатор пользователя (user ID — UID) и идентификатор группы (group ID — GID); стандартные библиотечные функции, которые мы рассмотрим далее в книге, позволяют напечатать эти значения в виде читаемых имен.

Владелец файла может изменить разрешения, используя команду 


 (change mode — изменить режим). (Права доступа к файлу, по существу, иногда называют «режимом файла».) Группу файла можно изменить с помощью команд 


 (change group — изменить группу) и 


 (change owner — сменить владельца)[11 - Некоторые системы позволяют рядовым пользователям назначать владельцем их файла кого-нибудь еще, таким образом «отдавая его». Детали определяются стандартом POSIX, но они несколько запутаны. Обычная конфигурация GNU/Linux не допускает этого — Примеч. автора.].

Групповые права доступа были нацелены на поддержку совместной работы: хотя определенным файлом может владеть один член группы или подразделения, возможно, каждый член группы должен иметь возможность изменять его. (Рассмотрите совместный маркетинговый доклад или данные исследования.)

Когда система проверяет доступ к файлу (обычно при открытии файла), если UID процесса совпадает с UID файла, используются права доступа владельца файла. Если эти права доступа запрещают операцию (скажем, попытка записи в файл с доступом 


), операция завершается неудачей; Unix и Linux не продолжают проверку прав доступа для группы и других пользователей[12 - Конечно, владелец всегда может изменить права доступа. Большинство пользователей не отменяют для себя нрава на запись — Примеч. автора.]. Это верно также, если UID различаются, но совпадают GID; если права доступа группы запрещают операцию, она завершается неудачей.

Unix и Linux поддерживают понятие суперпользователя (superuser): это пользователь с особыми привилегиями. Этот пользователь известен как root и имеет UID, равный 0. root позволено делать все; никаких проверок, все двери открыты, все ящики отперты.[13 - Для этого правила есть несколько редких исключений, но все они выходят за рамки данной книги — Примеч. автора.] (Это может иметь важные последствия для безопасности, которых мы будем касаться по всей книге, но не будем освещать исчерпывающе.) Поэтому, даже если файл имеет режим 


, 


 все равно может читать файл и записывать в него. (Исключением является то, что файл нельзя исполнить. Но поскольку 


 может добавить право на исполнение, это ограничение ничего не предотвращает.)

Модель прав доступа владелец/группа/другие, чтение/запись/исполнение проста, тем не менее достаточно гибка, чтобы охватывать большинство ситуаций. Существуют другие, более мощные, но и более сложные модели, реализованные на других системах, но ни одна из них не стандартизирована достаточно хорошо и не реализована достаточно широко, чтобы заслуживать обсуждения в общем руководстве, подобном этому.




1.1.2. Каталоги и имена файлов


Раз у вас есть файл, нужно где-то его хранить. В этом назначение каталога (известного в системах Windows или Apple Macintosh под названием «папка»). Каталог является особой разновидностью файла, связывающего имена файлов с метаданными, известными как узлы (inodes). Каталоги являются особыми, поскольку их может обновлять лишь операционная система путем описанных в главе 4, «Файлы и файловый ввод-вывод», системных вызовов. Они особые также потому, что операционная система предписывает формат элементов каталога.

Имена файлов могут содержать любой 8-битный байт, за исключением символа '


' (прямой косой черты) и ASCII символа NUL, все биты которого содержат 0. Ранние Unix- системы ограничивали имена 14 байтами; современные системы допускают отдельные имена файлов вплоть до 255 байтов.

Узел содержит всю информацию о файле, за исключением его имени: тип, владелец, группа, права допуска, размер, времена изменения и доступа. Он хранит также размещение на диске блоков, содержащих данные файла. Все это данные о файле, а не данные самого файла, отсюда термин метаданные.

Права доступа к каталогам по сравнению с правами доступа к файлам имеют несколько другой смысл. Разрешение на чтение означает возможность поиска в каталоге, т.е. его просмотр с целью определить, какие файлы в нем содержатся. Разрешение на запись дает возможность создавать и удалять файлы в каталоге. Разрешение на исполнение означает возможность прохода через каталог при открытии или ином доступе к содержащемуся файлу или подкаталогу.



ЗАМЕЧАНИЕ. Если у вас есть разрешение на запись в каталог, вы можете удалять файлы из этого каталога, даже если они не принадлежат вам! При интерактивной работе команда rm отмечает это, запрашивая в таком случае подтверждение

Каталог 


 имеет разрешение на запись для каждого, но ваши файлы в 


 находятся вполне в безопасности, поскольку 


 обычно имеет установленный так называемый «липкий» (sticky) бит:











Обратите внимание, что t находится в последней позиции первого поля. В большинстве каталогов в этом месте стоит x. При установленном «липком» бите ваши файлы можете удалять лишь вы, как владелец файла, или 


. (Более детально это обсуждается в разделе 11.2 5, «Каталоги и липкий бит».)





1.1.3. Исполняемые файлы


Помните, мы говорили, что операционная система на накладывает структуру на файлы? Мы уже видели, что это было невинной ложью относительно каталогов. Это же относится к двоичным исполняемым файлам. Чтобы запустить программу, ядро должно знать, какая часть файла представляет инструкции (код), а какая — данные. Это ведет к понятию формата объектного файла, которое определяет, как эти данные располагаются внутри файла на диске.

Хотя ядро запустит лишь файлы, имеющие соответствующий формат, создание таких файлов задача утилит режима пользователя. Компилятор с языка программирования (такого как Ada, Fortran, С или С++) создает объектные файлы, а затем компоновщик или загрузчик (обычно с именем 


) связывает объектные файлы с библиотечными функциями для окончательного создания исполняемого файла. Обратите внимание, что даже если все нужные биты в файле размешены в нужных местах, ядро не запустит его, если не установлен соответствующий бит, разрешающий исполнение (или хотя бы один исполняющий бит для 


).

Поскольку компилятор, ассемблер и загрузчик являются инструментами режима пользователя, изменить со временем по мере необходимости форматы объектных файлов (сравнительно) просто; надо только «научить» ядро новому формату, и он может быть использован. Часть ядра, загружающая исполняемые файлы, относительно невелика, и это не является невозможной задачей. Поэтому форматы файлов Unix развиваются с течением времени. Первоначальный формат был известен как a.out (Assembler OUTput — вывод сборщика). Следующий формат, до сих пор использующийся в некоторых коммерческих системах, известен как COFF (Common Object File Format — общий формат объектных файлов), а современный, наиболее широко использующийся формат — ELF (Extensible Linking Format — открытый формат компоновки). Современные системы GNU/Linux используют ELF.

Ядро распознает, что исполняемый файл содержит двоичный объектный код, проверяя первые несколько байтов файла на предмет совпадения со специальными магическими числами. Это последовательности двух или четырех байтов, которые ядро распознает в качестве специальных. Для обратной совместимости современные Unix-системы распознают несколько форматов. Файлы ELF начинаются с четырех символов «


».

Помимо двоичных исполняемых файлов, ядро поддерживает также исполняемые сценарии (скрипты). Такой файл также начинается с магического числа: в этом случае, это два обычных символа 


 . Сценарий является программой, исполняемой интерпретатором, таким, как командный процессор, awk, Perl, Python или Tcl. Строка, начинающаяся с 


, предоставляет полный путь к интерпретатору и один необязательный аргумент:











Предположим, указанное содержимое располагается в файле 


 и этот файл исполняемый. Когда вы набираете '


', ядро запускает программу, как если бы вы напечатали '


'. Любые дополнительные аргументы командной строки также передаются программе. В этом случае, 


 запускает программу и отображает общеизвестное сообщение 


.

Механизм с использованием 


 является элегантным способом скрыть различие между двоичными исполняемыми файлами и сценариями. Если 


 переименовать просто в 


, пользователь, набирающий '


', не сможет сказать (и, конечно, не должен знать), что 


 не является двоичной исполняемой программой.




1.1.4. Устройства


Одним из самых замечательных новшеств Unix было объединение файлового ввода- вывода и ввода-вывода от устройств.[14 - Эта особенность впервые появилась в Multics, но Multics никогда широко не использовался — Примеч. автора.] Устройства выглядят в файловой системе как файлы, для доступа к ним используются обычные права доступа, а для их открытия, чтения, записи и закрытия используются те же самые системные вызовы ввода-вывода. Вся «магия», заставляющая устройства выглядеть подобно файлам, скрыта в ядре. Это просто другой аспект движущего принципа простоты в действии, мы можем выразить это как никаких частных случаев для кода пользователя.

В повседневной практике, в частности, на уровне оболочки, часто появляются два устройства: 


 и 


.




 является «битоприемником». Все данные, посылаемые 


, уничтожаются операционной системой, а все попытки прочесть отсюда немедленно возвращают конец файла (EOF).




 является текущим управляющим терминалом процесса — тем, который он слушает, когда пользователь набирает символ прерывания (обычно CTRL-C) или выполняет управление заданием (CTRL-Z).

Системы GNU/Linux и многие современные системы Unix предоставляют устройства 


, 


 и 


, которые дают возможность указать открытые файлы, которые каждый процесс наследует при своем запуске.

Другие устройства представляют реальное оборудование, такое, как ленточные и дисковые приводы, приводы CD-ROM и последовательные порты. Имеются также программные устройства, такие, как псевдотерминалы, которые используются для сетевых входов в систему и систем управления окнами, 


 представляет системную консоль, особое аппаратное устройство мини-компьютеров. В современных компьютерах 


 представлен экраном и клавиатурой, но это может быть также и последовательный порт

К сожалению, соглашения по именованию устройств не стандартизированы, и каждая операционная система использует для лент, дисков и т.п. собственные имена. (К счастью, это не представляет проблемы для того, что мы рассматриваем в данной книге.) Устройства имеют в выводе '


' в качестве первого символа 


 или 


.
















Начальная '


' представляет блочные устройства, а '


' представляет символьные устройства. Файлы устройств обсуждаются далее в разделе 5.4, «Получение информации о файлах».




1.2. Модель процессов Linux/Unix



Процесс является работающей программой.[15 - Процесс может быть приостановлен, в этом случае он не «работающий»; но он и не завершён. В любом случае, на ранних этапах восхождения по кривой обучения не стоит быть слишком педантичным — Примеч. автора.] Процесс имеет следующие атрибуты:

уникальный идентификатор процесса (PID);

• родительский процесс (с соответствующим идентификатором, PPID);

• идентификаторы прав доступа (UID, GID, набор групп и т.д.);

• отдельное от всех других процессов адресное пространство;

• программа, работающая в этом адресном пространстве;

• текущий рабочий каталог ('


');

• текущий корневой каталог (


; его изменение является продвинутой темой);

• набор открытых файлов, каталогов, или и того, и другого;

• маска запретов доступа, использующаяся при создании новых файлов;

• набор строк, представляющих окружение[16 - Так называемые переменные окружения — Примеч. науч. ред.];

• приоритеты распределения времени процессора (продвинутая тема);

• установки для размещения сигналов (signal disposition) (продвинутая тема); управляющий терминал (тоже продвинутая тема).

Когда функция 


 начинает исполнение, все эти вещи уже помещены в работающей программе на свои места. Для запроса и изменения каждого из этих вышеназванных элементов доступны системные вызовы; их освещение является целью данной книги.

Новые процессы всегда создаются существующими процессами. Существующий процесс называется родительским, а новый процесс — порожденным. При загрузке ядро вручную создает первый, изначальный процесс, который запускает программу 


; идентификатор этого процесса равен 1, он осуществляет несколько административных функций. Все остальные процессы являются потомками 


. (Родительским процессом 


 является ядро, часто обозначаемое в списках как процесс с ID 0.)

Отношение порожденный-родительский является отношением один к одному; у каждого процесса есть только один родитель, поэтому легко выяснить PID родителя. Отношение родительский-порожденный является отношением один ко многим; каждый данный процесс может создать потенциально неограниченное число порожденных. Поэтому для процесса нет простого способа выяснить все PID своих потомков. (Во всяком случае, на практике это не требуется.) Родительский процесс можно настроить так, чтобы он получал уведомление при завершении порожденного процесса, он может также явным образом ожидать наступления такого события.

Адресное пространство (память) каждого процесса отделена от адресного пространства всех остальных процессов. Если два процесса не договорились явным образом разделять память, один процесс не может повлиять на адресное пространство другого. Это важно; это обеспечивает базовый уровень безопасности и надежности системы. (В целях эффективности, система разделяет исполняемый код одной программы с правом доступа только для чтения между всеми процессами, запустившими эту программу. Это прозрачно для пользователя и запущенной программы.)

Текущий рабочий каталог — это каталог, относительно которого отсчитываются относительные пути файлов (те, которые не начинаются с '


'). Это каталог, в котором вы находитесь, когда набираете команду оболочки '


'.

По соглашению, все программы запускаются с тремя уже открытыми файлами: стандартным вводом, стандартным выводом и стандартной ошибкой. Это места, откуда принимается ввод, куда направляется вывод и куда направляются сообщения об ошибках соответственно. На протяжении этой книги мы увидим, как они назначаются. Родительский процесс может открыть дополнительные файлы и сделать их доступными для порожденных процессов; порожденный процесс должен каким-то образом узнать, что они есть, либо посредством какого-либо соглашения, либо через аргументы командной строки или переменную окружения.

Окружение представляет собой набор строк, каждая в виде '


'. Для запроса и установки значений переменных окружения имеются специальные функции, а порожденные процессы наследуют окружение своих родителей. Типичными переменными окружения оболочки являются PATH и НОМЕ. Многие программы для управления своим поведением полагаются на наличие и значения определенных переменных окружения.

Важно понять, что один процесс в течение своего существования может исполнить множество программ. Все устанавливаемые системой атрибуты (текущий каталог, открытые файлы, PID и т.д.) остаются теми же самыми, если только они не изменены явным образом. Отделение «запуска нового процесса» от «выбора программы для запуска» является ключевым нововведением Unix. Это упрощает многие операции. Другие операционные системы, которые объединяют эти две операции, являются менее общими и их сложнее использовать.




1.2.1. Каналы: сцепление процессов


Без сомнения, вам приходилось использовать конструкцию ('


') оболочки для соединения двух или более запущенных программ. Канал действует подобно файлу: один процесс записывает в него, используя обычную операцию записи, а другой процесс считывает из него с помощью операции чтения. Процессы (обычно) не знают, что их ввод/вывод является каналом, а не обычным файлом.

Как ядро скрывает «магию» для устройств, заставляя их действовать подобно файлам, точно так же оно проделывает эту работу для каналов, принимая меры по задержке записи в канал при его наполнении и задержке чтения, когда нет ожидающих чтения данных.

Таким образом, принцип файлового ввода/вывода применительно к каналам служит ключевым механизмом для связывания запушенных программ; не требуется никаких временных файлов. Опять-таки общность и простота работы: никаких особых случаев для кода пользователя.




1.3. Стандартный С против оригинального С


В течение многих лет определение С де-факто можно было найти в первом издании книги Брайана Кернигана и Денниса Ричи «Язык программирования С» (Brian Kernighan & Dennis Ritchie, The С Programming Language). Эта книга описала С, как он существовал для Unix и на системах, на которые его перенесли разработчики лаборатории Bell Labs. На протяжении данной книги мы называем его как «оригинальный С», хотя обычным является также название «С Кернигана и Ричи» («K&R С»), по именам двух авторов книги. (Деннис Ричи разработал и реализовал С.)

Стандарт ISO С 1990 г.[17 - Между народный стандарт ISO/IEC 9899-1990 описывает разновидность языка С известную также как C89 или C90 — Примеч. науч. ред.] формализовал определения языка, включая функции библиотеки С (такие, как 


 и 


). Комитет по стандартам С проделал замечательную работу по стандартизации существующей практики и избежал введения новых возможностей, с одним значительным исключением (и несколькими незначительными). Наиболее заметным изменением языка было использование прототипов функций, заимствованных от С++.

Стандартные языки программирования С, C++ и Java используют прототипы функций для объявлений и определений функций. Прототип описывает не только возвращаемое значение функции, но также и число и тип ее аргументов. С прототипами компилятор может выполнить проверку типов в точке вызова функции:

Объявление











Определение



















































Это правильный вызов функции. Но рассмотрите ошибочный вызов:











Компилятор может сразу же определить этот вызов как неверный. Однако, в оригинальном С функции объявляются без указания списка аргументов:











Более того, определения функций перечисляют имена параметров в заголовке функции, затем объявляют параметры перед телом функции. Параметры типа int объявлять не нужно, и если функция возвращает int, его тоже не нужно объявлять:




































Рассмотрите снова тот же ошибочный вызов функции: '


'. В оригинальном С у компилятора нет возможности узнать, что вы (ошибочно, полагаем) передали 


 ошибочные аргументы. Подобные ошибочные вызовы обычно приводят к трудно устранимым проблемам времени исполнения (таким, как ошибки сегментации, из-за чего программа завершается), и для работы с такими вещами была создана программа Unix 


.

Поэтому, хотя прототипы функции и были радикальным отходом от существующей практики, дополнительную проверку типов посчитали слишком важной, чтобы обходиться без нее, и после небольшого сопротивления она была добавлена в язык.

Для С стандарта 1990 г. код, написанный в оригинальном стиле, является действительным как для объявлений, так и для определений. Это дает возможность продолжать компилировать миллионы строк существующего кода с помощью компилятора, удовлетворяющего стандарту. Новый код, очевидно, должен быть написан с прототипами из-за улучшенных возможностей проверки ошибок времени компилирования.

Стандарт С 1999 г.[18 - Стандарт C99 (ISO/IЕС 9899-1999) — Примеч. науч. ред.] продолжает допускать объявления и определения в оригинальном стиле. Однако, правило «неявного 


» было убрано; функции должны иметь возвращаемый тип, а все параметры должны быть объявлены.

Более того, когда программа вызывала функцию, которая не была формально объявлена, оригинальный С создал бы для функции неявное объявление с возвращаемым типом 


. С стандарта 1999 г. делал то же самое, дополнительно отметив, что у него не было информации о параметрах. С стандарта 1999 г. не предоставляет больше возможности «автоматического объявления».

Другими заметными дополнениями в стандарте С являются ключевое слово 


, также из С++, и ключевое слово 


, которое придумал комитет. Для кода, который вы увидите в этой книге, наиболее важной вещью является понимание различных синтаксисов объявлений и определений функций.

Для кода V7, использующего определения в оригинальном стиле, мы добавили комментарии, показывающие эквивалентный прототип. В остальных случаях мы оставили код как есть, предпочитая показать его точно таким, каким он был первоначально написан, и как бы вы его увидели, если бы сами загрузили код.

Хотя стандарт С 1999 г. добавляет некоторые дополнительные ключевые слова и возможности, отсутствующие в версии 1990 г., мы решили придерживаться диалекта 1990 г, поскольку компиляторы C99 не являются пока типичными. Практически, это не имеет значения: код C89 должен компилироваться и запускаться без изменений при использовании компилятора C99, а новые возможности C99 не затрагивают наше обсуждение или использование фундаментальных API Linux/Unix.




1.4. Почему программы GNU лучше



Что делает программу GNU программой GNU?[19 - Этот раздел адаптирован из статьи автора, который издавался в выпуске 16 Linux Journal (См. 


) Перепечатано и адаптировано по разрешению — Примеч. автора.] Что делает программное обеспечение GNU «лучше» по сравнению с другим (платным или бесплатным) программным обеспечением? Наиболее очевидной разницей является общедоступная лицензия (General Public License — GPL), которая описывает условия распространения для программного обеспечения GNU. Но это обычно не причина, чтобы вы могли услышать, как люди говорят: «Дайте GNU-версию 


, она намного лучше». Программное обеспечение GNU в общем более устойчиво, имеет лучшую производительность, чем в стандартных версиях Unix. В данном разделе мы рассмотрим некоторые причины этого явления, а также рассмотрим документ, описывающий принципы проектирования программного обеспечения GNU.

«Стандарты кодирования GNU» (GNU Coding Standards) описывают создание программного обеспечения для проекта GNU. Они охватывает ряд тем. Вы можете найти GNU Coding Standards по адресу 


. Смотрите в онлайн-версии ссылки на исходные файлы в других форматах.

В данном разделе мы описываем лишь те части GNU Coding Standards, которые относятся к проектированию и реализации программ.




1.4.1. Проектирование программ


Глава 3 GNU Coding Standards содержит общие советы относительно проектирования программ. Четырьмя главными проблемами являются совместимость (со стандартами и с Unix), язык, использование нестандартных возможностей других программ (одним словом, «ничего»), и смысл «переносимости».

Важной целью является совместимость со стандартом С и POSIX, а также, в меньшей степени, с Berkley Unix. Но она не преобладает. Общей идеей является предоставление всех необходимых возможностей через аргументы командной строки для предоставления точного режима ISO или POSIX.

Предпочтительным языком для написания программного обеспечения GNU является С, поскольку это наиболее доступный язык. В мире Unix стандарт С теперь обычен, но если для вас не представляет труда поддержка оригинального С, вы должны сделать это. Хотя стандарты кодирования отдают предпочтение С перед С++, C++ теперь тоже вполне обычен. Примером широко используемого пакета GNU, написанного на С++, является 


 (GNU 


). Наш опыт говорит, что с GCC, поддерживающим С++, установка 


 не представляет сложности.

Стандарты утверждают, что переносимость является чем-то вроде отвлекающего маневра. Утилиты GNU ясно нацелены на работу с ядром GNU и с библиотекой GNU С[20 - Это утверждение относится к ядру HURD, которое все еще находится в стадии разработки (в начале 2004 г.) Разработка на основе GCC и библиотеки GNU С (GLIBC) сегодня имеет место большей частью на Linux-системах — Примеч. автора.]. Но поскольку ядро еще не завершено, и пользователи используют инструменты GNU на не-GNU системах, переносимость желательна, но не является первостепенной задачей. Стандарт рекомендует для достижения переносимости между различными системами Unix использовать Autoconf.




1.4.2. Поведение программы


Глава 4 GNU Coding Standards предоставляет общие советы относительно поведения программы. Ниже мы вернемся к одному из ее разделов для более подробного рассмотрения. Глава фокусируется на строении программы, форматировании сообщений об ошибках, написании библиотек (делая их рентабельными) и стандартах для интерфейса командной строки.

Форматирование сообщений об ошибках важно, поскольку несколько инструментов, особенно Emacs, используют сообщения об ошибках, чтобы помочь вам попасть в то место в исходном файле или файле данных, где произошла ошибка.

Утилиты GNU должны использовать для обработки командной строки функцию 


. Эта функция предусматривает разбор аргументов командной строки как для опций в стиле традиционного Unix ('


'), так и для длинных опций в стиле GNU ('


'). Все программы должны предусматривать опции 


 и 


, а когда в одной программе используется длинное имя, оно таким же образом должно использоваться и в другой программе GNU. Для этой цели есть довольно полный список длинных опций, используемых современными GNU-программами.

В качестве простого, но очевидного примера, 


 пишется точно таким же способом во всех GNU-программах. Сравните это с 


, 


, 


 и т.д. во многих других программах Unix. Большая часть главы 2, «Аргументы, опции и окружение», с. 23, посвящена механике разбора аргументов и опций.




1.4.3. Программирование на С


Наиболее привлекательной частью GNU Coding Standards является глава 5, которая описывает написание кода на С, освещая такие темы, как форматирование кода, правильное использование комментариев, чистое использование С, именование ваших функций и переменных, а также объявление или не объявление стандартных системных функций, которые вы хотите использовать.

Форматирование кода является религиозной проблемой; у многих людей разные стили, которые они предпочитают. Лично нам не нравится стиль FSF, и если вы взглянете на 


, который мы поддерживаем, вы увидите, что он форматирован в стандартном стиле K&R (стиль расположения кода, использованный в обоих изданиях книги Кернигана и Ричи). Но это единственное отклонение в 


 от этой части стандартов кодирования.

Тем не менее, хотя нам и не нравится стиль FSF[21 - Стиль расположения кода, рекомендуемый фондом свободного программного обеспечения (Free Software Foundation) — Примеч. науч. ред.], мы чувствуем, что при модификации некоторых других программ, придерживание уже использованного стиля кода является исключительно важным. Последовательность в стиле кода более важна, чем сам стиль, который вы выбираете. GNU Coding Standards дает такой же совет. (Иногда невозможно обнаружить последовательный стиль кода, в этом случае программа, возможно, испорчена использованием 


 от GNU или 


 от Unix.)

Что мы сочли важным в главе о написании кода на С, это то, что эти советы хороши для любого кода на С, а не только когда вы работаете над программой GNU. Поэтому, если вы просто учите С или даже если вы уже работали некоторое время на С (или С++), мы рекомендуем вам эту главу, поскольку она заключает в себе многолетний опыт.




1.4.4. Вещи, которые делают программы GNU лучше


Теперь мы рассмотрим раздел, озаглавленный «Написание надежных программ», в главе 4 «Поведение программ для всех программ». Этот раздел описывает принципы проектирования программного обеспечения, которые делают программы GNU лучше их двойников в Unix Мы процитируем выбранные части главы, с несколькими примерами случаев, в которых эти принципы окупились.



Избегайте произвольных ограничений длины или числа любой структуры данных, включая имена файлов, строки, файлы и символы, выделяя все структуры данных динамически. В большинстве инструментов Unix «длинные строки молча срезаются». Это неприемлемо в инструменте GNU.


Это правило, возможно, единственное наиболее важное в проектировании программного обеспечения GNU — никаких произвольных ограничений. Все инструменты GNU должны быть способны обрабатывать произвольные объемы данных.

Хотя это требование, возможно, усложняет работу программиста, оно облегчает жизнь пользователю. С одной стороны, у нас есть пользователь 


, регулярно запускающий программу 


 для более чем 650 000 файлов (нет, это не опечатка) для сбора статистики, 


 заняла бы более 192 мегабайтов пространства данных, и программа работала бы в течение 7 часов. Он не смог бы запустить эту программу, используя другую реализацию 


.[22 - Эта ситуация имела место примерно в 1993 г; трюизм даже более очевиден сегодня, когда пользователи обрабатывают с помощью 


 гигабайты протокольных файлов — Примеч. автора.]



Утилиты, читающие файлы, не должны удалять символы NUL или любые другие неотображаемые символы, включая символы с кодами больше 0177. Единственными здравыми исключениями были бы утилиты, специально предназначенные для связывания с определенными типами терминалов или принтеров, которые не могут обработать эти символы.


Также хорошо известно, что Emacs может редактировать любые произвольные файлы, включая файлы, содержащие двоичные данные!



По возможности, программы должны обрабатывать должным образом последовательности байтов, представляющих многобайтные символы, используя такие кодировки, как UTF-8 и другие.[23 - Раздел 13.4, «Не могли бы вы произнести это для меня по буквам?», с. 521, дает обзор многобайтных символов и кодировок — Примеч. автора.] Каждый системный вызов проверяйте на предмет возвращенной ошибки, если вы не хотите игнорировать ошибки. Включите текст системной ошибки (от 


 или эквивалентной функции) в каждое сообщение об ошибке, возникшей при неудачном системном вызове, также, как и имя файла, если он есть, и имя утилиты. Простого «невозможно открыть foo.с» или «ошибка запуска» недостаточно.


Проверка каждого системного вызова создает устойчивость. Это еще один случай, когда жизнь программиста труднее, а пользователя легче. Подробно описанное сообщение об ошибке значительно упрощает нахождение и разрешение проблем[24 - Механика проверки ошибок и сообщений о них обсуждаются в разделе 4.3, «Обнаружение неправильной работы» — Примеч. автора.].

Наконец, мы цитируем главу 1 GNU Coding Standards, которая обсуждает, как написать вашу программу способом, отличным от того, каким написаны программы Unix.



Например, утилиты Unix обычно оптимизированы для минимизации использования памяти, если вы взамен хотите получить скорость, ваша программа будет сильно отличаться. Вы можете хранить весь входной файл в ядре и сканировать его там. вместо использования stdio. Используйте недавно открытый более изящный алгоритм вместо алгоритма Unix-программы. Исключите использование временных файлов. Делайте это в один проход вместо двух (мы сделали это на ассемблере) Или, напротив, сделайте упор на простоте вместо скорости. Для некоторых приложений скорость сегодняшних компьютеров делает адекватными более простые алгоритмы.

Или выберите обобщение. Например, программы Unix часто содержат статичные таблицы или строки фиксированного размера, которые создают произвольные ограничения, используйте вместо этого динамическое выделение памяти. Убедитесь, что ваша программа обрабатывает во входных файлах символы NUL и другие курьезные символы. Добавьте язык программирования для расширяемости и напишите часть программы на этом языке.

Или выделите части программы в независимо используемые библиотеки. Или используйте простой сборщик мусора вместо точного отслеживания, когда освобождать память, или используйте новую возможность GNU, такую как obstacks.


Великолепным примером того, какое отличие можно сделать в алгоритме, является GNU 


. Одним из первых ранних воплощений нашей системы было AT&T 3B1, система с процессором МС68010, огромными двумя мегабайтами памяти и 80 мегабайтами на диске. Мы проделали (и делаем) кучу исправлений в руководстве для 


, файле длиной почти 28 000 строк (хотя в то время он был лишь в диапазоне 10 000 строк). Обычно мы частенько использовали '


', чтобы посмотреть на сделанные нами изменения. На этой медленной системе переключение на GNU 


 показало ошеломительную разницу во времени появления контекста 


. Разница почти всецело благодаря лучшему алгоритму, который использует GNU 


.

В последнем параграфе упоминается идея структурирования программы как независимо используемой библиотеки, с оболочкой командной строки или другим окружающим се интерфейсом. Примером этого является GDB, отладчик GNU, который реализован в виде инструмента с интерфейсом командной строки поверх отладочной библиотеки. (Разделение основных возможностей GDB от интерфейса командной строки является продолжающимся проектом). Эта реализация дает возможность создать поверх отладочных функциональных возможностей графический интерфейс отладчика.




1.4.5. Заключительные соображения по поводу «GNU Coding Standards»


GNU Coding Standards является стоящим для прочтения документом, если вы хотите разрабатывать новое программное обеспечение GNU, обмениваться существующими программами GNU или просто научиться программировать лучше. Принципы и методики, которые она поддерживает — вот что делает программное обеспечение GNU предпочитаемым выбором в сообществе Unix.




1.5. Пересмотренная переносимость


Переносимость является чем-то вроде Святого Грааля; всегда недостающим впоследствии, но не всегда достижимым и определенно нелегким. Есть несколько аспектов написания переносимого кода. GNU Coding Standards обсуждает многие из них. Но есть и другие стороны. При разработке принимайте переносимость во внимание как на высоком, так и на низком уровнях. Мы рекомендуем следующие правила:

Соответствуйте стандартам

Хотя это может потребовать напряжения, знакомство с формальными стандартами языка, который вы используете, окупается. В частности, обратите внимание на стандарты ISO 1990 и 1999 гг. для С и стандарт 2003 г. для С++, поскольку большинство программ Linux создано на одном из этих двух языков.

В промышленности также широко поддерживается стандарт POSIX для интерфейса библиотечных и системных вызовов, хотя он и большой. Написание в соответствии с POSIX значительно повышает шансы успешного переноса вашего кода и на другие системы, помимо GNU/Linux. Этот стандарт вполне читабелен; он концентрирует в себе десятилетия опыта и хорошей практики.

Выбирайте для работы лучший интерфейс

Если стандартный интерфейс выполняет нужную вам работу, используйте его в своем коде. Для обнаружения недоступного интерфейса используйте Autoconf, и добавьте его замещающую версию для ограниченной системы. (Например, на некоторых более старых системах отсутствует функция 


, которую довольно легко запрограммировать самому или вставить из библиотеки GLIBC).

Изолируйте проблемы переносимости за новыми интерфейсами

Иногда вам может потребоваться выполнить специфичные для операционной системы задачи, которые можно исполнить на одних системах, но нельзя на других. (Например, на некоторых системах каждая программа должна сама раскрывать групповые символы в командной строке, вместо выполнения этой работы командным процессором.) Создайте новый интерфейс, который ничего не делает в системах, которым он не нужен, но проделывает необходимую коррекцию для систем, которые в этом нуждаются.

Используйте для конфигурирования Autoconf

По возможности избегайте 


. Если это невозможно, скройте его в низкоуровневом библиотечном коде. Для проверки тестов, которые должны исполняться с помощью 


, используйте Autoconf.




1.6. Рекомендуемая литература


1. The С Programming Language, 2nd edition, by Brian W. Kernighan and Dennis M. Ritchie Prentice-Hall, Englewood Cliffs, New Jersey, USA, 1989. ISBN: 0-13-110370-9[25 - Русский перевод Брайан Керниган, Денис Ритчи. Язык программирования Си (изд. 3-е, исправленное) Санкт- Петербург. Невский диалект, 2001 — Примеч. науч. ред.].

Это «библия» С, охватывающая версию стандарта С 1990 г. Это довольно сжатая книга, с большим количеством информации, помещенной в поразительно небольшое число страниц. Вам может потребоваться прочитать ее более одного раза; это стоит затраченных усилий.

2. С, A Reference Manual. 5th edition, by Samuel P. Harbison III and Guy L. Steele, Ji. Prentice-Hall, Upper Saddle River, New Jersey, USA, 2002. ISBN: 0-13-089592-X.

Это тоже классическая книга. Она охватывает оригинальный С, а также стандарты 1990 и 1999 гг. Поскольку она современна, она служит ценным дополнением к первой книге. Она охватывает многие важные темы, такие, как интернациональные типы и библиотечные функции, которых нет в книге Кернигана и Ричи.

3. Notes on Programming in С, by Rob Pike, February 21,1989 Доступна через множество веб-сайтов. Возможно, чаще всего упоминаемым местом является 


. (Многие другие полезные статьи доступны там же на один уровень выше: 


.) Роб Пайк много лет работал в исследовательском центре Bell Labs, где были созданы С и Unix, и проводил там изыскания. Его замечания концентрируют многолетний опыт в «философию ясности в программировании», это стоит прочтения.

4. Различные ссылки на 


. Этот сайт включает заметки Роба Пайка и несколько статей Генри Спенсера (Henry Spencer). Особенно высокое положение занимает «Рекомендуемый стиль С и стандарты программирования» (Recommended С Style and Coding Standards), первоначально написанный на сайте Bell Labs Indian Hill.




1.7. Резюме


• «Файлы и процессы» суммируют мировоззрение Linux/Unix. Трактовка файлов как потоков байтов, а устройств как файлов, и использование стандартных ввода, вывода и ошибки упрощают построение программ и унифицируют модель доступа к данным. Модель прав доступа проста, но гибка, и приложима как к файлам, так и каталогам.

• Процессы являются работающими программами, у которых есть связанные с ними идентификаторы пользователя и группы для проверки прав доступа, а также другие атрибуты, такие, как открытые файлы и текущий рабочий каталог.

• Наиболее заметным различием между стандартным С и оригинальным С является использование прототипов функций для более строгой проверки типов. Хороший программист на С должен быть способен прочесть код, написанный в оригинальном стиле, поскольку его используют многие существующие программы. Новый код должен быть написан с использованием прототипов.

• GNU Coding Standards описывает написание программ GNU. Она предусматривает многочисленные ценные методики и руководящие принципы для создания надежного, практичного программного обеспечения. Принцип «никаких произвольных ограничений» является, возможно, единственным наиболее важным из них. Этот документ является обязательным для прочтения серьезными программистами.

• Переносимость программ является сложной проблемой. Руководящие указания и инструментарий помогают, но в конечном счете нужен также и опыт.




Упражнения


1. Прочтите и прокомментируйте статью Ричарда М. Столмена «Проект GNU» (Richard M. Stallman, «The GNU Project»)[26 - 


 — Примеч. автора.], первоначально написанную в августе 1998 г.




Глава 2

Аргументы, опции и переменные окружения



Первой задачей любой программы обычно является интерпретация опций и аргументов командной строки. Данная глава рассматривает, как программы С (и С++) получают аргументы своей командной строки, описывает стандартные процедуры для разбора опций и бросает взгляд на переменные окружения.




2.1. Соглашения по опциям и аргументам



У слова аргументы есть два значения. Более техническим определением является «все 'слова' в командной строке». Например:






Здесь пользователь напечатал четыре «слова». Все четыре слова сделаны доступными программе в качестве ее аргументов[27 - Имя команды — 


 в данном примере, так же доступно программе в качестве аргумента — Примеч. науч. ред.].

Второе определение более неформальное: аргументами являются все слова командной строки, за исключением имени команды. По умолчанию, оболочки Unix отделяют аргументы друг от друга разделителями (пробелами или символами TAB). Кавычки позволяют включать в аргументы разделитель:





















Кавычки прозрачны для запущенной программы; 


 никогда не видит символов двойной кавычки. (В оболочке двойные и одинарные кавычки различаются; обсуждение этих правил выходит за рамки данной книги, которая фокусируется на программировании на С.)

Аргументы можно подразделить далее на опции и операнды. В предыдущих двух примерах все аргументы были операндами: файлы для 


 и простой текст для 


.

Опции являются специальными аргументами, которые каждая программа интерпретирует. Опции изменяют поведение программы или предоставляют программе информацию. По старому соглашению, которого (почти) всегда придерживаются, опции начинаются с черточки (т.е. дефиса, значка минус), и состоят из единственной буквы. Аргументы опции являются информацией, необходимой для опции, в отличие от обычных аргументов-операндов. Например, опция 


 программы 


 означает «использовать содержимое следующего файла в качестве списка строк для поиска». См. рис 2.1.




Рис. 2.1. Компоненты командной строки

Таким образом, 


 является не файлом данных для поиска, а предназначен для использования 


 в определении списка строк, которые нужно искать.




2.1.1. Соглашения POSIX


Стандарт POSIX описывает ряд соглашений, которых придерживаются удовлетворяющие стандарту программы. Никто от вас не требует, чтобы ваши программы удовлетворяли этим стандартам, но это хорошая мысль сделать так: пользователи Linux и Unix по всему миру понимают и используют эти соглашения, и если вы не будете им следовать, ваши пользователи будут несчастны. (Или у вас вообще не будет пользователей!) Более того, функции, которые мы обсуждаем далее в этой главе, освобождают вас от бремени ручной реализации этих соглашений для каждой программы, которую вы пишете. Вот эти правила, перефразированные из стандарта:

1. В имени программы должно быть не менее двух и не более девяти символов.

2. Имена программ должны содержать лишь строчные символы и цифры.

3. Имя опции должно быть простым буквенно-цифровым символом. Опции с множеством цифр не должны допускаться. Для производителей, реализующих утилиты POSIX, опция 


 зарезервирована для специфичных для производителя опций.

4. Все опции должны начинаться с символа '


'.

5. Для опций, не требующих аргументов, должно быть возможно объединение нескольких опций после единственного символа '


'. (Например, '


' и '


' должны интерпретироваться одинаково.)

6. Когда опции все же требуется аргумент, он должен быть отделен от опции пробелом (например, '


').

Однако, стандарт допускает историческую практику, при которой иногда опция и ее операнд могут находиться в одной строке: '


'. На практике функции 


 и 


 интерпретируют '


' как '


', а не как '


'.

7. Аргументы опций не должны быть необязательными.

Это означает, что если в документации программы указано, что опции требуется аргумент, этот аргумент должен присутствовать всегда, иначе программа потерпит неудачу GNU 


 все же предусматривает необязательные аргументы опций, поскольку иногда они полезны

8. Если опция принимает аргумент, который может иметь несколько значений, программа должна получать этот аргумент в виде одной строки со значениями, разделенными запятыми или разделителем.

Например, предположим, что гипотетической программе 


 требуется список пользователей для опции 


. Далее она может быть вызвана одним из двух способов:











В таком случае вы должны самостоятельно отделить и обработать каждое значение (т.е. здесь нет стандартной процедуры), но ручная реализация обычно проста.

9. Опции должны находиться в командной строке первыми, перед операндами. Версии 


 Unix проводят в жизнь это соглашение. GNU 


 по умолчанию этого не делает, хотя вы можете настроить его на это.

10. Специальный аргумент '


' указывает на окончание всех опций. Все последующие аргументы командной строки рассматриваются как операнды, даже если они начинаются с черточки.

11. Порядок, в котором приведены опции, не должен играть роли. Однако, для взаимно исключающих опций, когда одна опция перекрывает установки другой, тогда (так сказать) последняя побеждает. Если опция, имеющая аргумент, повторяется, программа должна обработать аргументы по порядку. Например, '


' то же самое, что и '


'. (Вам придется осуществить это самостоятельно; 


 вам не поможет.)

12. Нормально, когда порядок аргументов имеет для программы значение. Каждая программа должна документировать такие вещи.

13. Программы, читающие или записывающие именованные файлы, должны трактовать единственный аргумент '


' как означающий стандартный ввод или стандартный вывод, в зависимости от того, что подходит программе.

Отметим, что многие стандартные программы не следуют всем указанным соглашениям. Главной причиной является историческая совместимость; многие такие программы предшествовали систематизации этих соглашений.




2.1.2. Длинные опции GNU


Как мы видели в разделе 1.4.2 «Поведение программ», программам GNU рекомендуется использовать длинные опции в форме 


, 


 и т.д. Такие опции, поскольку они начинаются с '


', не конфликтуют с соглашениями POSIX. Их также легче запомнить, и они предоставляют возможность последовательности среди всех утилит GNU. (Например, 


 является везде одним и тем же, в отличие от 


 для «help», 


 для «information» и т.д.) Длинные опции GNU имеют свои собственные соглашения, реализованные в функции 


:

1. У программ, реализующих инструменты POSIX, каждая короткая опция (один символ) должна иметь также свой вариант в виде длинной опции.

2. Дополнительные специфические для GNU опции не нуждаются в соответствующей короткой опции, но мы рекомендуем это сделать.

3. Длинную опцию можно сократить до кратчайшей строки, которая остается уникальной. Например, если есть две опции 


 и 


, самыми короткими сокращениями будут 


 и 


.

4. Аргументы опции отделяются от длинных опций либо разделителем, либо символом 


. Например, 


 или 


.

5. Опции и аргументы могут быть заинтересованы в операндах командной строки, 


 переставляет аргументы таким образом, что сначала обрабатываются все опции, а затем все операнды доступны последовательно. (Такое поведение можно запретить.)

6. Аргументы опций могут быть необязательными. Для таких опций считается, что аргумент присутствует, если он находится в одной строке с опцией. Это работает лишь для коротких опций. Например, если -х такая опция и дана строка '


', аргументом 


 является '


'. Для '


' у 


 нет аргументов.

7. Программы могут разрешить длинным опциям начинаться с одной черточки (Это типично для многих программ X Window.)

Многое из этого станет яснее, когда позже в этой главе мы рассмотрим 


.

GNU Coding Standards уделяет значительное место перечислению всех длинных и коротких опций, используемых программами GNU. Если вы пишете программу, использующую длинные опции, посмотрите, нет ли уже использующихся имен опций, которые имело бы смысл использовать и вам.




2.2. Базовая обработка командной строки



Программа на С получает доступ к своим аргументам командной строки через параметры 


 и 


. Параметр 


 является целым, указывающим число имеющихся аргументов, включая имя команды. Есть два обычных способа определения 


, отличающихся способом объявления 


:





















Практически между двумя этими объявлениями нет разницы, хотя первое концептуально более понятно: 


 является массивом указателей на символы. А второе определение технически более корректно, это то, что мы используем. На рис. 2.2 изображена эта ситуация.




Рис. 2.2. Память для 




По соглашению, 


 является именем программы. (Детали см. в разделе 9.1.4.3. «Имена программ и 


».) Последующие элементы являются аргументами командной строки. Последним элементом массива 


 является указатель 


.




 указывает, сколько имеется аргументов; поскольку в С индексы отсчитываются с нуля, выражение '


' всегда верно. Из-за этого, особенно в коде для Unix, вы увидите различные способы проверки окончания списка аргументов, такие, как цикл с проверкой, что счетчик превысил 


, или '


', или '


' и т.д. Они все эквивалентны.




2.2.1. Программа 


 V7


Возможно, простейшим примером обработки командной строки является программа V7 


 печатающая свои аргументы в стандартный вывод, разделяя их пробелами и завершая символом конца строки. Если первым аргументом является 


, завершающий символ новой строки опускается. (Это используется для приглашений из сценариев оболочки.) Вот код[28 - См. 


 в дистрибутиве V7 — Примеч. автора.]:




















































































































Всего 23 строки! Здесь есть два интересных момента. Во-первых, уменьшение 


 и одновременное увеличение 


 (строки 12 и 13) являются обычным способом пропуска начальных аргументов. Во-вторых, проверка наличия 


 (строка 10) является упрощением. 


 также работает. (Откомпилируйте и проверьте это!)

Ручной разбор опций обычен для кода V7, поскольку функция 


 не была еще придумана.

Наконец, здесь и в других местах по всей книге, мы видим использование ключевого слова register. Одно время это ключевое слово давало компилятору подсказку, что данная переменная должна по возможности размещаться в регистре процессора. Теперь это ключевое слово устарело; современные компиляторы все основывают размещение переменных в регистрах на анализе исходного кода, игнорируя ключевое слово 


. Мы решили оставить использующий это слово код, как есть, но вы должны знать, что оно больше не имеет реального применения.[29 - Когда мы спросили Джима Мейеринга (Jim Meyering), сопроводителя Coreulils, о наличии 


 в GNU Coreutils, он дал нам интересный ответ. Он удаляет эти слова при изменении кода, но в остальных случаях оставляет их на месте, чтобы облегчить интеграцию сделанных изменений с существующими версиями — Примеч. автора.]




2.3. Разбор опций: 


 и 






Примерно в 1980-х группа поддержки Unix для System III в AT&T заметила, что каждая программа Unix использовала для разбора аргументов свои собственные методики. Чтобы облегчить работу пользователей и программистов, они разработали большинство из перечисленных ранее соглашений. (Хотя изложение в System III справки для intro(1) значительно менее формально, чем в стандарте POSIX.)

Группа поддержки Unix разработала также функцию 


, вместе с несколькими внешними переменными, чтобы упростить написание кода, придерживающегося стандартных соглашений. Функция GNU 


 предоставляет совместимую с 


 версию, а также упрощает разбор длинных опций в описанной ранее форме.




2.3.1. Опции с одним символом


Функция 


 объявлена следующим образом:























Аргументы 


 и 


 обычно передаются непосредственно от 


. 


 является строкой символов опций. Если за какой-либо буквой в строке следует двоеточие, эта опция ожидает наличия аргумента.

Для использования 


 вызывайте ее повторно из цикла 


 до тех пор, пока она не вернет 


. Каждый раз, обнаружив действительный символ опции, функция возвращает этот символ. Если опция принимает аргумент, указатель на него помещается в переменную 


. Рассмотрим программу, принимающую опцию 


 без аргумента и опцию 


 с аргументом:



























































































В ходе работы 


 устанавливает несколько переменных, контролирующих обработку ошибок:






Аргумент для опции, если она принимает аргумент.






Текущий индекс в 


. Когда цикл 


 завершается, оставшиеся операнды находятся с 


 по 


. (Помните, что '


'.)






Когда эта переменная не равна нулю (значение по умолчанию), 


 печатает свои собственные сообщения для недействительных опций или отсутствующих аргументов опций.






Когда находится недействительный символ опции, 


 возвращает либо '


', либо '


' (см ниже), a 


 содержит обнаруженный недействительный символ.

Люди есть люди, программы неизбежно будут иногда вызываться неправильно либо с недействительной опцией, либо с отсутствующим аргументом опции. Обычно в таких случаях 


 выводит свои собственные сообщения и возвращает символ '


'. Однако, вы можете изменить такое поведение двумя способами.

Во-первых, записав 0 в 


 перед вызовом 


, можно заставить 


 не предпринимать при обнаружении проблем никаких действий.

Во-вторых, если первый символ в 


 является двоеточием, 


 не предпринимает никаких действий и возвращает другой символ в зависимости от ошибки следующим образом:

Неверная опция




 возвращает '


', a 


 содержит неверный символ опции (Это обычное поведение).

Отсутствует аргумент опции




 возвращает '


'. Если первый символ 


 не является двоеточием, 


 возвращает '


', делая этот случай неотличимым от случая неверной опции.

Таким образом, помещение в качестве первого символа 


 двоеточия является хорошей мыслью, поскольку это позволяет различать «неверную опцию» и «отсутствующий аргумент опции». Расплатой за это является то, что 


 в этом случае также не предпринимает никаких действий, заставляя вас выводить собственные сообщения об ошибках. Вот предыдущий пример, на этот раз с обработкой ошибок:

























































































































Замечание о соглашениях по именованию флагов или опций: в большом количестве кода для Unix используются имена в виде 


 для любого данного символа опции x (например, 


 в 


 V7; обычным является также 


). Это может быть замечательным для авторе программы, который без проверки документации знает, что означает опция x. Но это не подходит для кого-то еще, кто пытается прочесть код и не знает наизусть значений всех символов опций. Гораздо лучше использовать имена, передающие смысл опции, как 


 для опции 


 echo.




2.3.2. GNU 


 и порядок опций


Стандартная функция 


 прекращает поиск опций, как только встречает аргумент командной строки, который не начинается с GNU 


 отличается: она просматривает в поисках опций всю командную строку. По мере продвижения она переставляет элементы 


, так что после ее завершения все опции оказываются переставленными в начало, и код, продолжающий разбирать аргументы с 


 до 


, работает правильно. Во всех случаях специальный аргумент '


' завершает сканирование опций.

Вы можете изменить поведение по умолчанию, использовав в 


 специальный первый символ следующим образом:






GNU 


 ведет себя, как стандартная 


; она возвращает опции по мере их обнаружения, останавливаясь на первом аргументе, не являющемся опцией. Это работает также в том случае, если в окружении присутствует строка 


.






GNU 


 возвращает каждый аргумент командной строки независимо от того, представляет он аргумент или нет. В этом случае для каждого такого аргумента функция возвращает целое 1, а указатель на соответствующую строку помещает в 


.

Как и для стандартной 


, если первым символом 


 является '


', GNU 


 различает «неверную опцию» и «отсутствующий аргумент опции», возвращая соответственно '


' или '


'. Символ '


' в 


 может быть вторым символом, если первым символом является '


' или '


'.

Наконец, если за символом опции в 


 следуют два двоеточия, эта опция может иметь необязательный аргумент. (Быстро повторите это три раза!) Такой аргумент считается присутствующим, если он находится в том же элементе 


, что и сама опция, и отсутствующим в противном случае. В случае отсутствия аргумента GNU 


 возвращает символ опции, а в 


 записывает NULL. Например, пусть имеем:











для 


, возвращаемое значение будет '


', a 


 указывает на «


», тогда как для 


 или '


' возвращаемое значение будет все то же '


', но в 


 будет помещен NULL. В последнем случае «


» представляет отдельный аргумент командной строки.




2.3.3. Длинные опции



Функция 


 осуществляет разбор длинных опций в описанном ранее виде. Дополнительная процедура 


 работает идентичным образом, но она используется для программ, в которых все опции являются длинными и начинаются с единичного символа '


'. В остальных случаях обе функции работают точно так же, как более простая функция GNU 


. (Для краткости, везде, где мы говорим «


», можно было бы сказать «


 и 


».) Вот объявления функций из справки getopt(3) GNU/Linux:






































Первые три аргумента те же, что и в 


. Следующая опция является указателем на массив 


, который мы назовем таблицей длинных опций и который вскоре опишем. Параметр 


, если он не установлен в NULL, указывает на переменную, в которую помешается индекс обнаруженной длинной опции в 


. Это полезно, например, при диагностике ошибок.




2.3.3.1. Таблица длинных опций


Длинные опции описываются с помощью массива структур 


. Структура 


 определена в 


; она выглядит следующим образом:































Элементы структуры следующие:






Это имя опции без предшествующих черточек, например, «


» или «


».






Переменная описывает, имеет ли длинная опция аргумент, и если да, какого вида этот аргумент. Значение должно быть одно из представленных в табл. 2.1. Макроподстановки являются некоторыми символическими именами для числовых значений, приведенных в таблице. Хотя числовые значения тоже работают, макроподстановки гораздо легче читать, и вы должны их использовать вместо соответствующих чисел в любом коде, который пишете.






Если этот указатель равен NULL, 


 возвращает значение поля 


 структуры. Если он не равен NULL, переменная, на которую он указывает, заполняется значением 


, a 


 возвращает 0. Если 


 не равен NULL, но длинная опция отсутствует, указанная переменная не изменяется.






Если длинная опция обнаружена, это возвращаемое значение или значение для загрузки в 


, если 


 не равен NULL. Обычно, если 


 не равен NULL, 


 является значением true/false, вроде 1 или 0. С другой стороны, если 


 равен NULL, 


 обычно содержит некоторую символьную константу. Если длинная опция соответствует короткой, эта символьная константа должна быть той же самой, которая появляется в аргументе 


 для этой опции. (Все это станет вскоре ясно, когда мы рассмотрим несколько примеров.)



Таблица 2.1. Значения для 







У каждой длинной опции есть один такой элемент с соответствующими заполненными значениями. В последнем элементе массива все значения должны быть равны нулю. Нет необходимости сортировать массив: 


 осуществляет линейный поиск. Однако, сортировка его по длинным именам может упростить его чтение для программиста.

При первой встрече использование 


 и 


 кажется сбивающим с толку. Давайте сделаем на время шаг назад и рассмотрим, почему это работает именно таким способом В большинстве случаев, обработка опций заключается в установке значений различных флаговых переменных при обнаружении различных символов опций, наподобие этого:






















































































Когда 


 не равен NULL, 


устанавливает значения переменных за вас. Это снижает число операторов 


 в предыдущем 


 с трех до одного. Вот пример таблицы длинных опций и код для работы с ней:

















































































































Обратите внимание, что значение, переданное аргументу 


, не содержит больше '


', '


' или '


'. Это означает, что соответствующие короткие опции неприемлемы. Чтобы разрешить как длинные, так и короткие опции, вам придется восстановить в 


 соответствующие 


 из первого примера.

На практике следует писать свои программы так, чтобы у каждой короткой опции была также соответствующая длинная опция. В этом случае проще всего установить в 


 NULL, а в 


 соответствующий единичный символ.




2.3.3.2. Длинные опции в стиле POSIX


Стандарт POSIX резервирует опцию 


 для специфических для производителя возможностей. Поэтому по определению 


 непереносимо между различными системами.

Если за 


 в аргументе 


 следует точка с запятой (обратите внимание не двоеточие), 


 рассматривает 


 так же, как 


. Соответственно в предыдущем примере измените вызов следующим образом:











С этим изменением 


 является тем же, что и 


, a 


 тем же, что 


. Использование точки с запятой позволяет программе использовать при желании 


 в качестве обычной опции. (Например, GCC использует ее как нормальную опцию, тогда как 


 использует ее для совместимости с POSIX.)




2.3.3 3. Сводка возвращаемых значений 





Теперь должно быть ясно, что 


 предоставляет гибкий механизм для разбора опций. В табл. 2.2 приведена сводка всех возможных возвращаемых значений функции и их значение.



Таблица 2.2. Возвращаемые значения 









Наконец, мы улучшим предыдущий пример кода, показав оператор 


 полностью:




















































































































































































































































































В своих программах вы можете захотеть сделать для каждого символа опции комментарии, объясняющие их значение. Однако, если вы использовали описательные имена переменных для каждого символа опции, комментарии уже не так нужны. (Сравните 


 и 


.)




2.3.3.4. GNU 


 или 


 в программах пользователей


Вы можете захотеть использовать в своих программах GNU 


 или 


 и заставить их работать на не-Linux системах/ Это нормально; просто скопируйте исходные файлы из программы GNU или из CVS архива библиотеки С GNU (GLIBC)[30 - См. 


 — Примеч. автора.]. Исходные файлы 


, 


 и 


. Они лицензированы на условиях меньшей общедоступной лицензии (Lesser General Public License) GNU, которая позволяет включать библиотечные функции даже в патентованные программы. Вы должны включить в свою программу копию файла 


 наряду с файлами 


, 


 и 


.

Включите исходные файлы в свой дистрибутив и откомпилируйте их с другими исходными файлами. В исходном коде, вызывающем 


, используйте '


', а не '


'. Затем, при компилировании, добавьте к командной строке компилятора С 


. Таким способом сначала будет найдена локальная копия заголовочного файла.

Вы можете поинтересоваться: «Вот так, я уже использую GNU/Linux. Почему я должен включать 


 в свой исполняемый модуль, увеличивая его размер, если процедура уже находится в библиотеке С?» Это хороший вопрос. Однако, здесь не о чем беспокоиться. Исходный код построен так, что если он компилируется на системе, которая использует GLIBC, откомпилированные файлы не будут содержать никакого кода! Вот подтверждение на нашей системе:



















































Команда 


 печатает размеры различных составных частей двоичного объекта или исполняемого файла. Мы объясним вывод в разделе 3.1 «Адресное пространство Linux/Unix». Что важно понять прямо сейчас, это то, что несмотря на ненулевой размер самих файлов, они не вносят никакого вклада в конечный исполняемый модуль. (Думаем, это достаточно ясно.)




2.4. Переменные окружения



Окружение представляет собой набор пар вида '


' для каждой программы. Эти пары называются переменными окружения. Каждое имя состоит от одной до любого числа буквенно-цифровых символов или символов подчеркивания ('


'), но имя не может начинаться с цифры. (Это правило контролируется оболочкой; С API может помешать в окружение все, что захочет, за счет возможного запутывания последующих программ.)

Переменные окружения часто используются для управления поведением программ. Например, если в окружении существует 


, многие программы запрещают расширения или историческое поведение, которые несовместимы со стандартом POSIX.

Вы можете решить использовать (и должны задокументировать) переменные окружения для управления поведением вашей программы. Например, вы можете вместо аргумента командной строки использовать для опций отладки переменную окружения. Преимуществом использования переменных окружения является то, что пользователи могут установить их в своем загрузочном файле и не беспокоиться больше постоянным набором определенных опций в командной строке.

Конечно, недостатком использования переменных окружения является то, что они могут молча изменять поведение программы. Джим Мейеринг (Jim Meyering), сопроводитель Coreutils, выразил это таким образом:



Они упрощают пользователю настройку программы без изменения способа ее вызова. Это может быть как благословением, так и проклятием. Если вы пишете сценарий, который зависит от значения определенной переменной окружения, а затем этот сценарий использует еще кто-то, у кого нет таких же установок окружения, он легко может потерпеть неудачу (или, что еще хуже, молча выдать неверные результаты).





2.4.1. Функции управления окружением


Несколько функций позволяют получать значения переменных окружения, изменять эти значения или удалять их. Вот соответствующие объявления:































































Функция 


 — та, которую вы будете использовать в 99% случаев. Ее аргументом является имя переменной окружения, которую нужно искать, такое, как «


» или «


». Если переменная существует, 


 возвращает указатель на строковое значение. Если нет, возвращается 


. Например:


























Иногда переменная окружения существует, но с пустым значением. В этом случае возвращаемое значение не равно 


, но первый символ, на которую оно указывает, будет нулевым байтом, который в С является символом конца строки, '


'. Ваш код должен позаботиться проверить, что возвращаемое значение не равно NULL. Если оно не 


, необходимо также проверить, что строка не пустая, если вы хотите для чего-то использовать значение переменной. В любом случае, не используйте возвращенное значение слепо.

Для изменения переменной окружения или добавления к окружению еще одной используется 


:
















Возможно, что переменная уже существует в окружении. Если третий аргумент равен true (не ноль), новое значение затирает старое. В противном случае, предыдущее значение не меняется. Возвращаемое значение равно -1, если для новой переменной не хватило памяти, и 0 в противном случае. 


 для сохранения в окружении делает индивидуальные копии как имени переменной, так и нового ее значения

Более простой альтернативой 


 является 


, которая берет одну строку «


» и помещает ее в окружение:



















 слепо заменяет любые предшествующие значения для той же переменной. А также, и это, возможно, более важно, строка, переданная 


, помещается непосредственно в окружение. Это означает, что если ваш код позже изменит эту строку (например, если это был массив, а не строковая константа), окружение также будет изменено. Это, в свою очередь, означает, что вам не следует использовать в качестве параметров для 


 локальную переменную. По всем этим причинам 


 является более предпочтительной функцией.



ЗАМЕЧАНИЕ. GNU 


 имеет дополнительную (документированную) особенность в своем поведении. Если строка аргумента является именем без следующего за ним символа 


, именованная переменная удаляется. Программа GNU 


, которую мы рассмотрим далее в мой главе, полагается на такое поведение.


Функция 


 удаляет переменную из окружения:






Наконец, функция 


 полностью очищает окружение:
















Эта функция не стандартизирована POSIX, хотя она доступна в GNU/Linux и нескольких коммерческих вариантах Unix. Ее следует использовать, если приложение должно быть очень безопасным и нужно построить собственное окружение с нуля. Если 


 недоступна, в справке GNU/Linux для clearenv(3) рекомендуется использовать для выполнения этой задачи '


'.




2.4.2. Окружение в целом: 





Правильным способом работы с окружением является использование функций, описанных в предыдущем разделе. Однако, стоит взглянуть на то, как это работает «под капотом».

Внешняя переменная 


 предоставляет доступ таким же способом, как 


 предоставляет доступ к аргументам командной строки. Вы сами должны объявить переменную. Хотя она и стандартизирована POSIX, 


 намеренно не объявлена ни в одном стандартном заголовочном файле (Это, кажется, прослеживается из исторической практики.) Вот объявление:






Как и в 


, завершающим элементом 


 является 


. Однако, здесь нет переменной «числа строк окружения», которая соответствовала бы 


. Следующая простая программа распечатывает все окружение:





















































Хотя это и маловероятно, перед попыткой использовать 


 эта программа проверяет, что она не равна 


.

Переменные хранятся в окружении в случайном порядке. Хотя некоторые оболочки Unix хранят переменные окружения в отсортированном по именам переменных виде, это формально не требуется, и многие оболочки не сортируют их.

В качестве уловки реализации можно получить доступ к окружению, объявив третий параметр 


:
















Затем можно использовать 


 также, как 


. Хотя это иногда можно увидеть в старом коде, мы не рекомендуем такое использование; 


 является официальным, стандартным, переносимым способом получения доступа ко всему окружению, если это вам необходимо.




2.4.3. GNU 





Чтобы завершить главу, рассмотрим GNU версию команды 


. Эта команда добавляет переменные к окружению в ходе выполнения одной команды. Она может использоваться также для очищения окружения в ходе этой команды или для удаления отдельных переменных окружения. Программа обеспечивает нас двойной функциональностью, поскольку проявляет возможности как 


, так и несколько других возможностей, обсуждавшихся в этом разделе. Вот как вызывается программа:



















































Вот несколько примеров вызовов команды:
















Код начинается со стандартной формулировки авторских прав GNU и разъясняющего комментария. Мы для краткости их опустили. (Формулировка авторского права обсуждается в Приложении С «Общедоступная лицензия GNU». Показанного ранее вывода 


 достаточно для понимания того, как работает программа.) За объявленным авторским правом и комментарием следуют подключаемые заголовочные файлы и объявления. Вызов макроса '


' (строка 93) предназначен для использования при локализации программного обеспечения, тема, освещенная в главе 13 «Интернационализация и локализация». Пока вы можете рассматривать его, как содержащий строковую константу.























































































































































GNU Coreutils содержит большое число программ, многие из которых выполняют одни и те же общие задачи (например, анализ аргументов). Для облегчения сопровождения многие типичные идиомы были определены в виде макросов. Двумя таким макросами являются 


 и 


 (строки 106 и 107). Вскоре мы рассмотрим их определения. Первая функция, 


, выводит информацию об использовании и завершает программу. Макрос 


 (строка 115, используется также по всей программе) также предназначен для локализации, пока также считайте его содержащим строковую константу.








































































































































Первая часть 


 объявляет переменные и настраивает локализацию. Функции 


, 


 и 


 (строки 147–149) обсуждаются в главе 13 «Интернационализация и локализация». Отметим, что эта программа использует аргумент 


 (строка 140). Это единственная программа Coreutils, которая так делает. Наконец, вызов 


 в строке 151 (см. раздел 9.1.5.3. «Функции завершения») регистрирует библиотечную функцию Coreutils, которая очищает все выходные буферы и закрывает 


, выдавая сообщение при ошибке. Следующая часть программы обрабатывает аргументы командной строки, используя 


.











































































































































































Вот отрывок из файла 


 в дистрибутиве Coreutils с упомянутыми ранее определениями и макросом '


', использованным выше (строки 164–165):




















































































































Результатом этого кода является печать сообщения об использовании утилиты для 


 и печать информации о версии для 


. Обе опции завершаются успешно («Успешный» и «неудачный» статусы завершения описаны в разделе 9.1.5.1 «Определение статуса завершения процесса».) Поскольку в Coreutils входят десятки утилит, имеет смысл вынести за скобки и стандартизовать как можно больше повторяющегося кода.

Возвращаясь к 


:



































































































































Строки 174–179 переносят существующие переменные в новую копию окружения. В глобальную переменную 


 помещается указатель на пустой локальный массив. Параметр 


 поддерживает доступ к первоначальному окружению.

Строки 181–184 удаляют переменные окружения, указанные в опции 


. Программа осуществляет это, повторно сканируя командную строку и удаляя перечисленные там имена. Удаление переменных окружения основывается на обсуждавшейся ранее особенности GNU 


: при вызове с одним лишь именем переменной (без указанного значения) 


 удаляет ее из окружения.

После опций в командной строке помещаются новые или замещающие переменные окружения. Строки 189–190 продолжают сканирование командной строки, отыскивая установки переменных окружения в виде '


'.

По достижении строки 192, если в командной строке ничего не осталось, предполагается, что 


 печатает новое окружение и выходит из программы. Она это и делает (строки 195–197).

Если остались аргументы, они представляют имя команды, которую нужно вызвать, и аргументы для передачи этой новой команде. Это делается с помощью системного вызова 


 (строка 200), который замещает текущую программу новой. (Этот вызов обсуждается в разделе 9.1.4 «Запуск новой программы: семейство 


»; пока не беспокойтесь о деталях.) Если этот вызов возвращается в текущую программу, он потерпел неудачу. В таком случае 


 выводит сообщение об ошибке и завершает программу.









































Значения кода завершения 


 и 


 (определяемые в строке 203) соответствуют стандарту POSIX. 


 означает, что программа, которую 


 попыталась запустить, не существует. (


 означает, что файл не содержит записи в каталоге.) 


 означает, что файл существует, но была какая-то другая ошибка.




2.5. Резюме


• Программы на С получают аргументы своей командной строки через параметры 


 и 


. Функция 


 предоставляет стандартный способ для последовательного разбора опций и их аргументов GNU версия 


 предоставляет некоторые расширения, a 


 и 


 дает возможность легкого разбора длинных опций.

• Окружение представляет собой набор пар '


', который каждая программа наследует от своего родителя. Программы могут по прихоти своего автора использовать для изменения своего поведения переменные окружения, в дополнение к любым аргументам командной строки. Для получения значений переменных окружения, изменения их значений или удаления существуют стандартные процедуры (


, 


, 


 и 


). При необходимости можно получить доступ ко всему окружению через внешнюю переменную 


 или через третий аргумент 


 функции 


. Последний способ не рекомендуется.




Упражнения


1. Предположим, что программа принимает опции 


, 


 и 


, и что 


 требует наличия аргумента. Напишите для этой программы код ручного разбора аргументов без использования 


 или 


. Для завершения обработки опций принимается 


. Убедитесь, что -ас работает, также, как 


, 


 и 


. Протестируйте программу.

2. Реализуйте 


. Для первой версии вы можете не беспокоиться насчет случая '


'. Можете также игнорировать 


.

3. Добавьте код для '


' и 


 к своей версии 


.

4. Распечатайте и прочтите файлы GNU 


, 


 и 


.

5. Напишите программу, которая объявляет как 


, так и 


, и сравните их значения.

6. Разбор аргументов командной строки и опций является тем колесом, которое многие люди не могут не изобретать вновь. Вы можете захотеть познакомиться с различными анализирующими аргументы пакетами, помимо 


 и 


, такими, как:

 • библиотека анализа аргументов Plan 9 From Bell Labs arg(2)[31 - 


 — Примеч. автора.],

 • Argp[32 - 


 — Примеч. автора.],

 • Argv[33 - 


 — Примеч. автора.],

 • Autoopts[34 - 


 — Примеч. автора.],

 • GNU Gengetopt[35 - 


 — Примеч. автора.],

 • Opt[36 - 


 — Примеч. автора.],

 • Popt[37 - 


 — Примеч. автора.]. См. также справочную страницу popt(3) системы GNU/Linux.

7. Дополнительный балл, почему компилятор С не может полностью игнорировать ключевое слово register? Подсказка: какие действия невозможно совершать с регистровой переменной?




Глава 3

Управление памятью на уровне пользователя



Без памяти для хранения данных программа не может выполнить никакую работу (Или, скорее, невозможно выполнить никакую полезную работу.) Реальные программы не могут позволить себе полагаться на буферы и массивы структур данных фиксированного размера. Они должны быть способны обрабатывать вводимые данные различных размеров, от незначительных до больших. Это, в свою очередь, ведет к использованию динамически выделяемой памяти — памяти, выделяемой в ходе исполнения, а не при компиляции. Вот как вводится в действие принцип GNU «никаких произвольных ограничений».

Поскольку динамически выделяемая память является основным строительным блоком для реальных программ, мы рассмотрим этот вопрос в начале, до рассмотрения всего остального. Наше обсуждение фокусируется на рассмотрении процесса и его памяти исключительно на уровне пользователя; оно не имеет ничего общего с архитектурой процессора.




3.1. Адресное пространство Linux/Unix


В качестве рабочего определения мы приняли, что процесс является запушенной программой. Это означает, что операционная система загрузила исполняемый файл для этой программы в память, сделала доступными аргументы командной строки и переменные окружения и запустила ее. Процесс имеет пять выделенных для него концептуально различных областей памяти:

Код

Часто называемая сегментом текста область, в которой находятся исполняемые инструкции. Linux и Unix организуют вещи таким образом, что несколько запушенных экземпляров одной программы по возможности разделяют свой код; в любое время в памяти находится лишь одна копия инструкций одной и той же программы (Это прозрачно для работающих программ.) Часть исполняемого файла, содержащая сегмент текста, называется секцией текста.

Инициализированные данные

Статически выделенные и глобальные данные, которые инициализированы ненулевыми значениями, находятся в сегменте данных. У каждого процесса с одной и той же запущенной программой свой собственный сегмент данных. Часть исполняемого файла, содержащая сегмент данных, является секцией данных.

Инициализированные нулями данные[38 - Существует также другое название для этой области данных — Неинициализированные данные — Примеч. науч. ред.]

Глобальные и статически выделенные данные, которые по умолчанию инициализированы нулями, хранятся в области процесса, который называют областью BSS[39 - BSS означает 'Block Started by Symbol', мнемоника из ассемблера IBM 7094 — Примеч. автора.]. У каждого процесса, в котором запущена одна и та же программа, своя область BSS. При запуске данные BSS помещаются в сегмент данных. В исполняемом файле они хранятся в секции BSS.

Формат исполняемого файла Linux/Unix таков, что пространство исполняемого файла на диске занимают лишь переменные, инициализированные ненулевыми значениями. Поэтому большой массив, объявленный как '


', который автоматически заполняется нулями, не занимает 2 Кб пространства на диске. (Некоторые компиляторы имеют опции, позволяющие вам помещать инициализированные нулями данные в сегмент данных.)

Куча (heap)

Куча является местом, откуда выделяется динамическая память (получаемая с помощью функции 


 и подобными ей). Когда из кучи выделяется память, адресное пространство процесса растет, что вы можете заметить, отслеживая запущенный процесс с помощью команды 


.

Хотя память можно вернуть обратно системе и сократить адресное пространство процесса, этого почти никогда не происходит. (Мы различаем освобождение больше не использующейся динамической памяти и сокращение адресного пространства; подробнее это обсуждается далее в этой главе.)

Для кучи характерен «рост вверх». Это означает, что последовательные элементы, добавляемые к куче, добавляются по адресам, численно превосходящим предыдущие. Куча обычно начинается сразу после области BSS сегмента данных.

Стек

Сегмент стека — это область, в которой выделяются локальные переменные. Локальными являются все переменные, объявленные внутри левой открывающей фигурной скобки тела функции (или другой левой фигурной скобки) и не имеющие ключевого слова 


.

В большинстве архитектур параметры функций также помещаются в стек наряду с «невидимой» учетной информацией, генерируемой компилятором, такой, как возвращаемое функцией значение и адрес возврата для перехода из функции к месту, откуда произошел вызов. (В некоторых архитектурах для этого используются регистры.) Именно использование стека для параметров функций и возвращаемых ими значений делает удобным написание рекурсивных функций (тех, которые вызывают сами себя) Переменные, хранящиеся в стеке, «исчезают», когда функция, их содержащая, возвращается, пространство стека используется повторно для последующих вызовов функций. В большинстве современных архитектур стек «растет вниз», это означает, что элементы, находящиеся глубже в цепи вызова, находятся по численно меньшим адресам. В работающей программе области инициализированных данных, BSS и кучи обычно размещаются в единой протяженной области: сегменте данных. Сегменты стека и кода отделены от сегмента данных и друг от друга. Это показано на рис. 3.1.




Рис. 3.1. Адресное пространство Linux/Unix

Хотя перекрывание стека и кучи теоретически возможно, операционная система предотвращает этот случай, и любая программа, пытающаяся это сделать, напрашивается на неприятности. Это особенно верно для современных систем, в которых адресные пространства большие и интервал между верхушкой стека и концом кучи значителен. Различные области памяти могут иметь различную установленную на память аппаратную защиту. Например, сегмент текста может быть помечен «только для исполнения», тогда как у сегментов данных и стека разрешение на исполнение может отсутствовать. Такая практика может предотвратить различные виды атак на безопасность. Подробности, конечно, специфичны для оборудования и операционной системы, и они могут со временем меняться. Стоит заметить, что стандартные как С, так и C++ позволяют размещать элементы с атрибутом 


 в памяти только для чтения. Сводка взаимоотношений различных сегментов приведена в табл. 3.1.



Таблица 3.1. Сегменты исполняемой программы и их размещение




Программа 


 распечатывает размеры в байтах каждой из секций text, data и BSS вместе с общим размером в десятичном и шестнадцатеричном виде. (Программа 


 показана далее в этой главе; см. раздел 3.2.5 «Исследование адресного пространства».)































































Общий размер загруженного в память из файла в 12 320 байтов всего лишь 1742 байта. Большую часть этого места занимают символы (symbols), список имен переменных и функций программы. (Символы не загружаются в память при запуске программы.) Программа 


 удаляет символы из объектного файла. Для большой программы это может сохранить значительное дисковое пространство ценой невозможности отладки дампа ядра[40 - Дамп ядра (core dump) является образом запущенного процесса в памяти, который создаётся при неожиданном завершении процесса. Позже этот дамп может быть использован для отладки Unix-системы, называют это файл 


, а системы GNU/Linux — 


, где 


 — ID потерпевшего крушения процесса — Примеч. автора.], если таковой появится (На современных системах об этом не стоит беспокоиться, не используйте 


.) Даже после удаления символов файл все еще больше, чем загруженный в память образ, поскольку формат объектного файла содержат дополнительные данные о программе, такие, как использованные разделяемые библиотеки, если они есть.[41 - Описание здесь намеренно упрощено. Запущенные программы занимают значительно больше места, чем указывает программа 


, поскольку разделяемые библиотеки включены в адресное пространство. Также сегмент данных будет расти по мере выделения программной памяти — Примеч. автора.]

Наконец, упомянем потоки (threads), которые представляют несколько цепочек исполнения в рамках единственного адресного пространства. Обычно у каждого потока имеется свой собственный стек, а также способ получения локальных данных потока, т.е. динамически выделяемых данных для персонального использования этим потоком. Мы больше не будем рассматривать в данной книге потоки, поскольку это является продвинутой темой.




3.2. Выделение памяти



Четыре библиотечные функции образуют основу управления динамической памятью С Мы опишем сначала их, затем последуют описания двух системных вызовов, поверх которых построены эти библиотечные функции. Библиотечные функции С, в свою очередь, обычно используются для реализации других выделяющих память библиотечных функций и операторов C++ 


 и 


.

Наконец, мы обсудим функцию, которую часто используют, но которую мы не рекомендуем использовать.




3.2.1. Библиотечные вызовы: 


, 


, 


, 






Динамическую память выделяют с помощью функций 


 или 


. Эти функции возвращают указатели на выделенную память. Когда у вас есть блок памяти определенного первоначального размера, вы можете изменить его размер с помощью функции 


. Динамическая память освобождается функцией 


.

Отладка использования динамической памяти сама по себе является важной темой. Инструменты для этой цели мы обсудим в разделе 15.5.2 «Отладчики выделения памяти».




3.2.1.1. Исследование подробностей на языке С


Вот объявления функций из темы справки GNU/Linux malloc(3):
















































Функции выделения памяти возвращают тип 


. Это бестиповый или общий указатель, все, что с ним можно делать — это привести его к другому типу и назначить типизированному указателю. Примеры впереди.

Тип 


 является беззнаковым целым типом, который представляет размер памяти. Он используется для динамического выделения памяти, и далее в книге мы увидим множество примеров его использования. На большинстве современных систем 


_t является 


, но лучше явно использовать 


 вместо простого целого типа 


.

Тип 


 используется для вычисления адреса в арифметике указателей, как в случае вычисления указателя в массиве:


























































Заголовочный файл 


 объявляет множество стандартных библиотечных функций С и типов (таких, как 


), он определяет также константу препроцессора 


, которая представляет «нуль» или недействительный указатель. (Это нулевое значение, такое, как 0 или '


'. Явное использование 0 относится к стилю С++; в С, однако, 


 является предпочтительным, мы находим его гораздо более читабельным для кода С.)




3.2.1.2. Начальное выделение памяти: 





Сначала память выделяется с помощью 


. Передаваемое функции значение является общим числом затребованных байтов. Возвращаемое значение является указателем на вновь выделенную область памяти или 


, если память выделить невозможно. В последнем случае для обозначения ошибки будет установлен 


. (errno является специальной переменной, которую системные вызовы и библиотечные функции устанавливают для указания произошедшей ошибки. Она описывается в разделе 4.3 «Определение ошибок».) Например, предположим, что мы хотим выделить переменное число некоторых структур. Код выглядит примерно так:





























































Представленные здесь шаги являются стереотипными. Порядок следующий:

1. Объявить указатель соответствующего типа для выделенной памяти.

2. Вычислить размер выделяемой памяти в байтах. Для этого нужно умножить число нужных объектов на размер каждого из них. Последний получается с помощью оператора С 


, который для этой цели и существует (наряду с другими). Таким образом, хотя размер определенной структуры среди различных компиляторов и архитектур может различаться, 


 всегда возвращает верное значение, а исходный код остается правильным и переносимым.

При выделении массивов для строк символов или других данных типа 


 нет необходимости умножения на 


, поскольку последнее по определению всегда равно 1. Но в любом случае это не повредит.

3. Выделить память с помощью 


, присвоив возвращаемое функцией значение переменной указателя. Хорошей практикой является приведение возвращаемого 


 значения к типу переменной, которой это значение присваивается. В С этого не требуется (хотя компилятор может выдать предупреждение). Мы настоятельно рекомендуем всегда приводить возвращаемое значение.

Обратите внимание, что на C++ присвоение знамения указателя одного типа указателю другого типа требует приведения типов, какой бы ни был контекст. Для управления динамической памятью программы C++ должны использовать 


 и 


, а не 


 и 


, чтобы избежать проблем с типами.

4. Проверить возвращенное значение. Никогда не предполагайте, что выделение памяти было успешным. Если выделение памяти завершилось неудачей, 


 возвращает 


. Если вы используете значение без проверки, ваша программа может быть немедленно завершена из-за нарушения сегментации (segmentation violation), которое является попыткой использования памяти за пределами своего адресного пространства.

Если вы проверите возвращенное значение, вы можете по крайней мере выдать диагностическое сообщение и корректно завершить программу. Или можете попытаться использовать какой-нибудь другой способ восстановления.

Выделив блок памяти и установив в 


 указатель на него, мы можем затем интерпретировать 


 как массив, хотя он в действительности указатель:































Компилятор создает корректный код для индексирования через указатель при получении доступа к членам структуры 


.



ЗАМЕЧАНИЕ. Блок памяти, возвращенный 


, не инициализирован. Он может содержать любой случайный мусор. Необходимо сразу же инициализировать память нужными значениями или хотя бы нулями. В последнем случае используйте функцию 


 (которая обсуждается в разделе 12.2 «Низкоуровневая память, функции 


):






Другой возможностью является использование 


, которая вскоре будет описана.


Джефф Колье (Geoff Collyer) рекомендует следующую методику для выделения памяти:











Этот подход гарантирует, что 


 выделит правильное количество памяти без необходимости смотреть объявление pointer. Если тип 


 впоследствии изменится, оператор 


 автоматически гарантирует, что выделяемое число байтов остается правильным. (Методика Джеффа опускает приведение типов, которое мы только что обсуждали. Наличие там приведения типов также гарантирует диагностику, если тип 


 изменится, а вызов 


 не будет обновлен.)




3.2.1.3. Освобождение памяти: 





Когда вы завершили использование памяти, «верните ее обратно», используя функцию 


. Единственный аргумент является указателем, предварительно полученным с использованием другой функции выделения. Можно (хотя это бесполезно) передать функции 


 пустой указатель:











После вызова f


 доступ к памяти, на которую указывает 


, запрещен. Она теперь «принадлежит» процедурам выделения, и они могут поступать с ней как сочтут нужным. Они могут изменить содержимое памяти или даже удалить ее из адресного пространства процесса! Таким образом, есть несколько типичных ошибок, которых нужно остерегаться при использовании 


:

Доступ к освобожденной памяти

Если она не была освобождена, переменная 


 продолжает указывать на блок памяти, который больше не принадлежит приложению. Это называется зависшим указателем (dangling pointer). На многих системах вы можете уйти от наказания, продолжая использовать эту память, по крайней мере до следующего выделения или освобождения памяти. На других системах, однако, такой доступ не будет работать. В общем, доступ к освобожденной памяти является плохой мыслью: это непереносимо и ненадежно, и GNU Coding Standards отвергает его. По этой причине неплохо сразу же установить в указателе программы значение 


. Если затем вы случайно попытаетесь получить доступ к освобожденной памяти, программа немедленно завершится с ошибкой нарушения сегментации (надеемся, до того, как вы успели вашу программу выпустить в свет).

Освобождение одного и того же указателя дважды

Это создает «неопределенное поведение». После передачи блока памяти обратно выделяющим процедурам они могут объединить освобожденный блок с другой свободной памятью, которая есть в их распоряжении. Освобождение чего-то уже освобожденного ведет к неразберихе и в лучшем случае к крушению; известно, что так называемые двойные освобождения приводили к проблемам безопасности.

Передача указателя, полученного не от функций


,


или




Это кажется очевидным, но тем не менее важно. Плоха даже передача указателя на адрес где-то в середине динамически выделенной памяти:











Этот вызов не будет работать и, возможно, приведет к пагубным последствиям, таким как крушение. (Это происходит потому, что во многих реализациях 


 «учетная» информация хранится перед возвращенными данными. Когда 


 пытается использовать эту информацию, она обнаружит там недействительные данные. В других реализациях, где учетная информация хранится в конце выделенного блока; возникают те же проблемы.)

Выход за пределы буфера

Доступ к памяти за пределами выделенного блока также ведет к неопределенному поведению, опять из-за того, что она может содержать учетную информацию или, возможно, вообще не принадлежать адресному пространству процесса. Запись в такой участок памяти гораздо хуже, поскольку это может уничтожить учетные данные.

Отказ в освобождении памяти

Любая динамическая память, которая больше не нужна, должна быть освобождена. В частности, необходимо тщательно управлять памятью и освобождать ее, когда она выделяется внутри циклов или рекурсивных или глубоко вложенных вызовов функций. Отказ от этого ведет к утечкам памяти, при которых память процесса может неограниченно расти; в конце концов, процесс завершается из-за нехватки памяти. Эта ситуация может быть особенно разрушительной, если память выделяется для ввода записи или как-то еще связана с вводом: утечка памяти будет незаметна при использовании незначительных объемов ввода, но внезапно станет очевидной (и приведет в замешательство) при больших. Эта ошибка еще хуже для систем, которые должны работать непрерывно, как в системах телефонных коммутаторов. Утечка памяти, вызывающая крушение такой системы, может привести к значительным денежным или другим потерям.

Даже если программа никогда не завершается из-за недостатка памяти, постоянно увеличивающиеся программы теряют производительность, поскольку операционная система должна сохранять использующиеся данные в физической памяти. В худшем случае, это может привести к поведению, известному как пробуксовка (thrashing), при которой операционная система так занята перекачкой содержимого адресного пространства в и из физической памяти, что реальная работа не делается.

Хотя 


 может вернуть освобожденную память системе и сократить адресное пространство процесса, это почти никогда не делается. Вместо этого освобожденная память готова для нового выделения при следующем вызове 


, 


 или 


.

При условии, что освобожденная память продолжает оставаться в адресном пространстве процесса, стоит обнулить ее перед освобождением. Например, такой способ может оказаться предпочтительным для программ с повышенными требованиями к безопасности.

Обсуждение ряда полезных инструментов для отладки динамической памяти см в разделе 15.5.2 «Отладчики выделения памяти».




3.2.1.4. Изменение размера: 





Динамическая память имеет существенное преимущество перед статически объявленными массивами, поскольку это позволяет использовать столько памяти, сколько нужно, и не больше. Не нужно объявлять глобальный, статический или локальный массив фиксированного размера и надеяться, что он: (а) достаточно большой и (б) не слишком большой. Вместо этого можно выделить ровно столько, сколько нужно, не больше и не меньше.

Вдобавок, можно изменять размер динамически выделенной области памяти. Хотя можно сократить размер блока памяти, обычно его увеличивают. Изменение размера осуществляется с помощью 


. Продолжая пример с 


, типичный код выглядит следующим образом:





























































Как и в случае с 


, шаги стереотипны по природе и сходны по идее.

1. Вычислить новый выделяемый размер в байтах.

2. Вызвать 


 с оригинальным указателем, полученным от 


 (или от 


 или предыдущего вызова 


) и с новым размером.

3. Привести тип и присвоить возвращенное 


 значение. Подробнее обсудим дальше.

4. Как и для 


, проверить возвращенное значение, чтобы убедиться, что оно не равно NULL. Вызов любой функции выделения памяти может завершиться неудачей.

При увеличении размера блока памяти 


 часто выделяет новый блок нужного размера, копирует данные из старого блока в новый и возвращает указатель уже на новый блок. При сокращении размера блока данных 


 часто обновляет внутреннюю учетную информацию и возвращает тот же указатель. Это избавляет от необходимости копировать первоначальные данные. Однако, если это случится, не думайте, что можно использовать память за пределами нового размера!

В любом случае вы можете предположить, что если 


 не возвращает 


, старые данные были скопированы для вас в новый участок памяти. Более того, старый указатель больше недействителен, как если бы вы вызвали 


 с ним, и использовать его больше не следует. Это верно для всех указателей на этот блок данных, а не только для того, который использовался при вызове 


.

Возможно, вы заметили, что в нашем примере для указания на измененный блок памяти использовалась отдельная переменная. Можно было бы (хотя это плохая идея) использовать ту же самую переменную, как здесь:






Это плохо по следующей причине. Когда 


 возвращает 


, первоначальный указатель все еще действителен; можно безопасно продолжить использовать эту память. Но если вы повторно используете ту же самую переменную и 


 возвращает 


, вы теряете указатель на первоначальную память. Эту память больше нельзя использовать. Что еще важнее, эту память невозможно освободить! Это создает утечку памяти, которую нужно избежать.

Для версии 


 в стандартном С есть некоторые особые случаи: когда аргумент 


 равен 


, 


 действует подобно 


 и выделяет свежий блок памяти. Когда аргумент 


 равен 0, 


 действует подобно 


 и освобождает память, на которую указывает 


. Поскольку (а) это может сбивать с толку и (б) более старые системы не реализуют эту возможность, мы рекомендуем использовать 


, когда вы имеете в виду 


, и 


, когда вы имеете в виду 


.

Вот другой довольно тонкий момент[42 - Он получен от реальной практики работы с 


 — Примеч. автора.]. Рассмотрим процедуру, которая содержит статический указатель на динамически выделяемые данные, которые время от времени должны расти. Процедура может содержать также автоматические (т.е. локальные) указатели на эти данные. (Для краткости, мы опустим проверки ошибок. В коде продукта не делайте этого.) Например:






























































































































Это выглядит просто; 


 размешает данные, использует их, изменяет размер и т.д. Но есть кое-какие проблемы, которые не выходят за рамки страницы (или экрана), когда вы смотрите на этот код.

В строке, помеченной '


', указатель cur используется для обновления элемента таблицы. Однако, 


 был инициализирован начальным значением 


. Если некоторое условие верно и 


 вернула другой блок памяти, 


 теперь указывает на первоначальный, освобожденный участок памяти! Каждый раз, когда 


 меняется, нужно обновить также все указатели на этот участок памяти. Здесь после вызова 


 и переназначения 


 недостает строки '


'.

Две строки, помеченные '


', еще более тонкие. В частности, предположим, что 


 делает рекурсивный вызов 


. Переменная 


 снова может быть изменена совершенно незаметно! После возвращения из 


 значение cur может снова стать недействительным.

Можно подумать (что мы вначале и сделали), что единственным решением является знать это и добавить после вызова функции переназначение 


 с соответствующим комментарием. Однако, Брайан Керниган (Brian Kernighan) любезно нас поправил. Если мы используем индексирование, проблема поддержки указателя даже не возникает:



























































































Использование индексирования не решает проблему, если вы используете глобальную копию первоначального указателя на выделенные данные; в этом случае, вам все равно нужно побеспокоиться об обновлении своих глобальных структур после вызова 


.



ЗАМЕЧАНИЕ. Как и в случае с 


, когда вы увеличиваете размер памяти, вновь выделенная после 


 память не инициализируется нулями. Вы сами при необходимости должны очистить память с помощью 


, поскольку 


 лишь выделяет новую память и больше ничего не делает.





3.2.1.5. Выделение с инициализацией нулями: 





Функция 


 является простой оболочкой вокруг 


. Главным ее преимуществом является то, что она обнуляет динамически выделенную память. Она также вычисляет за вас размер памяти, принимая в качестве параметра число элементов и размер каждого элемента:






По крайней мере идейно, код 


 довольно простой. Вот одна из возможных реализаций:














































Многие опытные программисты предпочитают использовать 


, поскольку в этом случае никогда не возникает вопросов по поводу вновь выделенной памяти.

Если вы знаете, что вам понадобится инициализированная нулями память, следует также использовать 


, поскольку возможно, что память, возвращенная 


, уже заполнена нулями. Хотя вы, программист, не можете этого знать, 


 может это знать и избежать лишнего вызова 


.




3.2.1.6. Подведение итогов из GNU Coding Standards


Чтобы подвести итоги, процитируем, что говорит об использовании процедур выделения памяти GNU Coding Standards:



Проверяйте каждый вызов 


 или 


 на предмет возвращенного нуля. Проверяйте 


 даже в том случае, если вы уменьшаете размер блока; в системе, которая округляет размеры блока до степени двойки, 


 может получить другой блок, если вы запрашиваете меньше памяти.

В Unix 


 может разрушить блок памяти, если она возвращает ноль. GNU 


 не содержит подобной ошибки: если она завершается неудачей, исходный блок остается без изменений. Считайте, что ошибка устранена. Если вы хотите запустить свою программу на Unix и хотите избежать потерь в этом случае, вы можете использовать GNU 


.

Вы должны считать, что 


 изменяет содержимое освобожденного блока. Все, что вы хотите получить из блока, вы должны получать до вызова 


.


В этих трех коротких абзацах Ричард Столмен (Richard Stallman) выразил суть важных принципов управления динамической памятью с помощью 


. Именно использование динамической памяти и принцип «никаких произвольных ограничений» делают программы GNU такими устойчивыми и более работоспособными по сравнению с их Unix-двойниками.

Мы хотим подчеркнуть, что стандарт С требует, чтобы 


не разрушал оригинальный блок памяти, если она возвращает 


.




3.2.1.7. Использование персональных программ распределения


Набор функций с 


 является набором общего назначения по выделению памяти. Он должен быть способен обработать запросы на произвольно большие или маленькие размеры памяти и осуществлять все необходимые учетные действия при освобождении различных участков выделенной памяти. Если ваша программа выделяет значительную динамическую память, вы можете обнаружить, что она тратит большую часть своего времени в функциях 


.

Вы можете написать персональную программу распределения — набор функций или макросов, которые выделяют большие участки памяти с помощью 


, а затем дробят их на маленькие кусочки по одному за раз. Эта методика особенно полезна, если вы выделяете множество отдельных экземпляров одной и той же сравнительно небольшой структуры.

Например, GNU awk (gawk) использует эту методику. Выдержка из файла 


 в дистрибутиве 


 (слегка отредактировано, чтобы уместилось на странице):





















Переменная 


 указывает на связанный список структур NODE. Макрос 


 убирает из списка первую структуру, если она там есть. В противном случае она вызывает 


, чтобы выделить новый список свободных структур 


. Макрос 


 освобождает структуру 


, помещая его в начало списка.



ЗАМЕЧАНИЕ. Первоначально при написании своего приложения делайте это простым способом: непосредственно используйте 


 и 


. Написание собственного распределителя вы должны рассмотреть лишь в том и только в том случае, если профилирование вашей программы покажет, что она значительную часть времени проводит в функциях выделения памяти.





3.2.1.8. Пример: чтение строк произвольной длины


Поскольку это, в конце концов, Программирование на Linux в примерах, настало время для примера из реальной жизни. Следующий код является функцией 


 из GNU Make 3.80 (


). Ее можно найти в файле 


.

Следуя принципу «никаких произвольных ограничений», строки в 


 могут быть любой длины. Поэтому главной задачей этой процедуры является чтение строк произвольной длины и гарантирование того, что они помещаются в используемый буфер.

Вторичной задачей является распоряжение продлением строк. Как и в С, строки, заканчивающиеся обратным слешем, логически продолжаются со следующей строки. Используется стратегия поддержания буфера. В нем хранится столько строк, сколько помещается в буфер, причем указатели отслеживают начало буфера, текущую строку и следующую строку. Вот структура:









































Поле 


 отслеживает размер всего буфера, a 


 является указателем типа 


 для файла ввода. Структура floc не представляет интереса при изучении процедуры.

Функция возвращает число строк в буфере. (Номера строк здесь даны относительно начала функции, а не исходного файла.)










































































































Для начала заметим, что GNU Make написан на С K&R для максимальной переносимости. В исходной части объявляются переменные, и если ввод осуществляется из строки (как в случае расширения макроса), код вызывает другую функцию, 


 (строки 13 и 14). Строка '


' (строка 13) является более короткой (и менее понятной, по нашему мнению) проверкой на пустой указатель; это то же самое, что и '


'.

Строки 19-21 инициализируют указатели и вводят байт NUL, который является символом завершения строки С в конце буфера. Затем функция входит в цикл (строки 23–95), который продолжается до завершения всего ввода.
































































































Функция 


 (строка 23) принимает указатель на буфер, количество байтов для прочтения и переменную 


 для файла, из которого осуществляется чтение. Она читает на один байт меньше указанного, чтобы можно было завершить буфер символом '


'. Эта функция подходит, поскольку она позволяет избежать переполнения буфера. Она прекращает чтение, когда встречается с символами конца строки или конца файла; если это символ новой строки, он помещается в буфер. Функция возвращает 


 при неудаче или значение указателя первого аргумента при успешном завершении.

В этом случае аргументами являются указатель на свободную область буфера, размер оставшейся части буфера и указатель 


 для чтения.

Комментарии в строках 32–36 очевидны; если встречается нулевой байт, программа выводит сообщение об ошибке и представляет вывод как пустую строку. После компенсирования нулевого байта (строки 30–41) код продолжает работу.



















































Строки 43–52 увеличивают указатель на участок буфера за только что прочитанными данными. Затем код проверяет, является ли последний прочитанный символ символом конца строки. Конструкция 


 (строка 48) проверяет символ перед p, также как 


 является текущим символом, а 


 — следующим. Сначала это кажется странным, но если вы переведете это на язык математики указателей, 


, это приобретет больший смысл, а индексированная форма, возможно, проще для чтения.

Если последний символ не был символом конца строки, это означает, что нам не хватило места, и код выходит (с помощью 


) для увеличения размера буфера (строка 49). В противном случае увеличивается число строк.














































Строки 54–62 обрабатывают вводимые строки, следующие соглашению Microsoft по завершению строк комбинацией символов возврата каретки и перевода строки (CR-LF), а не просто символом перевода строки (новой строки), который является соглашением Linux/Unix. Обратите внимание, что 


исключает этот код на платформе Microsoft, очевидно, библиотека 


 на этих системах автоматически осуществляет это преобразование. Это верно также для других не-Unix систем, поддерживающих стандартный С.

































































































































































До сих пор мы имели дело с механизмом получения в буфер по крайней мере одной полной строки. Следующий участок обрабатывает случай строки с продолжением. Хотя он должен гарантировать, что конечный символ обратного слеша не является частью нескольких обратных слешей в конце строки. Код проверяет, является ли общее число таких символов четным или нечетным путем простого переключения переменной 


 из 0 в 1 и обратно. (Строки 64–70.)

Если число четное, условие '


' (строка 72) будет истинным. В этом случае конечный символ конца строки замещается байтом NUL, и код выходит из цикла.

С другой стороны, если число нечетно, строка содержит четное число пар обратных слешей (представляющих символы \\, как в С), и конечную комбинацию символов обратного слеша и конца строки.[43 - Этот код несет с собой аромат практического опыта, не удивительно было узнать, что более ранние версии просто проверяли наличие обратного слеша перед символом конца строки, пока кто-то не пожаловался, что он не работает, когда в конце строки есть несколько обратных слешей — Примеч. автора.] В этом случае, если в буфере остались по крайней мере 80 свободных байтов, программа продолжает чтение в цикле следующей строки (строки 78–81). (Использование магического числа 80 не очень здорово; было бы лучше определить и использовать макроподстановку.)

По достижении строки 83 программе нужно больше места в буфере. Именно здесь вступает в игру динамическое управление памятью. Обратите внимание на комментарий относительно сохранения значения 


 (строки 83-84); мы обсуждали это ранее в терминах повторной инициализации указателей для динамической памяти. Значение end также устанавливается повторно. Строка 89 изменяет размер памяти.

Обратите внимание, что здесь вызывается функция 


. Многие программы GNU используют вместо 


 и 


 функции-оболочки, которые автоматически выводят сообщение об ошибке и завершают программу, когда стандартные процедуры возвращают 


. Такая функция-оболочка может выглядеть таким образом:
















































Таким образом, если функция 


 возвращается, она гарантированно возвращает действительный указатель. (Эта стратегия соответствует принципу «проверки каждого вызова на ошибки», избегая в то же время беспорядка в коде, который происходит при таких проверках с непосредственным использованием стандартных процедур.) Вдобавок, это позволяет эффективно использовать конструкцию '


', против которой мы предостерегали ранее.

Обратите внимание, что не всегда подходит использование такой оболочки. Если вы сами хотите обработать ошибки, не следует использовать оболочку. С другой стороны, если нехватка памяти всегда является фатальной ошибкой, такая оболочка вполне удобна.



















































В заключение, функция 


 проверяет ошибки ввода/вывода, а затем возвращает описательное значение. Функция 


 (строка 98) не возвращается.[44 - Эта функция завершает выполнение программы — Примеч. науч. ред.]




3.2.1.9. Только GLIBC: чтение целых строк: 


 и 





Теперь, когда вы увидели, как читать строки произвольной длины, вы можете сделать вздох облегчения, что вам не нужно самим писать такую функцию. GLIBC предоставляет вам для этого две функции:




























Определение константы 


 вводит объявления функций 


 и 


. В противном случае они неявно объявлены как возвращающие 


. Для объявления возвращаемого типа 


 нужен файл 


. (


 является «знаковым 


». Он предназначен для такого же использования, что и 


, но в местах, где может понадобиться использование также и отрицательных значений.)

Обе функции управляют для вас динамической памятью, гарантируя, что буфер, содержащий входную строку, достаточно большой для размещения всей строки. Их отличие друг от друга в том, что 


 читает до символа конца строки, a 


 использует в качестве разделителя символ, предоставленный пользователем. Общие аргументы следующие:






Указатель на 


 указатель для адреса динамически выделенного буфера. Чтобы 


 сделала всю работу, он должен быть инициализирован 


. В противном случае, он должен указывать на область памяти, выделенную с помощью 


.






Указатель на размер буфера. Если вы выделяете свой собственный буфер, 


 должно содержать размер буфера. Обе функции обновляют 


 новым значением размера буфера, если они его изменяют.






Место, откуда следует получать входные символы.

По достижении конца файла или при ошибке функция возвращает -1. Строки содержат завершающий символ конца строки или разделитель (если он есть), а также завершающий нулевой байт. Использование 


 просто, как показано в 


:




































































Вот эта функция в действии, показывающая размер буфера. Третья входная и выходная строки намеренно длинные, чтобы заставить 


 увеличить размер буфера:







































3.2.2. Копирование строк: 





Одной чрезвычайно типичной операцией является выделение памяти для копирования строки. Это настолько типично, что многие программисты предусматривают для нее простую функцию вместо использования внутритекстового кодирования, и часто эта функция называется 


:


























































С появлением стандарта POSIX 2001 программисты по всему миру могут вздохнуть свободнее: эта функция является теперь частью POSIX в виде расширения XSI:













Возвращаемое значение равно 


, если была ошибка, или указатель на динамически выделенную память с копией 


. Возвращенное значение должно быть освобождено с помощью 


, когда больше не требуется.




3.2.3. Системные вызовы: 


 и 





Четыре функции, которые мы рассмотрели (


, 


, 


 и 


) являются стандартными, переносимыми функциями для управления динамической памятью.

На Unix-системах стандартные функции реализованы поверх двух дополнительных, очень примитивных процедур, которые непосредственно изменяют размер адресного пространства процесса. Мы представляем их здесь, чтобы помочь вам понять, как работают GNU/Linux и Unix (снова «под капотом»); крайне маловероятно, что вам когда-нибудь понадобится использовать эти функции в обычных программах. Они определены следующим образом:























Системный вызов 


 действительно изменяет адресное пространство процесса. Адрес является указателем, представляющим окончание сегмента данных (на самом деле, области кучи, как было показано ранее на рис. 3.1). Ее аргумент является абсолютным логическим адресом, представляющим новое окончание адресного пространства. В случае успеха функция возвращает 0, а в случае неуспеха (-1).

Функцию 


 использовать проще; ее аргумент является числом байтов, на которое нужно увеличить адресное пространство. Вызвав ее с приращением 0, можно определить, где в настоящее время заканчивается адресное пространство. Таким образом, чтобы увеличить адресное пространство на 32 байта, используется код следующего вида:































Практически, вам не нужно непосредственно использовать 


. Вместо этого используется исключительно 


 для увеличения (или даже сокращения) адресного пространства. (Вскоре мы покажем, как это делать, в разделе 3.2.5. «Исследование адресного пространства».)

Еще более практично вообще никогда не использовать эти процедуры. Программа, которая их использует, не может затем использовать также и 


, и это создает большую проблему, поскольку многие элементы стандартной библиотеки полагаются на использование 


. Поэтому использование 


 или 


 может приводить к трудно обнаруживаемым крушениям программы.

Но знать о низкоуровневых механизмах стоит, и конечно же, набор функций 


 реализован с помощью 


 и 


.




3.2.4. Вызовы ленивых программистов: 





«Опасность, Билл Робинсон! Опасность!»

    - Робот -

Есть еще одна дополнительная функция выделения памяти, о которой вам нужно знать. Мы обсуждаем ее лишь для того, чтобы вы поняли ее, когда увидите, но не следует использовать ее в новых программах! Эта функция называется 


; она объявлена следующим образом:


















Функция 


 выделяет 


 байтов из стека. Хорошо, что выделенная память исчезает после возвращения из функции. Нет необходимости явным образом освобождать память, поскольку это осуществляется автоматически, как в случае с локальными переменными.

На первый взгляд, 


 выглядит чем-то типа панацеи для программистов, можно выделять память, о которой можно вовсе не беспокоиться. Подобно Темной Стороне Силы, это, конечно, привлекает. И подобным же образом этого нужно избегать по следующим причинам:

• Функция не является стандартной; она не включена ни в какой стандарт, ни в ISO, ни в С или POSIX.

• Функция не переносима. Хотя она существует на многих системах Unix и GNU/Linux, она не существует на не-Unix системах. Это проблема, поскольку код часто должен быть многоплатформенным, выходя за пределы просто Linux и Unix.

• На некоторых системах 


 невозможно даже реализовать. Весь мир не является ни процессором Intel x86, ни GCC.

• Цитируя справку[45 - alloca(3) — Примеч. науч. ред.] (добавлено выделение): «Функция 


 зависит от машины и от компилятора. На многих системах ее реализация ошибочна. Ее использование не рекомендуется».

• Снова цитируя справку: «На многих системах 


 не может быть использована внутри списка аргументов вызова функции, поскольку резервируемая в стеке при помощи 


 память оказалась бы в середине стека в пространстве для аргументов функции».

• Она потворствует неряшливому программированию. Тщательная и корректная работа с памятью не сложна; вам просто нужно подумать о том, что вы делаете, и планировать заранее.

GCC обычно использует встроенную версию функции, которая действует с использованием внутритекстового (inline) кода. В результате есть другие последствия 


. Снова цитируя справку:



Факт, что код является внутритекстовым (inline), означает, что невозможно получить адрес этой функции или изменить ее поведение путем компоновки с другой библиотекой.

Внутритекстовый код часто состоит из одной инструкции, подгоняющей указатель стека, и не проверяет переполнение стека. Поэтому нет возврата 


 при ошибке.


Справочная страница не углубляется в описание проблемы со встроенной 


 GCC. Если есть переполнение стека, возвращаемое значение является мусором. И у вас нет способа сообщить об этом! Это упущение делает невозможным использование GCC 


 в устойчивом коде.

Все это должно убедить вас избегать 


 в любом новом коде, который вы пишете. В любом случае, если приходится писать переносимый код с использованием 


 и 


, нет причины в использовании также и 


.




3.2.5. Исследование адресного пространства


Следующая программа, 


, подводит итог всему, что мы узнали об адресном пространстве. Она делает множество вещей, которые не следует делать на практике, таких, как вызовы 


 или непосредственные вызовы 


 и 


.




























































































































































































































































































































Эта программа распечатывает местонахождение двух функций 


 и 


 (строки 22–23). Затем она показывает, как стек растет вниз, позволяя 


 (строки 51–63) распечатать адреса последовательных экземпляров ее локальной переменной 


. (


 намеренно объявлена как 


, чтобы подчеркнуть, что она находится в стеке.) Затем она показывает расположение памяти, выделенной с помощью 


 (строки 28–32). В заключение она печатает местоположение переменных данных и BSS (строки 34–38), а затем памяти, выделенной непосредственно через 


 (строки 40–48). Вот результаты запуска программы на системе Intel GNU/Linux:























































































































3.3. Резюме


• У каждой программы Linux и (Unix) есть различные области памяти. Они хранятся в разных частях файла исполняемой программы на диске. Некоторые из секций загружаются при запуске программы в одну и ту же область памяти. Все запушенные экземпляры одной и той же программы разделяют исполняемый код (сегмент текста). Программа 


 показывает размеры различных областей переместимых объектных файлов и полностью скомпонованных исполняемых файлов.

• В адресном пространстве запушенной программы могут быть дыры, а размер адресного пространства может изменяться при выделении и освобождении памяти. На современных системах адрес 0 не является частью адресного пространства, поэтому не пытайтесь разыменовывать указатели 


.

• На уровне языка С память выделяется с помощью одной из функций 


, 


 или 


. Память освобождается с помощью 


. (Хотя с помощью 


 можно делать все, использование ее таким образом не рекомендуется.) Освобожденная память обычно не удаляется из адресного пространства; вместо этого она используется повторно при последующих выделениях.

• Необходимо предпринять чрезвычайные меры осторожности в следующих случаях

 • освобождать лишь память, выделенную с помощью соответствующих процедур,

 • освобождать память один и только один раз,

 • освобождать неиспользуемую память и

 • не допускать «утечки» динамически выделяемой памяти.

• POSIX предоставляет для удобства функцию 


, a GLIBC предоставляет функции 


 и 


 для чтения строк произвольной длины. Функции интерфейса низкоуровневых системных вызовов 


 и 


 предоставляют непосредственный, но примитивный доступ к выделению и освобождению памяти. Если вы не создаете свой собственный распределитель памяти, следует избегать их. Существует функция 


 для выделения памяти в стеке, но ее использование не рекомендуется. Подобно умению распознавать ядовитый плющ, про нее нужно знать лишь для того, чтобы избегать ее.




Упражнения


1. Начав со структуры —


























— напишите свою собственную функцию 


, которая будет читать строки любой длины. Не беспокойтесь о строках, продолженных с помощью обратного слеша. Вместо использования 


 для чтения строк используйте 


 для чтения одного символа за раз.

2. Сохраняет ли ваша функция завершающий символ конца строки? Объясните, почему.

3. Как ваша функция обрабатывает строки, оканчивающиеся CR-LF?

4. Как вы инициализируете структуру? В отдельной процедуре? С помощью документированных условий для определенных значений в структуре?

5. Как вы обозначаете конец файла? Как вы указываете, что возникла ошибка ввода/вывода? Должна ли ваша функция сообщать об ошибках? Объясните, почему.

6. Напишите программу, которая использует вашу функцию для ее тестирования, а также другую программу, создающую входные данные для первой программы. Протестируйте функцию.

7. Перепишите вашу функцию с использованием 


 и протестируйте ее. Является ли новый код более сложным или менее сложным? Какова его производительность по сравнению с версией 


?

8. Изучите страницу справки V7 для end(3) (


 в дистрибутиве V7). Пролила ли она свет на то, как может работать '


'?

9. Усовершенствуйте 


 так, чтобы она печатала расположение аргументов и переменных окружения. В какой области адресного пространства они находятся?




Глава 4

Файлы и файловый ввод/вывод



Данная глава описывает базовые файловые операции: открытие и создание файлов, чтение и запись в них, перемещение в них и их закрытие. По ходу дела она представляет стандартные механизмы для обнаружения ошибок и сообщений о них. Глава заканчивается описанием того, как установить длину файла и принудительно сбросить данные файла и вспомогательные данные на диск.




4.1. Введение в модель ввода/вывода Linux/Unix


Модель API Linux/Unix для ввода/вывода проста. Ее можно суммировать четырьмя словами. открыть, прочитать, записать, закрыть. Фактически, это имена системных вызовов: 


, 


, 


, 


. Вот их объявления:











































В следующем и дальнейших разделах мы проиллюстрируем модель, написав очень простую версию 


. Она так проста, что даже не имеет опций; все, что она делает, — объединяет содержимое двух именованных файлов и выводит его в стандартный вывод. Она выводит минимум сообщений об ошибках. Написав, мы сравним ее с V7 


.

Мы представим программу сверху вниз, начав с командной строки. В последующих разделах мы представим обработку ошибок, а затем перейдем к сущностным задачам, показав, каким образом осуществляется реальный файловый ввод/вывод.




4.2. Представление базовой структуры программы


Наша версия cat следует структуре, которая обычно является полезной. Первая часть начинается с комментариев, заголовочных файлов, объявлений и функции main():











































































































































































…продолжение далее в главе.

Переменная 


 (строка 14) используется далее для сообщений об ошибках; 


 первым делом устанавливает в ней имя программы (


). Затем 


 в цикле перечисляет аргументы. Для каждого аргумента она вызывает функцию 


.

Когда в качестве имени файла дано 


 (простая черточка, или знак минус), 


 Unix вместо попытки открыть файл с именем читает стандартный ввод. Вдобавок, 


 читает стандартный ввод, когда нет аргументов. 


 реализует оба этих поведения. Условие '


' (строка 27) истинно, когда нет аргументов имени файла; в этом случае 


 передает «


» функции 


. В противном случае, 


 перечисляет аргументы, рассматривая их как файлы, которые необходимо обработать. Если один из них окажется «


», программа обрабатывает стандартный ввод.

Если 


 возвращает ненулевое значение, это означает, что случилась какая- то ошибка. Ошибки подсчитываются в переменной 


 (строки 28 и 31). Когда 


 завершается, она возвращает 0, если не было ошибок, и 1, если были (строка 33). Это довольно стандартное соглашение, значение которого более подробно обсуждается в разделе 9.1.5.1 «Определение статуса завершения процесса».

Структура, представленная в 


, довольно общая: 


 может делать с файлом все, что мы захотим. Например (игнорируя особый случай «


»), process() также легко могла бы удалять файлы вместо их объединения!

Прежде чем рассмотреть функцию 


, нам нужно описать, как представлены ошибки системных вызовов и как осуществляется ввод/вывод. Сама функция 


 представлена в разделе 4.4.3 «Чтение и запись».




4.3. Определение ошибок


«Если неприятность может произойти, она случается»

    - Закон Мерфи -

«Будь готов»

    - Бойскауты -


Ошибки могут возникнуть в любое время. Диски могут заполниться, пользователи могут ввести неверные данные, сетевой сервер, с которого осуществляется чтение, может отказать, сеть может выйти из строя и т.д. Важно всегда проверять успешность завершения каждой операции.

Основные системные вызовы Linux почти всегда возвращают при ошибке -1 и 0 или положительное значение при успехе. Это дает возможность узнать, была операция успешной или нет:































Знания того, что произошла ошибка, недостаточно. Нужно знать, какая произошла ошибка. Для этого у каждого процесса есть предопределенная переменная с именем 


. Всякий раз, когда системный вызов завершается ошибкой, 


 устанавливается в один из набора предопределенных значений ошибок 


 и предопределенные значения ошибок определены в файле заголовка 


.













Хотя сама 


 может быть макросом, который действует подобно переменной 


 — она не обязательно является действительной целой переменной. В частности, в многопоточном окружении у каждого потока будет своя индивидуальная версия 


. Несмотря на это, практически для всех системных вызовов и функций в данной книге вы можете рассматривать 


 как простую 


.




4.3.1. Значения 





Стандарт POSIX 2001 определяет большое число возможных значений для errno. Многие из них относятся к сетям, IPC или другим специальным задачам. Справочная страница для каждого системного вызова описывает возможные значения 


, которые могут иметь место; поэтому вы можете написать код для проверки отдельных ошибок и соответствующим образом обработать их, если это нужно. Возможные значения определены через символические имена. Предусмотренные GLIBC значения перечислены в табл. 4.1.



Таблица 4.1. Значения GLIBC для 







Многие системы предоставляют также другие значения ошибок, а в более старых системах может не быть всех перечисленных значений ошибок. Полный список следует проверить с помощью справочных страниц intro(2) и errno(2) для локальной системы.



ЗАМЕЧАНИЕ. 


 следует проверять лишь после того, как возникла ошибка и до того, как сделаны дальнейшие системные вызовы. Начальное значение той переменной 0. Однако, в промежутках между ошибками ничто не изменяет ее значения, это означает, что успешный системный вызов не восстанавливает значение 0. Конечно, вы можете вручную установить ее в 0 в самом начале или когда захотите, однако это делается редко.


Сначала мы используем 


 лишь для сообщений об ошибках. Для этого имеются две полезные функции. Первая — 


:













Функция 


 выводит предоставленную программой строку, за которой следует двоеточие, а затем строка, описывающая значение 


:





















Мы предпочитаем функцию 


, которая принимает параметр со значением ошибки и возвращает указатель на строку с описанием ошибки:
















 предоставляет для сообщений об ошибках максимальную гибкость, поскольку 


 дает возможность выводить ошибки любым нужным нам способом, наподобие этого.


























По всей книге вы увидите множество примеров использования обеих функций.




4.3.2. Стиль сообщения об ошибках


Для использования в сообщениях об ошибках С предоставляет несколько специальных макросов. Наиболее широкоупотребительными являются 


 и 


, которые разворачиваются в имя исходного файла и номер текущей строки в этом файле. В С они были доступны с самого начала. C99 определяет дополнительный предопределенный идентификатор, 


, который представляет имя текущей функции в виде символьной строки. Макросы используются следующим образом:































Здесь сообщение об ошибке включает не только имя программы, но также и имя функции, имя исходного файла и номер строки. Полный список идентификаторов, полезных для диагностики, приведен в табл. 4.2.



Таблица 4.2. Диагностические идентификаторы C99




Использование 


 и 


 было вполне обычно для ранних дней Unix, когда у большинства людей были исходные коды и они могли находить ошибки и устранять их. По мере того, как системы Unix становились все более коммерческими, использование этих идентификаторов постепенно уменьшалось, поскольку знание положения в исходном коде дает немного пользы, когда имеется лишь двоичный исполняемый файл.

Сегодня, хотя системы GNU/Linux поставляются с исходными кодами, указанный исходный код часто не устанавливается по умолчанию. Поэтому использование этих идентификаторов для сообщений об ошибках не представляет дополнительной ценности. GNU Coding Standards даже не упоминает их.




4.4. Ввод и вывод



Все операции Linux по вводу/выводу осуществляются посредством дескрипторов файлов. Данный раздел знакомит с дескрипторами файлов, описывает, как их получать и освобождать, и объясняет, как выполнять с их помощью ввод/вывод.




4.4.1. Понятие о дескрипторах файлов


Дескриптор файла является целым значением. Действительные дескрипторы файлов начинаются с 0 и растут до некоторого установленного системой предела. Эти целые фактически являются индексами таблицы открытых файлов для каждого процесса (Таблица поддерживается внутри операционной системы; она недоступна запущенным программам.) В большинстве современных систем размеры таблиц большие. Команда '


' печатает это значение:











Из С максимальное число открытых файлов возвращается функцией 


 (получить размер таблицы дескрипторов):













Следующая небольшая программа выводит результат работы этой функции:






































Неудивительно, что после компиляции и запуска эта программа выводит то же значение, что и 


:











Дескрипторы файлов содержатся в обычных переменных 


; для использования с системными вызовами ввода/вывода можно увидеть типичные объявления вида '


'. Для дескрипторов файлов нет предопределенного типа.

В обычном случае каждая программа начинает свою работу с тремя уже открытыми для нее дескрипторами файлов. Это стандартный ввод, стандартный вывод и стандартная ошибка, с дескрипторами файлов 0, 1 и 2 соответственно. (Если не было использовано перенаправление, каждый из них связан с клавиатурой и с экраном.)




Очевидные символические константы. Оксюморон?

При работе с системными вызовами на основе дескрипторов файлов и стандартных ввода, вывода и ошибки целые константы 0, 1 и 2 обычно используются прямо в коде. В подавляющем большинстве случаев использование таких символических констант (manifest constants) является плохой мыслью. Вы никогда не знаете, каково значение некоторой случайной целой константы и имеет ли к ней какое-нибудь отношение константа с тем же значением, использованная в другой части кода. С этой целью стандарт POSIX требует объявить следующие именованные константы (symbolic constants) в 


:




«Номер файла» для стандартного ввода: 0.




Номер файла для стандартного вывода: 1.




Номер файла для стандартной ошибки: 2.

Однако, по нашему скромному мнению, использование этих макросов избыточно. Во-первых, неприятно набирать 12 или 13 символов вместо 1. Во-вторых, использование 0, 1 и 2 так стандартно и так хорошо известно, что на самом деле нет никаких оснований для путаницы в смысле этих конкретных символических констант.

С другой стороны, использование этих констант не оставляет сомнений в намерениях программиста. Сравните это утверждение:






Инициализируется ли 


 значением стандартного ввода, или же программист благоразумно инициализирует свои переменные подходящим значением? Вы не можете этого сказать.

Один из подходов (рекомендованный Джеффом Колье (Geoff Collyer)) заключается в использовании следующего определения 


:






Затем эти константы можно использовать вместо 0, 1 и 2. Их легко читать и печатать.





4.4.2. Открытие и закрытие файлов



Новые дескрипторы файлов получают (наряду с другими источниками) в результате системного вызова 


. Этот системный вызов открывает файл для чтения или записи и возвращает новый дескриптор файла для последующих операций с этим файлом. Мы видели объявление раньше:




























Три аргумента следующие:






Строка С, представляющая имя открываемого файла.






Поразрядное ИЛИ с одной или более констант, определенных в 


. Вскоре мы их рассмотрим.






Режимы доступа для создаваемого файла. Это обсуждается далее в главе, см. раздел 4.6 «Создание файлов». При открытии существующего файла опустите этот параметр[46 - 


 является одним из немногих варьирующих (variadic) системных вызовов — Примеч. автора.].

Возвращаемое open() значение является либо новым дескриптором файла, либо -1, означающим ошибку, в этом случае будет установлена 


. Для простого ввода/вывода аргумент 


 должен быть одним из значений из табл. 4.3.



Таблица 4.3. Значения 


 для 







Вскоре мы увидим пример кода. Дополнительные значения 


 описаны в разделе 4.6 «Создание файлов». Большой объем ранее написанного кода Unix не использовал эти символические значения. Вместо этого использовались числовые значения. Сегодня это рассматривается как плохая практика, но мы представляем эти значения, чтобы вы их распознали, если встретитесь с ними

Системный вызов 


 закрывает файл: его элемент в системной таблице дескрипторов файлов помечается как неиспользуемый, и с этим дескриптором нельзя производить никаких дальнейших действий. Объявление следующее:













В случае успеха возвращается 0, при ошибке (-1). При возникновении ошибки нельзя ничего сделать, кроме сообщения о ней. Ошибки при закрытии файлов являются необычными, но не невозможными, особенно для файлов, доступ к которым осуществляется через сеть. Поэтому хорошей практикой является проверка возвращаемого значения, особенно для файлов, открытых для записи.

Если вы будете игнорировать возвращаемое значение, специально приведите его к типу 


, чтобы указать, что вам не нужен результат:






Легкомысленность этого совета в том, что слишком большое количество приведений к 


 имеют тенденцию загромождать код. Например, несмотря на принцип «всегда проверять возвращаемое значение», чрезвычайно редко можно увидеть код, проверяющий возвращаемое значение 


 или приводящий его к 


. Как и со многими аспектами программирования на С, здесь также требуются опыт и рассудительность.

Как упоминалось, число открытых файлов, если оно большое, ограничивается, и вам всегда следует закрывать файлы, когда работа с ними закончена. Если вы этого не сделаете, то в конечном счете выйдете за пределы лимита дескрипторов файлов, создав ситуацию, которая ведет к потере устойчивости части вашей программы.

Система закрывает все открытые файлы, когда процесс завершается, но — за исключением 0, 1 и 2 — плохая манера полагаться на это.

Когда 


 возвращает новый дескриптор файла, она всегда возвращает наименьшее неиспользуемое целое значение. Всегда. Поэтому, если открыты дескрипторы файлов 0–6 и программа закрывает дескриптор файла 5, следующий вызов 


 вернет 5, а не 7. Это поведение важно; далее в книге мы увидим, как оно используется для аккуратной реализации многих важных особенностей Unix, таких, как перенаправление ввода/вывода и конвейеризация (piping)




4.4.2.1. Отображение переменных 


 на дескрипторы файлов


Стандартные библиотечные функции ввода/вывода и переменные 


 из 


, такие, как 


, 


 и 


, построены поверх основанных на дескрипторах файлов системных вызовах.

Иногда полезно получить непосредственный доступ к дескриптору файла, связанному с указателем файла 


, если вам нужно сделать что-либо, не определенное стандартом С ISO. Функция 


 возвращает лежащий в основе дескриптор файла:













Пример мы увидим позже, в разделе 4.4.4. «Пример: Unix cat».




4.4.2.2. Закрытие всех открытых файлов


Открытые файлы наследуются порожденными процессами от своих родительских процессов. Фактически они являются общими. В частности, общим является положение в файле. Подробности мы оставим для дальнейшего обсуждения в разделе 9.1.1.2 «Разделение дескрипторов файлов».

Поскольку программы могут наследовать другие файлы, иногда вы можете увидеть программы, которые закрывают все свои файлы, чтобы начать с «чистого состояния» В частности, типичен код наподобие этого:





















Предположим, что результат 


 равен 1024. Этот код работает, но он делает (1024-3)*2 = 2042 системных вызова. 


 из них не нужны, поскольку возвращаемое значение 


 не изменяется. Вот лучший вариант этого кода:
















Такая оптимизация не ухудшает читаемость кода, но может быть заметна разница, особенно на медленных системах. В общем, стоит поискать случаи, когда в циклах повторно вычисляется один и тот же результат, чтобы посмотреть, нельзя ли вынести вычисление за пределы цикла. Хотя в таких случаях нужно убедиться, что вы (а) сохраняете правильность кода и (б) сохраняете его читаемость!




4.4.3. Чтение и запись


Ввод/вывод осуществляется системными вызовами 


 и 


 соответственно:

































Каждая функция сделана как можно проще. Аргументами являются дескриптор открытого файла, указатель на буфер для чтения или записи данных и число читаемых или записываемых байтов.

Возвращаемое значение является числом действительно прочитанных или записанных байтов. (Это число может быть меньше запрошенного: при операции чтения это происходит, когда в файле осталось меньше 


 байтов, а при операции записи это случается, когда диск заполнен или произошла еще какая-нибудь ошибка.) Возвращаемое значение -1 означает возникшую ошибку, в этом случае errno указывает эту ошибку. Когда 


 возвращает 0, это означает, что достигнут конец файла.

Теперь мы можем показать оставшуюся часть кода для 


. Процедура 


 использует 0 для стандартного ввода, если именем файла является «


» (строки 50 и 51). В противном случае она открывает данный файл:










































































































Буфер 


 (строка 47) имеет размер 


; эта константа определена В 


 как «оптимальный» размер блока для ввода/вывода. Хотя значение 


 различается в разных системах, код, использующий эту константу, чистый и переносимый.

Основой процедуры является следующий цикл, который повторно читает данные до тех пор, пока не будет достигнут конец файла или не возникнет ошибка.














































Переменные 


 и 


 (строка 45) имеют тип 


, «знаковый 


», который позволяет хранить в них отрицательные значения. Обратите внимание, что число байтов, переданное 


, является значением, возвращенным 


 (строка 59). Хотя мы хотим читать порциями фиксированного размера в 


, маловероятно, что размер самого файла кратен 


. При чтении из файла завершающей, меньшей порции байтов, возвращаемое значение указывает, сколько байтов buffer получили новые данные. В стандартный вывод должны быть скопированы только эти байты, а не весь буфер целиком.

Условие '


' в строке 60 является правильным способом проверки на ошибки; если были записаны некоторые, но не все данные, 


 будет больше нуля, но меньше 


.

В заключение 


 проверяет наличие ошибок чтения (строки 68–72), а затем пытается закрыть файл. В случае (маловероятном) неудачного завершения 


 (строка 75) она выводит сообщение об ошибке. Избежание закрытия стандартного ввода не является абсолютно необходимым в данной программе, но является хорошей привычкой при разработке больших программ, в случае, когда другой код где-то в другом месте хочет что-то с ним делать или если порожденная программа будет наследовать его. Последний оператор (строка 82) возвращает 1, если были ошибки, и 0 в противном случае.




















































































 проверяет на ошибки каждый системный вызов. Хотя это утомительно, зато предоставляет устойчивость (или по крайней мере, ясность): когда что-то идет не так, 


 выводит сообщение об ошибке, которое специфично настолько, насколько это возможно. В сочетании с 


 и 


 это просто. Вот все с 


, всего 88 строк кода!

Для подведения итогов вот несколько важных моментов, которые нужно понять относительно ввода/вывода в Unix:

Ввод/вывод не интерпретируется

Системные вызовы ввода/вывода просто перемешают байты. Они не интерпретируют данные; вся интерпретация оставлена программе уровня пользователя. Это делает чтение и запись двоичных структур таким же простым, как чтение и запись строк текста (на самом деле, проще, хотя использование двоичных данных привносит проблемы переносимости).

Ввод/вывод гибок

За один раз вы можете прочесть или записать столько байтов, сколько захотите. Вы можете даже читать или записывать данные по одному байту за раз, хотя для больших объемов данных это обходится дороже, чем использование больших порций.

Ввод/вывод прост

Три уровня возвращаемых значений (отрицательные для ошибок, ноль для конца файла и положительные для счета) делают программирование простым и очевидным.

Ввод/вывод может быть частичным

Как 


, так и 


 могут переместить меньше байтов, чем запрошено. Код приложения (т.е. ваш код) всегда должен учитывать это.




4.4.4. Пример: Unix 





Как и было обещано, вот версия cat V7[47 - См. 


 в дистрибутиве V7. Программа без изменений компилируется для GNU/Linux. — Примеч. автора.]. Она начинается с проверки опций, 


 V7 принимает единственную опцию, 


, для осуществления небуферированного вывода.

Общая структура сходна с той, которую мы видели ранее; программа перечисляет файлы, указанные в аргументах командной строки и читает каждый файл, по одному символу за раз, посылая этот символ в стандартный вывод. В отличие от нашей версии, она использует возможности 


. Во многих случаях код, использующий стандартную библиотеку ввода/вывода, проще читать и писать, поскольку все проблемы с буферами скрыты библиотекой.




























































































































































































































































































































Следует заметить, что программа всегда завершается успешно (строка 62); можно было написать ее так, чтобы отмечать ошибки и указывать их в возвращаемом значении 


. (Механизм завершения процесса и значение различных кодов завершения обсуждаются в разделе 9.1.5.1 «Определение статуса завершения процесса».)

Код, работающий с 


 и функцией 


 (строки 31–36 и 50–56), без сомнения, непрозрачен, поскольку мы еще не рассматривали эти функции и не будем рассматривать до следующей главы (Но обратите внимание на использование 


 в строке 50 для получения нижележащего дескриптора файла, связанного с переменными 


.) Идея в основе этого кода заключается в том, чтобы убедиться, что входной и выходной файлы не совпадают. Это предназначено для предотвращения бесконечного роста файла, в случае подобной команды:






И конечно же, проверка работает:
















Если вы попробуете это с 


, программа продолжит работу, и 


 будет расти до тех пор, пока вы не прервете ее. GNU версия 


 осуществляет эту проверку. Обратите внимание, что что-то вроде этого выходит за рамки контроля 


:





















В данном случае это слишком поздно, поскольку оболочка урезала файл 


 (посредством оператора 


) еще до того, как 


 получила возможность исследовать файл! В разделе 5.4.4.2 «Возвращаясь к V7 cat» мы объясним код с 


.




4.5. Произвольный доступ: перемещения внутри файла


До сих пор мы обсуждали последовательный ввод/вывод, при котором данные читаются или записываются с начала файла и продолжаются до его конца. Часто это все, что требуется программе. Однако, возможно осуществление произвольного ввода/вывода; т.е. читать данные из произвольного положения в файле без необходимости предварительного чтения всего, что находится перед этим местом.

Смещение дескриптора файла является положением внутри открытого файла, начиная с которого будет осуществляться следующая операция чтения или записи. Программа устанавливает смещение с помощью системного вызова 


:


















Тип 


 (тип смещения) является знаковым целым, представляющим позиции байтов (смещений от начала) внутри файла. На 32-разрядных системах тип представлен обычно как 


. Однако, многие современные системы допускают очень большие файлы, в этом случае 


 может быть более необычным типом, таким, как C99 


 или какой-нибудь другой расширенный тип. 


 принимает три следующих аргумента.






Дескриптор открытого файла.






Позиция, в которую нужно переместиться. Интерпретация этого значения зависит от параметра 


. 


 может быть положительным или отрицательным; отрицательные значения перемещают к началу файла; положительные значения перемещают к концу файла.






Описывает положение в файле, относительно которого отсчитывается 


. См. табл. 4.4.



Таблица 4.4. Значения 


 для 







Большое количество старого кода использует числовые значения, приведенные в табл. 4.4. Однако, любой новый код, который вы пишете, должен использовать символические имена, значение которых более ясно.

Смысл значений и их действие на положение в файле показаны на рис. 4.1. При условии, что файл содержит 3000 байтов и что перед каждым вызовом 


 текущим является смещение 2000 байтов, новое положение после каждого вызова будет следующим.




Рис. 4.1. Смещения для 




Отрицательные смещения относительно начала файла бессмысленны; они вызывают ошибку «недействительный параметр».

Возвращаемое значение является новым положением в файле. Поэтому, чтобы получить ваше текущее местоположение в файле, используйте
















Буква 


 в 


 означает 


. 


 был введен в V7 Unix, когда размеры файлов были увеличены; в V6 был простой системный вызов 


. В результате большое количество старой документации (и кода) рассматривает параметр offset как имеющий тип 


, и вместо приведения к типу 


 довольно часто можно видеть суффикс L в константных значениях смешений:






На системах с компилятором стандартного С, где 


 объявлена с прототипом, такой старый код продолжает работать, поскольку компилятор автоматически преобразует 0L из 


 в 


, если это различные типы.

Одной интересной и важной особенностью 


 является то, что она способна устанавливать смещение за концом файла. Любые данные, которые впоследствии записываются в это место, попадают в файл, но с образованием «интервала» или «дыры» между концом предыдущих данных файла и началом новых данных. Данные в промежутке читаются, как если бы они содержали все нули.

Следующая программа демонстрирует создание дыр. Она записывает три экземпляра 


 в начало, середину и дальний конец файла. Выбранные смешения (строки 16–18, третий элемент каждой структуры) произвольны, но достаточно большие для демонстрации особенности:




































































































































































































Строки 27–30 гарантируют, что программа была вызвана правильно. Строки 32–37 открывают именованный файл и проверяют успешность открытия.

Вычисление числа элементов 


 массива в строке 39 использует отличный переносимый трюк число элементов является размером всего массива, поделенного на размер первого элемента. Красота этого способа в том, что он всегда верен: неважно, сколько элементов вы добавляете в массив или удаляете из него, компилятор это выяснит. Он не требует также завершающей сигнальной метки; т.е. элемента, в котором все поля содержат нули, 


 или т.п.

Работа осуществляется в цикле (строки 41–55), который отыскивает смещение байтов, приведенное в каждой структуре (строка 42), а затем записывает всю структуру (строка 49):





































































































Вот результаты запуска программы:


























Случайно мы знаем, что каждый дисковый блок файла использует 4096 байтов. (Откуда мы это знаем, обсуждается в разделе 5 4.2 «Получение информации о файле». Пока примите это как данное.) Финальная команда bc указывает, что файлу размером 81944 байтов нужен 21 дисковый блок. Однако, опция -s команды ls, которая сообщает нам, сколько блоков использует файл на самом деле, показывает, что файл использует лишь 16 блоков![48 - По крайней мере, три из этих блоков содержат данные, которые мы записали, другие для использования операционной системой при отслеживании размещения этих данных — Примеч. автора.] Отсутствующие блоки в файле являются дырами. Это показано на рис. 4.2.




Рис. 4.2. Дыры в файле



ЗАМЕЧАНИЕ. 


 не осуществляет непосредственный двоичный ввод/вывод. Это хорошо демонстрирует красоту ввода/вывода с произвольным доступом: вы можете рассматривать дисковый файл, как если бы он был очень большим массивом двоичных структур данных.

На практике сохранение данных путем использования двоичного ввода/вывода является решением, которое необходимо тщательно взвесить. Например, что если предположить, что вам нужно переместить данные на систему, использующую отличный порядок байтов для целых? Или другие форматы чисел с плавающей точкой? Или на систему с другими требованиями выравнивания? Игнорирование подобных вопросов может стать слишком дорогостоящим.





4.6. Создание файлов



Как было описано ранее, 


, очевидно, открывает лишь существующие файлы. Данный раздел описывает, как создавать новые файлы. Есть две возможности: 


 и 


 с дополнительными файлами. Первоначально 


 был единственным способом создания файла, но затем эта возможность была добавлена также и к 


. Оба механизма требуют указания начальных прав доступа к файлу.




4.6.1. Определение начальных прав доступа к файлу


Как пользователь GNU/Linux, вы знакомы с правами доступа к файлу, выдаваемыми командой '


': на чтение, запись и исполнение для каждого из владельца файла, группы и остальных. Различные сочетания часто выражаются в восьмеричной форме, в частности, для команд 


 и 


. Например, права доступа к файлу 


r-- эквивалентны восьмеричному 0644, a 


 эквивалентно восьмеричному 0755. (Ведущий 0 в нотации С означает восьмеричные значения.)

Когда вы создаете файл, вы должны знать, какую защиту необходимо назначить новому файлу. Вы можете сделать это с помощью простого восьмеричного числа, если захотите, и такие числа довольно обычно можно увидеть в старом коде. Однако, лучше использовать побитовую операцию OR для одной или более символических имен из 


, описанных в табл. 4.5.



Таблица 4.5. Символические имена POSIX для режимов доступа к файлу




Следующий фрагмент показывает, как создать переменные, представляющие разрешения 


 и 


 (0644 и 0755 соответственно):
















Более старый код использовал 


, 


 и 


 вместе со сдвигом битов для получения того же результата:





















К сожалению, ни одна из записей не является очень удобной. Современные версии предпочтительнее, поскольку у каждого бита доступа есть собственное имя и меньше вероятность неправильного выполнения побитовых операций.

При изменении прав доступа к файлу для использования доступны биты дополнительных разрешений, показанные в табл. 4.6, но они не должны использоваться при первоначальном создании файла. Возможность включения этих битов широко варьирует между операционными системами. Лучше всего не пробовать; вместо этого следует изменить права доступа к файлу явным образом после его создания. (Изменение прав доступа описано в разделе 5.5.2 «Изменение прав доступа: 


 и 


». Значения этих битов обсуждаются в главе 11 «Права доступа и идентификаторы пользователя и группы».)



Таблица 4.6. Дополнительные символические имена POSIX для режимов доступа к файлам




Когда стандартные утилиты создают файлы, они по умолчанию используют права доступа 


 (или 0666). Поскольку большинство пользователей предпочитают избегать файлов, в которые может записывать кто угодно, каждый процесс имеет при себе umask. 


 является набором битов допуска, указывающим те биты, которые никогда не должны устанавливаться при создании новых файлов, (umask не используется при изменении прав доступа.) Концептуально осуществляется операция









 обычно устанавливается с помощью команды 


 в 


, когда вы входите в систему. Из программы С она устанавливается с помощью системного вызова 


.











Возвращается старое значение 


. Поэтому для определения текущей маски нужно установить новое значение, а затем восстановить старое (или изменить его при необходимости):











Вот пример работы 


 на уровне оболочки:

















































4.6.2. Создание файлов с помощью 





Системный вызов 


[49 - Да, это пишется так. Кена Томпсона (Ken Thompson), одного из двух «отцов» Unix, однажды спросили, что бы он сделал по-другому, если бы ему пришлось переделать Unix. Он ответил, что написал бы 


 с «e» на конце. И в самом деле, именно это он сделал для операционной системы Plan 9 From Bell Labs — Примеч. автора.] создает новые файлы. Он объявлен следующим образом:























Аргумент 


 представляет права доступа к новому файлу (как обсуждалось в предыдущем разделе). Создается файл с именем 


 данными правами доступа, модифицированными с использованием 


. Он открыт (только) для чтения, а возвращаемое значение является дескриптором нового файла или -1, если была проблема. В последнем случае 


 указывает ошибку. Если файл уже существует, он будет при открытии урезан.

Во всех остальных отношениях дескрипторы файлов, возвращаемые 


, являются теми же самыми, которые возвращаются 


; они используются для записи и позиционирования и должны закрываться при помощи 


:





























4.6.3. Возвращаясь к open()


Вы можете вспомнить объявление для 


:






Ранее мы сказали, что при открытии файла для простого ввода/вывода мы можем игнорировать аргумент 


. Хотя, посмотрев на 


, вы, возможно, догадались, что 


 также может использоваться для создания файлов и что в этом случае используется аргумент 


. Это в самом деле так.

Помимо флагов 


, 


 и 


, при вызове 


 могут добавляться с использованием поразрядного 


 дополнительные флаги. Стандарт POSIX предоставляет ряд этих дополнительных флагов. В табл. 4.7 представлены флаги, которые используются для большинства обычных приложений.



Таблица 4.7. Дополнительные флаги POSIX для 







Если даны 


 и 


, можно представить, как оболочка могла бы открывать или создавать файлы, соответствующие операторам 


 и 


. Например:


























Обратите внимание, что флаг 


 здесь не используется, поскольку как для 


, так и для 


 не является ошибкой существование файла. Запомните также, что система применяет к запрошенным правам доступа 


.

Также легко видеть, что, по крайней мере концептуально, 


 можно было бы легко написать следующим образом:


















ЗАМЕЧАНИЕ. Если файл открыт с флагом 


, все данные будут записаны в конец файла, даже если текущее смещение было восстановлено с помощью 


.


Современные системы предоставляют дополнительные флаги с более специализированным назначением. Они кратко описаны в табл. 4.8.



Таблица 4.8. Дополнительные расширенные флаги POSIX для 







Флаги 


, 


 и 


 требуют некоторых пояснений. Системы Unix (включая Linux) содержат внутренний кэш дисковых блоков, который называется буферным кэшем (buffer cache). Когда возвращается системный вызов 


, данные, переданные операционной системе, были скопированы в буфер в буферном кэше. Они необязательно были записаны на диск.

Буферный кэш значительно повышает производительность: поскольку дисковый ввод/ вывод часто на порядок и медленнее операций центрального процессора и памяти, программы значительно снизили бы производительность, если бы им пришлось ждать завершения каждой записи на диск. Вдобавок, если данные были недавно записаны на диск, при последующем чтении тех же данных они уже находились бы в буферном кэше, откуда их можно вернуть немедленно, не дожидаясь завершения операции чтения с диска.

Системы Unix осуществляют также опережающее чтение; поскольку чтение в большинстве случаев последовательное, операционная система после прочтения одного блока осуществляет чтение нескольких дополнительных последовательных блоков таким образом, что эта информация будет уже находиться в кэше, когда программа ее запросит. Если один и тот же файл читают несколько программ, они все получают преимущество, поскольку все получают свои данные из одной копии дисковых блоков файла в буферном кэше.

Все это кэширование, конечно, замечательно, но бесплатного обеда не бывает. В то время, пока данные находятся в буферном кэше и до того, как они будут записаны на диск, есть небольшое, но вполне реальное окно, в котором может случиться катастрофа; например, если выключат питание. Современные дисковые приводы обостряют эту проблему: у многих из них есть собственные внутренние буферы, поэтому при записи данных на диск они могут оказаться не записанными на носитель при выключении питания! Это может быть значительной проблемой для небольших систем, которые не находятся в информационном центре с контролируемым энергоснабжением или не имеют источников бесперебойного питания (UPS).[50 - Если у вас нет UPS и вы используете систему для критической работы, мы настоятельно рекомендуем вам обзавестись им. Следует также регулярно делать резервные копии. — Примеч. автора.]

Для большинства приложений вероятность того, что данные в буферном кэше могут быть нечаянно потеряны, довольно низка. Однако, для некоторых приложений любой такой шанс неприемлем. Поэтому в системе Unix было введено понятие синхронного ввода/вывода, при котором программе гарантируется, что по возвращении из системного вызова данные безопасно записаны на физическое устройство хранения.

Флаг 


 гарантирует целостность данных; данные и любая другая информация, которую операционная система должна найти, записываются на диск до возвращения 


. Однако, вспомогательные данные, такие, как время модификации или доступа к файлу, могут быть не записаны на диск. Флаг 


 требует, чтобы эти данные также были записаны на диск до возвращения 


. (Здесь тоже нет бесплатного обеда; синхронные записи могут серьезно повлиять на производительность программы, заметно ее снизив.)

Флаг 


 предназначен для чтения данных: если 


 находит данные в буферном кэше, которые были назначены для записи на диск, функция не вернет эти данные до тех пор, пока они не будут записаны. Два других флага влияют на это: в частности, 


 заставит 


 ждать, пока не будут также записаны и вспомогательные данные.



ЗАМЕЧАНИЕ. Что касается ядра версии 2.4, Linux рассматривает все три флага одинаково со значением флага 


. Более того, Linux определяет дополнительные флаги, которые специфичны для Linux и предназначены для специального использования. Дополнительные подробности см. в справочной странице GNU/Linux для open(2).





4.7. Форсирование записи данных на диск


Ранее мы описали флаги 


, 


 и 


 для 


. Мы отметили, что использование этих флагов может замедлить программу, поскольку 


 не возвращается до тех пор, пока все данные не будут записаны на физический носитель.

Со слегка более высоким уровнем риска мы можем сами испечь свое пирожное и съесть его. Это осуществляется путем открытия файла без указания флагов 


, но с последующим использованием одного из следующих двух системных вызовов в любой момент, когда это необходимо для безопасного перемещения данных на физический носитель:


















Системный вызов 


 подобен 


: он форсирует запись данных на конечное физическое устройство. Системный вызов 


 подобен 


, форсируя запись на физическое устройство не только данных файла, но и вспомогательных данных. Вызов 


 более переносим; он существовал в мире Unix в течение более продолжительного времени, и вероятность его наличия среди широкого ряда систем больше.

Можно использовать эти вызовы с указателями файлов 


, вызвав сначала 


, а затем 


 для получения дескриптора нижележащего файла. Вот функция 


, которая может использоваться для заключения обеих операций в один вызов. Она возвращает в случае успеха 0:































Технически оба этих вызова являются расширениями базового стандарта POSIX: 


 в расширении «Синхронизация файлов» (FSC), a 


 в расширении «Синхронизированный ввод и вывод». Тем не менее, можно без проблем использовать их в системе GNU/Linux




4.8. Установка длины файла


Два системных вызова позволяют настраивать размер файла:























Как должно быть очевидно из параметров, 


 принимает аргумент имени файла, тогда как 


 работает с дескриптором открытого файла. (Обычным является соглашение по именованию пар системных вызовов 


 и 


, работающих с именами файлов и дескрипторами файлов. Мы увидим несколько примеров в данной и последующих главах.) В обоих случаях аргумент 


 является новым размером файла.

Этот системный вызов происходит от 4.2 BSD Unix, и на ранних системах мог использоваться лишь для сокращения длины файла, отсюда и название. (Он был создан, чтобы облегчить реализацию операции урезания в Фортране.) На современных системах, включая Linux, имя является неправильным, поскольку с помощью этих вызовов можно также увеличить, а не только сократить длину файла. (Однако, POSIX указывает, что возможность увеличения размера файла относится к расширению XSI.)

Для этих вызовов сокращаемый файл должен иметь разрешение на запись (для 


), или должен быть открыт для записи (для 


). Если файл сокращается, все данные после нового конца файла теряются. (Поэтому вы не можете сократить файл, снова удлинить его и найти там первоначальные данные.) Если файл-расширен, как в случае записи данных после 


, данные между старым концом файла и новым концом файла читаются как нули.

Эти вызовы сильно отличаются от '


', который полностью урезает файл, отбрасывая все его данные. Эти же вызовы просто устанавливают абсолютную длину файла в данное значение.

Эти функции довольно специализированы; они используются лишь четыре раза во всем коде GNU Coreutils. Мы представляем пример использования 


 в разделе 5.5.3 «Изменение отметок времени: 


».




4.9. Резюме


• Когда системный вызов завершается неудачей, он обычно возвращает -1, а в глобальной переменной errno устанавливается предопределенное значение, указывающее на проблему. Для сообщений об ошибках могут использоваться функции 


 и 


.

• Доступ к файлам осуществляется через небольшие целые, которые называются дескрипторами. Дескрипторы файлов для стандартного ввода, стандартного вывода и стандартной ошибки наследуются от родительского процесса программы. Другие получаются через 


 или 


. Для их закрытия используется 


, a 


 возвращает разрешенное максимальное число открытых файлов. Значение 


 (устанавливаемое с помощью 


) влияет на права доступа, получаемые новыми файлами при создании с помощью 


 или с флагом 


 для 


.

• Системные вызовы 


 и 


 соответственно читают и записывают данные. Их интерфейс прост. В частности, они не интерпретируют данные, файлы представлены линейными потоками байтов. Системный вызов 


 осуществляет ввод/выводе произвольным доступом: возможность перемещаться внутри файла.

• Для синхронного ввода/вывода предусмотрены дополнительные флаги для 


, при этом данные записываются на физический носитель данных до возвращения 


 или 


. Можно также форсировать запись данных на диск на управляемой основе с помощью 


 или 


.

• Системные вызовы 


 и 


 устанавливают абсолютную длину файла. (На более старых системах они могут использоваться лишь для сокращения длины файла; на современных системах они могут также увеличивать файл.)




Упражнения


1. Используя лишь 


, 





 и 


, напишите простую программу 


, которая копирует файл, имя которого дается в первом аргументе, в файл с именем во втором аргументе.

2. Усовершенствуйте программу 


 так, чтобы она принимала "


" в значении «стандартный ввод» при использовании в качестве первого аргумента и в значении «стандартный вывод» в качестве второго аргумента. Правильно ли работает '


'?

3. Просмотрите страничку справки для proc(5) на системе GNU/Linux. В частности, посмотрите подраздел 


. Выполните '


' и непосредственно проверьте файлы в 


. Если бы 


 и дружественные устройства были бы в ранних версиях Unix, как это упростило бы код для программы V7 


? (Во многих других современных системах Unix есть каталог или файловая система 


. Если вы не используете GNU/Linux, посмотрите, что вы можете обнаружить в своей версии Unix.)

4. Даже если вы пока этого не понимаете, постарайтесь скопировать сегмент кода из V7 


, который использует 


 и функцию 


, в 


, чтобы она также сообщала об ошибке для '


'.

5. (Простое) Предположив наличие 


, напишите свою версию 


.

6. Каков результат выполнения '


' на вашей системе?

7. Напишите простую версию программы 


, назвав ее 


, которая принимает в командной строке восьмеричную маску. Используйте 


 с основанием 8 для преобразования строки символов аргумента командной строки в целое значение. Измените 


 с помощью системного вызова 


.

Откомпилируйте и запустите 


, затем проверьте значение 


 с помощью стандартной команды 


. Объясните результаты. (Подсказка: в оболочке Bash введите '


'.)

8. Измените простую программу 


, которую вы написали ранее, для использования 


 с флагом 


. Используя команду 


, сравните характеристики первоначальной и новой версии большого файла.

9. Мы сказали, что для 


 файл должен быть открыт для записи. Как можно открыть файл для записи, когда у самого файла нет доступа записи?

10. Напишите программу 


, которая используется следующим образом: '


'.




Глава 5

Каталоги и служебные данные файлов



Данная глава продолжает подъем по кривой обучения до следующего плато: понимания каталогов и информации о файлах.

В данной главе мы исследуем то, как информация хранится в каталоге, как читаются, создаются и удаляются сами каталоги, какая информация о файлах доступна и как ее получить. Наконец, мы рассмотрим другие способы обновления служебных данных файлов, таких, как владелец, группа, права доступа и время доступа и изменения файла.




5.1. Просмотр содержимого каталога



Все Unix-системы, включая Linux, используют для хранения файловой информации на диске один и тот же концептуальный дизайн. Хотя в реализации дизайна есть значительные вариации, интерфейс на уровне С остается постоянным, давая возможность писать переносимые программы, которые компилируются и запускаются на многих различных системах.




5.1.1. Определения





Рис. Copyright 1997-2004 © J.D. «Illiad» Frazer. Использовано по разрешению, http://www.userfriendly.org

Мы начнем обсуждение с определения нескольких терминов.

Раздел (partition)

Единица физического хранилища. Физические разделы обычно являются либо частями диска, либо целым диском. Современные системы дают возможность создавать из нескольких физических логические разделы.

Файловая система (filesystem)

Раздел (физический или логический), содержащий данные файла и служебные данные (metadata), информацию о файлах (в противоположность содержимому файла, которое является информацией в файле). Такие служебные данные включают владельца файла, права доступа, размер и т.д., а также информацию, использующуюся операционной системой при поиске содержимого файла. Файловые системы размещаются «в» разделах (соотношение одни к одному) посредством записи в них стандартной информации. Это осуществляется программой уровня пользователя, такой, как 


 в GNU/Linux или 


 в Unix. (Команда Unix 


 создает разделы, но ее трудно использовать, непосредственно, 


 вызывает ее с нужными параметрами. Если ваша система является системой Unix, подробности см. в справочных страницах для newfs(8) и mkfs(8).)

Большей частью GNU/Linux и Unix скрывают наличие файловых систем и разделов. (Дополнительные подробности приведены в разделе 8.1 «Монтирование и демонтирование файловых систем».) Доступ ко всему осуществляется через пути, безотносительно к тому, на каком диске расположен файл. (Сравните это с почти любой коммерческой операционной системой, такой, как OpenVMS, или с поведением по умолчанию любой системы Microsoft.)

Индекс (inode)

Сокращение от '


' (индексный узел), первоначально сокращалось '


', а теперь пишется '


'. Небольшой блок информации, содержащий все сведения о файле, за исключением имени файла. Число индексов и, следовательно, число уникальных файлов в файловой системе, устанавливается и делается постоянным при создании файловой системы. Команда '


' может показать, сколько имеется индексов и сколько из них используется.

Устройство (device)

В контексте файлов, файловых систем и служебных данных файлов, уникальный номер, представляющий используемую («смонтированную») файловую систему. Пара (устройство, индекс) однозначно идентифицирует файл: два различных файла будут гарантированно иметь различные пары (устройство, индекс). Более подробно это обсуждается далее в этой главе.

Каталог (directory)

Специальный файл, содержащий список пар (индекс, имя). Каталоги могут быть открыты для чтения, но не для записи; все изменения в содержимом каталога делает операционная система.

Концептуально каждый дисковый блок содержит либо некоторое число индексов, либо данные файла. Индекс, в свою очередь, содержит указатели на блоки, содержащие данные файла. См. рис. 5.1.




Рис. 5.1. Концептуальное представление индексов и блоков данных

На рисунке показаны все блоки индексов перед разделом и блоки данных после них. Ранние файловые системы Unix были организованы именно таким способом. Однако, хотя все современные системы до сих пор содержат индексы и блоки данных, их организация для повышения эффективности и устойчивости была изменена. Детали меняются от системы к системе, и даже в рамках систем GNU/Linux имеется множество разновидностей файловых систем, но концепция остается той же самой.




5.1.2. Содержимое каталога


Каталоги устанавливают связь между именем файла и индексом. Элементы каталога содержат номер индекса и имя файла. Они содержат также дополнительную учетную информацию, которая нам здесь не интересна. См. рис. 5.2.




Рис. 5.2. Концептуальное содержание каталога

На ранних Unix-системах были двухбайтные номера индексов, а имена файлов — до 14 байтов. Вот полное содержание файла V7 


:









































 определен в V7 


 как '


'. Поскольку на PDP-11 


 является 16-разрядным, таким же является и 


. Такая организация упрощала непосредственное чтение каталогов; поскольку размер элемента был фиксирован, код был простым. (Единственно, за чем нужно было следить, это то, что полное 14-символьное 


 не завершалось символом NUL.)

Управление содержанием каталога для системы также было простым. Когда файл удалялся из каталога, система заменяла номер индекса двоичным нулем, указывая, что элемент каталога не используется. Новые файлы могли потом использовать пустой элемент повторно. Это помогало поддерживать размер самих файлов каталогов в приемлемых рамках. (По соглашению, номер индекса 1 не используется; первым используемым индексом всегда является 2. Дополнительные сведения приведены в разделе 8.1 «Монтирование и демонтирование файловых систем».)

Современные системы предоставляют длинные имена файлов. Каждый элемент каталога имеет различную длину, с обычным ограничением для компонента имени файла каталога в 255 байтов. Далее мы увидим, как читать на современных системах содержимое каталога. Также в современных системах номера индексов 32 (или даже 64!) разрядные.




5.1.3. Прямые ссылки



Когда файл создается с помощью 


 или 


, система находит не использующийся индекс и присваивает его новому файлу. Она создает для файла элемент каталога с именем файла и номером индекса. Опция 


 команды 


 отображает номер индекса.
















Поскольку элементы каталога связывают имена файлов с индексами, у одного файла может быть несколько имен. Каждый элемент каталога, ссылающийся на один и тот же индекс, называется ссылкой (link) или прямой ссылкой (hard link) на файл. Ссылки создаются с помощью команды 


. Она используется следующим образом: '


'.































Вывод показывает, что номера индексов двух файлов одинаковые, а третье поле расширенного вывода теперь равно 2. Это поле показывает счетчик ссылок, указывающий, сколько имеется ссылок (элементов каталога, ссылающихся на данный индекс) на данный файл.

Нельзя не подчеркнуть: прямые ссылки все относятся к одному и тому же файлу. Если вы измените один файл, изменятся и все остальные:































Хотя мы создали две ссылки на один файл в одном каталоге, прямые ссылки не обязательно должны находиться в одном и том же каталоге; они могут находиться в любом каталоге в той же самой файловой системе. (Несколько подробнее это обсуждается в разделе 5.1.6 «Символические ссылки».)

Вдобавок, вы можете создать ссылку на файл, который вам не принадлежит, если у вас есть право записи в каталоге, в котором вы создаете ссылку. (Такой файл сохраняет все атрибуты первоначального файла: владельца, права доступа и т.д. Это потому, что это и есть оригинальный файл; просто он получил дополнительное имя.) Код уровня пользователя не может создать прямую ссылку на каталог.

После удаления ссылки создание еще одного файла с прежним именем создает новый файл:


























Обратите внимание, что теперь счетчик ссылок каждого из файлов равен 1. На уровне С ссылки создаются с помощью системного вызова 


:











При успешном создании ссылки возвращается 0, в противном случае (-1), при этом errno отражает ошибку. Важным-случаем ошибки является тот, когда 


 уже существует. Система не удалит его для вас, поскольку попытка сделать это может вызвать несовместимости в файловой системе.




5.1.3.1. Программа GNU link


Программа 


 сложная и большая. Однако, GNU Coreutils содержит несложную программу 


, которая просто вызывает 


 со своими двумя аргументами. Следующий пример показывает код из файла 


, не относящиеся к делу части удалены. Номера строк относятся к действительному файлу.








































































































































































































































































































Строки 67–75 являются типичным шаблоном Coreutils, устанавливающими интернациональные настройки, выход по завершении и анализ аргументов. Строки 79–95 гарантируют, что 


 вызывается лишь с двумя аргументами. Сам системный вызов 


 осуществляется в строке 97 (Функция 


 обеспечивает отображение аргументов в стиле, подходящем для текущей локали; подробности сейчас несущественны.)




5.1.3.2. Точка и точка-точка


Завершая обсуждение ссылок, давайте взглянем на то, как обрабатываются специальные имена '


' и '


'. На самом деле они просто являются прямыми ссылками. В первом случае '


' является прямой ссылкой на каталог, содержащий ее, а '


' — прямой ссылкой на родительский каталог. Операционная система создает для вас эти ссылки; как упоминалось ранее, код уровня пользователя не может создать прямую ссылку на каталог. Этот пример иллюстрирует ссылки:



















































Родительский каталог корневого каталога (


) является особым случаем; мы отложим его обсуждение до главы 8 «Файловые системы и обход каталогов».




5.1.4. Переименование файлов


При данном способе отображения элементами каталога имен на номера индексов, переименование файла концептуально очень просто:

1. Если новое имя файла обозначает существующий файл, сначала удалить этот файл.

2. Создать новую ссылку на файл через новое имя.

3. Удалить старое имя (ссылку) для файла. (Удаление имен обсуждается в следующем разделе.)

Ранние версии команды mv работали таким способом. Однако, при таком способе переименование файла не является атомарным; т.е. оно не осуществляется посредством одной непрерываемой операции. И на сильно загруженной системе злонамеренный пользователь мог бы воспользоваться условиями состояния гонки[51 - Состояние .гонки (race condition) является ситуацией, при которой детали временных соотношений могут вызывать непреднамеренные побочные эффекты или ошибки. В данном случае, каталог в течение короткого периода времени находится в противоречивом состоянии, и именно эта противоречивость и создаёт уязвимость — Примеч. автора.], разрушая операцию переименования и подменяя оригинальный файл другим.

По этой причине 4.2 BSD ввело системный вызов 


:











На системах Linux операция переименования является атомарной; справочная страница утверждает:



Если 


 уже существует, он будет атомарно замещен 


 таким образом, что при попытке другого процесса получить доступ к 


 он никогда не обнаружит его отсутствующим.

Если 


 существует, но по какой-либо причине операция завершается неудачей, 


 гарантирует, что экземпляр 


 останется на месте. Однако, в ходе переписывания возможно будет окно, в котором как 


, так и 


 ссылаются на переименовываемый файл.


Как и в случае с другими системными вызовами, возвращенный 0 означает успех, а (-1) означает ошибку.




5.1.5. Удаление файла



Удаление файла означает удаление элемента каталога для файла и уменьшение счетчика ссылок на файл, который содержится в индексе. Содержимое файла и дисковые блоки, в котором оно размешается, не освобождаются до тех пор, пока счетчик ссылок не достигнет нуля.

Системный вызов называется 


:













В нашем обсуждении ссылок на файлы имя имеет смысл; этот вызов удаляет данную ссылку (элемент каталога) для файла. Она возвращает 0 в случае успеха и -1 при ошибке. Возможность удаления файла требует права записи лишь для каталога, а не для самого файла. Этот факт может сбивать с толку, особенно начинающих пользователей Linux/Unix. Однако, поскольку операция в каталоге одна, это имеет смысл; меняется именно содержимое каталога, а не содержимое файла[52 - Конечно, меняются служебные данные файла (число ссылок), но это не влияет ни на какой другой атрибут файла, также, как не влияет на содержимое файла. Обновление счетчика ссылок на файл является единственной операцией над файлом, при которой не проверяются права доступа к файлу — Примеч. автора.].




5.1.5.1. Удаление открытых файлов


С самых первых дней Unix было возможно удалять открытые файлы. Просто вызовите 


 с именем файла после успешного вызова 


 или 


.

На первый взгляд, это кажется странным. Поскольку система освобождает блоки данных, когда счетчик ссылок на файл достигает нуля, возможно ли использовать открытый файл?

Ответ — да, вы можете продолжить использовать открытый файл обычным способом. Система знает, что файл открыт, поэтому она откладывает освобождение хранилища файла до тех пор, пока не будет закрыт последний дескриптор файла. Когда файл вообще больше не используется, память освобождается.

Эта операция также оказывается полезной: это простой способ для программы получить временный файл, который гарантированно будет и конфиденциальным, и автоматически освобождаемым по завершении использования.









































Недостатком такого подхода является то, что вышедшее из-под контроля приложение может заполнить систему открытыми, но анонимными файлами, в этом случае администраторам придется попытаться найти и завершить этот процесс. В прежние дни могли потребоваться перезагрузка и проверка целостности файловой системы; к счастью, на современных системах это требуется исключительно редко.




5.1.5.2. Использование ISO С: 





ISO С предоставляет для удаления файлов функцию 


; она предназначена в качестве обшей функции, годной для любой системы, поддерживающей ISO С, а не только для Unix и GNU/Linux:













Хотя технически это не системный вызов, возвращаемое значение в том же стиле: 0 в случае успеха и -1 при ошибке, причем 


 содержит значение ошибки.

В GNU/Linux 


 использует для удаления файлов системный вызов 


, а для удаления каталогов — системный вызов 


 (обсуждаемый далее в главе). (На более старых системах GNU/Linux, не использующих GLIBC, 


 является псевдонимом для 


; поэтому для каталогов завершается неудачей. Если у вас такая система, вам, возможно, следует ее обновить.)




5.1.6. Символические ссылки


Мы начали главу с обсуждения разделов, файловых систем и индексов. Мы также увидели, что элементы каталога связывают имена с номерами индексов. Поскольку элементы каталога не содержат другой информации, прямые ссылки ограничены файлами внутри одной и той же файловой системы. Это должно быть; нет способа отличить индекс 2341 одной файловой системы от индекса 2341 другой файловой системы. Вот что случится, если мы попытаемся это сделать:





























































На больших системах часто много разделов как на физически подключенных локальных дисках, так и на удаленно смонтированных файловых системах. Ограничение прямых ссылок одной и той же файловой системой неудобно, например, если некоторые файлы или каталоги должны быть перемешены в новое место, но старое программное обеспечение использует жестко вшитые в код имена файлов для старых местоположений.

Чтобы обойти это ограничение, 4.2 BSD ввело символические ссылки (symbolic links, называемые также soft links). Символическая ссылка является особой разновидностью файла (также, как особой разновидностью файла является каталог). Содержимое этого файла представляет собой путь к файлу, на который данный файл «указывает». Все современные Unix-системы, включая Linux, предусматривают символические ссылки; конечно, они теперь являются частью POSIX.

Символические ссылки могут ссылаться на любой файл в системе. Они могут также ссылаться на каталоги. Это упрощает перемещение каталогов с места на место, когда на старом месте остается символическая ссылка, указывающая на новое положение.

При обработке имени файла система отмечает символические ссылки и осуществляет требуемые действия в файле или каталоге, который указан. Символические ссылки создаются с помощью опции 


 команды 


:




































Файл, на который указывает ссылка, необязательно должен существовать. Система обнаруживает это во время исполнения и действует соответствующим образом:









































Символические ссылки создаются с помощью системного вызова 


:













Аргумент 


 содержит указываемый файл или каталог, a 


 является именем создаваемой символической ссылки. При успехе возвращается 0, а при ошибке (-1), возможные значения 


 см. в справочной странице для symlink(2). У символических ссылок есть свои недостатки:

• Они занимают лишнее дисковое пространство, требуя отдельного индекса и блока данных. Прямые ссылки занимают лишь элемент каталога.

• Они добавляют лишние накладные расходы. Ядро должно больше работать для разрешения имени пути, содержащего символические ссылки.

• Они могут создать «циклы». Рассмотрите следующее:


























Ядро должно быть способно определить такой случай и выдать сообщение об ошибке.

• Они легко обрываются. Если переместить указываемый файл в другое место или переименовать его, символическая ссылка больше не действительна. С прямой ссылкой такого случиться не может.




5.2. Создание и удаление каталогов


Создание и удаление каталогов просто. Двумя системными вызовами, что неудивительно, являются 


 и 


 соответственно:
































Оба возвращают 0 при успехе и (-1) при ошибке, с соответствующим 


. Аргумент 


 для 


 представляет права доступа, которые должны быть использованы для каталога. Он полностью идентичен аргументам 


 для 


 и 


, обсуждавшимся в разделе 4.6 «Создание файлов».

Обе функции обрабатывают '


' и '


' в создаваемом или удаляемом каталоге. Перед удалением каталог должен быть пуст; если это не так, 


 устанавливается в 


. (В данном случае, «пуст» означает, что каталог содержит только '


' и '


'.)

Новым каталогам, как и всем файлам, присваивается идентификационный номер группы. К сожалению, его работа запутана. Мы отложим обсуждение до раздела 11.5.1 «Группа по умолчанию для новых файлов и каталогов».

Обе функции работают на одном уровне каталога за раз. Если 


 существует, a 


 нет, '


' завершится неудачей. Каждый компонент в длинном пути должен создаваться отдельно (в соответствии с опцией 


, см. mkdir(1)).

Также, если 


 завершается символом '


', на некоторых системах 


 и 


 потерпят неудачу, а на других нет. Следующая программа, 


, демонстрирует оба аспекта.









































































































































































































Вот результаты для GNU/Linux:


































































Обратите внимание, как GNU/Linux принимает завершающий слеш. Не все системы так делают.




5.3. Чтение каталогов



В оригинальных системах Unix чтение содержимого каталогов было просто. Программа открывала каталог с помощью 


 и непосредственно читала двоичные структуры 


, по 16 байтов за раз. Следующий фрагмент кода из программы V7 


[53 - См 


 с в дистрибутиве V7 — Примеч. автора.], строки 60–74. Он показывает проверку на пустоту каталога.












































































В строке 60 каталог открывается для чтения (второй аргумент равен 0, что означает 


). В строке 65 читается 


. В строке 66 проверяется, не является ли элемент каталога пустым, т. е. с номером индекса 0. Строки 67 и 68 проверяют на наличие '


' и '


'. По достижении строки 69 мы знаем, что было встречено какое-то другое имя файла, следовательно, этот каталог не пустой.

(Тест '


' является более короткой формой '


', т.е. проверкой совпадения строк. Стоит заметить, что мы рассматриваем '


' как плохой стиль. Как сказал однажды Генри Спенсер (Henry Spencer), «


 это не boolean!».)

Когда 4.2 BSD представило новый формат файловой системы, который допускал длинные имена файлов и обеспечивал лучшую производительность, были также представлены несколько новых функций для абстрагирования чтения каталогов. Этот набор функций можно использовать независимо от того, какова лежащая в основе файловая система и как организованы каталоги. Основная ее часть стандартизована POSIX, а программы, использующие ее, переносимы между системами GNU/Linux и Unix.




5.3.1. Базовое чтение каталогов



Элементы каталогов представлены 


 (не то же самое, что V7 


!):































Для переносимости POSIX указывает лишь поле 


, которое является завершающимся нулем массивом байтов, представляющим часть элемента каталога с именем файла. Размер 


 стандартом не указывается, кроме того, что там перед завершающим нулем может быть не более 


 байтов. (


 определен в 


.) Расширение XSI POSIX предусматривает поле номера индекса 


.

На практике, поскольку имена файлов могут быть различной длины, a 


 обычно довольно велико (подобно 255), 


 содержит дополнительные члены, которые помогают вести на диске учет элементов каталогов с переменными длинами. Эти дополнительные члены не существенны для обычного кода.

Следующие функции предоставляют интерфейс чтения каталогов:

































Тип 


 является аналогом типа 


 в 


. Это непрозрачный тип, что означает, что код приложения не должен знать, что находится внутри него; его содержимое предназначено для использования другими процедурами каталогов. Если 


 возвращает 


, именованный каталог не может быть открыт для чтения, а errno содержит код ошибки.

Открыв переменную 


, можно использовать ее для получения указателя на 


, представляющего следующий элемент каталога. 


 возвращает 


, если достигнут конец каталога[54 - То есть прочитаны все элементы каталога — Примеч. науч. ред.] или произошла ошибка.

Наконец, 


 является аналогичной функции 


 в 


; она закрывает открытую переменную 


. Чтобы начать с начала каталога, можно использовать функцию 


.

Имея в распоряжении (или по крайней мере в библиотеке С) эти функции, мы можем написать небольшую программу 


, которая «отображает» содержимое каталога. Такая программа представлена в 


:








































































































































Эта программа вполне подобна 


 (см. раздел 4.2 «Представление базовой структуры программы»); функция 


 почти идентична. Главное различие в том, что по умолчанию используется текущий каталог, если нет аргументов (строки 20–21).





















































































































































































Функция 


 делает всю работу и большую часть кода проверки ошибок. Основой функции являются строки 48 и 49:











Этот цикл читает элементы каталога, по одной за раз, до тех пор, пока 


 не возвратит 


. Тело цикла отображает для каждого элемента номер индекса и имя файла. Вот что происходит при запуске программы:







































































Вывод никаким образом не сортируется; он представляет линейное содержимое каталога. (Как сортировать содержимое каталога мы опишем в разделе 6.2 «Функции сортировки и поиска»).




5.3.1.1. Анализ переносимости


Есть несколько соображений по переносимости. Во-первых, не следует предполагать, что двумя первыми элементами, возвращаемыми 


, всегда будут '


' и '


'. Многие файловые системы используют организацию каталогов, которые отличаются от первоначального дизайна Unix, и '


' и '


' могут быть в середине каталога или даже вовсе не присутствовать[55 - В системах GNU/Linux могут монтироваться файловые системы многих операционных систем, не относящихся к Unix. Во многих коммерческих системах Unix также можно смонтировать файловые системы MS-DOS. В таких случаях предположения относительно файловых систем Unix неприменимы — Примеч. автора.].

Во-вторых, стандарт POSIX ничего не говорит о возможных значениях 


. Он говорит, что возвращенные структуры представляют элементы каталогов для файлов; это предполагает, что 


 не возвращает пустые элементы, поэтому реализация GNU/Linux 


 не беспокоится с возвратом элементов, когда '


'; она переходит к следующему действительному элементу.

Поэтому по крайней мере на системах GNU/Linux и Unix маловероятно, что 


 когда-нибудь будет равен нулю. Однако, лучше по возможности вообще избегать использования этого поля.

Наконец, некоторые системы используют 


 вместо 


 в 


. Знайте об этом, когда нужно перенести на такие системы код, читающий каталоги.




Косвенные системные вызовы

«Не пробуйте это дома, дети!»

- М-р Wizard -

Многие системные вызовы, такие, как 


, 


 и 


, предназначены для вызова непосредственно из кода пользователя: другими словами, из кода, который пишете вы как разработчик GNU/Linux.

Однако, другие системные вызовы существуют лишь для того, чтобы дать возможность реализовать стандартные библиотечные функции более высокого уровня, и никогда не должны вызываться непосредственно. Одним из таких системных вызовов является GNU/Linux 


; он читает несколько элементов каталога в буфер, предоставленный вызывающим — в данном случае, кодом реализации 


. Затем код 


 возвращает действительные элементы каталога, по одному за раз, пополняя при необходимости буфер.

Эти системные вызовы только-для-библиотечного-использования можно отличить от вызовов для-использования-пользователем по их представлению в странице справки. Например, из getdents(2).
























































Любой системный вызов, использующий макрос 


, не должен вызываться кодом приложения. (Дополнительную информацию об этих вызовах можно найти в справочной странице для intro(2); вам следует прочесть эту справочную страницу, если вы этого еще не сделали.)

В случае 


 на многих других системах Unix есть сходный системный вызов; иногда с тем же именем, иногда с другим. Поэтому попытка использования этих вызовов привела бы в любом случае лишь к большому беспорядку с переносимостью; гораздо лучше во всех случаях использовать 


, интерфейс которого хорошо определен, стандартизован и переносим.





5.3.1.2. Элементы каталогов Linux и BSD


Хотя мы только что сказали, что вам следует использовать лишь члены 


 и 


 структуры 


, стоит знать о члене 


 в 


 BSD и Linux. Это значение 


, в котором хранится тип файла, имя которого находится в элементе каталога:







































 может принимать любые значения, описанные в табл. 5.1.



Таблица 5.1. Значения для 







Знание типа файла просто путем чтения элемента каталога очень удобно; это может сэкономить на возможно дорогом системном вызове 


. (Вызов 


 вскоре будет описан в разделе 5.4.2 «Получение информации о файле».)




5.3.2. Функции размещения каталогов BSD


Иногда полезно отметить текущее положение в каталоге для того, чтобы иметь возможность позже к нему вернуться. Например, вы пишете код, обходящий дерево каталога, и хотите рекурсивно входить в каждый подкаталог, когда его проходите. (Как отличить файлы от каталогов обсуждается в следующем разделе). По этой причине первоначальный интерфейс BSD включал две дополнительные процедуры:























Эти процедуры подобны функциям 


 и 


 и 


. Они возвращают текущее положение в каталоге и устанавливают текущее положение в ранее полученное значение соответственно.

Эти процедуры включены в часть XSI стандарта POSIX, поскольку они имеют смысл лишь для каталогов, которые реализованы с линейным хранением элементов каталога

Помимо предположений, сделанных относительно лежащей в основе структуры каталога, эти процедуры рискованнее использовать, чем простые процедуры чтения каталога. Это связано с тем, что содержание каталога может изменяться динамически: когда файлы добавляются или удаляются из каталога, операционная система приводит в порядок содержание каталога. Поскольку элементы каталога имеют различный размер, может оказаться, что сохраненное ранее абсолютное смещение больше не представляет начало элемента каталога! Поэтому мы не рекомендуем вам использовать эти функции, если вам они действительно не нужны[56 - Стоит внимательно подумать прежде чем использовать эти функции — Примеч. науч. ред.].




5.4. Получение информации о файлах



Чтение каталога для получения имен файлов лишь половина дела. Получив имя файла, нужно знать, как получить остальную информацию, связанную с файлом, такую, как тип файла, права доступа к нему, владельца и т.д.




5.4.1. Типы файлов Linux


Linux (и Unix) поддерживает следующие различные типы файлов:

Обычные файлы

Как предполагает имя, данный тип используется для данных, исполняемых программ и всего прочего, что вам может понравиться. В листинге '


' они обозначаются в виде первого символа '


' поля прав доступа (режима).

Каталоги

Специальные файлы для связывания имен файлов с индексами. В листинге '


' они обозначаются первым символом 


 поля прав доступа.

Символические ссылки

Как описано ранее в главе. В листинге '


' обозначаются первым символом 


 (буква «эль», не цифра 1) поля прав доступа.

Устройства

Файлы, представляющие как физические аппаратные устройства, так и программные псевдоустройства. Есть две разновидности:

Блочные устройства

Устройства, ввод/вывод которых осуществляется порциями некоторого фиксированного размера физической записи, такие, как дисковые и ленточные приводы. Доступ к таким устройствам осуществляется через буферный кэш ядра. В листинге '


' они обозначаются первым символом 


 поля прав доступа.

Символьные устройства

Известны также как непосредственные (raw) устройства. Первоначально символьными устройствами были те, в которых ввод/вывод осуществлялся по несколько байтов за раз, как в терминалах. Однако, символьное устройство используется также для непосредственного ввода/вывода на блочные устройства, такие, как ленты и диски, минуя буферный кэш[57 - Linux использует блочные устройства исключительно для дисков. Другие системы используют оба типа — Примеч. автора.]. В листинге '


' они отображаются первым символом 


 поля прав доступа.

Именованные каналы (named pipes)

Известны также файлы FIFO («first-in first-out» — «первым вошел, первым обслужен»). Эти специальные файлы действуют подобно конвейерам (pipes); данные, записанные в них одной программой, могут быть прочитаны другой; данные не записываются на диск и не считываются с диска. FIFO создаются с помощью команды 


; они обсуждаются в разделе 9.3.2 «FIFO». В листинге '


' они отображаются первым символом 


 поля прав доступа.

Сокеты

Сходные по назначению с именованными каналами[58 - Именованные каналы и сокеты были разработаны независимо группами Unix System V и BSD соответственно. Когда системы Unix вновь сошлись, обе разновидности файлов стали доступными универсально —- Примеч. автора.], они управляются системными вызовами межпроцессных взаимодействий (IPC) сокетов, и мы не будем в данной книге иметь с ними дело в других отношениях. В листинге '


' они отображаются первым символом 


 поля прав доступа.




5.4.2. Получение информации о файле


Три системных вызова возвращают информацию о файлах:

































Функция 


 получает имя файла с путем и возвращает сведения о данном файле. Она следует по символическим ссылкам; т. е. при применении к символической ссылке 


 возвращает информацию об указываемом файле, а не о самой ссылке. В тех случаях, когда вам нужно знать, является ли файл символической ссылкой, используйте вместо нее функцию 


; последняя не следует по символическим ссылкам.

Функция 


 получает сведения об уже открытом файле. Это особенно полезно для дескрипторов файлов 0, 1 и 2 (стандартных ввода, вывода и ошибки), которые уже открыты при запуске процесса. Однако, она может использоваться с любым открытым файлом. (Дескриптор открытого файла никогда не будет относиться к символической ссылке; убедитесь, что понимаете, почему.)

Значение, переданное в качестве второго параметра, должно быть адресом 


, объявленной в 


. Как в случае с 


, 


 содержит по крайней мере следующие члены:






















































































(Размещение на разных системах может быть разное.) Эта структура использует ряд определенных через 


 типов. Хотя они все (обычно) целые типы, использование специально определенных типов позволяет использовать для них различные размеры на разных системах. Это сохраняет переносимость кода пользователя, который их использует. Вот более полное описание каждого поля.






Устройство для монтируемой файловой системы. У каждой монтируемой файловой системы уникальное значение 


.






Номер индекса файла в пределах файловой системы. Пара (


, 


) уникально идентифицирует файл.






Тип файла и права доступа к нему, закодированные в одном поле. Вскоре мы рассмотрим, как извлечь эту информацию.






Число прямых ссылок на файл (счетчик ссылок). Может равняться нулю, если файл был удален после открытия.






UID файла (номер владельца).






GID файла (номер группы).






Тип устройства, если файл является блочным или символьным устройством. 


 содержит закодированную информацию об устройстве. Вскоре мы увидим, как извлечь эту информацию. Это поле не имеет смысла, если файл не является блочным или символьным устройством.






Логический размер файла. Как упоминалось в разделе 4.5 «Произвольный доступ: перемещение внутри файла», файл может содержать в себе дыры, в этом случае размер может не отражать истинного значения занимаемого им места.






«Размер блока» файла. Представляет предпочтительный размер блока данных для ввода/вывода данных в или из файла. Почти всегда превышает размер физического сектора диска. У более старых систем Unix нет этого поля (или поля 


) в 


. Для файловых систем Linux ext2 и ext3 это значение составляет 4096.






Число «блоков», используемых файлом. В Linux это значение представлено в единицах 512-байтных блоков. На других системах размер блока может быть различным, проверьте свою локальную страницу справки для stat(2). (Это число происходит от константы 


 в 


. Эта константа не стандартизована, но довольно широко используется в системах Unix.)

Число блоков может быть больше, чем '


'; кроме блоков данных, файловая система может использовать дополнительные блоки для хранения размещений блоков данных. Это особенно необходимо для больших файлов.






Время доступа к файлу; т.е. когда в последний раз читались данные файла.






Время модификации файла; т е. когда в последний раз данные файла записывались или урезались.






Время изменения индекса файла. Указывает время последнего изменения служебных данных файла, таких, как права доступа или владелец.



ЗАМЕЧАНИЕ. Поле 


 не является «временем создания»! В системе Linux или Unix нет такой вещи. Часть более ранней документации называла поле 


 временем создания. Это была вводящая в заблуждение попытка упростить представление служебных данных файла


Тип 


, использованный для полей 


, 


 и 


, представляет дату и время. Эти относящиеся ко времени значения иногда называют временными метками (timestamps). Обсуждение того, как использовать значение 


, отложено до раздела 6.1 «Время и даты». Подобным же образом типы 


 и 


 представляют номера владельца и группы, которые обсуждаются в разделе 6.3 «Имена пользователя и группы». Большинство других типов не представляют широкого интереса.




5.4.3. Только Linux: указание файлового времени повышенной точности


Ядра Linux 2.6 и более поздние предоставляют в 


 три дополнительных поля. Они предусматривают точность файлового времени до наносекунд:




Наносекундная компонента времени доступа к файлу.




Наносекундная компонента времени изменения файла




Наносекундная компонента времени изменения служебных данных файла.

Некоторые другие системы также предоставляют такие поля с повышенной точностью времени, но имена соответствующих членов структуры 


не стандартизованы, что затрудняет написание переносимого кода, использующего эти времена. (Связанные с этим расширенные системные вызовы см. в разделе 14.3.2 «Файловое время в микросекундах: 


».)




5.4.4. Определение типа файла



Вспомните, что в поле 


 закодированы как тип файла, так и права доступа к нему. 


 определяет ряд макросов, которые определяют тип файла. В частности, эти макросы возвращают 


 или 


 при использовании с полем 


. У каждого описанного ранее типа файла есть свой макрос. Предположим, выполняется следующий код:































Когда система заполнила 


, можно вызывать следующие макросы, причем в качестве аргумента передается 


:






Возвращает 


, если 


 является обычным файлом.






Возвращает 


, если 


 является каталогом.






Возвращает 


, если 


 является символьным устройством. Устройства вскоре будут обсуждены более подробно.






Возвращает 


, если 


 является блочным устройством.






Возвращает 


, если 


 является FIFO.






Возвращает 


, если 


 является символической ссылкой. (Это может никогда не вернуть 


, если вместо 


 использовались 


 или 


.)






Возвращает 


, если 


 является сокетом.



ЗАМЕЧАНИЕ. В GNU/Linux эти макросы возвращают 1 для 


 и 0 для 


. Однако, на других системах возможно, что они будут возвращать для 


 вместо 1 произвольное неотрицательное число. (POSIX определяет лишь ненулевое значение в противоположность нулевому). Поэтому всегда следует использовать эти макросы как автономные тесты вместо проверки возвращаемого значения.






















Наряду с макросами 


 предоставляет два набора битовых масок. Один набор для проверки прав доступа, а другой - для проверки типа файла. Мы видели маски прав доступа в разделе 4.6 «Создание файлов», когда обсуждали тип 


 и значения для 


 и 


. Битовые маски, их числовые значения для GNU/Linux и смысл приведены в табл. 5.2.



Таблица 5.2. Битовые маски POSIX для типов файлов и прав доступа в 







Некоторые из этих масок служат цели изолирования различных наборов битов, закодированных в поле 


:

• 


 представляет биты 12–15, которыми закодированы различные типы файлов.

• 


 представляет биты 6–8, являющиеся правами доступа владельца (на чтение, запись, исполнение для User).

• 


 представляет биты 3–5, являющиеся правами доступа группы (на чтение, запись, исполнение для Group).

• 


 представляет биты 0–2, являющиеся правами доступа для «остальных» (на чтение, запись, исполнение для Other).

Биты прав доступа и типа файла графически изображены на рис. 5.3.




Рис. 5.3. Биты прав доступа и типа файлов

Маски типов файлов стандартизованы главным образом для совместимости со старым кодом; они не должны использоваться непосредственно, поскольку такой код менее читаем, чем соответствующие макросы. Случается, что макрос реализован с использованием масок: довольно логично, но это не подходит для кода уровня пользователя.

Стандарт POSIX явным образом констатирует; что в будущем не будут стандартизированы новые битовые маски и что тесты для любых дополнительных разновидностей типов файлов, которые могут быть добавлены, будут доступны лишь в виде макросов 


.




5.4.4.1. Сведения об устройстве


Стандарт POSIX не определяет значение типа 


, поскольку предполагалось его использование на не-Unix системах также, как на Unix-системах. Однако стоит знать, что находится в 


.

Когда истинно 


 или 


, сведения об устройстве находятся в поле 


. В противном случае это поле не содержит никакой полезной информации.

Традиционно файлы устройств Unix кодируют старший и младший номера устройства в значении 


. По старшему номеру различают тип устройства, такой, как «дисковый привод» или «ленточный привод». Старшие номера различают также разные типы устройств, такие, как диск SCSI в противоположность диску IDE. Младшие номера различают устройства данного типа, например, первый диск или второй. Вы можете увидеть эти значения с помощью '


':


































































Вместо размера файла 


 отображает старший и младший номера. В случае жесткого диска 


 представляет диск в целом, 


, 


 и т.д. представляют разделы внутри диска. У них у всех общий старший номер устройства (3), но различные младшие номера устройств.

Обратите внимание, что дисковые устройства являются блочными устройствами, тогда как 


 является символьным устройством. Блочные и символьные устройства являются отдельными сущностями; даже если символьное устройство и блочное устройство имеют один и тот же старший номер устройства, они необязательно связаны

Старший и младший номера устройства можно извлечь из значения 


 с помощью функций 


 и 


, определенных в 


:




























(Некоторые системы реализуют их в виде макросов.)

Функция 


 идет другим путем; она принимает отдельные значения старшего и младшего номеров и кодирует их в значении 


. В других отношениях ее использование выходит за рамки данной книги; патологически любопытные должны посмотреть mknod(2).

Следующая программа, 


, показывает, как использовать системный вызов 


, макросы проверки типа файла и, наконец, макросы 


 и 


.

























































































































































Вот что происходит при запуске программы:































К счастью, вывод согласуется с выводом 


, давая нам уверенность[59 - Технический термин warm fuzzy — Примеч. автора.], что мы в самом деле написали правильный код.

Воспроизведение вывода ls замечательно и хорошо, но действительно ли это полезно? Ответ — да. Любое приложение, работающее с иерархиями файлов, должно быть способно различать различные типы файлов. Подумайте об архиваторе, таком как 


 или 


. Было бы пагубно, если бы такая программа рассматривала файл дискового устройства как обычный файл, пытаясь прочесть его и сохранить его содержимое в архиве! Или подумайте о 


, которая может выполнять произвольные действия, основываясь на типе и других атрибутах файлов, с которыми она сталкивается, (


 является сложной программой; посмотрите find(1), если вы с ней не знакомы.) Или даже нечто простое, как пакет, оценивающий свободное дисковое пространство, тоже должно отличать обычные файлы от всего остального.




5.4.4.2. Возвращаясь к V7 





В разделе 4.4.4 «Пример: Unix cat» мы обещали вернуться к программе V7 


, чтобы посмотреть, как она использует системный вызов 


. Первая группа строк, использовавшая ее, была такой:































Этот код теперь должен иметь смысл. В строке 31 вызывается 


 для стандартного вывода, чтобы заполнить структуру 


. Строка 32 отбрасывает всю информацию в 


 за исключением типа файла, используя логическое AND с маской 


. Строка 33 проверяет, что используемый для стандартного вывода файл не является файлом устройства. В таком случае программа сохраняет номера устройства и индекса в 


 и 


. Эти значения затем проверяются для каждого входного файла в строках 50–56.




































Если значения 


 и 


 входного файла совпадают с соответствующими значениями выходного файла, 


 выдает сообщение и продолжает со следующего файла, указанного в командной строке.

Проверка сделана безусловно, хотя 


 и 


 устанавливаются, лишь если вывод не является файлом устройства. Это срабатывает нормально из-за того, как эти переменные объявлены:






Поскольку 


 инициализирован значением (-1), ни один действительный номер индекса не будет ему соответствовать[60 - Это утверждение было верно для V7, на современных системах больше нет таких гарантий — Примеч. автора.]. То, что 


 не инициализирован так, является небрежным, но не представляет проблемы, поскольку тест в строке 51 требует, чтобы были равными значения как устройства, так и индекса. (Хороший компилятор выдаст предупреждение, что 


 используется без инициализации: '


' сделает это.)

Обратите также внимание, что ни один вызов 


 не проверяется на ошибки. Это также небрежность, хотя не такая большая, маловероятно, что 


 завершится неудачей с действительным дескриптором файла

Проверка того, что входной файл не равен выходному файлу, осуществляется лишь для файлов, не являющихся устройствами. Это дает возможность использовать 


 для копирования ввода из файлов устройств в самих себя, как в случае с терминалами:





























5.4.5. Работа с символическими ссылками


В общем, символические ссылки ведут себя подобно прямым ссылкам; файловые операции, такие, как 


 и 


, применяются к указываемому файлу вместо самой символической ссылки. Однако, бывают моменты, когда в самом деле необходимо работать с символической ссылкой вместо файла, на которую она указывает.

По этой причине существует системный вызов 


. Он действует точно также, как 


, но если проверяемый файл окажется символической ссылкой, возвращаемые сведения относятся к символической ссылке, а не к указываемому файлу. А именно:

• 


 будет 


.

• 


 содержит число байтов в имени указываемого файла.

Мы уже видели, что системный вызов 


 создает символическую ссылку. Но если дана существующая символическая ссылка, как можно получить имя файла, на которую она указывает? (Очевидно, 


 может получить это имя; поэтому мы должны быть способны это сделать.)

Открывание ссылки с помощью 


 для чтения ее с использованием 


 не будет работать, 


 следует по ссылке на указываемый файл. Таким образом, символические ссылки сделали необходимым дополнительный системный вызов, который называется 


:
















 помещает содержимое символической ссылки, на имя которой указывает 


, в буфер, на который указывает 


. Копируется не более 


 символов. Возвращаемое значение равно числу символов, помещенных в 


, либо -1, если возникла ошибка, 


не вставляет завершающий нулевой байт.

Обратите внимание, что если буфер, переданный 


, слишком маленький, информация будет потеряна; полное имя указываемого файла будет недоступно. Чтобы использовать 


 должным образом, вы должны делать следующее:

1. Используйте 


, чтобы убедиться, что это символическая ссылка.

2. Убедитесь, что ваш буфер для содержимого символической ссылки составляет по крайней мере '


' байтов; '


' нужно для завершающего нулевого байта, чтобы сделать буфер годной к употреблению строкой С.

3. Вызовите 


. Не мешает проверить, что возвращенное значение равно 


.

4. Добавьте '


' к байту после содержимого ссылки, чтобы превратить его в строку С. Код для всего этого мог бы выглядеть примерно так:












































































Данный пример для простоты представления использует буферы фиксированного размера. Реальный код мог бы использовать для выделения буфера нужного размера 


, поскольку массивы фиксированного размера могли бы оказаться слишком маленькими. Файл 


 в GNU Coreutils делает именно это. Он читает содержимое символической ссылки в память, выделенную 


. Мы покажем здесь саму функцию, большая часть файла представляет собой стереотипные определения. Номера строк относятся к началу файла:































































































































































































Тело функции состоит из бесконечного цикла (строки 68–91), разрываемого в строке 84, которая возвращает выделенный буфер. Цикл начинается выделением первоначального буфера (строка 70) и чтения ссылки (строка 71). Строки 73–79 обрабатывают случай ошибки, сохраняя и восстанавливая errno таким образом, что она может корректно использоваться вызывающим кодом.

Строки 81–85 обрабатывают случай «успеха», при котором размер содержимого ссылки меньше размера буфера. В этом случае добавляется завершающий ноль (строка 83), а затем буфер возвращается, прерывая бесконечный цикл. Это гарантирует, что в буфер помещено все содержимое ссылки, поскольку у 


 нет возможности сообщить о «недостаточном размере буфера».

Строки 87–88 освобождают буфер и удваивают размер буфера для следующей попытки в начале цикла. Строки 89–90 обрабатывают случай, при котором размер ссылки слишком велик: 


 больше, чем 


, или 


 больше, чем значение, которое может быть представлено в знаковом целом того же размера, который использовался для хранения 


, и 


 обернулся в ноль. (Это маловероятные условия, но странные вещи все же случаются.) Если одно из этих условий верно, программа завершается с сообщением об ошибке. В противном случае функция возвращается в начало цикла, чтобы сделать еще одну попытку выделить буфер и прочесть ссылку.

Некоторое дополнительное разъяснение: условие '


' верно лишь на системах, в которых '


'; мы не знаем таких, но лишь на таких системах 


 может обернуться в ноль. Поскольку на практике это условие не может быть истинным, компилятор может оптимизировать все выражение, включив следующую проверку '


'. После прочтения этого кода вы можете спросить: «Почему не использовать 


 для получения размера символической ссылки, не выделить буфер нужного размера с помощью 


, и все?» На это есть несколько причин.[61 - Спасибо Джиму Мейерингу (Jim Meyering) за объяснение проблем — Примеч. автора.]

• 


 является системным вызовом — лучше избежать накладных расходов по его вызову, поскольку содержимое большинства символических ссылок поместится в первоначальный размер буфера в 128.

• Вызов 


 создает условие состязания: ссылка может измениться между исполнением 


 и 


, в любом случае вынуждая повторение.

• Некоторые системы не заполняют должным образом член 


 для символической ссылки. (Печально, но верно.) Сходным образом, как мы увидим в разделе 8.4.2 «Получение текущего каталога: 


», Linux в 


 предоставляет специальные символические ссылки, у которых 


 равен нулю, но для которых 


 возвращает действительное содержимое.

Наконец, буфер не слишком большой, 


 использует 


 и 


 с большим размером вместо 


, чтобы избежать бесполезного копирования, которое делает 


. (Поэтому комментарий в строке 58 устарел, поскольку 


 не используется; это исправлено в версии Coreutils после 5.0.)




5.5. Смена владельца, прав доступа и времени изменения



Несколько других системных вызовов дают вам возможность изменять другие относящиеся к файлу сведения: в частности, владельца и группу файла, права доступа к файлу и времена доступа и изменения файла.




5.5.1. Смена владельца файла: 


, 


 и 





Владелец и группа файла изменяются с помощью трех сходных системных вызовов.































 работает с аргументом имени файла, 


 работает с открытым файлом, а 


 работает с символической ссылкой вместо файла, на который эта ссылка указывает. Во всех других отношениях эти три вызова работают идентично, возвращая 0 в случае успеха и -1 при ошибке.

Стоит заметить, что один системный вызов изменяет как владельца, так и группу файла. Чтобы изменить лишь владельца или лишь группу, передайте (-1) в качестве того идентификационного номера, который должен остаться без изменений.

Хотя вы могли бы подумать, что можно передать соответствующее значение из полученного заранее 


 для файла или файлового дескриптора, этот метод больше подвержен ошибкам. Возникает условие состязания: между вызовами 


 и 


 владелец или группа могут измениться.

Вы могли бы поинтересоваться: «Зачем нужно изменять владельца символической ссылки? Права доступа и владение ей не имеют значения». Но что случится, если пользователь уходит, а все его файлы все еще нужны? Необходима возможность изменения владельца всех файлов этого лица на кого-то еще, включая символические ссылки.

Системы GNU/Linux обычно не позволяют рядовым пользователям (не root) изменять владельца («отдавать») своих файлов. Смена группы на одну из групп пользователя, конечно, разрешена. Ограничение в смене владельцев идет от BSD систем, у которых тоже есть этот запрет. Главная причина в том, что разрешение пользователям отдавать файлы может нарушить дисковый учет. Рассмотрите такой сценарий:































В этом примере 


 теперь принадлежит пользователю 


. Первоначальный пользователь может продолжать читать и записывать файл из-за его прав доступа. Но дисковое пространство, которое он занимает, будет записано на счет 


. Однако, поскольку он находится в каталоге, который принадлежит первому пользователю и к которому 


 не может получить доступ, 


 не имеет возможности удалить файл.

Некоторые системы System V разрешают пользователям передавать свои файлы. (При смене владельца соответствующие биты файлов 


 и 


 сбрасываются.) Это может быть особенной проблемой, когда файлы извлекаются из архива 


 или 


; извлеченные файлы имеют UID и GID, закодированный в архиве. На таких системах программы 


 и 


 имеют опции, предотвращающие это, но важно знать, что поведение 


 действительно отличается на разных системах.

В разделе 6.3 «Имена пользователя и группы» мы увидим, как соотносить имена пользователя и группы с соответствующими числовыми значениями




5.5.2. Изменение прав доступа: 


 и 





Изменение прав доступа осуществляется с помощью одного из двух системных вызовов, 


 и 


:


























 работает с аргументом имени файла, a 


 работает с открытым файлом. (В POSIX нет вызова 


, поскольку система игнорирует установки прав доступа для символических ссылок. Хотя на некоторых системах такой вызов действительно есть). Как и для большинства других системных вызовов, они возвращают 0 в случае успеха и -1 при ошибке. Права доступа к файлу может изменить лишь владелец файла или 


.

Значение mode создается таким же образом, как для 


 и 


, как обсуждалось в разделе 4.6 «Создание файлов». См. также табл. 5.2, в которой перечислены константы прав доступа.

Система не допустит установки бита setgid (


), если группа файла не совпадает с ID действующей группы процесса или с одной из его дополнительных групп. (Мы пока не обсуждали подробно эти проблемы; см. раздел 11.1.1 «Реальные и действующие ID».) Разумеется, эта проверка не относится к 


 или коду, выполняющемуся как 


.




5.5.3. Изменение временных отметок: 






Структура 


 содержит три поля типа 


:




Время последнего доступа к файлу (чтение)




Время последнего изменения файла (запись).




Время последнего изменения индекса файла (например, переименования)

Значение 


 представляет время в «секундах с начала эпохи». Эпоха является Началом Времени для компьютерных систем GNU/Linux и Unix используют в качестве начала Эпохи полночь 1 января 1970 г по универсальному скоординированному времени (UTC).[62 - UTC представляет собой независимое от языка сокращение для Coordinated Universal Time (универсальное скоординированное время). Старый код (а иногда и люди постарше) называют это Гринвичским временем (Greenwich Mean Time, GMT), которое является временем в Гринвиче, Великобритания. Когда стали широко использоваться часовые пояса, в качестве точки отсчета, относительно которого все остальные часовые пояса отсчитывались либо вперед, либо назад, был выбран Гринвич — Примеч. автора.] Системы Microsoft Windows используют в качестве начала Эпохи полночь 1 января 1980 г. (очевидно, местное время).

Значения 


 иногда называют временными отметками (timestamps). В разделе 6.1 «Время и даты» мы рассмотрим, как получаются эти данные и как они используются. Пока достаточно знать, чем является значение 


 и то, что оно представляет секунды с начала Эпохи.

Системный вызов 


 позволяет изменять отметки времени доступа к файлу и его изменения:


















Структура 


 выглядит следующим образом:





















При успешном вызове возвращается 0, в противном случае возвращается -1. Если 


 равен 


, система устанавливает время доступа и время изменения равным текущему времени.

Чтобы изменить только одну временную отметку, используйте оригинальное значение из 


. Например.





















































Вы можете спросить себя: «Почему может понадобиться кому-нибудь изменять времена доступа и изменения файла?» Хороший вопрос.

Чтобы на него ответить, рассмотрите случай программы, создающей дублирующие архивы, такой, как 


 или 


. Эти программы должны прочесть содержание файла, чтобы заархивировать его. Чтение файла, конечно, изменяет время доступа к файлу.

Однако, этот файл, возможно, не читался человеком в течение 10 лет. Некто, набрав '


', что отображает время доступа (вместо времени изменения по умолчанию), увидел бы, что последний раз данный файл просматривали 10 лет назад. Поэтому программа архивации должна сохранить оригинальные значения времени доступа и изменения, прочесть файл для архивации, а затем восстановить первоначальное время с помощью 


.

Аналогичным образом, рассмотрите случай архивирующей программы, восстанавливающей файл из архива. В архиве хранятся первоначальные значения времени доступа и изменения. Однако, когда файл извлечен из архива во вновь созданную копию на диске, новый файл имеет текущие дату и время для значений времени доступа и изменения.

Однако полезнее, когда вновь созданный файл выглядит, как если бы он имел тот же возраст, что и оригинальный файл в архиве. Поэтому архиватор должен иметь возможность устанавливать значения времени доступа и изменения в соответствии со значениями в архиве.



ЗАМЕЧАНИЕ. В новом коде вы можете захотеть использовать вызов 


 (обратите внимание на s в имени), который описан далее в книге, в разделе 14.3.2 «Файловое время в микросекундах: 


»





5.5.3.1. Подделка 





Некоторые более старые системы не устанавливают значения времени доступа и изменения равным текущему времени, когда второй аргумент 


 равен 


. Однако код более высокого уровня (такой, как GNU 


) проще, если он может полагаться на один стандартизованный интерфейс.

Поэтому библиотека GNU Coreutils содержит замещающую функцию для 


, которая обрабатывает этот случай, которую потом может вызвать код более высокого уровня. Это отражает принцип проектирования «выбор лучшего интерфейса для работы», который мы описали в разделе 1.5 «Возвращаясь к переносимости».

Замещающая функция находится в файле 


 в дистрибутиве Coreutils Следующий код является версией из Coreutils 5.0. Номера строк относятся к началу файла:








































































































































































































































































































Строки 33–41 определяют структуру 


; как сказано в комментарии, некоторые системы не объявляют эту структуру. Работу осуществляет функция 


. Используется системный вызов 


, если он доступен (


 является сходным, но более развитым системным вызовом, который рассматривается в разделе 14.3.2 «Файловое время в микросекундах: 


.» Он допускает также в качестве второго аргумента 


, что означает использование текущего времени.)

В случае, когда время должно обновляться вручную, код осуществляет обновление, прочитав сначала из файла байт, а затем записав его обратно. (Первоначальный touch Unix работал таким способом.) Операции следующие:

1. Открыть файл, строка 58.

2. Вызвать для файла 


, строка 60.

3. Прочесть один байт, строка 61 Для наших целей 


 действует подобно 


; это объясняется в разделе 10.4.4 «Повторно запускаемые системные вызовы»).

4. Переместиться обратно на начало файла с помощью 


, строка 62. Это сделано для записи только что прочитанного байта обратно поверх себя.

5. Записать байт обратно, строка 63. 


 действует подобно 


; это также рассматривается в разделе 10.4.4 «Повторно запускаемые системные вызовы»).

6. Если файл имеет нулевой размер, использовать 


 для установки его размера в ноль (строка 68). Это не изменяет файл, но имеет побочный эффект обновления времени доступа и изменения (


 была описана в разделе 4 8 «Установка длины файла».)

7. Закрыть файл, строка 69.

Все эти шаги осуществляются в одной длинной последовательной цепи проверок внутри 


. Проверки сделаны так, что если любое сравнение неверно, 


 возвращает -1, как обычный системный вызов, 


 автоматически устанавливается системой для использования кодом более высокого уровня.

Функция 


 (строки 75–82) является «заместителем 


». Если второй аргумент не равен 


, она вызывает настоящую 


. В противном случае она вызывает 


.




5.5.4. Использование 


 и 


 для обеспечения безопасности


В исходных системах Unix были только системные вызовы 


 и 


. Однако, на сильно загруженных системах эти системные вызовы попадают в условия состязания, посредством чего злоумышленник может организовать замещение другим файлом файла, у которого изменяется владелец или права доступа.

Однако, после открытия файла условие состязания больше не представляет проблему. Программа может использовать 


 с именем файла для получения информации о файле. Если получены сведения, которые ожидались, после открытия файла 


 может проверить, что файл тот же самый (сравнив поля 


 и 


 структур 


 «до» и «после»).

Когда программа знает, что файлы те же самые, владение или права доступа могут быть изменены с помощью 


 или 


.

Эти системные вызовы, также как 


, сравнительно недавние;[63 - 


 и 


 были введены в 4 2 BSD, но не включались в System V до выпуска 4 — Примеч. автора.] в старых системах Unix их не было, хотя в современных совместимых с POSIX системах они есть.

Соответствующих функций 


 или 


 нет. В случае 


 это (очевидно) потому, что временные отметки не являются критическими для безопасности системы в том же отношении, что для владения и прав доступа, 


 отсутствует потому, что временные отметки неуместны для символических ссылок.




5.6. Резюме


• Иерархия файлов и каталогов, как она видится пользователю, является одним логическим деревом, корень которого находится в 


. Оно составлено из одного или более разделов, каждый из которых содержит файловую систему. Внутри файловой системы в индексах хранятся данные о файлах (метаданные), включая размещение блоков данных.

• Каталоги осуществляют связь между именами файлов и индексами. Концептуально содержимое каталога, которое является просто последовательностью пар (индекс, имя). Каждый элемент каталога для файла называется (прямой) ссылкой, а файлы могут иметь множество ссылок. Прямые ссылки, поскольку они работают лишь по номеру индекса, все должны находиться в одной файловой системе. Символические ссылки являются указателями на файлы или каталоги и работают на основе имени файла, а не номера индекса, поэтому их использование не ограничено одной и той же файловой системой.

• Прямые ссылки создаются с помощью 


, символические ссылки создаются с помощью 


, ссылки удаляются с помощью 


, а переименовываются файлы (с возможным перемещением в другой каталог) с помощью 


. Блоки данных файла не освобождаются до тех пор, пока счетчик ссылок не достигнет нуля и не закроется последний открытый дескриптор файла.

• Каталоги создаются с помощью 


, а удаляются с помощью 


; перед удалением каталог должен быть пустым (не оставлено ничего, кроме '


' и '


'). GNU/Linux версия функции ISO С 


 вызывает соответствующие функции 


 или 


.

• Каталоги обрабатываются с помощью функций 


, 


, 


 и 


. 


 содержит номер индекса и имя файла. Максимально переносимый код использует в члене 


 только имя файла. Функции BSD 


 и 


 для сохранения и восстановления текущего положения в каталоге широко доступны, но не полностью переносимы, как другие функции работы с каталогами.

• Вспомогательные данные получаются с помощью семейства системных вызовов 


, структура 


 содержит всю информацию о файле за исключением имени файла. (В самом деле, поскольку у файла может быть множество имен или он может совсем не иметь ссылок, невозможно сделать имя доступным.)

• Макрос 


 в 


 дает возможность определить тип файла. Функции 


 и 


 из 


 дают возможность расшифровки значений 


, представляющих блочные и символьные устройства.

• Символические ссылки можно проверить, использовав 


, а поле 


 структуры 


 для символической ссылки возвращает число байтов, необходимых для размещения имени указываемого файла. Содержимое символической ссылки читают с помощью 


. Нужно позаботиться о том, чтобы размер буфера был правильным и чтобы завершить полученное имя файла нулевым байтом, чтобы можно было его использовать в качестве строки С.

• Несколько разнообразных системных вызовов обновляют другие данные: семейство 


 используется для смены владельца и группы, процедуры 


 для прав доступа к файлу, a 


 для изменения значений времени доступа и изменения файла.




Упражнения


1. Напишите программу '


'. Ввод представляет собой значение 


, полученное из поля 


 структуры 


; т.е. оно содержит как биты прав доступа, так и типа файла.

Вывод должен представлять строку в 10 символов, идентичную первому полю вывода '


'. Другими словами, первый символ обозначает тип файла, а остальные девять — права доступа.

Когда установлены биты 


 и 


, используйте 


 вместо 


; если установлен лишь бит 


, используйте 


. То же относится к битам 


 и 


. Если установлены оба бита 


 и 


, используйте 


; для одного 


 используйте 


.

Для простоты можете использовать статический (


) буфер, содержимое которого перезаписывается при каждом вызове процедуры.

2. Доработайте 


, чтобы она вызывала 


 для каждого найденного имени файла. Затем выведите номер индекса, результат вызова 


, число ссылок и имя файла.

3. Доработайте 


 так, что если файл является символической ссылкой, программа будет также выводить имя указываемого файла.

4. Добавьте такую опцию, что если имя файла является именем подкаталога, программа рекурсивно входит в него и отображает сведения о файлах (и каталогах) этого подкаталога. Необходим лишь один уровень рекурсии.

5. Если вы не работаете на системе GNU/Linux, запустите 


 (см. раздел 5.2 «Создание и удаление каталогов») на своей системе и сравните результаты с приведенными нами.

6. Напишите программу 


. Посмотрите свою локальную справочную страницу для mkdir(1) и реализуйте все ее опции.

7. В корневом каталоге, 


, как номер устройства, так и номер индекса для '


' и '


' совпадают. Используя эту информацию, напишите программу 


.

Вначале программа должна найти имя текущего каталога, прочитав содержимое родительского каталога. Затем она должна продолжить собирать сведения о иерархии файловой системы, пока не достигнет корневого каталога.

Отображение имени каталога в обратном порядке, от текущего каталога до корневого, легко. Как будет справляться ваша версия 


 с выводом имени каталога правильным образом, от корневого каталога вниз?

8. Если вы написали 


, использовав рекурсию, напишите ее снова, использовав итерацию. Если вы использовали итерацию, напишите ее с использованием рекурсии. Что лучше? (Подсказка: рассмотрите очень глубоко вложенные деревья каталогов.)

9. Тщательно исследуйте функцию 


 (см. раздел 5.5.3.1 «Подделка 


»). Какой ресурс не восстанавливается, если одна из проверок в середине 


 не выполняется? (Спасибо Джеффу Колье (Geoff Collyer).)

10. (Трудное) Прочтите страницу справки для chmod(1). Напишите код для анализа аргумента символических опций, который позволяет добавлять, удалять и устанавливать права доступа на основе владельца, группы, других и «всех».

Когда вы решите, что это работает, напишите свою собственную версию 


, которая применяет назначенные права доступа к каждому файлу или каталогу, указанному в командной строке. Какую функцию вы использовали, 


 — или 


 и 


 — и почему?




Глава 6

Общие библиотечные интерфейсы — часть 1



В главе 5 «Каталоги и служебные данные файлов» мы видели, что непосредственное чтение каталога возвращает имена файлов в том порядке, в каком они хранятся в каталоге. Мы также видели, что 


 содержит всю информацию о файле за исключением его имени. Однако, некоторые компоненты этой структуры не могут использоваться непосредственно; они являются просто числовыми значениями.

В данной главе представлена оставшаяся часть API, необходимая для полного использования значений компонентов 


. Мы по порядку рассматриваем следующие темы: значения 


 для представления времени и функций форматирования времени; функции сортировки и поиска (для сортировки имен файлов или других данных); типы 


 и 


 для представления пользователей, групп и функций, которые сопоставляют их с соответствующими именами пользователей и групп; и наконец, функцию для проверки того, что дескриптор файла представляет терминал.




6.1. Времена и даты



Значения времени хранятся в типе, который известен как 


. Стандарт ISO С гарантирует, что это числовой тип, но во всем остальном никак не указывает, чем именно он является (целым или с плавающей точкой), как и не указывает степень точности хранящихся в нем значений.

На системах GNU/Linux и Unix значения 


 представляют «секунды с начала Эпохи». Эпоха представляет собой начало записываемого времени, которое относится к полночи 1 января 1970 г. по UTC. На большинстве систем 


 является 


 С. Для 32-разрядных систем это означает, что 


 переполнится 19 января 2038 г. К тому времени, мы надеемся, тип 


 будет переопределен как по меньшей мере 64-разрядное значение.

Для получения текущего времени, вычисления разницы между двумя значениями 


, преобразования значений 


 в более удобное представление и форматирования обоих представлений в виде символьных строк существуют различные функции. Вдобавок, представление даты и времени можно преобразовать обратно в 


, доступна также ограниченная информация по часовым поясам.

Отдельный набор функций предоставляет доступ к текущему времени с разрешением, большим чем одна секунда. Функции работают с предоставлением двух различных значений, времени в виде секунд с начала Эпохи и числа микросекунд в текущей секунде. Эти функции описаны далее в разделе 14.3.1 «Время в микросекундах: 


».




6.1.1. Получение текущего времени: 


 и 





Системный вызов 


 получает текущие дату и время; 


 вычисляет разницу между двумя значениями 


:





















 возвращает текущее время. Если параметр 


 не равен 


, переменная, на которую указывает 


, также заполняется значением текущего времени. Функция возвращает 


, если была ошибка, устанавливая 


.

Хотя ISO С не указывает, чем является значение 


, POSIX определяет, что оно представляет время в секундах. Поэтому это предположение является обычным и переносимым. Например, чтобы посмотреть, что значение времени представляет отметку в прошлом шесть месяцев назад или позже, можно использовать код, подобный этому:














































Однако, поскольку переносимый код может потребоваться запустить на не-POSIX системах, существует функция 


 для вычисления разницы между двумя значениями времени. Тот же самый тест с использованием 


 можно было бы написать таким способом:









































Возвращаемым типом 


 является 


, поскольку 


 может также содержать доли секунд. На системах POSIX он всегда представляет целые секунды.

В обоих предыдущих примерах обратите внимание на использование типизированных констант, чтобы форсировать выполнение вычислений с нужным математическим типом: 


 в первом случае для целых 


, 6.0 во втором случае для чисел с плавающей точкой




6.1.2. Разложение времени: 


 и 





На практике форма представления даты и времени в виде «секунд с начала эпохи» не является очень удобной, кроме очень простых сравнений. Самостоятельное вычисление компонентов времени, таких, как месяц, день, год и т.д., подвержено ошибкам, поскольку необходимо принять во внимание местный часовой пояс (возможно, с учетом перехода на летнее время), правильно вычислить високосные годы и пр. К счастью, две стандартные процедуры делают за вас эту работу:





















 возвращает указатель на 


, которая представляет время UTC. 


 возвращает указатель на 


, представляющий местное время, т.е. в расчет берутся текущий часовой пояс и переход на летнее время. На самом деле это «время для настенных часов», дата и время, которые были бы отображены на настенных или ручных часах. (Как это работает, обсуждается далее в разделе 6.1.5 «Получение сведений о часовом поясе».)

Обе функции возвращают указатель на 


, которая выглядит следующим образом:



























































 называют разложенным временем (broken-down time), поскольку значение 


 «разложено» на свои составные части. Составные части, их диапазоны и значения показаны в табл. 6.1.



Таблица 6.1. Поля структуры 







Стандарт ISO С представляет большинство этих значений как «


 после 


». Например, 


 является числом «секунд после минуты», 


 «месяцев после января», 


 «дней недели после воскресенья» и т.д. Это помогает понять, почему все значения начинаются с 0. (Единственным исключением, достаточно логичным, является 


, день месяца, имеющий диапазон 1–31.) Конечно, отсчет их с нуля также практичен; поскольку массивы С отсчитываются с нуля, использование этих значений в качестве индексов тривиально:





















































Как 


, так и 


 возвращают указатель на 


. Указатель указывает на static 


, содержащуюся в каждой процедуре, и похоже, что эти структуры 


 переписываются каждый раз, когда вызываются процедуры. Поэтому хорошая мысль сделать копию возвращенной 


. Возвращаясь к предыдущему примеру.




































Поле 


 указывает, действует ли в настоящий момент летнее время (DST) Значение 0 означает, что DST не действует, положительное значение означает, что действует, а отрицательное значение — что информация о DST недоступна. (Стандарт С намеренно неконкретен, указывая лишь нулевое, положительное и отрицательное значения; это дает возможность большей свободы при реализации.)




6.1.3. Форматирование даты и времени



Примеры в предыдущем разделе показали, как поля в 


 могли бы быть использованы в качестве индексов символьных строк для вывода информативных значений даты и времени. Хотя можно было бы написать собственный код, использующий такие массивы для форматирования даты и времени, стандартные процедуры облегчают работу




6.1.3.1. Простое форматирование времени: 


 и 





Две первые стандартные процедуры, перечисленные ниже, выводят данные в фиксированном формате:


















Как и в случае с 


 и 


, 


 и 


 возвращают указатели на статические буфера, которые могут быть перезаписаны после каждого вызова. Более того, эти две процедуры возвращают строки в одном и том же формате. Они отличаются лишь видом принимаемых аргументов, 


 и 


 должны использоваться тогда, когда все, что вам нужно, это простые сведения о дате и времени.






































После запуска эта программа выводит результат в виде: '


'. Завершающий символ конца строки включен в результат. Точнее, возвращаемое значение указывает на массив из 26 символов, как показано на рис. 6.1.




Рис. 6.1. Возвращаемая функциями 


 и 


 строка

Значительная часть старого кода Unix полагается на тот факт, что значения в возвращенной строке имеют фиксированную позицию. При использовании этих функций помните, что они включают завершающий символ конца строки. Поэтому наш небольшой пример программы использует для 


 простую форматирующую строку "


", а не "


", как можно было бы ожидать.




 устраняет необходимость шага вызова 


; в сущности, это эквивалентно
























6.1.3.2. Сложное форматирование времени: 





Хотя часто достаточно использования 


 и 


, у них есть также и ограничения:

• Формат вывода фиксирован. Нет способа изменить порядок элементов.

• В вывод не включаются сведения о часовом поясе.

• В выводе используются сокращенные названия месяца и дня.

• В выводе используются английские названия месяцев и дней.

По этим причинам C89 ввело стандартную библиотечную процедуру 


:





















 сходна с 


. Ее аргументы следующие:






Буфер для форматированной строки.






Размер буфера.






Форматирующая строка.






Указатель на 


, представляющий разложенное время, которое надо отформатировать.

Форматирующая строка содержит символы букв, смешанные о описателями преобразования, указывающими, что должно быть помещено в строку, такими, как полное имя дня недели, час в соответствии с 24-часовым или 12-часовым циклом, наличие указателей am или p.m[64 - a.m. — от ante meridiem (до полудня), p.m. — от post meridiem (пополудни), американская система обозначения 12-часового цикла времени суток. — Примеч. перев.], и т.д. (Вскоре будут приведены примеры.)

Если всю строку можно отформатировать с использованием не более 


 символов, возвращаемое значение представляет собой число символов, помещенных в 


, не включая завершающий нулевой байт. В противном случае, возвращаемое значение ноль. В последнем случае содержание 


 «неопределенно». Следующий простой пример дает представление об использовании 


:




































































После запуска эта программа выводит что-то типа:






В табл. 6.2 предоставлен полный список описателей преобразования, их возможные альтернативные представления и их значения. Вдобавок стандарт C99 добавил к списку дополнительные описатели; новые для C99 описатели помечены символом &#8730;.



Таблица 6.2. Описатели преобразования формата 







Локаль (locale) является способом описания местной специфики, принимая во внимание такие вещи, как язык, кодировка символов и значения по умолчанию для форматирования дат, времени, денежных сумм и т.д. Мы будем иметь с ними дело в главе 13 «Интернационализация и локализация». Пока достаточно понять, что результаты 


 для одной и той же форматирующей строки могут быть разными в зависимости от настроек текущей локали.

Версии, начинающиеся с 


 и 


, предназначены для «альтернативного представления». В некоторых локалях есть несколько способов представления одних и тех же сведений; эти описатели предоставляют доступ к дополнительным представлениям. Если определенная локаль не поддерживает альтернативного представления, 


 использует обычную версию.

Многие Unix-версии 


 дают возможность предоставить в командной строке форматирующую строку, начинающуюся с символа '


'. Затем 


 форматирует текущие дату и время и выводит в соответствии с форматирующей строкой:











Большинство новых описателей C99 происходит от таких существующих реализаций 


 Unix. Описатели 


 и 


 не являются в С абсолютно необходимыми, поскольку символы табуляции и конца строки могут быть помещены в строку непосредственно. Однако в контексте форматирующей строки 


 для командной строки они имеют больше смысла. Поэтому они также включены в спецификацию 


.

Стандарт ISO 8601 определяет (среди других вещей), как нумеруются недели в пределах года. В соответствии с этим стандартом недели отсчитываются с понедельника по воскресенье, а понедельник является днем недели 1, а не 0. Если неделя, в которой оказывается 1 января, содержит по крайней мере четыре дня нового года, она считается неделей 1. В противном случае, это последняя неделя предыдущего года с номером 52 или 53. Эти правила используются для вычислений описателей форматов 


, 


 и 


. (Хотя ограниченным американцам, таким, как автор, эти правила могут показаться странными, они обычно повсюду используются в Европе.)

Многие из описателей стандартов дают результаты, специфичные для текущей локали. Вдобавок некоторые указывают, что они выдают «подходящее» представление для локали (например, 


). Стандарт C99 определяет значения для локали «С». Эти значения перечислены в табл. 6.3



Таблица 6.3. Значения локали «С» для определенных форматов 







Должно быть очевидно, что 


 предоставляет значительную гибкость и контроль над связанным с датой и временем выводом, во многом таким же образом, как 


 и 


. Более того, 


 не может переполнить буфер, поскольку она проверяет входной параметр размера, что делает ее более безопасной процедурой, чем 


.

В качестве простого примера рассмотрим создание файлов журнала программы, когда каждый час создается новый файл. Имя файла должно включать дату и время создания:





















































Формат год-месяц-день-час-минута вызывает сортировку файлов в том порядке, в каком они были созданы.



ЗАМЕЧАНИЕ. Некоторые форматы данных более полезны, чем другие. Например, 12-часовое время двусмысленно, также, как чисто числовые форматы дат. (Что означает '


'? Это зависит от того, где вы живете) Сходным образом, годы из двух цифр также являются плохой мыслью. Используйте 


 благоразумно





6.1.4. Преобразование разложенного времени в 





Получение от системы значений «секунд с начала Эпохи» просто; именно так даты и времена хранятся в индексах и возвращаются с помощью 


 и 


. Эти значения также легко оценивать на равенство или посредством < и > для простых тестов раньше/позже.

Однако, с датами, введенными людьми, не так легко работать. Например, многие версии команды 


 позволяют предусмотреть дату и время, в которое 


 должна установить время модификации или доступа к файлу (с помощью 


, как было описано в разделе 5.5.3 «Изменение отметок времени: 


»).

Преобразование даты, введенной человеком, в значение 


 трудно: надо принять во внимание високосные годы, учесть часовые пояса и т.д. Поэтому стандарт C89 ввел функцию 


:













Для использования 


 укажите в 


 соответствующие значения — год, месяц, день и т.д. Если вы знаете, действовало ли для данной даты летнее время, установите соответствующим образом поле 


: 0 для «нет» и положительное значение для «да». В противном случае, используйте отрицательное значение для «не знаю». Поля 


 и 


 игнорируются.




 предполагает, что 


 представляет локальное время, не UTC. Она возвращает значение 


, представляющее переданные дату и время, или 


, если данные дата/время не могут быть правильно представлены. После успешного возвращения все значения 


 выверены на попадание в правильные диапазоны, a 


 и 


 также корректно установлены. Вот простой пример:



































































































































В строке 11 запрашиваются дата и время, а в строках 12–14 соответствующие значения считываются. (В коде изделия возвращаемые 


 значения должны проверяться.) Строки 17 и 18 компенсируют различную базу для лет и месяцев соответственно. Строка 20 указывает, что мы не знаем, представляют ли данные дата и время летнее время. Строка 22 вызывает 


, а строка 24 выводит результат преобразования. После компилирования и запуска мы видим, что это работает:



















6.1.5. Получение сведений о часовом поясе



На ранних системах Unix сведения о часовом поясе внедрялись в ядро при компиляции. Правила перехода на летнее время обычно были жестко вшиты в код, что создавало трудности для пользователей вне Соединенных Штатов или в местах внутри Соединенных Штатов, в которых не осуществлялся переход на летнее время.

В современных системах эти сведения выделены в двоичные файлы, которые читаются библиотекой С при извлечении функций, связанных со временем. Эта методика позволяет избежать необходимости в перекомпилировании библиотек и системных файлов при изменении правил и гораздо упрощает обновление правил.

Интерфейс языка С для сведений о часовых поясах развивался в разных версиях Unix, как на System V, так и Berkley, пока, наконец, не был стандартизован POSIX следующим образом.






























Функция 


 проверяет переменную окружения 


 для получения сведений о часовом поясе и переходе на летнее время.[65 - Хотя POSIX стандартизует формат TZ, он не представляет интереса, поэтому мы не стали возиться здесь с его документированием. В конце концов, именно 


 должна понимать формат, а не код пользователя. Реализации могут использовать и используют форматы, которые расширяют POSIX — Примеч. автора.] Если эта переменная не установлена, 


 использует «определенный в реализации часовой пояс по умолчанию», который скорее всего является часовым поясом машины, на которой вы работаете.

После вызова 


 сведения о локальном часовом поясе доступны в нескольких переменных:






Стандартное имя и имя летнего времени для часового пояса. Например, для областей США в восточном часовом поясе именами часового пояса являются 'EST' (Eastern Standard Time) и 'EDT' (Eastern Daylight Time).






Разница в секундах между текущим часовым поясом и UTC. Стандарт не определяет, как эта разница работает. На практике отрицательные значения представляют часовые пояса восточнее (перед, или те, которые позже) UTC; положительные значения представляют часовые пояса западнее (за, или те, которые раньше) UTC. Если вы посмотрите на это значение как «насколько изменить местное время, чтобы оно стало равно UTC», тогда знак этого значения имеет смысл.






Эта переменная равна нулю, если правила перехода на летнее время никогда не должны использоваться для данного часового пояса, и не равны нулю в противном случае.



ЗАМЕЧАНИЕ. Переменная 


 не означает, действует ли в настоящий момент летнее время! Вместо этого она просто констатирует, может ли текущий часовой пояс вообще иметь летнее время.


Стандарт POSIX указывает, что 


, 


, 


 и 


 действуют, «как если бы» они вызывали 


. Это означает, что им в действительности не нужно вызывать 


, но они должны вести себя, как если бы эта функция была вызвана. (Формулировка призвана дать определенную гибкость при реализации, в то же время гарантируя правильное поведение кода уровня пользователя.)

На практике это означает, что вы сами почти никогда не будете вызывать 


. Но если понадобится, эта функция есть.




6.1.5.1. Системы BSD: 


, не 





Некоторые производные от BSD 4.4 системы вместо переменной POSIX 


 предоставляют функцию 


:











Аргумент 


 является числом минут западнее GMT, a 


 истинно, если действует летнее время. Возвращаемое значение является строкой, дающей имя указанного часового пояса, или значение, выраженное относительно GMT. Эта функция обеспечивает совместимость с функцией V7 с тем же именем и поведением.




Локальное время: откуда оно известно?

Системы GNU/Linux хранят информацию о часовых поясах в файлах и каталогах в 


:





























































Когда возможно, этот каталог использует прямые ссылки для предоставления одних и тех же данных с разными именами. Например, файлы 


 и 


 на самом деле одни и те же:
















Частью установки системы является выбор часового пояса. Надлежащий файл данных часового пояса помещается затем в 


:











На нашей системе это автономная копия файла для нашего часового пояса. На других системах это может быть символическая ссылка на файл в 


. Преимуществом использования отдельной копии является то, что все по-прежнему работает, если 


 не смонтирован.

Переменная окружения 


, если она установлена, перекрывает значение по умолчанию для часового пояса:





































Широкое распространение этой функции делает переносимое использование переменной POSIX 


 трудной. К счастью, мы не видим большой потребности в ней 


 должно быть достаточно едва ли не для большинства необычных потребностей




6.2. Функции сортировки и поиска



Сортировка и поиск являются двумя фундаментальными операциями, потребность в которых постоянно возникает во многих приложениях Библиотека С предоставляет ряд стандартных интерфейсов для осуществления этих задач.

Все процедуры разделяют общий лейтмотив; данные управляются через указатели 


, а сортировку осуществляют предоставленные пользователем функции. Обратите также внимание, что эти API применяются к данным в памяти. Структуры сортировки и поиска в файлах значительно более сложны и выходят за рамки вводного руководства, подобного данному. (Однако, команда 


 хорошо работает для текстовых файлов; см. справочную страницу для sort(1). Сортировка двоичных файлов требует написания специальной программы.)

Поскольку ни один алгоритм не работает одинаково хорошо для всех приложений, имеются несколько различных наборов библиотечных процедур для сопровождения искомых коллекций данных. Данная глава рассматривает лишь один простой интерфейс для поиска. Другой, более развитый интерфейс описан в разделе 14.4 «Расширенный поиск с использованием двоичных деревьев». Более того, мы намеренно не объясняем лежащие в основе алгоритмы, поскольку данная книга об API, а не об алгоритмах и структурах данных. Важно понять, что API можно рассматривать как «черные ящики», выполняющие определенную работу без необходимости понимания подробностей их работы.




6.2.1. Сортировка: 






Сортировка выполняется с помощью 


:


















Название 


 происходит от алгоритма машинного поиска Хоара Quicksort (C.A.R. Hoare's Quicksort algorithm), который использовался в первоначальной реализации Unix. (Ничто в стандарте POSIX не требует использования этого алгоритма для 


. Реализация GLIBC использует высоко оптимизированную комбинацию Quicksort и Insertion Sort.)




 сортирует массивы произвольных объектов. Она работает, перетасовывая непрозрачные участки памяти из одного места массива в другой и полагаясь на то, что вы, программист, предоставите функцию сравнения, которая позволяет определить относительное расположение одного элемента массива относительно другого. Аргументы следующие:






Адрес начала массива.






Общее число элементов в массиве.






Размер каждого элемента массива. Лучший способ получения этого значения — оператор С 


.






Возможно устрашающее объявление указателя функции. Оно говорит, что «


 указывает на функцию, которая принимает два параметра '


' и возвращает 


».

Большая часть работы заключается в написании соответствующей функции сравнения. Возвращаемое значение должно имитировать соответствующее значение 


: меньше нуля, если первое значение «меньше» второго, ноль, если они равны, и больше нуля, если первое значение «больше» второго. Именно функция сравнения определяет значения «больше» и «меньше» для всего, что вы сравниваете. Например, для сравнения двух значений 


 мы могли бы использовать эту функцию:


































































Это показывает общий стереотип для функций сравнения: привести тип аргументов от 


 к указателям на сравниваемый тип, а затем вернуть результат сравнения.

Для чисел с плавающей точкой простое вычитание, подобное '


', не работает, особенно если одно значение очень маленькое или одно или оба значения являются специальными значениями «не число» или «бесконечность». Поэтому нам приходится осуществлять сравнение вручную, принимая во внимание нечисловое значение (которое даже не равно самому себе!)




6.2.1.1. Пример: сортировка сотрудников


Для более сложных структур требуются более сложные функции. Например, рассмотрите следующую (довольно тривиальную) 


:































Мы могли бы написать функцию для сортировки сотрудников по фамилии, имени и идентификационному номеру:





































































































Логика здесь проста: сначала сравниваются фамилии, затем имена, а затем номера ID, если два имени совпадают. Используя для строк 


, мы автоматически получаем правильное отрицательное/нулевое/положительное значение для возвращения.

При сравнении ID сотрудников нельзя просто использовать вычитание: представьте, что 


 64-разрядный, а 


 32-разрядный, а два значения отличаются лишь в старших 32 битах (скажем, младшие 32 бита равны нулю). В таком случае вычитание автоматически привело бы к приведению типа к 


 с отбрасыванием старших 32 битов и возвращением неверного результата.



ЗАМЕЧАНИЕ. Возможно, мы остановились при сравнении имен, в этом случае все сотрудники с совпадающими фамилиями и именами оказались бы сгруппированы, но никак не отсортированы

Это важный момент 


 не гарантирует стабильной сортировки. Стабильна сортировка, в которой, если два элемента равны на основе значения какого-либо ключа(-ей), они сохраняют свой первоначальный порядок друг относительно друга в конечном отсортированном массиве. Например, рассмотрите трех сотрудников с одинаковыми фамилиями и именами и с номерами 17, 42 и 81. Их порядок в первоначальном массиве. возможно, был 42, 81 и 17 (Что означает, что сотрудник 42 находится по индексу с меньшим значением, чем сотрудник 81, который, в свою очередь, находится по индексу с меньшим значением, чем сотрудник 17). После сортировки порядок может оказаться 81, 42 и 17. Если ото представляет проблему, процедура сравнения должна рассматривать все важные ключевые значения (Наша так и делает.)


Просто используя другую функцию, мы можем отсортировать сотрудников по старшинству:

















































































Для максимальной переносимости мы использовали 


, которая возвращает разницу в секундах между двумя значениями 


. Для данного конкретного случая приведение, такое, как






должно сработать, поскольку значения 


 находятся в приемлемом диапазоне. Тем не менее, мы вместо этого использовали полный трехсторонний оператор 


, просто из предосторожности.

Вот пример файла данных со списком пяти президентов США:




































В 


 приведена простая программа, которая считывает этот файл в массив 


, а затем сортирует его, используя две только что представленные функции сравнения.









































































































































































































































































































































































Строки 70–77 считывают данные. Обратите внимание, что любое использование 


 требует от входных данных «хорошего поведения». Если, например, какое-нибудь имя содержит более 29 символов, возникает проблема. В данном случае, мы вне опасности, но в коде изделия нужно быть гораздо более осмотрительным.

Строка 82 сортирует данные по имени и по ID сотрудника, а затем строки 84–91 выводят отсортированные данные. Сходным образом строка 94 пересортировывает данные, на этот раз по старшинству, а строки 97–103 выводят результаты. После компилирования и запуска программа выдает следующие результаты:


































































(Мы использовали 1 час пополудни как приблизительное время, когда все президенты начали работать.)[66 - Вывод, показанный здесь, относится к US Eastern Standard Time. Вы получите различные результаты для одних и тех же программ и данных, если используете другой часовой пояс — Примеч. автора.]

Стоит заметить одну вещь: 


 переставляет данные в массиве. Если каждый элемент массива представляет собой большую структуру, при сортировке массива большое количество данных будут копироваться туда-сюда. Вместо этого может оказаться выгодным создать отдельный массив указателей, каждый из которых указывает на один элемент массива. Затем использовать 


 для сортировки массива указателей, получая доступ к несортированным данным через сортированные указатели.

Платой за это является дополнительная память для размещения указателей и модификация функций сравнения для дополнительного перенаправления указателей при сравнении структур. Полученной выгодой может стать значительное ускорение работы, поскольку на каждом шаге перемещается лишь четырех- или восьмибайтный указатель вместо большой структуры. (Наша 


 имеет размер по крайней мере 68 байтов. При обмене четырехбайтных указателей перемещается в 17 раз меньше данных, чем при обмене структур.) Для тысяч размещенных в памяти структур разница мажет быть существенной.



ЗАМЕЧАНИЕ. Если вы являетесь программистом С++, знайте! 


 может быть опасной для использования с массивами объектов! 


 осуществляет простые перемещения памяти, копируя байты. Она совершенно ничего не знает о конструкциях С++, таких, как конструкторы копирования или функции 


. Вместо этого используйте одну из функций сортировки STL[67 - STL (Standard Template Library, стандартная библиотека шаблонов). — Примеч. науч. ред.] или используйте методику отдельного массива указателей.





6.2.1.2. Пример: сортировка содержимого каталога


В разделе 5.3 «Чтение каталогов» мы продемонстрировали, как элементы каталогов возвращаются в физическом порядке каталога. В большинстве случаев гораздо полезнее иметь содержимое каталога отсортированным каким-нибудь образом, например, по имени или по времени изменения. Хотя и не стандартизованные POSIX, несколько процедур упрощают это, используя 


 в качестве лежащего в основе сортирующего агента:

































Функции 


 и 


 были сделаны доступными в 4.2 BSD и широко поддерживаются[68 - Заметным исключением является лишь Sun Solaris, где эти две функции существуют лишь в трудной для использования библиотеке совместимости с BSD — Примеч. автора.], 


 является расширением GNU.




 читает каталог, имя которого дано в 


, создает с использованием 


 массив указателей 


 и устанавливает 


, чтобы он указывал на начало этого массива. Как массив указателей, так и указываемые структуры 


 выделяются с помощью 


; вызывающий код должен использовать 


, чтобы избежать утечек памяти.

Для выбора нужных элементов используйте указатель функции 


. Когда это значение равно 


, все действительные элементы каталога включаются в конечный массив. В противном случае 


 вызывается для каждого элемента, и те элементы, для которых она возвращает ненулевое (истинное) значение, включаются в массив.

Указатель функции compare сравнивает два элемента каталога. Он передается функции 


 для использования при сортировке.




 лексикографически сравнивает имена файлов. Она использует для сравнения функцию 


. 


 похожа на 


, но учитывает связанные с местной спецификой правила сортировки (см. раздел 13.4 «Не могли бы вы написать это для меня по буквам?»).




 является расширением GNU, которое использует для сравнения имен файлов функцию GNU 


 (см. strverscmp(3).) Короче говоря, эта функция понимает обычные соглашения по версиям имен файлов и сравнивает их соответствующим образом.

В 


 приведена программа, похожая на 


. Однако, она использует для работы 


 и 


.






































































































































































































































































































































Функция 


 программы (строки 1–27) следует стандартному шаблону, который мы использовали до этого. Функция 


 (строки 31–35) действует как параметр 


, выбирая лишь имена файлов, которые не начинаются с точки.

Функция 


 (строки 43–65) довольно проста, причем 


 делает большую часть работы. Обратите внимание, как каждый элемент отдельно освобождается с помощью 


 (строка 59) и как освобождается также весь массив (строка 62).

При запуске содержимое каталога в самом деле выводится в отсортированном порядке, без '


' и '


'.






















































6.2.2. Бинарный поиск: 





Линейный поиск в значительной степени похож на свое название: вы начинаете в начале и проходите искомый массив, пока не встретите то, что нужно. Для чего-нибудь простого, типа поиска целых, это обычно принимает форму цикла 


. Рассмотрите эту функцию:









































Преимуществом линейного поиска является его простота; легко с самого начала написать правильный код. Более того, он работает всегда. Даже если в конец массива добавляются элементы или они удаляются из него, нет необходимости сортировать массив.

Недостатком линейного поиска является то, что он медленный. В среднем для массива, содержащего 


 элементов, при линейном поиске случайного элемента требуется '


' сравнений, прежде чем найдется нужный элемент. Это становится чрезмерно дорогим даже на современных высокопроизводительных системах, когда 


 принимает большие значения. Поэтому линейный поиск следует использовать лишь с небольшими массивами.

В отличие от линейного, бинарный поиск требует, чтобы входной массив был уже отсортирован. Недостатком здесь является то, что если добавляются элементы, массив перед новым поиском нужно повторно отсортировать. (Когда элементы удаляются, остальное содержимое массива все равно должно быть перетасовано. Это не так дорого, как повторная сортировка, но все равно может потребовать большого перемещения данных.)

Преимуществом бинарного поиска, и значительным, является то, что бинарный поиск умопомрачительно быстр, требуя самое большее log


(N) сравнений, где N является числом элементов в массиве. Функция 


 объявлена следующим образом:


















Параметры и их назначение сходны с таковыми для 


:






Объект, который ищется в массиве.






Начало массива.






Число элементов в массиве.






Размер каждого элемента, полученный с помощью 


.






Функция сравнения. Она должна работать таким же образом, как функция сравнения для 


, возвращая отрицательные/нулевые/положительные значения в соответствии с тем, меньше/равен/больше первый параметр по сравнению со вторым.

Если объект не найден, 


 возвращает 


. В противном случае она возвращает указатель на найденный объект. Если 


 соответствует более одного объекта, какой из них будет возвращен, не определено. Поэтому, как и в случае с 


, убедитесь, что функция сравнения принимает во внимание все существенные части искомой структуры данных.




 показывает 


 на практике, расширяя использованный ранее пример 


:


























































































































































































Строки 7–12 определяют 


; она та же, что и раньше. Строки 16–29 служат в качестве функции сравнения как для 


, так и для 


. Они сравнивают лишь ID сотрудников. Строки 33–37 определяют 


, которая является удобной функцией для печати структуры, поскольку это делается из разных мест.





















































































































































































































































































































































Функция 


 начинается с проверки аргументов (строки 52–55). Затем она читает данные из указанного файла (строки 57–72). Стандартный ввод для данных сотрудников использоваться не может, поскольку он зарезервирован для запроса у пользователя ID искомого сотрудника.

Строки 77–84 сортируют, а затем печатают данные. Затем программа входит в цикл, начинающийся со строки 86. Она запрашивает идентификационный номер сотрудника, выходя из цикла по достижению конца файла. Для поиска в массиве мы используем 


 с именем 


. Достаточно лишь установить в его поле emp_id введенный номер ID; другие поля при сравнении не используются (строка 92).

Если найден элемент с подходящим ключом, 


 возвращает указатель на него. В противном случае она возвращает 


. Возвращенное значение проверяется в строке 96, и осуществляется нужное действие. Наконец, строка 102 выводит символ конца строки, чтобы системное приглашение появилось с новой строки. Вот что появляется после компилирования и запуска программы:












































































Дополнительный, более продвинутый API для поиска коллекций данных описан в разделе 14.4 «Расширенный поиск с использованием двоичных деревьев».




6.3. Имена пользователей и групп



Хотя операционная система для сохранения владельцев файлов и проверки прав доступа работает с идентификационными номерами пользователей и групп, люди предпочитают работать с именами пользователей и групп.

Ранние системы Unix хранили информацию, сопоставляющую имена с номерами ID, в простых текстовых файлах 


 и 


. На современных системах эти файлы до сих пор существуют, а их формат не изменился после V7 Unix. Однако, они больше не определяют данные полностью. Большие установленные системы с множеством сетевых хостов хранят сведения в сетевых базах данных, которые представляют собой способ хранения информации на небольшом числе серверов, доступ к которым осуществляется через сеть[69 - Типичные сетевые базы данных включают Network Information Service (NIS) и NIS+ от Sun Microsystems, Kerberos (Hesiod), MacOS X NetInfo (версии вплоть до и включая 10.2) и LDAP, Lightweight Directory Access Protocol. Системы BSD хранят сведения в базах данных на диске и автоматически создают файлы 


 и 


 — Примеч. автора.]. Однако, такое использование прозрачно для большинства приложений, поскольку доступ к информации осуществляется через тот самый API, который использовался для получения сведений из текстовых файлов. Именно по этой причине POSIX стандартизует лишь API; в совместимой с POSIX системе файлы 


 и 


 не обязательно должны существовать.

API для этих двух баз данных похожи; большая часть обсуждения фокусируется на базе данных пользователей.




6.3.1. База данных пользователей


Традиционный формат /etc/passwd поддерживает по одной строке на пользователя. В каждой строке есть несколько полей, каждое из которых отделено от следующего символом двоеточия:











По порядку эти поля следующие:

Имя пользователя

Это то, что пользователь набирает при регистрации, что отображается с помощью '


', а также используется в любом другом контексте при отображении пользователей.

Поле пароля

На старых системах здесь хранился зашифрованный пароль пользователя. На новых системах в этом поле скорее всего стоит x (как в данном случае), это означает, что сведения о пароле находятся в другом файле. Это разделение является средством обеспечения безопасности; если непривилегированному пользователю недоступен зашифрованный пароль, его значительно сложнее «взломать».

ID пользователя

Должен быть уникальным; один номер на пользователя.

ID группы

Это номер ID начальной группы пользователя. Как обсуждается далее, на современных системах с процессами связаны несколько групп.

Настоящее имя пользователя

Это по крайней мере имя и фамилия пользователя. Некоторые системы допускают разделяемые запятыми поля для местоположения офиса, номера телефона и т.д., но это не стандартизовано.

Входной каталог

Этот каталог становится домашним каталогом для пользователей, когда они зарегистрируются в системе (


 — по умолчанию для команды 


).

Входная программа

Программа, которая запускается при регистрации пользователя. Обычно это оболочка, но не обязательно. Если это поле оставлено пустым, по умолчанию используется 


.

Доступ к базе данных пользователей осуществляется через процедуры, объявленные в 


:








































Поля в 


, использующиеся различными процедурами API, напрямую соответствуют полям файла паролей.














































(Имя 


 историческое; когда разрабатывались ранние системы Unix, это поле содержало соответствующие сведения для учетной записи пользователя на системах Bell Labs Honeywell с операционной системой GECOS.)

Назначение каждой процедуры описано в следующем списке.






Возвращает указатель на внутреннюю структуру 


, содержащую сведения о «текущем» пользователе. Эта процедура читает всю базу данных паролей, по одной записи за раз, возвращая указатель на структуру для каждого пользователя. Каждый раз возвращается тот же самый указатель; т.е. для каждой записи пользователя внутренняя 


 переписывается заново. Когда 


 достигает конца базы данных паролей, она возвращает 


. Таким образом, она позволяет пройти через всю базу данных по одному пользователю за раз. Порядок, в котором возвращаются записи, не определен.






Сбрасывает внутреннее состояние, так что следующий вызов 


 возвращает первую запись в базе данных паролей.






«Закрывает базу данных», так сказать, будь то простой файл, сетевое соединение или что-нибудь еще.






Ищет пользователя с членом 


, соответствующим 


, возвращая указатель на 


, описывающий пользователя, или 


, если пользователь не найден.






Сходным образом ищет пользователя с номером ID, приведенным в 


, возвращая указатель на 


, описывающий пользователя, или 


, если пользователь не найден.




 — вот что нужно, когда есть номер ID пользователя (такой, как в 


) и вам нужно вывести имя соответствующего пользователя. 


 преобразует имя в номер ID пользователя, например, если вы хотите использовать с файлом 


 или 


. Теоретически обе эти процедуры осуществляют линейный поиск по базе данных паролей для обнаружения нужных сведений. На практике это верно, когда используется файл паролей, однако, кулуарные базы данных (сетевые или другие, как на системах BSD) склоняются к использованию более эффективных методов хранения, так что эти вызовы, возможно, в таком случае не такие дорогие[70 - К сожалению, если производительность является проблемой, нет стандартных способов узнать, как ваша библиотека осуществляет работу, а на самом деле способ ее работы может варьировать во время исполнения! (См. справочную страницу nsswitchconf(5) в системе GNU/Linux.) С другой стороны, назначением API помимо всего прочего является сокрытие деталей — Примеч. автора.].




 полезна, когда нужно пройти через всю базу данных паролей. Например, может быть необходимо прочесть ее всю в память, отсортировать, а затем осуществить быстрый поиск с помощью 


. Это очень полезно для избежания множества линейных поисков, свойственных поиску по одному элементу за раз с помощью 


 или 


.



ЗАМЕЧАНИЕ. Указатели, возвращаемые 


, 


 и 


, все указывают на внутренние 


 данные. Поэтому следует сделать копию их содержимого, если нужно сохранить сведения.

Хорошенько рассмотрите определение 


. Члены, представляющие символьные строки, являются указателями, они также указывают на внутренние 


 данные, и если вы собираетесь скопировать структуру, не забудьте также скопировать и данные, на которые указывает каждый член структуры.





6.3.2. База данных групп


Формат базы данных групп 


 подобен формату 


, но с меньшим числом полей.































Опять-таки на одну группу отводится одна строка, с полями, разделенными двоеточием. Поля следующие.

Имя группы

Это имя группы, как оно отображается в '


' или в любом другом контексте, когда требуется имя группы.

Пароль группы

Историческое поле. Оно больше не используется.

ID группы

Как и для ID пользователя, должен быть уникальным для каждой группы.

Список пользователей

Разделенный запятыми список пользователей, являющихся членами группы.

В предыдущем примере мы видели, что пользователь 


 является членом нескольких групп. Это членство на практике отражается в том, что называют набором групп (group set). Помимо главных номеров ID пользователя и ID группы, которые есть у процессов, набор групп является набором номеров ID дополнительных групп, который имеет при себе каждый процесс. Система проверяет на соответствие с этими ID групп, ID группы файла при осуществлении проверки прав доступа. Эта тема более подробно обсуждается в разделе 11 «Разрешения и ID пользователя и группы».

API базы данных групп сходна с API для базы данных пользователей. Следующие функции определены в 


:








































struct group соответствует записям в /etc/group:































Поле 


 требует некоторого объяснения. Хотя оно объявлено в виде указателя на указатель (


), лучше представить его как массив строк (наподобие 


). Последний элемент в массиве устанавливается в 


. Когда в списке нет членов, первый элемент массива равен 


.




 демонстрирует, как использовать 


 и поле 


. Программа принимает в командной строке имя единственного пользователя и печатает все записи групп, в которых появляется этот пользователь:























































































































































Функция 


 сначала проверяет ошибки (строки 17–20). Основным компонентом программы является вложенный цикл. Внешний цикл (строка 22) перечисляет все записи базы данных группы. Внутренний цикл (строка 23) перечисляет всех членов массива 


. Если один из членов соответствует имени из командной строки (строка 24), для печати записи вызывается 


 (строка 25):






















































































Функция 


 (строки 34–48) проста, ее логика подобна логике 


 для печати списка членов. Члены списка группы разделены запятыми; поэтому тело цикла до вывода запятой должно проверить, что следующий элемент в массиве не является 


. Этот код работает правильно, даже если в группе нет членов. Однако мы знаем, что для этой программы есть члены, иначе 


 не была бы вызвана! Вот что происходит при запуске программы:


































6.4. Терминалы: 





Модель стандартного ввода, стандартного вывода и стандартной ошибки Linux/Unix препятствует специальной трактовке устройств ввода и вывода. Программам обычно не нужно знать или беспокоиться о том, направляется ли их вывод на терминал, в файл, канал, физическое устройство или что-то еще.

Однако иногда бывают моменты, когда программе действительно нужно знать, с какого рода файлом связан файловый дескриптор. Семейство вызовов 


 часто предоставляет достаточно сведений обычный файл, каталог, устройство и т.д. Хотя иногда даже этого недостаточно, и для интерактивных программ, в частности, вам может потребоваться знать, не представляет ли дескриптор файла 


.

tty (сокращение для Teletype, одного из ранних производителей компьютерных терминалов) является любым устройством, представляющим терминал, т.е. нечто, что человек мог бы использовать для взаимодействия с компьютером. Это может быть либо аппаратное устройство, такое, как клавиатура и монитор персонального компьютера, или старинный терминал видеодисплея, соединенный с компьютером через последовательный порт или модем, или программный псевдотерминал, такой, который используется в оконных системах и при сетевых регистрациях.

Различить можно с помощью 


.













Эта функция возвращает 1, если дескриптор файла 


 представляет терминал, в противном случае 0. В соответствии с POSIX 


 может установить 


 для указания ошибки; поэтому до вызова 


 следует установить errno в 0, а затем проверить ее значение, если был возвращен 0. (Справочная страница GNU/Linux isatty(3) не упоминает об использовании 


.) Стандарт POSIX также указывает, что просто возврат 


 1 не означает, что на другом конце дескриптора файла находится человек!

Одним местом, где используется 


, является современная версия 


, в которой имена файлов по умолчанию печатаются в столбцы, если терминалом является стандартный вывод, а если нет, они печатаются по одной на строчку.




6.5. Рекомендуемая литература


1. Mastering Algorithms With C by Kyle Loudon. O'Reilly & Associates, Sebastopol, California, USA, 1999. ISBN: 1-56592-453-3.

Эта книга предоставляет практическое, утилитарное введение в алгоритмы и структуры данных с использованием С, освещая среди прочих вещей таблицы хэшей, деревья, сортировку и поиск.

2. The Art of Computer Programming Volume 3. Sorting and Searching, 2nd edition, by Donald E. Knuth Addison-Wesley, Reading Massachusetts, USA, 1998. ISBN: 0-201-89685-0.[71 - Русский перевод Дональд E. Кнут. Искусство программирования Том 3. Сортировка и поиск (2-е издание). Москва • Санкт-Петербург • Киев, Вильямс, 2000 — Примеч. науч. ред.]

На эту книгу обычно ссылаются как на последнее слово в сортировке и поиске. Примите во внимание, что она значительно более сжата и труднее для чтения, чем книга Loudon'a.

3. Проект GTK+[72 - 


 — Примеч. автора.] состоит из нескольких совместно работающих библиотек GTK+ является лежащим в основе инструментарием, используемым проектом GNU GNOME.[73 - 


 — Примеч. автора.] В основе иерархии библиотек располагается Glib, библиотека фундаментальных типов, структур данных и функций для работы с ними. Glib включает возможности для всех основных операций, которые мы до сих пор рассмотрели в данной книге, и многое другое, включая связанные списки и хэш-таблицы. Для просмотра онлайн-документов начните с веб-сайта проекта документации GTK+[74 - 


 — Примеч. автора.], щелкните на ссылке «Загрузить» (Download) и идите дальше по онлайн-версии.




6.6. Резюме


• Время внутренне хранится в виде значений 


, представляющих «секунды с начала Эпохи». Эпоха для систем GNU/Linux и Unix начинается с полночи 1 января 1970 г. по UTC. Текущее время получается от системы с помощью системного вызова 


, а 


 возвращает разницу в секундах между двумя значениями 


.

• Структура 


 представляет «разложенное время», которое является значительно более удобным представлением даты и времени. 


 и 


 преобразуют значения 


 в значения 


, a 


 действует в обратном направлении.

• 


 и 


 осуществляют упрошенное форматирование значений времени, возвращая указатель на 


 строку символов фиксированного размера и формата, 


 предусматривает гораздо более гибкое форматирование, включая значения на основе местных настроек.

• Сведения о часовом поясе доступны через вызов 


. Поскольку стандартные процедуры действуют так, как если бы они автоматически вызывали 


, необходимость в непосредственном вызове этой функции возникает редко.

• Стандартной процедурой для сортировки массивов является 


. Используя предоставленную пользователем функцию сравнения и принимая параметры числа элементов массива и их размера, 


 может сортировать любые виды данных. Это обеспечивает значительную гибкость.

• 


 читает в массив 


 каталог целиком. Для выбора того, какие элементы включить в массив и для обеспечения упорядочения элементов в массиве могут использоваться предоставленные пользователем функции 


 является стандартной функцией для сортировки элементов каталога по имени; 


 передает функцию сортировки прямо через 


.

• Функция 


 работает подобно 


. Она осуществляет быстрый бинарный поиск. Используйте ее, если цена линейного поиска перевешивает цену сортировки ваших данных. (Дополнительный API для поиска коллекций данных описан в разделе 14.4 «Расширенный поиск с помощью двоичных деревьев».)

• Базы данных пользователей и групп могут храниться в файлах на локальном диске или могут быть доступны через сеть. Стандартный API намеренно скрывает это различие. Каждая база данных обеспечивает как линейный просмотр всей базы данных, так и непосредственные запросы имени или ID пользователя/группы.

• Наконец, для тех случаев, когда недостаточно простого 


, 


 может вам сообщить, представляет ли открытый файл устройство терминала.




Упражнения


1. Напишите простую версию команды 


, которая принимает в командной строке строку формата и использует ее для форматирования и вывода текущего времени.

2. Когда файл старше шести месяцев, '


' использует для печати времени изменения более простой формат. GNU версия файла 


 использует следующее вычисление:


























Сравните это с нашим примером вычисления шести прошлых месяцев. Каковы преимущества и недостатки каждого из методов?

3. Напишите простую версию команды 


, которая изменяет время модификации файла, имя которого указано в командной строке, на текущее время

4. Добавьте к вашей команде 


 опцию, которая принимает в командной строке значения даты и времени и использует их в качестве нового времени модификации файлов, указанных в командной строке.

5. Добавьте к своей версии 


 еще одну опцию, которая принимает имя файла и использует время модификации данного файла как новое время модификации файла, указанного в командной строке.

6. Усовершенствуйте 


 так, чтобы она сортировала отдельный массив указателей, указывающих на массив сотрудников.

7. Добавьте к 


 опции для сортировки по номеру индекса, времени модификации, времени доступа и размеру. Добавьте «обратную опцию», так, чтобы основанная на времени сортировка первым помещала самый недавний файл, а по другим критериям (размеру, индексу) помещала вначале наибольшее значение.

8. Напишите простую версию команды 


. Она должна использоваться так:






Здесь пользователь и группа являются именами пользователя и группы, представляющими новых пользователя и группу для указанных файлов. Группа необязательна; если она присутствует, она отделяется от пользователя двоеточием. Чтобы протестировать свою версию на системе GNU/Linux, вы должны зарегистрироваться в качестве 


. Делайте это осторожно!

9. Усовершенствуйте свою 


, чтобы допустить использование числовых значений пользователя или группы наряду с их именами.

10. Напишите функции для копирования структур пользователя и группы, включая указываемые данные. Для выделения памяти используйте при необходимости 


.

11. Напишите специализированную библиотеку поиска пользователей, которая считывает в динамически выделяемый массив всю базу данных пользователей. Предусмотрите быстрый поиск пользователей как по ID, так и по именам. Гарантируйте обработку случая, при котором запрошенный пользователь не найден.

12. Сделайте то же самое для базы данных групп.

13. Напишите программу 


, которая печатает содержимое 


 для каждого файла, указанного в командной строке. Она должна выводить все значения в формате, удобном для восприятия человеком: значения 


 в виде дат и времени, значения 


 и 


 в виде соответствующих имен (если они доступны), а также содержимое символических ссылок. Выведите поле 


 таким же образом, как вывела бы 


.

Сравните свою программу с программой 


 GNU Coreutils как по их выводу, так и по исходному коду.




Глава 7

Соединяя все вместе: 






Команда V7 


 хорошо связывает воедино все, что мы до сих пор видели. Она использует почти все API, которые мы рассмотрели, затрагивая многие аспекты программирования Unix: выделение памяти, вспомогательные данные файлов, времена и даты, имена пользователей, чтение каталогов и сортировку.




7.1. Опции V7 





По сравнению с современными версиями 


, V7 


 принимает лишь небольшое количество опций, а значение некоторых из них для V7 отличается от значения для современной 


. Эти опции следующие:




 Выводит все элементы каталога. Без нее '


' и '


' не выводятся. Довольно интересно, V7 игнорирует лишь '


' и '


', тогда как с V1 по V6 игнорируется любой файл, имя которого начинается с точки. Это последнее является также поведением по умолчанию и для современных версий 


.




 Вместо времени модификации файла использует для 


 или 


 время изменения индекса.




 Для аргументов каталогов выводит сведения о самом каталоге, а не о его содержимом.




 «Заставляет» читать каждый элемент как каталог и печатать найденное в каждом слоте имя. Эта опция отключает 


, 


, 


, 


 и включает 


. (Эта опция, очевидно, существует для отладки и исправления файловой системы.)




 Для '


' использует вместо имени пользователя имя группы.




 Выводит в первом столбце номер индекса вместе с именем файла или длинным листингом.




 Осуществляет привычный вывод в длинном формате. Обратите, однако, внимание, что V7 '


' выводила лишь имя владельца, а не имена владельца и группы вместе.




 Изменяет порядок сортировки, будь то по алфавиту для имен файлов или по времени.




 Выводит размер файла в 512-байтовых блоках. Справочная страница V7 ls(1) утверждает, что вспомогательные блоки (indirect blocks) — блоки, используемые файловой системой для обнаружения блоков больших файлов — также учитываются при вычислении, но, как мы увидим, это утверждение было неверным.




 Сортирует вывод вместо имени по времени модификации, сначала более ранние.




 С опциями 


 и/или 


 использует время доступа вместо времени модификации. Наибольшие различия между V7 


 и современной 


 затрагивают опцию 


 и опцию 


. Современные системы опускают все файлы с точками, если не указана 


, и они включают в длинный листинг 


 имена и владельца, и группы. На современных системах 


 означает вывод лишь имени группы, а 


 означает вывод лишь имени владельца. Стоит заметить, что у GNU 


 свыше 50 опций!




7.2. Код V7 





Файл 


 в дистрибутиве V7 содержит код. Весь он занимает 425 строк.












































































































































































































































Программа начинается с включения файлов (строки 5–8) и объявлений переменных. 


 (строки 14–27) инкапсулирует части 


, которые интересны 


. Позже мы увидим, как эта структура заполняется.

Переменные 


, 


 и т.д. (строки 29 и 30) все указывают на наличие соответствующей опции. Такой стиль именования переменных типичен для кода V7. Переменные 


, 


 и 


 (строки 37–39) представляют файлы, о которых 


 выводит сведения. Обратите внимание, что flist является массивом фиксированного размера, которая позволяет обрабатывать не более 1024 файлов. Вскоре мы увидим, как используются все эти переменные.

После объявлений переменных идут объявления функций (строки 42–45), а затем определение 


, которая различает файл, указанный в командной строке, от файла, найденного при чтении каталога.







































































Функция 


 начинается с объявления переменных и функций (строки 52–58), устанавливая буфер для стандартного вывода, получая время дня (строки 60–61) и вычисляя значение секунд с начала Эпохи для примерно шести месяцев (строка 62). Обратите внимание, что у всех констант есть суффикс 


, указывающий на использование арифметики 


.

























































































































































































































































































Строки 63–118 разбирают опции командной строки. Обратите внимание на ручной разбор кода: 


 еще не была придумана. Переменная 


 устанавливается в 


, когда опция требует использования системного вызова 


.

Избежание ненужного вызова 


 для каждого файла дает большой выигрыш в производительности. Вызов 


 был чрезвычайно дорогим, поскольку он мог вызвать поиск расположения индекса на файле, дисковое чтение для получения индекса, а затем поиск на диске расположения содержимого каталога (для того, чтобы продолжить чтение элементов каталога).

В современных системах индексы находятся в группах, распределенных по всей файловой системе, вместо объединения их вместе в начале. Это дает заметный прирост производительности. Тем не менее, вызовы 


 до сих пор не бесплатны, вы должны использовать их лишь при необходимости, но не более.






















































































Строки 119–125 обрабатывают опцию 


, выключая 


, 


, 


 и 


. Строки 126–131 обрабатывают 


, устанавливая для файла чтение сведений о владельце или группе. Помните, что V7 показывает лишь одно из этих сведений, но не оба.

Если аргументов больше не осталось, строки 132–135 устанавливают 


 таким образом, что он указывает на строку, представляющую текущий каталог. Назначение '


' действительно, хотя и необычно. '


' компенсирует '


' в строке 137. Это позволяет избежать в главной части программы специального случая для '


'.



































































































































Строки 136–141 перебирают аргументы, собирая сведения о каждом. Второй аргумент 


 булевый: 


, если имя является аргументом командной строки, в противном случае 


. Строка 140 добавляет флаг 


 к полю 


 для каждого аргумента командной строки.

Функция 


 добавляет каждую новую 


 к глобальному массиву 


 (строка 137). Она также обновляет глобальный указатель 


, чтобы он указывал в этом массиве на текущий последний элемент.

Строки 142–143 сортируют массив, используя 


, и сохраняют текущее значение 


 в 


. Строки 144–159 перебирают в цикле каждый элемент массива, выводя соответствующим образом сведения о файле или каталоге.

Код для каталогов заслуживает дальнейшего объяснения:






Строка 146. Если файл является каталогом и 


 не предусмотрено или было установлено 


, 


 должна прочесть каталог вместо того, чтобы выводить сведения о самом каталоге.






Строки 147–148. Выводят имя каталога и двоеточие, если в командной строке было указано несколько файлов.











Строки 149–150. Восстанавливают 


 из 


. Массив 


 действует как двухуровневый стек имен файлов. Аргументы командной строки хранятся с 


 до 


. Когда 


 читает каталог, она помещает структуры 


 для содержимого каталога в стек, начиная с 


 и до 


. Это показано на рис. 7.1.




Рис. 7.1. Массив 


 как двухуровневый стек






Строки 151–152. Сортируют элементы подкаталога, если не действует 


.






Строки 153–154. Выводят для 


 или 


 общее число блоков, используемых файлами в каталоге. Эта сумма хранится в переменной 


, которая сбрасывается для каждого каталога. На современных системах форматирующая строка 


 для 


 эквивалентна 


; она означает «вывести длинное целое». (В V7 есть также 


, см. строку 192.)






Строки 155–156. Выводит сведения о каждом файле в подкаталоге. Обратите внимание, что V7 


 спускается лишь на один уровень в дереве каталогов. У нее отсутствует современная «рекурсивная» опция 


.












































































Процедура 


 выводит сведения о файле. Строки 172–173 проверяют, установлен ли -1 в поле 


, и если так, функция возвращается. Когда верно '


', структура 


 недействительна. В противном случае это поле содержит номер индекса файла.

Строки 174–175 выводят номер индекса, если действует 


. Строки 176–177 выводят общее число блоков, если действует 


. (Как мы увидим ниже, это число может быть неточным.)






























































































































Строки 178–197 обрабатывают опцию 


. Строки 179–181 выводят тип файла, права доступа и число ссылок. Строки 182–184 устанавливают 


 на ID владельца или группы, в зависимости от опции 


. Строки 185–188 получают соответствующее имя и выводят его, если оно доступно. В противном случае программа выводит числовое значение.

Строки 189–192 проверяют, является ли файл блочным или символьным устройством. Если да, они выводят старшее и младшее номера устройств, извлеченные с помощью макросов 


 и 


. В противном случае они выводят размер файла.

Строки 193–196 выводят соответствующее время. Если оно старше шести месяцев, код выводит месяц, день и год. В противном случае, выводятся месяц, день и время (формат результата с 


 см. раздел 6.1.3.1 «Простое форматирование времени: 


 и 


»).

Наконец, строки 198–201 выводят имя файла. Мы знаем, что для аргумента командной строки это завершающаяся нулем строка, и может быть использована 


. Для файла, прочитанного из каталога, оно может не завершаться нулем, поэтому должна использоваться явно указанная точность, 


.






































































































































































Функция 


 преобразует ID владельца или группы в соответствующее имя. Она реализует простую схему кэширования; если переданное 


 то же самое, которое находится в глобальной переменной 


, функция возвращает 0 (все нормально), буфер уже содержит имя (строки 210–211). 


 инициализируется в -1 (строка 33), поэтому этот тест не проходит, когда 


 вызывается первый раз.




 уже открыт либо в 


, либо в 


 (см. строки 126–130). Код здесь проверяет, что открытие было успешным, и если нет, возвращает -1 (строки 212–213).

Удивительно, 


не использует 


 или 


. Вместо этого она использует преимущество того факта, что формат 


 и 


 идентичен для трех первых полей (имя, пароль, числовой ID) и что оба используют в качестве разделителя двоеточие.

Строки 216–232 реализуют линейный поиск по файлу. 


 содержит число обнаруженных до сих пор двоеточий: 0 для имени и 2 для ID. Таким образом, при сканировании строки она заполняет как имя, так и ID.

Строки 233–235 завершают буфер 


, устанавливают в глобальной 


 последний найденный ID и возвращают 0 для обозначения успеха.































Функция 


 сообщает, сколько дисковых блоков использует файл. Это вычисление основано на размере файла, возвращенном 


. Размер блока V7 равен 512 байтам — размер физического сектора диска.

Вычисление в строке 242 выглядит несколько устрашающим. '


' является сдвигом вправо на девять битов. Это осуществляет деление на 512 для получения числа блоков. (На раннем аппаратном обеспечении сдвиг вправо выполнялся гораздо быстрее деления.) Пока все хорошо. Теперь, файл даже размером в один байт все равно занимает целый дисковый блок. Однако, '


' дает ноль (целое деление срезает), что неверно. Это объясняет '


'. Добавляя 511, этот код гарантирует, что сумма дает правильное число блоков при делении на 512.

Это вычисление, однако, лишь приблизительное. У очень больших файлов есть также дополнительные блоки. Несмотря на заявление в справочной странице V7 ls(1), данное вычисление не принимает в расчет дополнительные блоки.

Более того, рассмотрите случай файла с большими дырами (созданными установкой указателя файла дальше конца файла с помощью 


). Дыры не занимают дисковых блоков; однако, это не отражается в значении размера. Поэтому вычисления, выполненные 


, будучи обычно верными, могут давать результаты больше или меньше реальных.

По этим причинам в 


 4 2 BSD были добавлены члены 


, которые затем были приняты для System V и POSIX.




























































































































































Строки 245–275 выдают права доступа к файлу. Код компактен и довольно элегантен, он требует тщательного изучения.

• Строки 245–253: массивы с 


 по 


 кодируют биты прав доступа для проверки вместе с соответствующими буквами для вывода. На каждую выводимую букву режима файла имеется один массив. Первый элемент каждого массива является числом пар (право доступа, буква), закодированных в данном конкретном массиве. Последний элемент является буквой, которая должна быть выведена в случае, если не найден ни один из битов прав доступа.

Обратите также внимание, что права доступа обозначены как '


', '


', '


' и т.д. Отдельные константы для каждого бита (


, 


 и т.п.) не были еще придуманы. (См. табл. 4.5 в разделе 4 6.1 «Указание начальных прав доступа к файлу».)

• Строка 255: массив 


 указывает на каждый из массивов с 


 по 


.

• Строки 257–264: функция 


 сначала устанавливает глобальную переменную 


 равной переданному параметру 


. Затем она просматривает в цикле массив 


, передавая каждый элемент функции 


. Переданный элемент представляет один из массивов с 


 по 


.

• Строки 266–275: функция 


 понимает структуру каждого из массивов с 


 по 


. 


 является числом пар в массиве (первый элемент); его устанавливает строка 271. Строки 272–273 ищут биты прав доступа, проверяя установленную ранее в строке 261 глобальную переменную 


.

Обратите внимание на использование оператора 


 как в проверке цикла, так и в теле цикла. Результатом является пропуск пары в массиве, если в 


 не обнаружен бит доступа в первом элементе пары.

Когда цикл завершается, либо бит разрешения был найден, в этом случае 


 указывает на второй элемент пары, являющийся нужным для вывода символом, либо он не был найден, в этом случае 


 указывает на символ по умолчанию. В любом случае, строка 274 выводит символ, на который указывает 


.

Последним стоящим внимания моментом является то, что на С символьные константы (такие как '


') имеют тип 


, а не 


[75 - В C++ это по-другому: там символьные константы действительно имеют тип char. Это различие не влияет на данный конкретный код — Примеч. автора.]. Поэтому проблем с помещением этих констант в массив целых нет; все работает правильно.
































































































Строки 277–295 определяют функцию 


. Ее работа заключается в соединении имени каталога с именем файла, разделенным символом косой черты, с образованием строки. Она осуществляет это в 


 буфере 


. Обратите внимание, что 


 всего лишь 100 символов длиной и что проверка ошибок не выполняется.

Сам код прост, он копирует по одному символу за раз. 


 используется функцией 


.


















































































































































Строки 297–325 определяют функцию 


, чья работа заключается в чтении содержимого каталогов, указанных в командной строке.

Строки 304–307 открывают каталог для чтения, завершая функцию, если 


 возвращает ошибку. Строка 308 инициализирует глобальную переменную 


 нулем. Ранее (строки 153–154) это использовалось для вывода общего числа блоков, использованных файлами в каталоге.

Строки 309–323 являются циклом, который читает элементы каталога и добавляет их к массиву 


. Строки 310–311 читают один элемент, выходя из цикла в конце файла.

Строки 312–315 пропускают неинтересные элементы. Если номер индекса равен нулю, этот слот не используется. В противном случае, если не был указан -а и имя файла является '


' или '


', оно пропускается.

Строки 316–318 вызывают 


 с полным именем файла и вторым аргументом, равным 


, указывающим, что он не из командной строки. 


 обновляет глобальный указатель 


 и массив 


. Возвращаемое значение 


 обозначает какую-нибудь разновидность ошибки.

Строки 319–322 сохраняют номер индекса и имя в 


. Если 


 возвращается из 


 установленным в -1, это означает, что операция 


 с файлом завершилась неудачей. Наконец, строка 324 закрывает каталог.

Следующая функция, 


 (строки 327–398), является центральной функцией для получения и сохранения сведений о файле.


















































































































































Статическая переменная 


 [важно] указывает, что 


 при предыдущем вызове завершилась неудачей. Поскольку она статическая, она автоматически инициализируется 0 (т.е. 


). Если на входе она равна 


, 


 просто возвращает 


. В противном случае, если 


 завершается неудачей, 


 выводит сообщение об ошибке, устанавливает в 





 и возвращает 


 (строки 334–343).

Строки 344–351 гарантируют, что в массиве 


 все еще остается место. Если нет, 


 выдает сообщение (но лишь однажды; заметьте использование статической переменной 


), а затем повторно использует последний слот 


.

Строка 352 заставляет слот 


 указывать на новую 


 (


). Это также обновляет 


, который используется для сортировки в 


 (строки 142 и 152). Строки 353–355 устанавливают значения по умолчанию для полей флагов, номеров индексов и типов в 


.
























































































































































































































Строки 356–396 обрабатывают вызов 


. Если это аргумент командной строки или если 


 установлен в 


 благодаря опции, код заполняет 


 следующим образом:

• Строки 357–366: вызывают 


, при ее неудаче выводится сообщение об ошибке с установкой соответствующих значений, затем возвращается 


 (выраженный в виде 0).

• Строки 367–368: устанавливают в struct stat поля номера индекса и размера, если вызов 


 был успешным.

• Строки 369–384: обрабатывают особые случаи каталогов, блочных и символьных устройств. Во всех случаях код обновляет поле 


. Для устройств значение 


 замещается значением 


.

• Строки 385–388. заполняются поля 


, 


, 


 и 


 из соответствующих полей в 


. Строка 385 удаляет биты типа файла, оставляя 12 битов прав доступа (на чтение/запись/исполнение для владельца/группы/остальных, а также setuid, setgid и save-text).

• Строки 389–394: основываясь на опциях командной строки, используют одно из трех полей времени в 


 для поля 


 в 


.

• Строка 395: обновляет глобальную переменную 


 числом блоков в файле.



































































































































Функция 


 сжата: в небольшом пространстве происходит многое. Первая вещь, которую следует запомнить, это смысл возвращаемого значения: отрицательное значение означает, что первый файл должен идти перед вторым, ноль означает, что файлы равны, а положительное значение означает, что второй файл должен идти перед первым

Следующая вещь, которую нужно понять, это то, что 


 выводит содержимое каталогов после выведения сведений о файлах. Поэтому результат сортировки должен быть таким, чтобы все каталоги, указанные в командной строке, следовали за всеми файлами, указанными там же

Наконец, переменная 


 помогает реализовать опцию 


, которая меняет порядок сортировки. Она инициализируется 1 (строка 30). Если 


 используется, 


 устанавливается в -1 (строки 89–91).

Следующий псевдокод описывает логику 


; номера строк на левой границе соответствуют номерам строк 


:















































































































Аргументы 


 в строках 423–424 выглядят сбивающими с толку. В зависимости от того, было ли имя файла указано в командной строке или было прочитано из каталога, должны использоваться различные члены объединения 


 в 


.




7.3. Резюме


• V7 


 является сравнительно небольшой программой, хотя она затрагивает многие фундаментальные аспекты программирования Unix — файловый ввод-вывод, вспомогательные данные файлов, содержание каталогов, пользователи и группы, значения времени и даты, сортировку и динамическое управление памятью.

• Наиболее примечательным внешним различием между V7 


 и современной 


 является трактовка опций 


 и 


. У версии V7 значительно меньше опций, чем у современных версий; заметным недостатком является отсутствие рекурсивной опции 


.

• Управление 


 является чистым способом использования ограниченной памяти архитектуры PDP-11, предоставляя в то же время как можно больше сведений, 


 хорошо извлекает нужные сведения из 


; это значительно упрощает код. Код для вывода девяти битов доступа компактен и элегантен.

• Некоторые части 


 используют удивительно маленькие лимиты, такие, как верхняя граница числа файлов в 1024 или размер буфера в 


 в 100.




Упражнения


1. Рассмотрите функцию 


. Что случится, если запрошенный ID равен 256, а в 


 есть следующие две строки, в этом порядке:











2. Рассмотрите функцию 


. Может ли она использовать 


 для составления имени? Почему может или почему нет?

3. Являются ли строки 319–320 в 


 действительно необходимыми?

4. Возьмите программу 


, которую вы написали в качестве упражнения в «Упражнениях» к главе 6. Добавьте функцию 


 из V7 


 и выведите результаты вместе с полем 


 из 


. Добавьте видимый маркер, когда они различны.

5. Как бы вы оценили V7 


 по ее использованию 


? (Подсказка: как часто вызывается 


? Где ее следовало бы вызвать?)

6. Как вы оценили бы ясность кода V7 


? (Подсказка: сколько там комментариев?)

7. Очертите шаги, которые нужно было бы сделать, чтобы адаптировать V7 


 для современных систем.




Глава 8

Файловые системы и обходы каталогов



Данная глава завершает обсуждение файловых систем и каталогов Linux (и Unix). Сначала мы опишем, как к логическому пространству имен файловой системы добавляется (и удаляется) раздел диска, содержащий файловую систему, таким образом, что в общем пользователю не нужно ни знать, ни заботиться о месте физического размещения файла, вместе с API для работы с файловыми системами

Затем мы опишем, как перемещаться по иерархическому пространству имен файлов, как получать полный путь текущего рабочего каталога и как без труда обрабатывать произвольные иерархии (деревья) каталогов, используя функцию 


. Наконец, мы опишем специализированный, но важный системный вызов 


.




8.1. Монтирование и демонтирование файловых систем



Унифицированное иерархическое пространство имен файлов является большим достоинством дизайна Linux/Unix. Данный раздел рассматривает, как административные файлы, команды и операционная система объединяются для построения пространства имен из отдельных физических устройств, содержащих данные и служебные данные файлов.




8.1.1. Обзор основ


В главе 5 «Каталоги и служебные данные файлов», были представлены индексы для служебных данных файлов и описано, как элементы каталогов связывают имена файлов с индексами В ней также были описаны разделы и файловые системы, и вы видели, что прямые ссылки ограничены работой в пределах одной файловой системы, поскольку каталоги содержат лишь номера индексов, а последние не уникальны среди всего набора использующихся файловых систем.

Помимо индексов и блоков данных, файловые системы содержат также одну или более копий суперблока. Это специальный дисковый блок, который описывает файловую систему; его сведения обновляются по мере изменений в самой файловой системе. Например, он содержит число свободных и используемых индексов, свободных и используемых блоков и другие сведения. Он включает также магическое число: специальное уникальное значение в специальном месте, которое идентифицирует тип файловой системы (Вскоре мы увидим, насколько это важно.)

Обеспечение доступа к разделу, содержащему файловую систему, называется монтированием (mounting) файловой системы. Удаление файловой системы из использования называется, что неудивительно, демонтированием (unmounting) файловой системы.

Эти две задачи выполняются программами 


 и 


 [так], названными по соответствующим системным вызовам. У системного вызова 


 каждой системы Unix свой, отличный интерфейс. Поскольку монтирование и демонтирование считаются проблемой реализации, POSIX намеренно не стандартизует эти системные вызовы

Вы монтируете файловую систему в каталог; такой каталог называется точкой монтирования файловой системы. По соглашению, каталог должен быть пустым, но ничто не принуждает к этому. Однако, если точка монтирования не пуста, все ее содержимое становится , пока в ней не смонтирована файловая система[76 - GNU/Linux и Solaris дают возможность монтировать один файл поверх другого; это продвинутое использование, которое мы не будем обсуждать — Примеч. автора.].

Ядро поддерживает уникальный номер, известный как номер устройства, который идентифицирует каждый смонтированный раздел. По этой причине именно пара (устройство, индекс) вместе уникально идентифицируют файл; когда структуры 


 для двух имен файлов указывают, что оба эти номера одни и те же, можно быть уверенным, что они на самом деле ссылаются на один и тот же файл.

Как упоминалось ранее, программы уровня пользователя помещают структуры индексов и другие вспомогательные данные на раздел диска, создавая тем самым файловую систему. Эти самые программы создают для файловой системы начальный корневой каталог. Таким образом, нам придется провести различие между «корневым каталогом, названным 


», который является каталогом самого верхнего уровня в иерархическом пространстве имен файлов, и «корневым каталогом файловой системы», который является отдельным каталогом верхнего уровня каждой файловой системы. Каталог 


 является также «корневым каталогом» «корневой файловой системы».

По причинам, описанным на врезке, у корневого каталога файловой системы номер индекса всегда равен 2 (хотя это не стандартизовано формально). Поскольку может быть несколько файловых систем, у каждой из них один и тот же номер индекса корневого каталога 2. При разрешении пути ядро знает, где смонтирована каждая файловая система и заставляет имя точки монтирования ссылаться на корневой каталог смонтированной файловой системы. Более того, '


' в корне смонтированной файловой системы ссылается на родительский каталог точки монтирования.

На рис. 8.1 показаны две файловые системы: одна для корневого каталога, а другая для 


, до того, как 


 смонтирована. На рис. 8.2 показана ситуация после монтирования 


.




Рис. 8.1. Отдельные файловые системы до монтирования




Рис. 8.2. Отдельные файловые системы после монтирования

Каталог 


, корень всей логической иерархии, особый еще в одном отношении: 


 и 


 ссылаются на один и тот же каталог; это неверно для любого другого каталога в системе. (Таким образом, после команды типа '


' вы все еще будете в 


.) Это поведение реализуется простым способом: как 


, так и 


 являются прямыми ссылками на корневой каталог файловой системы. (Вы можете видеть это как на рис. 8.1, так и 8.2.) Каждая файловая система работает таким способом, но ядро рассматривает 


 особым образом и не рассматривает как особый случай каталог '


' для файловой системы, смонтированной в 


.




Номера индексов корневого каталога

Номер индекса для корневого каталога файловой системы всегда равен 2. Почему это так? Ответ имеет отношение как к технологии, так и к истории.

Как упоминалось в разделе 5.3 «Чтение каталогов», элемент каталога с номером индекса ноль означает неиспользуемый, или пустой слот. Поэтому индекс 0 не может использоваться для настоящего файла или каталога.

Хорошо, так что насчет индекса 1? Ну, особенно в 70-80 годах XX века, диски не были сделаны так же хорошо, как сейчас. Когда вы покупали диск, он приходил с (бумажным) списком испорченных блоков — известных мест на диске, которые не могли быть использованы. Каждой операционной системе приходилось отслеживать эти плохие блоки и избегать их использования.

Под Unix это осуществлялось созданием файла особого назначения, блоки данных которого были известны, как испорченные. Этот файл присоединялся к индексу 1, оставляя 2 в качестве первого индекса, доступного для использования обычными файлами или каталогами.

На современных дисках присутствует значительное количество встроенной электроники, и они сами управляют испорченными блоками. Поэтому технически было бы осуществимо использовать для файла индекс 1. Однако, поскольку такое большое количество программ Unix, которые предполагают, что индекс 2 является индексом для корневых каталогов файловых систем, Linux также следует этому соглашению. (Однако, Linux иногда использует индекс 1 для не собственных файловых систем, таких, как 


 или 


.)





8.1.2. Обзор различных типов файловых систем




ЗАМЕЧАНИЕ. Обсуждение в данном разделе специфично для Linux. Однако, у многих современных систем Unix также есть сходные особенности. Мы рекомендуем вам изучить документацию своей системы.


Исторически V7 Unix поддерживал лишь один тип файловой системы; вспомогательные данные и организация каталогов каждого из разделов были структурированы одним и тем же способом. 4.1 BSD использовал файловую систему с такой же как у V7 структурой, но с размером блока 1024 байта вместо 512 байтов. 4.2 BSD ввело «файловую систему BSD», которая разительно изменила расположение индексов и данных на диске и дала возможность использовать гораздо большие размеры блоков. (В общем, использование больших протяженных блоков данных обеспечивает лучшую производительность, особенно для чтения файлов.)

Вплоть до 4.3 BSD и System V Release 2 в начале и середине 1980-х системы Unix продолжали поддерживать один тип файловой системы. Для переключения компьютера от одной файловой системы на другую[77 - Например, при обновлении VAX 11/780 с 4.1 BSD до 4.2 BSD — Примеч. автора.] приходилось сначала резервировать каждую файловую систему на среду архивирования (9-дорожечную ленту), обновлять систему, а затем восстанавливать данные.

В середине 1980-х Sun Microsystems разработала архитектуру ядра, которая сделала возможным использование нескольких архитектур файловой системы в одно и то же время. Этот проект был реализован в их операционной системе SunOS, сначала для поддержки сетевой файловой системы Sun (Network File System — NFS). Однако, как следствие, стало возможным также поддерживать несколько архитектур на диске. System V Release 3 использовала сходную архитектуру для поддержки удаленной файловой системы (Remote File System — RFS), но она продолжала поддерживать лишь одну архитектуру на диске.[78 - System V Release 3 поддерживала два различных размера блоков: 512 байтов и 1024 байта, но в остальном организация диска была той же самой — Примеч. автора.] (RFS никогда широко не использовалась и сейчас является лишь исторической сноской.)

Общий дизайн Sun стал популярным и широко реализовывался в коммерческих системах Unix, включая System V Release 4. Системы Linux и BSD используют разновидность этого дизайна для поддержки множества форматов файловых систем на диске. В частности, обычным для всех разновидностей Unix на платформе Intel x86 является возможность монтирования файловых систем MS-DOS/Windows FAT, включая поддержку длинных имен, а также форматированные в соответствии с ISO 9660 CD-ROM.

Linux имеет несколько собственных (т.е. размещаемых на диске) файловых систем. Наиболее популярными являются файловые системы 


 и 


. Однако, доступно значительно больше файловых систем. Сведения о большинстве из них вы можете найти в каталоге 


 (если вы установили исходный код ядра). В табл. 8.1 перечислены имена различных файловых систем с кратким описанием каждой из них. Сокращение «RW» означает «чтение/запись», a «RO» означает «только чтение».



Таблица 8.1. Поддерживаемые ядром файловые системы Linux (ядро 2.4.x)




Не все из этих файловых систем поддерживаются командой 


; список поддерживаемых см. в mount(8).

Журналирование является методикой, впервые использованной в системах баз данных для увеличения производительности обновлений файлов таким образом, что восстановление файловой системы в случае аварии могло быть сделано быстро и правильно. В момент написания этого были доступны несколько различных журналируемых файловых систем, конкурирующих за продвижение в мире GNU/Linux. Одной из них является 


; у нее преимущество обратной совместимости с существующими файловыми системами 


, очень просто конвертировать файловые системы туда-сюда между этими двумя видами (См. tune2fs(8).) ReiserFS и XFS также имеют своих твердых сторонников.

Файловые системы 


, 


, 


 и 


 все разделяют общий исходный код. В общем, можно использовать 


 для монтирования разделов Windows FAT-32 (или другой FAT-xx), a 


, если нужно использовать раздел FAT в качестве корневой файловой системы для GNU/Linux.

Файловые системы Coherent, MINIX, первоначальной System V и Xenix все имеют сходные структуры на диске. Тип файловой системы 


 поддерживает все из них; четыре имени 


, 


, 


 и 


 являются псевдонимами один для другого. Имена 


 и 


 в конечном счете будут удалены.

Быстрая файловая система BSD в течение нескольких лет успешно развилась. Файловая система 


 поддерживает операции чтения/записи для версий, начиная с 4.4 BSD, которая является основой для трех широко распространенных операционных систем BSD: FreeBSD, NetBSD и OpenBSD. Она поддерживает также операции чтения/записи для файловой системы Sun Solaris как для SPARC, так и для систем Intel x86. Первоначальный формат BSD и формат операционной системы NeXTStep поддерживаются в режиме только для чтения.

Обозначения «RO» для 


 и 


 означают, что файловые системы этих типов можно смонтировать и читать, но в них невозможно записать файлы или удалить из них файлы. (Со временем это может измениться; проверьте документацию своей системы.) Файловые системы 


, 


, 


 и 


 отмечены «RO», поскольку лежащее в их основе средство по своей сути является устройством только для чтения.

Две файловые системы, которых больше не существует, это 


, которая была оригинальной расширенной файловой системой, и 


, которая расширяла оригинальную файловую систему MINIX для использования длинных имен и больших размеров файлов, 


 и 


 появились примерно в одно время, но 


 в конечном счете стала доминирующей файловой системой.[80 - Источник: 


 — Примеч. автора.]




8.1.3. Монтирование файловых систем: 





Команда 


 монтирует файловые системы, соединяя их содержимое в системную иерархию файлов в их точках монтирования. Под GNU/Linux это иногда запутано, поскольку приходится иметь дело со всеми известными типами файловых систем и их опциями. Обычно запустить 


 может лишь 


, хотя в некоторых случаях можно сделать исключения, как в случае, обсуждаемом далее в главе.

Файловую систему вы указываете с помощью опции 


:






Например (


 является приглашением для 


):
















Можно использовать '


', чтобы заставить 


 угадать тип файловой системы. Это обычно работает, хотя если вы точно знаете, каков тип файловой системы, опция '


' помогает указать тип и избежать вероятности ошибочного определения файловой системы, 


 по умолчанию угадывает нужный тип, поэтому '


' не является абсолютно необходимым.

Системы GNU/Linux предусматривают специальную разновидность монтирования посредством кольцевого (loopback) устройства. Таким способом образ файловой системы, содержащийся в обычном файле, может быть смонтирован, как если бы это было настоящее дисковое устройство. Эта возможность очень полезна, например, при использовании образов CD-ROM. Она позволяет создать образ и испытать его без необходимости прожига на болванке CD с последующим его монтированием. Следующий пример использует первый образ CD из дистрибутива GNU/Linux RedHat 9:
































































































Возможность монтирования таким способом образа ISO 9660 особенно полезна при тестировании сценариев, создающих образы CD. Вы можете создать образ в обычном файле, смонтировать его и проверить, что он подготовлен правильно. Затем, убедившись, что все в порядке, можно скопировать образ на записываемый CD («прожечь» CD). Возможность кольцевого устройства полезна также для монтирования образов гибких дисков




8.1.4. Демонтирование файловых систем: 





Команда 


 демонтирует файловую систему, удаляя ее содержимое из системной иерархии файлов. Использование следующее:






Демонтируемая файловая система не должна быть занята. Это означает, что нет процессов с открытыми в файловой системе файлами и что ни у одного процесса текущий рабочий каталог не находится в этой файловой системе:




















































































8.2. Файлы для администрирования файловой системы



Файл 


[81 - Ha GNU/Linux и большинстве систем Solaris и некоторые системы на основе System V Release 4 используют 


, возможно, с другим форматом — Примеч. автора.] перечисляет файловые системы, которые могут быть смонтированы. Большинство из них монтируются автоматически, когда система загружается. Формат следующий:






(


 и 


 являются административными особенностями, не относящимися к настоящему обсуждению). Например, на нашей системе файл выглядит следующим образом:





























































Разрешены комментарии, начинающиеся с 


. Вскоре, в разделе 8.2 1 «Использование опций монтирования», будет обсуждение различных опций.

Тот же самый формат файла используется для 


, куда 


 записывает информацию о файловых системах, когда они смонтированы; 


 удаляет информацию из этого файла, когда файловая система демонтирована:














































Ядро делает доступным (почти) те же самые сведения в 


, в том же формате:



















































Обратите внимание, что в 


 есть некоторые сведения, которые отсутствуют в 


. (Например, см. строку для точки монтирования 


.) С другой стороны, возможно (используя '


') помещать в 


 элементы, которые не являются настоящими (эта практика имеет свое применение, см. mount(8)). Подводя итог, 


 всегда описывает, что смонтировано в действительности; однако, 


 содержит сведения об опциях 


, которых нет в 


. Поэтому, чтобы получить полную картину, вам может понадобиться прочесть оба файла




8.2.1. Использование опций монтирования


Команда 


 поддерживает опции, которые контролируют то, какие операции ядро будет позволять или не позволять применять к файловой системе. Их приличное количество. Лишь две из них полезны на самом деле в командной строке:






Монтирует файловую систему только для чтения. Это необходимо для устройств только для чтения, таких, как CD-ROM и DVD.






Использует кольцевое устройство для интерпретации обычного файла в качестве файловой системы. Пример этого мы показали ранее (см. раздел 8.1.3 «Монтирование файловых систем: 


»).

Опции передаются с опцией командной строки -о и могут группироваться, отделяясь запятыми. Например, вот использованная ранее командная строка:






Оставшиеся опции предназначены для использования в 


 (хотя они могут использоваться также и в командной строке). Следующий список представляет те опции, которые, как мы полагаем, наиболее важны в повседневном использовании.




, 




Файловые системы, помеченные 


, должны монтироваться при загрузке системы через '


' (монтировать все файловые системы). Файловые системы 


 должны монтироваться вручную. Они по-прежнему находятся в 


 вместе с другими файловыми системами. (См., например, элемент 


 для показанного ранее файла 


).






Использует по умолчанию опции 


, 


, 


, 


, 


, 


 и 


. (


 является продвинутой опцией, повышающей производительность ввода/вывода).




, 




Позволяет (не позволяет) использовать в файловой системе файлы символьных или блочных устройств.




, 




Позволяет (не позволяет) запускать в файловой системе двоичные исполняемые файлы.




, 




Позволяет (не позволяет) монтировать данную файловую систему любому пользователю. Это полезно для CD-ROM; даже если вы находитесь на рабочей станции с одним пользователем, удобно не переключаться на 


 просто для монтирования CD. Демонтировать файловую систему может лишь пользователь, который смонтировал ее. 


 предполагает наличие опций 


, 


 и 


.




, 




Поддерживает (не поддерживает) биты 


 и 


 исполняемых файлов в файловой системе.






Монтирует файловую систему в режиме для чтения/записи.

Опции 


, 


 и 


 особенно ценны для безопасности на файловых системах гибких дисков и CD-ROM. Рассмотрите студенческую среду, в которой студентам разрешено монтировать собственные гибкие диски или CD. Тривиально смастерить для жесткого диска файловую систему с оболочкой setuid-root или с файлом устройства с разрешением записи для всех, которая позволила бы предприимчивому пользователю изменить права доступа к системным файлам.

У каждой файловой системы есть специфичные для нее опции. Важной опцией для 


 и 


 является 


. Мы отложим обсуждение этой опции до раздела 11.5.1 «Группа по умолчанию для новых файлов и каталогов». Подробности для всех поддерживаемых файловых систем можно найти в справочной странице mount(8).

В качестве конкретного примера вернемся к строчке для раздела Windows в нашей системе:











Опция 


 предотвращает монтирование раздела Windows при загрузке. Опция 


 та же самая, что 


, 


, 


, 


, 


. Опция 


 позволяет нам монтировать файловую систему, не будучи 


. Опции 


 и 


 делает файлы в 


 принадлежащими нам, так что нам не нужно иметь права 


 при работе с этим разделом.




8.2.2. Работа со смонтированными файловыми системами: 





Любой из файлов 


, 


 и 


 может быть прочитан программное использованием набора процедур 


:









































 открывает файл, содержащий элементы точек монтирования. Аргумент 


 является файлом, который должен быть открыт. Аргумент 


 похож на второй аргумент 


, указывая доступ для чтения, записи или чтения/записи. (Рассмотрите команду 


, которой приходится добавлять элемент к 


 для каждой файловой системы, которую она монтирует, и 


, которая должна удалять этот элемент.) Затем возвращаемое значение типа 


 используется с оставшимися процедурами.




 читает файл, возвращая указатель на 


, которая заполнена соответствующими значениями. Это статическое хранилище переписывается при каждом вызове. Когда больше не осталось элементов, она возвращает 


. (Это сходно с процедурами для чтения файлов паролей и групп; см раздел 6.3 «Имена пользователей и групп».)




 вызывается для добавления сведений в конец открытого файла, она предназначена для использования функцией 


.




 закрывает открытый файл; вызывайте ее после завершения обработки. Не вызывайте просто 


; может потребоваться очистить другие внутренние структуры данных, связанные с переменной 


.




 является более специализированной функцией. Она просматривает 


, переданную в качестве первого параметра, в поисках опции 


, совпадающей со вторым аргументом. Если опция найдена, она возвращает адрес совпадающей подстроки. В противном случае возвращается 


.

Поля в 


 непосредственно соответствуют полям в файле 


. Структура выглядит следующим образом:









































Обычным принципом работы со смонтированными файловыми системами является создание внешнего цикла, читающего 


, обрабатывая по одной 


 за раз. Наш первый пример, 


, делает именно это:


























































































































































































































































































































































В отличие от большинства программ, которые мы до сих пор видели, эта специфична для Linux. Во многих Unix-системах есть схожие процедуры, но их идентичность не гарантируется.

По умолчанию, 


 читает 


, выводя сведения о каждой смонтированной файловой системе. Опция 


 позволяет указать другой файл для чтения, такой, как 


 или даже 


.

Функция 


 обрабатывает командную строку (строки 23–32) и вызывает для указанного файла 


. (Эта программа следует нашему стандартному шаблону.)




, в свою очередь, открывает файл (строка 45) и проходит в цикле через каждую возвращённую файловую систему (строки 52–53). После завершения она закрывает файл (строка 55).

Функция 


 выводит информацию из 


. Вывод во многом напоминает вывод '


':

















































8.3. Получение сведений о файловой системе



Вывод сведений о файловой системе, рассмотренный ранее — это хорошо и замечательно, но это не захватывает. Раз мы знаем, что определенная точка монтирования представляет файловую систему, нам нужны сведения о файловой системе. Это даст нам возможность выводить вещи наподобие сведений, полученных с помощью 


 и '


'.
































































8.3.1. Стиль POSIX: 


 и 





На ранних системах Unix была только одна разновидность файловой системы. Для них было достаточно, если 


 считывала суперблок каждой смонтированной файловой системы, извлекала значимые сведения и красиво форматировала их для отображения. (Суперблок обычно был вторым блоком в файловой системе; первым был загрузочный блок, содержащий загрузочный код).

Однако в современном мире такой подход был бы непригодным. POSIX предоставляет расширение XSI для получения доступа к этой информации. Главная функция называется 


 («vfs» часть происходит от лежащей в основе технологии SunOS, использованной позже в System V Release 4, которая называется виртуальной файловой системой.) Имеется две функции:


























 использует для любого файла имя пути; она возвращает сведения о файловой системе, содержащей файл. 


 принимает в качестве первою аргумента дескриптор открытого файла, здесь также возвращается информация о файловой системе, содержащей открытый файл, 


 содержит следующие члены:







































































Сведений, которые в ней содержатся, достаточно для написания 


:






Размер блока является предпочтительным размером для осуществления ввода/вывода. Файловая система пытается хранить по крайней мере 


 байтов стоящих данных в смежных секторах на диске. (Сектор является наименьшим количеством адресуемых данных на диске. Обычно дисковый сектор равен 512 байтам.)






Некоторые файловые системы (такие, как BSD Fast Filesystem) проводят различие между блоками и фрагментами блоков. Небольшие файлы, общий размер которых меньше размера блока, находятся в некотором числе фрагментов. Это позволяет избежать пустой потери дискового пространства (за счет допустимой цепы большей сложности кода ядра). Размер фрагмента выбирается во время создания файловой системы.






Общее число блоков (в единицах 


) в файловой системе.






Общее число свободных блоков в файловой системе.






Число блоков, которые действительно могут использоваться. Некоторые файловые системы резервируют часть блоков файловой системы для использования суперпользователем при заполнении файловой системы. Современные системы резервируют около 5 процентов, хотя это число может быть изменено администратором. (См. tune2fs(8) на системе GNU/Linux и tunefs(8) на системах Unix.)






Общее число индексов («порядковых номеров файлов» на языке POSIX) в файловой системе. Это число обычно инициализируется и делается постоянным при создании файловой системы.






Общее число свободных узлов.






Число индексов, которые действительно могут быть использованы. Некоторая часть индексов резервируются для суперпользователя, точно так же, как для блоков.






ID файловой системы. POSIX не определяет, что оно представляет, и это под Linux не используется.






Флаги, дающие информацию о файловой системе. POSIX определяет два флага: 


 для файловых систем только для чтения (таких, как CD-ROM) и 


, который запрещает использование битов setuid и setgid в исполняемых файлах. Системы GNU/Linux предусматривают дополнительные флаги: они перечислены в табл. 8.2.



Таблица 8.2. Значения GLIBC для 














Максимальная длина имени файла. Это относится к каждому отдельному компоненту в имени пути; другими словами, максимальная длина для элемента каталога

Типы 


 и 


 определены в 


. Они обычно являются 


, но на современных системах они могут быть даже 64-разрядными, поскольку диски стали очень большими. Следующая программа, 


, показывает, как использовать 


:








































































































































































































































































































Строки 1–59 в сущности те же самые, как и для 


. 


 обрабатывает командную стоку, a 


 просматривает в цикле каждую смонтированную файловую систему. 


 осуществляет действительную работу, выводя для каждой интересующей файловой системы 


.









































































































































































































Строки 67–68 пропускают файловые системы, которые не основываются на реальных дисковых устройствах. Это означает, что файловые системы типа 


 или 


 игнорируются. (Правда, эта проверка эвристическая, но она работает: в 


 смонтированные устройства перечислены по полному пути устройства: например, 


.) Строка 70 вызывает 


 с соответствующей проверкой ошибок, а строки 77-99 выводят сведения.

Строки 89–96 имеют дело с флагами: отдельные биты информации, которые присутствуют или не присутствуют. Обсуждение того, как биты флагов используются в коде С, см. во врезке. Вот вывод 


:



































































































































Во время написания этого, для GLIBC 2.3.2 и ранее, GNU 


 не использует 


. Это потому, что код читает 


 и вызывает 


 для каждой смонтированной файловой системы, чтобы найти ту, номер устройства которой совпадает с соответствующим аргументом для файла (или дескриптора файла). Для того, чтобы прочесть опции монтирования, коду нужно найти файловую систему, поэтому он может установить биты 


. Проблема в том, что 


 на смонтированной удаленной файловой системе, сервер которой недоступен, может висеть неопределенно долго, вызвав также зависание 


. С тех пор эта проблема в GLIBC была исправлена, но 


 не будет изменяться в течение некоторого времени, так что она сможет продолжать работать на более старых системах.



ЗАМЕЧАНИЕ. Хотя POSIX определяет 


 и 


, не все системы их поддерживают или поддерживают корректно. Многие системы (включая Linux, как вскоре будет описано), имеют свои собственные системные вызовы, предоставляющие сходную информацию. GNU 


 использует библиотечную процедуру для получения сведений о файловой системе; исходный файл для этой процедуры наполнен 


 для большого числа различных систем. Со временем ситуация с переносимостью должна улучшиться.





Битовые флаги

Обычной методикой, применимой во многих случаях, является использование набора значений флагов; когда флаг установлен (т.е. true), имеет место некоторый факт или применяется некоторое условие. Значения флагов определены либо через именованные константы 


, либо через перечисления. В данной главе API 


 (описанный далее) также использует флаги. Для поля 


 структуры 


 есть только два флага:











Физически каждая именованная константа представляет различные позиции битов в значении 


. Логически каждое значение представляет отдельный бит информации о состоянии; т.е. некоторый факт или условие, которое является или не является истинным для данного конкретного экземпляра 


.

Флаги устанавливаются, проверяются и очищаются с помощью побитовых операторов С. Например, 


 устанавливает эти флаги, используя побитовый оператор ИЛИ:














































Побитовый оператор И проверяет, установлен ли флаг, а сочетание побитовых операторов И и дополнения очищает флаг:











Побитовые операторы отпугивают, если вы не использовали их ранее. Однако, только что показанный код примера представляет обычный стиль С. Тщательно изучите каждую операцию; возможно, нарисуйте себе несколько картин, показывающих работу этих операторов. Однажды разобравшись с ними, вы можете тренировать себя, распознавая эти операторы как высокоуровневые операции для управления значениями флагов вместо их трактовки как низкоуровневых манипуляций с битами.

Причина использования флагов кроется в том, что они обеспечивают значительную экономию пространства данных. Одно поле 


 дает возможность хранить по меньшей мере 32 отдельных бита информации. GLIBC (на момент написания) определяет 11 различных флагов для поля 


.[82 - См. 


 на системе GNU/Linux — Примеч. автора.] Если бы вы использовали для каждого флага отдельно поле 


, это потребовало бы использования 11 байтов вместо четырех, используемых 


. Если бы у вас было 32 флага, это были бы 32 байта вместо четырёх!





8.3.2. Стиль Linux: 


 и 





Системные вызовы 


 и 


 специфичны для Linux. Их определения следующие:























Как и в случае с 


 и 


, две версии работают с именем файла или с дескриптором открытого файла соответственно, struct statfs выглядит следующим образом:





























































Поля аналогичны полям в 


. По крайней мере в GLIBC 2.3.2 функции POSIX 


 и 


 являются оболочками вокруг 


 и 


 соответственно, копируя значения из одной разновидности структуры в другую.

Преимуществом использования 


 или 


 является то, что они системные вызовы. Ядро возвращает информацию непосредственно. Поскольку нет поля 


 с опциями монтирования, нет необходимости просматривать каждую смонтированную файловую систему для нахождения нужной. (Другими словами, для заполнения опций монтирования 


 должна проверить каждую смонтированную файловую систему, чтобы найти содержащую файл, имя которого содержится в 


 или 


. Функция 


 не нуждается в этом, поскольку она не предоставляет сведений об опциях монтирования.)

Есть два неудобства в использовании этих вызовов. Во-первых, они специфичны для Linux. Во-вторых, часть сведений из 


 отсутствует в 


, наиболее значительными из них являются флаги (


) и число доступных индексов (


). (Поэтому 


 Linux приходится находить опции монтирования из других источников, таких, как 


, и она «фабрикует» информацию для тех полей 


, для которых действительные сведения недоступны.)

Одно поле 


 заслуживает особого замечания. Это поле 


, указывающее тип файловой системы. Значение является магическим числом файловой системы, извлеченной из суперблока. Справочная страница statfs(2) предоставляет список обычно используемых файловых систем и их магические числа, которые мы используем в 


. (Увы, отдельного файла 


 нет.)

















































































































































































































































































































































































































































































































































































Чтобы сохранить место, мы опустили 


, которая не изменилась с представленной ранее другой программы, мы также опустили 


, которая теперь вызывает 


 вместо 


.

Строки 13–35 содержат список магических чисел файловых систем из справочной страницы statfs(2). Хотя эти числа можно получить из заголовочных файлов исходного кода ядра, это трудно (мы пробовали), а показанному здесь способу представления следовать легче. Строки 86–125 определяют 


, которая преобразует магическое число в выводимую строку. Она осуществляет простой линейный поиск в таблице пар (значение, строка). В (маловероятном) случае, когда магическое число в таблице отсутствует, 


 создает сообщение «неизвестный тип» и возвращает его (строки 123–124).




 (строки 129–153) выводит сведения из 


. Член 


 опущен, поскольку 


 является непрозрачным типом. Код прост; строка 145 использует 


 для вывода типа файловой системы. Как для сходной программы, использующей 


, эта функция игнорирует файловые системы, которые не расположены на локальных устройствах (строки 133–134). Вот вывод на нашей системе:





































































































В заключение, использование 


 или 


 в вашем собственном коде зависит от ваших потребностей. Как описано в предыдущем разделе, GNU 


 не использует 


 под GNU/Linux и в общем имеет тенденцию использовать уникальный для каждой Unix-системы системный вызов «получения сведений о файловой системе». Хотя это работает, это не очень привлекательно. С другой стороны, иногда у вас нет выбора: например, проблемы GLIBC, о которых мы упоминали выше. В этом случае нет безупречного решения.




8.4. Перемещение по иерархии файлов



Несколько системных вызовов и стандартных библиотечных функций дают возможность изменять текущий каталог и определять полный путь к текущему каталогу. Более сложные функции позволяют осуществлять произвольные действия с каждым объектом файловой системы в иерархии каталогов.




8.4.1. Смена каталога: 


 и 





В разделе 1.2 «Модель процессов Linux/Unix» мы говорили:



Текущим каталогом является каталог, относительно которого отсчитываются относительные пути (те, которые не начинаются с 


). Это каталог, «в» котором вы находитесь, когда даете оболочке команду '


'.


У каждого процесса есть текущий рабочий каталог. Каждый новый процесс наследует свой текущий каталог от процесса, который его запустил (своего родителя). Две функции позволяют перейти в другой каталог:


















Функция 


 принимает строку с названием каталога, тогда как 


 ожидает дескриптор файла, который был открыт для каталога с помощью 


.[83 - На системах GNU/Linux и BSD для получения нижележащего дескриптора файла можно применить функцию 


 к указателю 


, см. справочную страницу GNU/Linux dirfd(3) — Примеч. автора.] Обе возвращают 0 при успехе и -1 при ошибке (с 


, установленной соответствующим образом). Обычно, если 


 для каталога завершается успешно, 


 также достигает цели, если кто-то не изменил права доступа к каталогу между вызовами, (


 сравнительно новая функция; на старых системах Unix ее нет.)

Использование этих функций почти тривиально. Следующая программа, 


, демонстрирует обе функции. Она демонстрирует также, что 


 может потерпеть неудачу, если права доступа открытого каталога не включают доступа на поиск (исполнение).








































































































































Строка 15 открывает текущий каталог. Строка 16 вызывает 


 для открытого каталога, так что мы получаем копию его прав доступа. Строка 17 использует 


 для перемещения на один уровень в иерархии файлов. Строка 18 выполняет грязную работу, отменяя все права доступа первоначального каталога.

Строки 20–21 пытаются перейти обратно в первоначальный каталог. Ожидается, что эта попытка будет безуспешной, поскольку текущие права доступа не позволяют это. Строка 23 восстанавливает первоначальные права доступа, '


' получает младшие 12 битов прав доступа; это обычные 9 битов rwxrwxrwx и биты setuid, setgid и «липкий» бит, которые мы обсудим в главе 11 «Права доступа и ID пользователя и группы». Наконец, строка 24 заканчивает работу, закрывая открытый дескриптор файла. Вот что происходит при запуске программы.


































8.4.2. Получение текущего каталога: 





Названная должным образом функция 


 получает абсолютный путь текущего рабочего каталога.











Функция заносит в 


 путь; ожидается, что размер 


 равен 


 байтам. При успешном завершении функция возвращает свой первый аргумент. В противном случае, если требуется более 


 байтов, она возвращает 


 и устанавливает в 


. Смысл в том, что если случится 


, следует попытаться выделить буфер большего размера (с помощью 


 или 


) и попытаться снова.

Если любой из компонентов каталога, ведущих к текущему каталогу, не допускает чтения или поиска, 


 может завершиться неудачей, а 


 будет установлен в 


. Следующая простая программа демонстрирует ее использование:





























































































Эта простая программа выводит текущий каталог, переходит в родительский каталог, затем выводит новый текущий каталог. (Переменная 


 здесь на самом деле не нужна, но в реальной программе она была бы использована для проверки ошибок). При запуске программа создает следующий вывод:





















Формально, если аргумент 


 равен 


, поведение 


 не определено. В данном случае версия GLIBC 


 вызовет 


 за вас, выделяя буфер с размером 


. Идя даже дальше, если 


 равен 0, выделяется «достаточно большой» буфер для вмещения возвращенного имени пути. В любом случае вы должны вызвать для возвращенного указателя 


 после завершения работы с буфером.

Поведение GLIBC полезно, но не переносимо. Для кода, который должен работать на разных платформах, вы можете написать замещающую функцию, которая предоставляет те же самые возможности, в то же время заставив ее непосредственно вызывать 


 на системе с GLIBC.

Системы GNU/Linux предоставляют файл 


. Этот файл является символической ссылкой на текущий каталог:































Это удобно на уровне оболочки, но представляет проблему на уровне программирования. В частности, размер файла равен нулю! (Это потому, что это файл в 


, который продуцирует ядро; это не настоящий файл, находящийся на диске.)

Почему нулевой размер является проблемой? Если вы помните из раздела 5.4.5 «Работа с символическими ссылками», 


 для символической ссылки возвращает в поле 


 структуры 


 число символов в имени связанного файла. Это число может затем использоваться для выделения буфера соответствующего размера для использования с 


. Здесь это не будет работать, поскольку размер равен нулю. Вам придется использовать (или выделять) буфер, который, как вы полагаете, достаточно большой. Однако, поскольку 


 не выдает символов больше, чем вы предоставили места, невозможно сказать, достаточен буфер или нет; 


 не завершается неудачей, когда недостаточно места. (См. в разделе 5.4.5 «Работа с символическими ссылками» функцию Coreutils 


, которая решает проблему.)

В дополнение к 


 GLIBC имеет несколько других непереносимых процедур. Они избавляют вас от хлопот по управлению буферами и обеспечивают совместимость со старыми системами BSD. Подробности см в getcwd(3).




8.4.3. Перемещение по иерархии: 






Обычной задачей программирования является обработка целых иерархий каталогов: выполнение действий над каждым файлом и каждым каталогом и подкаталогом в целостном дереве. Рассмотрите, например, команду 


, которая выводит сведения об использовании диска, '


', которая рекурсивно изменяет владельцев, или программу 


, которая находит файлы, подходящие по определенным критериям.

На данный момент вы знаете достаточно, чтобы написать собственный код для открывания и чтения каталогов вручную, вызова 


 (или 


) для каждого элемента и рекурсивной обработки подкаталогов. Однако, такой код трудно сделать правильным; можно выйти за пределы дескрипторов файлов, если вы будете оставлять родительские каталоги открытыми при обработке подкаталогов; нужно решить, обрабатывать ли символические ссылки как таковые или как файлы, на которые они указывают; нужно суметь справиться с каталогами, которые недоступны для чтения или поиска и т.д. Также трудно писать один и тот же код снова и снова, когда он требуется в нескольких приложениях.




8.4.3.1. Интерфейс 





Чтобы избавиться от проблем, System V предложила функцию 


 («file tree walk» — обход дерева файлов), 


 осуществляла всю работу по «прохождению» дерева (иерархии) файлов. Вы предоставляете ей указатель на функцию, и она вызывает эту функцию для каждого объекта файла, с которым сталкивается. Ваша функция должна затем обработать каждый объект файловой системы, как считает нужным.

Со временем стало ясно, что интерфейс 


 не вполне выполнял свою работу;[84 - POSIX стандартизировал 


 для поддержки существующего кода, а GNU/Linux b коммерческие системы Unix продолжают её поддерживать. Однако, поскольку она недостаточно функциональна, мы не будем больше ее обсуждать. Если интересуетесь, см. ftw(3). — Примеч. автора.] например, первоначально он не поддерживал символические ссылки. По этим причинам к X/Open Portability Guide, который теперь является частью POSIX, была добавлена 


 («new (новая) 


» [важно]). Вот прототип:

































А вот аргументы:






Строка с именем отправной точки иерархии для обработки.






Указатель на функцию с данными аргументами. Эта функция вызывается для каждого объекта в иерархии. Подробности ниже.






Этот аргумент назван неверно. Чтобы избежать выхода за пределы дескрипторов файлов, 


 держит открытыми не более, чем 


 одновременно открытых каталогов. Это не препятствует обработке 


 иерархий, которые глубже уровня 


, но меньшие значения 


 означают, что 


 придется делать больше работы.






Набор флагов, объединяемых побитовым ИЛИ, которые указывают, как 


 должна обрабатывать иерархию.

Интерфейс 


 имеет два отдельных набора флагов. Одни набор контролирует саму 


 (аргумент 


 функции 


). Другой набор передается предоставленной пользователем функции, которую вызывает 


 (аргумент 


 для 


). Однако, интерфейс запутывает, поскольку имена обоих наборов флагов начинаются с префикса '


'. Мы постараемся сделать все, чтобы это прояснить по ходу дела. В табл. 8.3 представлены флаги, которые контролируют 


.



Таблица 8.3. Управляющие флаги для 










 предоставляет большую эффективность; при обработке глубоких иерархий файлов ядру не приходится обрабатывать снова и снова полные пути имен при осуществлении 


 или открытии каталога. Экономия времени для больших иерархий может быть вполне ощутимой.[85 - У некоторых старых версий GLIBC были проблемы с FTW_CHDIR. Это не относится к GLIBC 2.3.2 и более поздним, и маловероятно, что вы столкнетесь с проблемами — Примеч. автора.]




 может быть, а может и не быть тем, что вам нужно; для некоторых приложений это безусловно справедливо. Рассмотрите '


'. Эта команда удаляет права чтения и исполнения для владельца для всех файлов и подкаталогов в текущем каталоге. Если это изменение прав доступа применено к каталогу до того, как оно применено к содержимому каталога, любые последующие попытки обработки содержимого потерпят неудачу! Поэтому команда должна применяться к каталогу после обработки его содержимого.[86 - Мы не знаем, почему кому-нибудь может понадобиться делать такое изменение, но философия «что вы просили, то и получили» применяется и здесь! — Примеч. автора.] Справочная страница GNU/Linux nftw(3) отмечает для 


, что «это то, что вам нужно». Это позволяет вам обрабатывать сами символические ссылки, что обычно бывает нужно (Рассмотрите 


, она должна подсчитывать занимаемое ссылками пространство отдельно от связанных с ними файлов.)




8.4.3.2. Функция обратного вызова 





После запуска 


 она вызывает функцию, указатель для которой предоставляете вы. (Такие функции называются функциями обратного вызова (callback functions), поскольку они «вызываются обратно» из библиотечного кода.) Функция обратного вызова получает четыре аргумента:






Имя текущего обрабатываемого файла (каталога, символической ссылки и т.д.).






Указатель на 


 для файла.






Одно из нескольких значений флагов (описанных ниже), указывающих, какой это вид файла или была ли ошибка для объекта.






Эта структура предоставляет две отдельные части информации:





















Параметр 


 имеет одно из перечисленных в табл. 8.4 значений.



Таблица 8.4. Значения флагов для функции обратного вызова 










 предоставляет дополнительную информацию, которая может быть полезной. 


e действует в качестве индекса в 


; 


 является полным путем обрабатываемого объекта (относительно точки отсчета), '


' указывает на первый символ компонента имени файла.




 указывает текущую глубину иерархии; считается, что первоначальная точка отсчета находится на уровне 0.

Функция обратного вызова должна вернуть 0, если все нормально. Любое ненулевое возвращенное значение заставляет 


 прекратить свою обработку и вернуть то самое ненулевое значение. Справочная страница отмечает, что функция обратного вызова должна останавливать обработку только путем возвращаемого значения, чтобы у 


 был шанс произвести очистку: т.е. освободить динамически выделенную память, закрыть открытые дескрипторы файлов и т.д. Функции обратного вызова не следует использовать 


, если только программа не завершается немедленно, (


 является продвинутой функцией, которую мы опишем в разделе 12.5 «Нелокальные goto».) Рекомендуемой методикой обработки ошибок является установка глобальной переменной, указывающей на наличие проблем, возвращение 0 из функции обратного вызова и обработка ошибок после завершения перемещения 


 по иерархии файлов. (GNU 


 это делает, как мы вскоре увидим.)

Давайте свяжем все это воедино в примере программы. 


 обрабатывает каждый файл или каталог, указанный в командной строке, запуская для них 


. Функция, обрабатывающая каждый файл, выводите отступом имя и тип файла, показывая иерархическое положение каждого файла. Для разнообразия мы сначала покажем результаты, а затем покажем и обсудим программу:












































































Вот сама программа:
















































































































































































































































































































































Строки 3–11 включают заголовочные файлы. По крайней мере в GLIBC 2.3.2 перед включением любого заголовочного файла необходимы 


 для 


 и 


. Они дают возможность получить объявления и значения флагов, которые 


 предоставляет свыше предоставляемых 


. Это специфично для GLIBC. Потребность в этом в конечном счете исчезнет, когда GLIBC станет полностью совместимой со стандартом POSIX 2001.

Строки 35–44 обрабатывают опции. Опция 


 добавляет к флагам 


. Это эксперимент с целью увидеть, сможете ли вы оказаться где-то в другом месте от того, где начинали. Кажется, это возможно, если 


 завершается неудачей, в противном случае вы заканчиваете там же, где начинали. (POSIX не документирует это явным образом, но целью, похоже, было действительно заканчивать там же, где начинали. Стандарт не говорит, что функция обратного вызова не должна менять текущий каталог.)

Строка 49 сохраняет начальный каталог для дальнейшего использования, пользуясь 


.

Строка 51 вычисляет число дескрипторов, которые может использовать 


. Мы не хотим, чтобы она использовала все доступные дескрипторы файлов, если функция обратного вызова также хочет открывать файлы. В вычислении используется 


 (см. раздел 4.4.1 «Понятие о дескрипторах файлов») для получения максимально возможного числа и вычета из него 


, который был вычислен ранее в строке 13.

Эта процедура служит основанием для больших объяснений. В обычном случае по крайней мере три дескриптора уже используются для стандартного ввода, стандартного вывода и стандартной ошибки. 


 нужно некоторое количество дескрипторов файлов для открытия и чтения каталогов; внутри себя 


 использует 


 при открытии каталогов для чтения. Если функции обратного вызова также нужно открывать файлы, мы должны предотвратить израсходование функцией 


 всех доступных дескрипторов файлов для открывания каталогов. Мы делаем это, вычитая некоторое число из максимально допустимого. Для данного примера мы выбрали пять, но если функции обратного вызова нужно открывать файлы, должно использоваться большее число, (


 знает, как восстановиться при израсходовании дескрипторов файлов; мы не должны беспокоиться о таком случае.)

Строки 52–58 являются главным циклом над нашими аргументами; строки 53–57 проверяют ошибки; когда они появляются, код выводит диагностическое сообщение и увеличивает значение переменной 


.

Строки 60–64 являются частью эксперимента с 


, выводящего начальный и конечный каталоги, если было использовано 


.

По-настоящему интересной функцией является 


; это функция обратного вызова, которая обрабатывает каждый файл. Она использует базовый шаблон для функции обратного вызова 


, который является оператором 


 для значения 


.




































































































































































































Строка 75 использует '


' для получения имени из полного пути. Это значение указателя сохраняется в переменной 


 для повторного использования в функции.

Строка 77 делает отступ нужного размера, используя красивый трюк. Используя 


, 


 получает от первого аргумента ширину поля. Это вычисляется динамически как '


'. Строка, которая должна быть выведена — «», пустая строка. Конечным результатом является то, что 


 создает для нас отступ нужного размера без необходимости запуска цикла.

Строки 79–104 являются оператором 


. В данном случае он не делает ничего весьма интересного, кроме вывода имени файла и его типа (файл, каталог и т.д.)

Хотя эта программа не использует 


, должно быть ясно, что вы могли бы сделать в функции обратного вызова все, что хотите.



ЗАМЕЧАНИЕ. Джим Мейеринг (Jim Meyering), сопроводитель GNU Coreutils, замечает, что дизайн 


 несовершенен из-за ее рекурсивной природы. (Она рекурсивно вызывает себя при обработке подкаталогов.) Если иерархия каталогов становится действительно глубокой, в диапазоне уровней 20 000–40 000 (!), 


 может выйти за пределы размера стека, уничтожив программу. Есть также и другие проблемы, связанные с дизайном 


. Версия GNU Coreutils после 5.0 исправляет это путем использования набора процедур 


 (см. fts(3)).





8.5. Обход дерева файлов: GNU 





GNU версия 


 в GNU Coreutils использует 


 для обхода одной или более иерархии файлов, собирая и выводя сведения, касающиеся количества используемого дискового пространства. У нее большое число опций, которые управляют ее поведением но отношению к символическим ссылкам, форматом вывода чисел и т.д. Это делает разбор кода труднее, чем могло бы быть при более простой версии. (Однако, мы не собираемся позволить этому остановить нас.) Вот сводка опций 


, которые вскоре будут полезны, когда мы рассмотрим код.














































































































































































































Чтобы еще больше усложнить дело, 


 использует частную версию 


, у которой есть несколько расширений. Сначала имеются дополнительные значения флагов для функции обратного вызова:






Это значение означает, что 


 не может выполнять '


'.






Это значение означает, что 


 не может использовать 


 для перехода в сам каталог.






Частная 


 вызывает для каталогов функцию обратного вызова дважды. Это значение используется при первой встрече с каталогом. После обработки всех нижележащих объектов каталога используется стандартное значение 


.

Частная 


 добавляет также в 


 новый член, 


. Если текущий объект является каталогом и функция обратного вызова устанавливает в поле 


 ненулевое значение, 


 не будет больше обрабатывать этот каталог. (Функция обратного вызова должна установить 


 таким образом, когда 


 равен 


; делать это для 


 слишком поздно.)

С этим объяснением за поясом, вот функция 


 из 


. Номера строк приведены относительно начала функции:










































































































Эта функция делает многое, поскольку ей приходится реализовать все опции 


. Строка 17 устанавливает 


 в true (1); по умолчанию выводятся сведения о каждом файле. Дальнейший код устанавливает ее при необходимости в false (0).

Строка 20 устанавливает 


 на основе опции 


. Обратите внимание, что это исключает подкаталоги, если каталог совпадает с шаблоном для 


.
















































































































































































Строки 22–51 являются стандартным оператором 


. Ошибки, для которых нет информации о размере, устанавливают глобальную переменную 


 в 1 и возвращают 0, чтобы продолжить обработку (см строки 24–27 и 29–33). Ошибки, для которых есть размер, также устанавливают 


, но затем прерывают 


 для того, чтобы обработать статистику (см. строки 35–40 и 42–47).

Строки 55–56 сразу завершают функцию, если это первая встреча с каталогом
































































































Теперь становится интересно. По умолчанию 


 подсчитывает пространство, занимаемое прямыми ссылками, лишь одни раз. Опция 


 заставляет ее подсчитывать пространство для каждой ссылки; переменная 


 равна true, когда указана 


. Для отслеживания ссылок 


 содержит хэш-таблицу[87 - Хэш-таблица является структурой данных, позволяющей быстрое получение сохраненной информации, подробности выходят за рамки данной книги — Примеч. автора.] уже встречавшихся пар (устройство, индекс).

Строки 60–63 проверяют, следует ли не включать файл в подсчет, либо из-за того, что он был исключен (


 равно true, строка 60), либо потому что не была указана 


 (строка 61) и у файла несколько ссылок (строка 62) и файл уже находится в хеш-таблице (строка 63). В этом случае размер устанавливается в 0, поэтому он не входит в конечную сумму, a 


 также устанавливается в false (строки 68–69).

Если ни одно из этих условий не отмечается, размер вычисляется либо в соответствии с размером в 


, либо в соответствии с числом блоков диска (строки 73–75) Это решение основывается на переменной 


, которая установлена при использовании опции 


.















































































































Строки 78–97 управляют динамической памятью, используемой для хранения статистики о размере файла, 


 является статической переменной (строка 12), которая равна true при первом вызове 


. В этом случае вызывается 


 (через упаковывающий макрос в строках 81–82; это обсуждалось в разделе 3.2.1.8 «Пример чтение строк произвольной длины»). Остальную часть времени 


 равно false, и используется 


 (снова через упаковывающий макрос, строки 91–96).

Строка 99 заносит значение 


 в 


; эта переменная может обновляться в зависимости от того, должна ли она включать размеры дочерних элементов. Хотя 


 могла бы использоваться повторно, отдельная переменная упрощает чтение кода.

































































































































































Строки 101–132 сравнивают текущий уровень с предыдущим. Возможны три случая.

Уровни те же самые

В этом случае нет необходимости беспокоиться о статистике дочерних элементов. (Строки 103–106.)

Текущий уровень выше предыдущего

В этом случае мы спустились по иерархии, и статистику нужно восстановить (строки 107–116). Термин «аккумулятор» в комментарии подходящий: каждый элемент аккумулирует общее дисковое пространство, использованное на этом уровне. (На заре вычислительной техники регистры центрального процессора часто назывались «аккумуляторами».)

Текущий уровень ниже предыдущего

В этом случае мы завершили обработку всех дочерних элементов каталога и только что вернулись обратно в родительский каталог (строки 117–131). Код обновляет суммы, включая 


.















































































































Строки 134–135 устанавливают статические переменные 


 и 


 таким образом, что они содержат правильные значения для последующего вызова 


, гарантируя, что весь предыдущий код работает правильно.

Строки 137–144 выверяют статистику на основе опций и типа файла. Комментарии и код достаточно просты. Строки 146–155 сразу завершают функцию, если сведения не должны выводиться.








































































































































Условие в строках 158–160 сбивает с толку, и комментарий в строке 157 указывает на это. Условие утверждает: «Если (1a) файл является каталогом и (1b) уровень меньше максимального для вывода (переменные — 


 и 


) или нулевой, или (2a) должны быть выведены все файлы и уровень меньше, чем максимальный для вывода, или (2b) уровень нулевой», тогда вывести файл. (Версия 


 после 5.0 использует в этом случае несколько менее запутанное условие.)

Строки 162–179 осуществляют вывод. Строки 162–163 выводят размер и символ TAB Строки 164–173 обрабатывают специальный случай. Это объяснено далее в 


, в строках файла 524–529:































В этом случае 


 равен true, поэтому строки 164–173 должны вывести первоначальное имя, а не измененное В противном случае строки 174–177 могут вывести имя как есть.

Фу! Куча кода. Мы находим, что это верхний уровень спектра сложности, по крайней мере, насколько это может быть просто представлено в книге данного содержания. Однако, он демонстрирует, что код из реальной жизни часто бывает сложным. Лучшим способом справиться с этой сложностью является ясное именование переменных и подробные комментарии 


 в этом отношении хорош; мы довольно легко смогли извлечь и изучить код без необходимости показывать все 735 строк программы!




8.6. Изменение корневого каталога: 





Текущий рабочий каталог, установленный с помощью 


) (см. раздел 8.4.1 «Изменение каталога — 


 и 


»), является атрибутом процесса, таким же, как набор открытых файлов. Он также наследуется новыми процессами.

Менее известным является то, что у каждого процесса есть также текущий корневой каталог. Это именно на этот каталог ссылается имя пути 


. В большинстве случаев корневые каталоги процесса и системы идентичны. Однако, суперпользователь может изменить корневой каталог с помощью (как вы догадались) системного вызова 


:













Возвращаемое значение равно 0 при успешном завершении и -1 при ошибке.

Как указывает справочная страница GNU/Linux chroot(2), изменение корневого каталога не изменяет текущий каталог: программы, которые должны обеспечить нахождение под новым корневым каталогом, должны также вызвать затем 


: 





















Системный вызов 


 чаще всего используется для демонов — фоновых программ, которые должны работать в специальном ограниченном окружении. Например, рассмотрите демон Интернета FTP, допускающий анонимный FTP (соединение любого клиента из любого места, без обычных имени пользователя и пароля). Очевидно, такое соединение не должно быть способным видеть все файлы целой системы. Вместо этого демон FTP выполняет 


 в специальный каталог со структурой, достаточной лишь чтобы позволить ему функционировать. (Например, со своим собственным 


 для перечисления файлов, со своей копией библиотеки С времени исполнения, если она разделяется, и, возможно, со своей копией 


 и 


 для отображения ограниченного набора имен пользователей и групп.)

POSIX не стандартизует этот системный вызов, хотя GNU/Linux и все системы Unix его поддерживают. (Он популярен с V7.) Он специализирован, но при необходимости очень удобен.




8.7. Резюме


• Файловые системы являются коллекциями блоков индексов, данных, вспомогательных данных и свободных блоков, организованных особым способом. Файловые системы один к одному соответствуют (физическим или логическим) разделам, на которых они создаются. У каждой файловой системы есть свой корневой каталог; по соглашению, у корневого каталога номер индекса всегда равен 2.

• Команда 


 монтирует файловую систему, наращивая логическое иерархическое пространство имен файлов. Команда 


 отсоединяет файловую систему. Ядро делает 


 и 


 одним и тем же; корневой каталог всего пространства имен является своим собственным родителем. Во всех остальных случаях ядро устанавливает в корневом каталоге смонтированной файловой системы указывающим на родительский каталог точки монтирования.

• Современные Unix-системы поддерживают множество типов файловых систем. В частности, повсеместно поддерживается сетевая файловая система (NFS) Sun, также, как ISO 9660 является стандартным форматом для CD-ROM, а разделы FAT MS- DOS поддерживаются на всех Unix-системах, работающих на платформе Intel x86. Насколько мы знаем, Linux поддерживает наибольшее число различных файловых систем — свыше 30! Многие из них специализированные, но многие из оставшихся предназначены для общего использования, включая по крайней мере четыре различные журналируемые файловые системы.

• Файл 


 перечисляет разделы каждой системы, их точки монтирования и относящиеся к монтированию опции, 


 перечисляет те файловые системы, которые смонтированы в настоящее время, то же делает 


 на системах GNU/Linux. Опция 


 функции 


 особенно полезна под GNU/Linux для монтирования образов файловых систем, содержащихся в обычных файлах, таких, как образы CD-ROM. Другие опции полезны для безопасности и монтирования внешних файловых систем, таких, как файловые системы vfat Windows.

• Файлы формата 


 можно читать с помощью набора процедур 


. Формат GNU/Linux общий с рядом других коммерческих вариантов Unix, особенно Sun Solaris.

• Функции 


 и 


 стандартизованы POSIX для получения сведений о файловой системе, таких, как число свободных и используемых дисковых блоков, число свободных и используемых индексов и т.д. В Linux есть свой собственный системный вызов для получения подобной информации: 


 и 


.

• 


 и 


 дают процессу возможность изменить его текущий каталог, 


 получает абсолютное имя пути текущего каталога. Эти три функции просты в использовании.

• Функция 


 централизует задачу «обхода дерева файлов», т.е. посещения каждого объекта файловой системы (файла, устройства, символической ссылки, каталога) во всей иерархии каталогов. Ее поведением управляют различные флаги. Программист должен предоставить функцию обратного вызова, которая получает имя каждого файла, 


 для файла, тип файла и сведения об имени файла и уровне в иерархии. Эта функция может делать для каждого файла все что нужно. Версия функции 


 из Coreutils 5.0 GNU использует для выполнения этой работы расширенную версию 


.

• Наконец, системный вызов 


 изменяет текущий корневой каталог процесса. Это специализированная, но важная возможность, которая особенно полезна для определенных программ в стиле демонов.




Упражнения


1. Изучите справочную страницу mount(2) под GNU/Linux и на всех различных системах Unix, к которым у вас есть доступ. Как отличаются системные вызовы?

2. Усовершенствуйте программу 


, чтобы она принимала опцию, предоставляющую открытый целый дескриптор файла; для получения сведений о файловой системе она должна использовать 


.

3. Усовершенствуйте 


, чтобы она не игнорировала смонтированные файловые системы NFS. Такие файловые системы имеют устройство в форме 


.

4. Измените 


 (ту, которая использует специфичный для Linux вызов 


), чтобы ее вывод был похож на вывод 


.

5. Добавьте опцию 


 к программе, которую вы написали для предыдущего упражнения, чтобы ее вывод был такой же, как у '


'.

6. Используя 


, 


, 


 или 


, 


 и 


, напишите собственную версию 


. Как вы вычислите общий размер, который должен иметь буфер? Как вы будете перемещаться по иерархии каталогов?

7. Усовершенствуйте свою версию 


, чтобы она выделяла буфер для вызывающего, если первый аргумент равен NULL.

8. Можете ли вы использовать 


 для написания 


? Если нет, почему?

9. Используя 


, напишите свою собственную версию 


, которая принимает опцию 


 для рекурсивной обработки целых деревьев каталогов. Убедитесь, что без 


, '


' не является рекурсивной. Как вы это проверите?

10. Набор процедур BSD 


 («file tree stream» — «поток дерева файлов») предоставляет другой способ для обработки иерархии каталогов. У него несколько более тяжелый API как в смысле числа функций, так и структур, которые доступны для вызывающих функций уровня пользователя. Эти функции доступны как стандартная часть GLIBC.

Прочтите справочную страницу fts(3). (Для удобства ее можно распечатать.) Перепишите свою частную версию chown для использования 


.

11. Посмотрите справочную страницу find(1). Если бы вы пытались написать 


 с самого начала, какой набор деревьев файлов вы бы предпочли, 


 или 


? Почему?




Часть 2

Процессы, IPC и интернационализация





Глава 9

Управление процессами и каналы



Как мы говорили в главе 1 «Введение», если бы нужно было резюмировать Unix (а следовательно, и Linux) в трёх словах, это были бы «файлы и процессы». Теперь, когда мы увидели, как работать с файлами и каталогами, время взглянуть на оставшуюся часть утверждения: процессы. В частности, мы исследуем, как создаются и управляются процессы, как они взаимодействуют с открытыми файлами и как они могут взаимодействовать друге другом. Последующие главы исследуют сигналы — грубый способ дать возможность одному процессу (или ядру) сообщить другому о том, что произошло некоторое событие — и проверку прав доступа.

В данной главе картина начинает усложняться. В частности, для полноты мы должны упомянуть о вещах, которые не будут рассматриваться до конца главы или до конца книги В таких случаях мы предусмотрели ссылки вперед, но вы должны быть способны без подготовки уловить суть каждого раздела.




9.1. Создание и управление процессами



В отличие от многих предшествующих и последующих операционных систем, создание процессов в Unix задумывалось (и было сделано) дешевым. Более того, Unix разделяет идеи «создания нового процесса» и «запуска данной программы в процессе». Это было элегантное проектное решение, которое упрощает многие операции.




9.1.1. Создание процесса: 






Первым шагом в запуске новой программы является вызов 


:


















Использование 


 просто. Перед вызовом один процесс, который мы называем родительским, является запущенным. Когда 


 возвращается, имеется уже два процесса: родительский и порожденный (child).

Вот ключ: оба процесса выполняют одну и ту же программу. Два процесса могут различить себя, основываясь на возвращённом 


 значении:

Отрицательное

Если была ошибка, 


 возвращает -1, а новый процесс не создается. Работу продолжает первоначальный процесс.

Нулевое

В порожденном процессе 


 возвращает 0.

Положительное

В родительском процессе 


 возвращает положительный идентификационный номер (PID) порожденного процесса.

Код шаблона для создания порожденного процесса выглядит следующим образом:







































 является знаковым целым типом для хранения значений PID. Скорее всего, это просто 


, но специальный тип делает код более понятным, поэтому он должен использоваться вместо 


.

На языке Unix, помимо названия системного вызова, слово «fork» является и глаголом, и существительным[88 - Fork (англ.) — «n вилка, развилка, v разветвлять, ответвлять» — Примеч. перев.]. Мы можем сказать, что «один процесс ответвляет другой», и что «после разветвления работают два процесса». (Думайте «развилка (fork) на дороге», а не «вилка (fork), нож и ложка».)




9.1.1.1. После 


: общие и различные атрибуты


Порожденный процесс «наследует» идентичные копии большого числа атрибутов от родителя. Многие из этих атрибутов специализированы и здесь неуместны. Поэтому следующий список намеренно неполон. Существенны следующие:

• Окружение, см. раздел 2.4 «Окружение».

• Все открытые файлы и открытые каталоги; см. раздел 4.4.1 «Понятие о дескрипторах файлов» и раздел 5.3.1 «Базовое чтение каталогов».

• Установки umask; см. раздел 4.6 «Создание файлов».

• Текущий рабочий каталог; см раздел 8.4.1 «Смена каталога: 


 и 


.

• Корневой каталог; см. раздел 8.6 «Изменение корневого каталога: 


».

• Текущий приоритет (иначе называемый «значение nice»; вскоре мы это обсудим; см раздел 9.1.3 «Установка приоритета процесса: 


»).

• Управляющие терминалы. Это устройство терминала (физическая консоль или окно эмулятора терминала), которому разрешено посылать процессу сигналы (такие, как CTRL-Z для прекращения выполняющихся работ). Это обсуждается далее в разделе 9.2.1 «Обзор управления работой».

• Маска сигналов процесса и расположение всех текущих сигналов (еще не обсуждалось; см. главу 10 «Сигналы»).

• Реальный, эффективный и сохраненный ID пользователя, группы и набора дополнительных групп (еще не обсуждалось; см. главу 11 «Права доступа и ID пользователя и группы»).

Помимо возвращаемого значения 


 два процесса различаются следующим образом:

• У каждого есть уникальный ID процесса и ID родительского процесса (PID и PPID) Они описаны в разделе 9.1.2 «Идентификация процесса: 


 и 


».

• PID порожденного процесса не будет равняться ID любой существующей группы процессов (см. раздел 9.2 «Группы процессов»).

• Аккумулированное время использования процессора для порожденного процесса и его будущих потомков инициализируется нулем. (Это имеет смысл; в конце концов, это совершенно новый процесс.)

• Любые сигналы, которые были ожидающими в родительском процессе, в порожденном сбрасываются, также как ожидающие аварийные сигналы и таймеры. (Мы еще не рассматривали эти темы; см. главу 10 «Сигналы» и раздел 14.3.3 «Интервальные таймеры: 


 и 


».)

• Блокировки файлов в родительском процессе не дублируются в порожденном (также еще не обсуждалось; см. раздел 14.2 «Блокировка файлов»).




9.1.1.2. Разделение дескрипторов файлов


Атрибуты, которые порожденный процесс наследует от родителя, устанавливаются в те же значения, которые были в родительском процессе в момент выполнения 


. Однако, с этого момента два процесса продолжают идти собственными путями (большей частью) независимо один от другого. Например, если порожденный процесс изменяет каталог, каталог родительского процесса не затрагивается. Сходным образом, если порожденный изменяет среду, среда родителя не меняется.

Открытые файлы являются важным исключением из этого правила. Дескрипторы открытых файлов являются разделяемыми, и действия одного процесса с разделяемым дескриптором файла затрагивает состояние файла также и для другого процесса. Это лучше всего понять, изучив рис. 9.1.




Рис. 9.1. Разделение дескрипторов файлов

Рисунок отображает внутренние структуры данных ядра. Ключевой структурой данных является таблица файлов. Каждый элемент ссылается на открытый файл. Помимо других учетных данных, таблица файлов содержит текущее положение (смещение чтения/записи) в файле. Оно устанавливается либо автоматически каждый раз при чтении или записи файла, либо непосредственно через 


 (см. раздел 4.5 «Произвольный доступ: перемещения внутри файла»).

Дескриптор файла, возвращенный функциями 


 или 


, действует как индекс имеющегося в каждом процессе массива указателей на таблицу файлов. Размер этого массива не превышает значение, возвращенное 


 (см. раздел 4.4.1 «Понятие о дескрипторах файлов»).

На рис. 9.1 показаны два процесса, разделяющие стандартный ввод и стандартный вывод; для каждого из процессов указаны одни и те же элементы в таблице файлов. Поэтому, когда процесс 45 (порожденный) осуществляет 


, общее смещение обновляется; следующий раз, когда процесс 42 (родитель) осуществляет 


, он начинает с позиции, в которой закончила чтение 


 процесса 45.

Это легко можно видеть на уровне оболочки:



























































































Первая исполняемая строка 


 читает из стандартного ввода строку, изменяя смещение файла. Следующая строка 


 запускает команды, заключенные между скобками, в подоболочке (subshell). Это отдельный процесс оболочки, созданный — как вы догадались — с помощью 


. Порожденная подоболочка наследует от родителя стандартный ввод, включая текущее смещение. Этот процесс читает строку и обновляет разделяемое смещение в файле. Когда третья строка, снова в родительской оболочке, читает файл, она начинает там, где остановился порожденный.

Хотя команда 


 встроена в оболочку, все работает таким же образом и для внешних команд. В некоторых ранних Unix-системах была команда 


, которая читала одну строку ввода (по одному символу за раз!) для использования в сценариях оболочки; если бы смещение файла не было разделяемым, было бы невозможно использовать такую команду в цикле.

Разделение дескрипторов файлов и наследование играют центральную роль в перенаправлении ввода/вывода оболочки; системные вызовы и их семантика делают примитивы уровня оболочки простыми для реализации на С, как мы позже увидим в данной главе.




9.1.1.3. Разделение дескрипторов файлов и 





Тот факт, что несколько дескрипторов файлов могут указывать на один и тот же открытый файл, имеет важное следствие: файл не закрывается до тех пор, пока не будут закрыты все дескрипторы файла.

Позже в главе мы увидим, что несколько дескрипторов для одного файла могут существовать не только для разных процессов, но даже и внутри одного и того же процесса; это правило особенно важно для работы с каналами (pipes).

Если вам нужно узнать, открыты ли два дескриптора для одного и того же файла, можете использовать 


 (см. раздел 5.4.2 «Получение сведений о файле») для двух дескрипторов с двумя различными структурами 


. Если соответствующие поля 


 и 


 равны, это один и тот же файл.

Позже в главе мы завершим обсуждение манипуляций с дескрипторами файлов и таблицей дескрипторов файлов.




9.1.2. Идентификация процесса: 


 и 





У каждого процесса есть уникальный ID номер процесса (PID). Два системных вызова предоставляют текущий PID и PID родительского процесса:























Функции так просты, как выглядят:




Возвращает PID текущего процесса




Возвращает PID родителя.

Значения PID уникальны; по определению, не может быть двух запущенных процессов с одним и тем же PID. PID обычно возрастают в значении, так что порожденный процесс имеет обычно больший PID, чем его родитель. Однако, на многих системах значения PID переполняются; когда достигается значение системного максимума для PID, следующий процесс создается с наименьшим не используемым номером PID. (Ничто в POSIX не требует такого поведения, и некоторые системы назначают неиспользуемые номера PID случайным образом.)

Если родительский процесс завершается, порожденный получает нового родителя, 


. В этом случае PID родителя будет 1, что является PID 


. Такой порожденный процесс называется висячим (orphan). Следующая программа, 


, демонстрирует это. Это также первый пример 


 в действии:


























































































































































































Строка 15 получает PID начального процесса, используя 


. Строки 17–20 создают порожденный процесс, проверяя по возвращении ошибки.

Строки 21–24 выполняются порожденным процессом: строка 22 получает PPID. Строка 23 приостанавливает процесс на две секунды (сведения о 


 см в разделе 10.8.1 «Аварийные часы: 


, 


 и 


»), а строка 24 снова получает PPID.

Строки 25–27 исполняются в родительском процессе. Строка 26 задерживает родителя на одну секунду, давая порожденному процессу достаточно времени для осуществления первого вызова 


. Строка 27 завершает родителя.

Строки 31–34 выводят значения. Обратите внимание, что переменная 


, которая была установлена до разветвления, сохраняет свое значение в порожденном процессе. После порождения у двух процессов идентичные, но независимые копии адресного пространства. Вот что происходит при запуске программы:































Помните, что обе программы выполняются параллельно. Графически это изображено на рис. 9.2.




Рис. 9.2. Два параллельно исполняющихся процесса после разветвления



ЗАМЕЧАНИЕ. Использование 


, чтобы заставить один процесс пережить другой, работает в большинстве случаев. Однако, иногда случаются ошибки, которые трудно воспроизвести и трудно обнаружить. Единственным способом гарантировать правильное поведение является явная синхронизация с помощью 


 или 


, которые описываются далее в главе (см. раздел 9.1.6.1 «Использование функций POSIX: 


 и 


»).





9.1.3. Установка приоритетов процесса: 






Когда процессы запущены, ядро динамически меняет приоритет каждого процесса. Как и в жизни, элементы с большим приоритетом получают внимание до элементов с меньшим приоритетом. Короче говоря, каждому процессу выделяется небольшая порция времени для исполнения, которая называется квантом времени (time slice). Когда квант истекает, если текущий процесс все еще является процессом с наивысшим приоритетом, ему разрешается продолжать.

Linux, как и Unix, обеспечивает вытесняющую многозадачность. Это означает, что ядро может вытеснить процесс (приостановить его), если настало время дать возможность поработать другому процессу. Приоритет длительное время работающих процессов (например, процессов, выполняющих интенсивные вычисления), снижается в конце их кванта времени, поэтому они дают шанс другим процессам получить время процессора. Сходным образом, процессам, длительное время бездействовавшим в ожидании завершения ввода/вывода (таким, как интерактивный текстовый редактор), приоритет повышается, так что они могут ответить на ввод/вывод, когда он происходит. Короче, ядро гарантирует, что все процессы, усредненные по времени, получают свою «справедливую долю» времени процессора. Повышение и понижение приоритетов является частью этого процесса.

Проектирование хорошего планировщика процессов для ядра является искусством; практические подробности выходят за рамки данной книги. Однако, процесс может влиять на назначения приоритетов ядром посредством своего значения относительного приоритета (nice).

Значение относительного приоритета является указанием того, насколько «приятным» хочет быть процесс в отношении других процессов. В соответствии с этим большие значения означают во все большей степени терпеливые процессы; т.е. те, которые все более приятны другим, снижая свой приоритет по отношению к ним.

Отрицательное значение относительного приоритета, с другой стороны, означает, что процесс желает быть «менее приятным» по отношению к другим. Такой процесс более эгоистичный, требуя себе большего количества времени процессора[89 - Такие процессы часто демонстрируют детское поведение. — Примеч. автора.]. К счастью, в то время как пользователи могут повышать значение относительного приоритета (быть более приятными), лишь 


 может снижать значение относительного приоритета (быть менее приятным).

Значение относительного приоритета является лишь одним фактором в уравнении, используемом ядром для вычисления приоритета; это не значение самого приоритета, которое изменяется с течением времени на основе поведения процесса и состояния других процессов системы. Для изменения значения относительного приоритета используется системный вызов 


:













Значение относительного приоритета по умолчанию равно 0. Разрешен диапазон значений от -20 до 19. Это требует некоторой привычки. Чем более отрицательное значение, тем выше приоритет процесса: -20 является наивысшим приоритетом (наименьшая приятность), а 19 — наинизшим приоритетом (наибольшая приятность)

Аргумент 


 является приращением, на который надо изменить значение приоритета. Для получения текущего значения, не изменяя его, используйте '


'. Если результат '


' выйдет за пределы от -20 до 19, система принудительно включит его в этот диапазон.

Возвращаемое значение является новым значением относительного приоритета или -1, если возникла ошибка. Поскольку -1 также является действительным значением относительного приоритета, при вызове 


 следует сначала явным образом установить 


 в ноль, а затем проверить его насчет имевшихся проблем:




































Этот пример может завершиться неудачей, если в 


 отрицательное значение, а процесс не запущен как 


.




9.1.3.1. POSIX против действительности


Диапазон значений относительного приоритета от -20 до 19, которые использует Linux, имеет исторические корни; он ведет начало по крайней мерее V7. POSIX выражает состояние менее прямым языком, что дает возможность большей гибкости, сохраняя в то же время историческую совместимость. Это также затрудняет чтение и понимание стандарта, вот почему вы и читаете эту книгу. Итак, вот как описывает это POSIX

Во-первых, значение относительного приоритета процесса, поддерживаемое системой, колеблется от 0 до '


'. Константа 


 определена в 


 и должна равняться по крайней мере 20. Это дает диапазон 0–39.

Во-вторых, как мы описывали, сумма текущего значения относительного приоритета и приращение 


 загоняются в этот диапазон.

В заключение, возвращаемое 


 значение является значением относительного приоритета процесса минус 


. При значении 


 20 это дает первоначальный диапазон от -20 до 19, который мы описали вначале.

Результатом является то, что возвращаемое nice() значение в действительности изменяется от '


' до '


', и лучше всего писать свой код в терминах этой именованной константы. Однако, на практике трудно найти систему, в которой 


 не было бы равно 20.




9.1.4. Запуск новой программы: семейство 






После запуска нового процесса (посредством 


) следующим шагом является запуск в процессе другой программы. Имеется несколько функций, которые служат различным целям:











































Мы ссылаемся на эти функции как на «семейство 


». Функции с именем 


 нет; вместо этого мы используем это имя для обозначения любой из перечисленных выше функций. Как и в случае с 


, «


» используется на языке Unix и в качестве глагола, означающего исполнение (запуск) программы, и в качестве существительного.




9.1.4.1. Системный вызов 





Простейшей для объяснения функцией является 


. Она является также лежащим в основе системным вызовом. Другие являются функциями-оболочками, как вскоре будет объяснено.














 является именем программы для исполнения. Это может быть именем полного или относительного пути. Файл должен иметь формат исполняемого файла, который понимает ядро. Современные системы используют формат исполняемого файла ELF (Extensible Linking Format — открытый формат компоновки). GNU/Linux распознает ELF и несколько других форматов. С помощью 


 можно исполнять интерпретируемые сценарии, если они используют особую первую строку с именем интерпретатора, начинающуюся с '


'. (Сценарии, которые не начинаются с '


', потерпят неудачу.) В разделе 1.1.3 «Исполняемые файлы» представлен пример использования '#!'. argv является стандартным списком аргументов С — массив символьных указателей на строки аргументов, включая значение для использования с


[90 - См. 9.1.4.3 Имена программ и 


 — Примеч. науч. ред.], завершающийся указателем 


.




 является окружением для использования новым процессом, с таким же форматом, как глобальная переменная 


 (см. раздел 2.4 «Переменные окружения»). В новой программе это окружение становится начальным значением 


.

Программа не должна возвращаться из вызова 


. Если она возвращается, возникла проблема. Чаще всего либо не существует затребованная программа, либо она существует, но не является исполняемой (значения для 


 и 


 соответственно). Может быть множество других ошибок; см. справочную страницу execve(2).

В предположении, что вызов был успешным, текущее содержимое адресного пространства процесса сбрасывается. (Ядро сначала сохраняет в безопасном месте данные 


 и 


.) Ядро загружает для новой программы исполняемый код вместе со всеми глобальными и статическими переменными. Затем ядро инициализирует переменные окружения переданными 


 данными, а далее вызывает процедуру 


 новой программы с переданным функции 


 массивом 


. Подсчитывается число аргументов и это значение передается 


 в 


.

К этому моменту новая программа запущена. Она не знает (и не может определить), какая программа была в процессе до нее. Обратите внимание, что ID процесса не меняется. Многие другие атрибуты при вызове 


 сохраняются; вскоре мы рассмотрим это более подробно.




 для процесса можно сравнить с ролями, которые играют в жизни люди. В различное время в течение дня один человек может быть родителем, супругом, другом, студентом или рабочим, покупателем в магазине и т.д. Это одна и та же личность, исполняющая различные роли. Также и процесс — его PID, открытые файлы, текущий каталог и т.п. — не изменяются, тогда как выполняемая работа - запущенная с помощью 


 программа — может измениться.




9.1.4.2. Функции-оболочки: 


 и др.


Пять дополнительных функций, действующих в качестве оболочек, предоставляют более удобные интерфейсы для 


. В первой группе все принимают список аргументов, каждый из которых передается в виде явного параметра функции:






Первый аргумент, 


, является путем к исполняемому файлу. Последующие аргументы, начиная с 


, являются отдельными элементами, которые должны быть помещены в 


. Как и ранее, явным образом должен быть включен 


. Вы должны в качестве последнего аргумента передать завершающий указатель 


, чтобы 


 смогла определить, где заканчивается список аргументов. Новая программа наследует любые переменные окружения, которые находятся в переменной 


.






Эта функция подобна 


, но она имитирует механизм поиска команд оболочки, разыскивая 


 в каждом каталоге, указанном в переменной окружения 


. Если 


 содержит символ 


, этот поиск не осуществляется. Если 


 в окружении не присутствует, 


 использует путь по умолчанию. В GNU/Linux по умолчанию используется "


", но в других системах может быть другое значение. (Обратите внимание, что ведущее двоеточие в 


 означает, что сначала поиск осуществляется в текущем каталоге.)

Более того, если файл найден и имеет право доступа на исполнение, но не может быть исполнен из-за того, что неизвестен его формат, 


 считает, что это сценарий оболочки и запускает оболочку с именем файла в качестве аргумента.











Эта функция также подобна 


, но принимает дополнительный аргумент, 


, который становится окружением новой программы. Как и в случае с 


, вы должны для завершения списка аргументов поместить перед 


 указатель 


.

Вторая группа функций-оболочек принимает массив в стиле 


:






Эта функция подобна 


, но новая программа наследует любое окружение, которое находится в переменной environ текущей программы.






Эта функция подобна 


, но она осуществляет такой же поиск в 


, как и функция 


. Она также переходит на исполнение сценария оболочки, если найденный файл не может быть исполнен непосредственно.

В табл. 9.1 подведены итоги для шести функций 


.



Таблица 9.1. Сводка семейства функций 


 по алфавиту




Функций 


 и 


 лучше избегать, если вы не знаете, что переменная окружения 


 содержит приемлемый список каталогов.




9.1.4.3. Имена программ и 





До сих пор мы все время считали 


 именем программы. Мы знаем, что оно может содержать, а может и не содержать символ 


, в зависимости от способа вызова программы, если этот символ содержится, это хорошая подсказка к тому, что для вызова программы использовалось имя пути.

Однако, как должно быть ясно к этому времени, то, что 


 содержит имя файла, является лишь соглашением. Ничто не может воспрепятствовать передаче вами вызываемой программе в качестве 


 произвольной строки. Следующая программа, 


, демонстрирует передачу произвольной строки:






























































































































Первый аргумент является путем к запускаемой программе, а второй аргумент является новым именем для программы (которое большинство утилит игнорируют, кроме сообщений об ошибках); все остальные аргументы передаются вызываемой программе.

Строки 13–16 осуществляют проверку ошибок. Строка 18 сохраняет путь в 


 Строка 20 осуществляет 


; если программа доходит до строк 22–23, это указывает на ошибку. Вот что происходит при запуске программы:




































Следующий пример несколько неестественен: мы заставили 


 запустить себя, передав в качестве имени программы '


'. Поскольку аргументов для второго запуска недостаточно, она выводит сообщение об использовании и завершается:











Хотя она и не очень полезна, 


 ясно показывает, что 


 не обязательно должен иметь какое-нибудь отношение к файлу, который в действительности запускается.

В System III (примерно в 1980-м) команды 


, 


 и 


 представляли один исполняемый файл с тремя ссылками с этими именами в 


. Программа проверяла 


 и решала, что она должна делать. Это сохраняло некоторое количество дискового пространства за счет усложнения исходного кода и форсирования выполнения программой действия по умолчанию при запуске с неизвестным именем. (Некоторые современные коммерческие системы Unix продолжают эту практику!) Без явной формулировки причин GNU Coding Standards рекомендует, чтобы программы не основывали свое поведение на своем имени. Одна причина, которую мы видели, состоит в том, что администраторы часто устанавливают GNU версию утилиты наряду со стандартной версией коммерческих систем Unix, используя префикс g: 


, 


 и т.д. Если такие программы ожидают лишь стандартные имена, они при запуске с другим именем потерпят неудачу.

Сегодня также дисковое пространство дешево; если из одного и того же исходного кода можно построить две почти идентичные программы, лучше это сделать, использовав 


, что у вас есть. Например, 


 и 


 имеют значительную часть общего кода, но GNU версия строит два отдельных исполняемых файла.




9.1.4.4. Атрибуты, наследуемые 





Как и в случае с 


, после вызова программой 


 сохраняется ряд атрибутов:

• Все открытые файлы и открытые каталоги; см. раздел 4.4.1 «Понятие о дескрипторах файлов» и раздел 3.3.1 «Базовое чтение каталогов». (Сюда не входят файлы, помеченные для закрытия при исполнении (close-on-exec), как описано далее в этой главе; см. раздел 9.4.3.1 «Флаг close-on-exec».)

• Установки umask; см. раздел 4.6 «Создание файлов».

• Текущий рабочий каталог, см. раздел 8.4.1 «Изменение каталога: 


 и 


»

• Корневой каталог; см. раздел 8.6 «Изменение корневого каталога: 


».

• Текущее значение относительного приоритета.

• ID процесса и ID родительского процесса.

• ID группы процесса и контролирующий терминал; см. раздел 9.2.1 «Обзор управления работами».

• Маску сигналов процесса и любые ожидающие сигналы, а также любые не истекшие аварийные сигналы или таймеры (здесь не обсуждается; см. главу 10 «Сигналы»).

• Действительные ID пользователя и ID группы, а также дополнительный набор групп. Эффективные ID пользователя и группы (а следовательно, и сохраненные ID set-user и set-group) могут быть установлены с помощью битов setuid и setgid исполняемого файла. (Ничто из этого пока не обсуждалось; см. главу 11 «Права доступа и ID пользователя и группы».)

• Блокировки файлов сохраняются (также пока не обсуждалось; см. раздел 14.2 «Блокировка файлов»).

• Суммарное использованное время процессора для процесса и его потомков не меняется.

После 


 размещение сигналов изменяется; дополнительные сведения см. в разделе 10.9 «Сигналы для 


 и 


».

После 


 все открытые файлы и каталоги остаются открытыми и доступными для использования. Вот как программы наследуют стандартные ввод, вывод и ошибку: они на месте, когда программа запускается.

В большинстве случаев при исполнении 


 и 


 для отдельной программы не нужно ничего наследовать, кроме дескрипторов файлов 0, 1 и 2. В этом случае можно вручную закрыть все другие открытые файлы в порожденном процессе после выполнения 


 и до выполнения 


. В качестве альтернативы можно пометить дескриптор файла для автоматического закрытия системой при исполнении exec; эта последняя возможность обсуждается далее в главе (см раздел 9.4.3.1 «Флаг close-on-exec».)




9.1.5. Завершение процесса



Завершение процесса включает два шага: окончание процесса с передачей системе статуса завершения и восстановление информации родительским процессом.




9.1.5.1. Определение статуса завершения процесса


Статус завершения (exit status) (известный также под другими именами значения завершения (exit value), кода возврата (return code) и возвращаемого значения (return value)) представляет собой 8-битовое значение, которое родитель может использовать при завершении порожденного процесса (на языке Unix, «когда порожденный кончается (dies)»). По соглашению статус завершения 0 означает, что программа отработала без проблем. Любое ненулевое значение указывает на какую-нибудь разновидность ошибки; программа определяет используемые числа и их значения, если они есть. (Например, 


 использует 0 для указания, что образец был встречен по крайней мере один раз, 1 означает, что образец вообще не встретился, а 2 означает, что возникла ошибка.) Этот статус завершения доступен на уровне оболочки (для оболочек в стиле оболочки Борна) через специальную переменную 


.

Стандарт С определяет две константы, которые следует использовать для полной переносимости на не-POSIX системы:






Программа завершилась без проблем. Для обозначения успеха может также использоваться ноль.




_FAILURE

В программе была какая-нибудь проблема.

На практике использование лишь этих значений довольно ограничивает. Вместо этого следует выбрать небольшой набор кодов возврата, документировать их значения и использовать. (Например, 1 для ошибок опций командной строки и аргументов, 2 для ошибок ввода/вывода, 3 для ошибок данных и т.д.) Для удобочитаемости стоит использовать константы 


 или значения 


. Слишком большой список ошибок делает их использование обременительным; в большинстве случаев вызывающая программа (или пользователь) интересуется лишь нулевым или ненулевым значением.

Когда достаточно двоичного разделения успех/неудача, педантичный программист использует 


 и 


. Наш собственный стиль более естественный, используя с 


 и 


 явные константы 0 или 1. Это настолько обычно, что рано заучивается и быстро становится второй натурой. Однако для своих проектов вы сами должны принять решение.



ЗАМЕЧАНИЕ. Для родительского процесса доступны лишь восемь наименее значимых битов значения. Поэтому следует использовать значения в диапазоне 0–255. Как мы вскоре увидим, у чисел 126 и 127 есть традиционные значения (помимо простого «неуспешно»), которых ваши программы должны придерживаться.

Поскольку имеют значение лишь восемь наименее значимых битов, вы никогда не должны использовать отрицательные статусы завершения. Когда из небольших отрицательных чисел выделяются восемь последних битов, они превращаются в большие положительные значения! (Например. -1 становится 255, а -5 становится 251.) Мы видели книги по программированию на С, в которых это понималось неправильно — не дайте сбить себя с толку





9.1.5.2. Возвращение из 





Программа может естественно завершиться одним из двух способов: посредством использования одной из описанных далее функций или возвратившись из 


. (Третий, более радикальный способ описан далее в разделе 12.4 «Совершение самоубийства: 


».) В последнем случае следует использовать явное возвращаемое значение вместо выпадения в конце функции:































Стандарт С 1999 г. указывает, что при выпадении в конце, поведение функции 


 должно быть таким, как если бы она возвращала 0. (Это верно также для С++; однако, стандарт С 1989 г. намеренно оставляет этот случай неопределенным.) Во всех случаях плохо полагаться на это поведение; однажды вы можете программировать для системы со скудной поддержкой С времени исполнения, или для внедренной системы, или где-то еще, где это будет по-другому. (В общем, выпадение в конце любой функции, не являющейся 


 — плохая мысль, которая может вести лишь к ошибочному коду.)

Возвращенное из 


 значение автоматически передается обратно системе, от которой родительский процесс может его впоследствии получить. Мы опишем, как это делается, в разделе 9.1.6.1 «Использование функций POSIX: 


 и 


».



ЗАМЕЧАНИЕ. На системах GNU/Linux управляемая компилятором команда c99 запускает компилятор с соответствующими опциями, так что возвращаемое значение при выпадении из конца функции равно 0. Простой gcc этого не делает.





9.1.5.3. Функции завершения


Другим способом естественного завершения программы является вызов функций завершения. Стандарт С определяет следующие функции:























Эти функции работают следующим образом:






Эта функция завершает программу, 


 передается системе для использования родителем. Перед завершением программы 


 вызывает все функции, зарегистрированные с помощью 


, сбрасывает на диск и закрывает все открытые потоки <


* и удаляет все временные файлы, созданные 


 (см. раздел 12.3.2 «Создание и открытие временных файлов»). Когда процесс завершается, ядро закрывает любые оставшиеся открытыми файлы (которые были открыты посредством 


, 


 или через наследование дескрипторов), освобождает его адресное пространство и освобождает любые другие ресурсы, которые он мог использовать. 


 никогда не возвращается.






Эта функция в сущности идентична функции POSIX 


; мы на короткое время отложим ее обсуждение,









 является указателем на функцию обратного вызова, которая должна вызываться при завершении программы, 


 запускает функцию обратного вызова перед закрытием файлов и завершением. Идея в том, что приложение может предоставить одну или более функций очистки, которые должны быть запущены перед окончательным завершением работы. Предоставление функции называется ее регистрацией. (Функции обратного вызова для 


 обсуждались в разделе 8.4.3.2 «Функция обратного вызова 


»; здесь та же идея, хотя 


 вызывает каждую зарегистрированную функцию лишь однажды.)




 возвращает 0 при успехе или -1 при неудаче и соответствующим образом устанавливает 


.

Следующая программа не делает полезной работы, но демонстрирует, как работает 


:



















































































Вот что происходит при запуске:














































Как показывает пример, функции, зарегистрированные с помощью 


, запускаются в порядке, обратном порядку их регистрации: последние первыми. (Это обозначается также LIFO — last-in-first-out — вошедший последним выходит первым).

POSIX определяет функцию 


. В отличие от 


, которая вызывает функции обратного вызова и выполняет 


-очистку, 


 является «сразу заканчивающейся» функцией:













Системе передается 


, как и для 


, но процесс завершается немедленно. Ядро все еще делает обычную очистку: все открытые файлы закрываются, использованная адресным пространством память освобождается, любые другие ресурсы, использованные процессом, также освобождаются.

На практике функция 


 ISO С идентична 


. Стандарт С говорит, что от реализации функции зависит, вызывает ли 


 зарегистрированные 


 функции и закрывает ли открытые файлы. Для систем GLIBC это не так, и функция ведет себя подобно 


.

Время использовать 


 наступает, когда 


 в порожденном процессе завершается неудачей. В этом случае вам не нужно использовать обычный 


, поскольку это сбрасывает на диск данные буферов, хранящиеся в потоках 


. Когда позже родительский процесс сбрасывает на диск свои копии буферов, данные буфера оказываются записанными дважды; это очевидно нехорошо.

Например, предположим, что вы хотите запустить команду оболочки и хотите сами выполнить 


 и 


. Такой код выглядел бы следующим образом:




































Проверка значения 


 и завершающего значения следуют соглашениям, используемым оболочкой POSIX. Если запрошенная программа не существует (


 — нет для неё элемента в каталоге), завершающее значение равно 127. В противном случае, файл существует, но 


 не могла быть выполнена по какой-то другой причине, поэтому статус завершения равен 126. Хорошая мысль следовать этим соглашениям также и в ваших программах. Вкратце, чтобы хорошо использовать 


 и 


, следует делать следующее:

• Определить небольшой набор значений статуса завершения, которые ваша программа будет использовать для сообщения этой информации вызывающему. Используйте для них в своем коде константы 


 или 


.

• Решить, имеет ли смысл наличие функций обратного вызова для использования с 


. Если имеет, зарегистрировать их в 


 в соответствующий момент; например, после анализа опций и инициализации всех структур данных, которые функция обратного вызова должна очищать. Помните, что функции должны вызываться в порядке LIFO (последняя вызывается первой).

• Использовать 


 для выхода из программы во всех местах, когда что-то идет не так и когда выход является правильным действием. Используйте коды ошибок, которые определили.

• Исключением является 


, для которой можно использовать при желании 


. Наш собственный стиль заключается обычно в использовании 


 при наличии проблем и '


' в конце 


, если все прошло хорошо.

• Использовать 


 или 


 в порожденном процессе, если exec() завершается неудачей.




9.1.6. Использование статуса завершения порожденного процесса



Когда процесс заканчивается, нормальным ходом событий для ядра является освобождение всех его ресурсов. Ядро сохраняет статус завершения законченного процесса, также, как сведения о ресурсах, которые он использовал в своей работе, a PID продолжает считаться используемым. Такой завершившийся процесс называется зомби.

Родительский процесс, будь то первоначальный родитель или 


, может получить статус завершения порожденного процесса. Или, посредством использования функций BDS, которые не стандартизованы POSIX, можно получить статус завершения вместе со сведениями об использовании ресурсов. Использование статуса осуществляется ожиданием окончания процесса: это известно также как пожинание (reaping) процесса[91 - Мы это не придумываем. Терминология, конечно, не совсем правильна, но таким было чувство юмора разработчиков оригинальной Unix — Примеч. автора.].

Между механизмами, которые ожидают завершения потомков, и сигнальными механизмами, которые мы еще не обсуждали, есть значительное взаимодействие. Что из них описать вначале представляет собой нечто вроде проблемы курицы и яйца; мы решили сначала поговорить сначала о механизмах ожидания порожденного процесса, а глава 10 «Сигналы» дает полный рассказ о сигналах.

Пока достаточно понять, что сигнал является способом уведомления процесса о том, что произошло некоторое событие. Процессы могут генерировать сигналы, которые посылаются самим себе, или сигналы могут посылаться извне другими процессами или пользователем за терминалом. Например, CTRL-C посылает сигнал «прерывания», a CTRL-Z посылает сигнал управления работой «стоп».

По умолчанию, многие сигналы, такие, как сигнал прерывания, заставляют получающий процесс закончиться. Другие, такие, как сигналы управления работами, вызывают изменение его состояния. Механизмы ожидания порожденного процесса могут определить, претерпел ли процесс сигнал завершения, и если да, какой это был сигнал. То же верно и для остановки процесса и, на некоторых системах возобновления процесса.




9.1.6.1. Использование функций POSIX: 


 и 





Первоначальным системным вызовом V7 был 


. Более новым вызовом POSIX, основанным на возможностях BSD, является 


. Объявления функций следующие:


























 ждет завершения любого порожденного процесса; сведения о том, как он завершился, возвращаются в 


. (Вскоре мы обсудим, как интерпретировать 


.) Возвращаемое значение является PID завершившегося процесса или -1, если возникла ошибка.

Если порожденных процессов нет, 


 возвращает -1 с 


, установленным в 


 (отсутствует порожденный процесс). В противном случае, функция ждет завершения первого порожденного процесса или поступления сигнала.

Функция 


 дает возможность ждать завершения определенного порожденного процесса. Она предоставляет значительную гибкость и является предпочтительной для использования функцией. Она также возвращает PID закончившегося процесса или -1 при возникновении ошибки. Аргументы следующие:






Значение указывает, завершения какого порожденного процесса ждать как по-настоящему 


, так и по группе процесса. Смысл значения 


 следующий:




Ждать завершения любого порожденного процесса с ID группы процесса, равной абсолютному значению 


.




Ждать завершения любого порожденного процесса. Таким способом работает 


.




Ждать завершения любого порожденного процесса с ID группы процесса, равной ID группе родительского процесса.




Ждать завершения конкретного процесса с PID, равным 


.






То же, что и для 


. 


 определяет различные макросы, которые интерпретируют значение в 


, которые мы вскоре опишем






Этот параметр должен быть равен либо 0, либо побитовым ИЛИ одного или более из следующих флагов:






 Если ни один порожденный процесс не завершился, вернуться немедленно. Таким способом можно периодически проверять, не закончился ли какой- нибудь порожденный процесс. (Такая периодическая проверка известна как опрашивание события.)






 Вернуть сведения о порожденном процессе, который остановился, но еще не завершился. (Например, для управления работой.)






 (XSI.) Вернуть сведения о порожденном процессе, который продолжился, если его статус не сообщался с момента изменения. Это также для управления работой. Этот флаг является расширением XSI и не доступен под GNU/Linux.

С заполненным значением 


 работают несколько макросов, определяющие, что случилось. Они имеют тенденцию образовывать пары: один макрос для определения, что что-то случилось, и если этот макрос истинен, еще один макрос позволяет получить подробности. Макросы следующие:






Этот макрос не равен нулю (true), если процесс завершился (в противоположность изменению состояния).






Этот макрос дает статус завершения; он равен восьми наименее значимым битам значения, переданного 


 или возвращенного из 


. Этот макрос следует использовать лишь если 


 равен true.






Этот макрос не равен нулю, если процесс подвергся действию завершающего сигнала death-by-signal.






Этот макрос предоставляет номер сигнала, который завершил процесс. Этот макрос следует использовать, лишь когда 


 равен true.






Этот макрос не равен нулю, если процесс был остановлен.






Этот макрос предоставляет номер сигнала, который остановил процесс. (Процесс остановить могут несколько сигналов.) Этот макрос следует использовать лишь когда 


 равен true. Сигналы управления работами обсуждаются в разделе 10.8.2 «Сигналы управления работой».






(XSI.) Этот макрос не равен нулю, если процесс был продолжен. Соответствующего макроса 


 нет, поскольку лишь один сигнал может вызвать продолжение процесса.

Обратите внимание, что этот макрос является расширением XSI и в частности, он недоступен в GNU/Linux. Следовательно, если вы хотите его использовать, заключите код внутри '


'.






(Общий.) Этот макрос не равен нулю, если процесс создал снимок. Снимок процесса (core dump) является образом запущенного процесса в памяти, созданном при завершении процесса. Он предназначен для использования впоследствии при отладке. Системы Unix называют файл 


, тогда как системы GNU/Linux используют 


, где 


 является ID завершившегося процесса. Определенные сигналы завершают процесс и автоматически создают снимок процесса.

Обратите внимание, что этот макрос не стандартный. Системы GNU/Linux, Solaris и BSD его поддерживают, однако некоторые другие системы Unix нет. Поэтому и здесь, если нужно его использовать, заключите код внутрь '


'.

Большинство программ не интересуются, почему завершился порожденный процесс; им просто нужно, что он завершился, возможно, отметив, было завершение успешным или нет. Программа GNU Coreutils 


 демонстрирует такое простое использование 


, 


 и 


. Опция 


 заставляет 


 запустить для устанавливаемого двоичного исполняемого файла программу 


. 


 удаляет из исполняемого файла отладочную и прочую информацию. Это может сохранить значительное пространство. На современных системах с многогигабайтными жесткими дисками при установке редко бывает необходимо использовать 


 для исполняемых файлов.) Вот функция 


 из 


:























































































































































Строка 523 вызывает 


. Затем оператор 


 предпринимает нужное действие для возвращения ошибки (строки 527–529), порожденного процесса (строки 530–533) и родительского процесса (строки 534–539).

Стиль строк 536–537 типичен; они ожидают завершения нужного порожденного процесса. Возвращаемое значение wa


 является PID этого потомка. Оно сравнивается с PID порожденного процесса, 


 проверяется лишь на предмет равенства нулю (строка 538), в случае ненулевого результата потомок завершился неудачно. (Тест, хотя и правильный, грубый, но простой. Более правильным был бы тест наподобие '


'.)

Из описаний и кода, представленных до сих пор, может показаться, что родительские программы должны выбрать определенный момент, чтобы ожидать завершения любого порожденного процесса, возможно, с опросом в цикле (как делает 


), ожидая всех потомков. В разделе 10.8.3 «Родительский надзор: три различные стратегии» мы увидим, что это необязательно. Скорее, сигналы предоставляют ряд механизмов для использования уведомлениями родителей о завершении порожденных процессов.




9.1.6.2. Использование функций BSD: 


 и 





Системные вызовы BSD 


 и 


 полезны, если вы интересуетесь ресурсами, использованными порожденным процессом. Функции нестандартны (что означает, что они не являются частью POSIX), но широко доступны, в том числе на GNU/Linux. Объявления следующие:






































Переменная 


 та же, что и для 


 и 


. Все описанные ранее макросы (


 и т.д.) могут использоваться и с ними.

Значение 


 также то же самое, что и для 


: либо 0, либо побитовое ИЛИ с одним или обоими флагами 


 и 


.




 ведет себя подобно 


, получая сведения о первом доступном порожденном зомби, a 


 подобна 


, получая сведения об определенном процессе. Обе функции возвращают PID потомка, -1 при ошибке или 0, если нет доступных процессов и был использован флаг 


. Аргумент 


 может принимать те же значения, что и аргумент 


 для 


.

Ключевым отличием является указатель 


. Если он не равен 


, система заполняет ее сведениями о процессе. Эта структура описана в POSIX и в справочной странице getrusage(2):



























































































Чисто BSD системы (4.3 Reno и более поздние) поддерживают все поля. В табл. 9.2 описаны доступность различных полей 


 для POSIX и Linux.



Таблица 9.2. Доступность полей 







Стандартом определены лишь поля, помеченные «POSIX». Хотя Linux определяет полную структуру, ядро 2.4 поддерживает лишь поля времени пользователя и системного времени. Ядро 2.6 поддерживает также поля, связанные с переключением контекста.[92 - Дважды проверьте справочную страницу getrusage(2), если у вас более новое ядро, поскольку это поведение, возможно, изменилось — Примеч. автора.]

Наиболее интересными полями являются 


 и 


, использование времени процессора в режиме пользователя и ядра соответственно. (Время процессора в режиме пользователя является временем, потраченным на исполнение кода уровня пользователя. Время процессора в режиме ядра является временем, потраченным в ядре в пользу процесса.)

Эти два поля используют 


, которая содержит значения времени с точностью до микросекунд. Дополнительные сведения по этой структуре см. в разделе 14.3.1 «Время в микросекундах: 


».

В BSD 4.2 и 4.3 аргумент 


 функций 


 и 


 был 


. Он умещался в 


 и предоставлял доступ к тем же сведениям, которые выдают современные макросы 


 и др., но через членов объединения. Не все члены были действительными во всех случаях. Эти члены и их использование описаны в табл. 9.3.



Таблица 9.3. 


 4.2 и 4.3 BSD




POSIX не стандартизует 


, a BSD 4.4 не документирует его, используя вместо этого макросы POSIX. GLIBC делает несколько бросков, чтобы заставить использующий его старый код продолжать работать. Мы опишем его здесь главным образом для того, чтобы вы увидев его — узнали; новый код должен использовать макросы, описанные в разделе 9.1.6.1 «Использование функций POSIX: 


 и 


».




9.2. Группы процессов



Группа процесса является группой связанных процессов, которые в целях управления заданием (job) рассматриваются вместе. Процессы с одним и тем же ID группы процессов являются членами группы процессов, а процесс, PID которого равен ID группы процессов, является лидеров группы процессов. Новые процессы наследуют ID группы процессов своих родительских процессов.

Мы уже видели, что 


 позволяет вам ждать любой процесс в данной группе процессов. В разделе 10.6.7 «Отправка сигналов: 


 и 


» мы увидим также, что вы можете отправить сигнал всем процессам в определенной группе процессов. (Всегда применяется проверка прав доступа; вы не можете послать сигнал процессу, которым не владеете.)




9.2.1. Обзор управления заданиями


Управление заданиями является сложной темой, той, в которую мы решили не погружаться в данной книге. Однако, здесь приведен краткий концептуальной обзор.

Устройство терминала (физическое или другое) с работающим на нем пользователем называется управляющим терминалом.

Сеанс (session) является коллекцией групп процессов, связанных с управляющим терминалом. На одном терминале имеется лишь один сеанс, с несколькими группами процессов в сеансе. Один процесс назначен лидером сеанса; обычно это оболочка, такая, как Bash, 


, 


 или 


[93 - 


 и 


 также могут быть включены в эту категорию, но мы предпочитаем оболочки в стиле оболочки Борна — Примеч. автора.], которая может осуществлять управление заданиями. Мы называем такую оболочку оболочкой, управляющей заданиями.

Каждое задание, запущенное управляющей заданиями оболочкой, будь то простая программа или конвейер, получает отдельный идентификатор группы процессов. Таким способом оболочка может манипулировать заданием как отдельной сущностью, хотя в нем может быть несколько процессов.

Управляющий терминал также имеет связанный с ним идентификатор группы процессов. Когда пользователь набирает специальный символ, такой, как CTRL-C для «прерывания» или CTRL-Z для «остановки», ядро посылает данный сигнал процессам в группе процессов терминала.

Группе процессов, ID которой совпадает с ID управляющего терминала, разрешено записывать в терминал и читать с него. Эта группа называется приоритетной (foreground) группой процессов. (Она получает также генерируемые клавиатурой сигналы.) Любые другие группы процессов в сеансе являются фоновыми (background) группами процессов и не могут читать или записывать в терминал; они получают специальные сигналы, которые их останавливают, если они пытаются это делать.

Задания переходят из приоритетного режима в фоновый и обратно не путем изменения атрибута задания, но посредством изменения группы процессов управляющего терминала. Это изменение осуществляет именно контролирующая задания оболочка, и если новая группа процессов останавливается, оболочка вновь запускает ее, посылая сигнал «продолжить» всем членам группы процессов.

В былые времена пользователи часто использовали последовательные терминалы, соединенные с модемами, для подключения к централизованным Unix-системам на мини-компьютерах. Когда пользователь закрывал соединение (вешал трубку), линия последовательной передачи обнаруживала отсоединение, и ядро посылало сигнал «отсоединение» всем подключенным к терминалу процессам.

Эта концепция остается: если возникает отключение (оборудование последовательной связи все еще существует и все еще используется), ядро посылает сигнал отсоединения приоритетной группе процессов. Если существует лидер сеанса, происходит то же самое.

Висячая (orphaned) группа процессов — это такая группа, в которой для каждого процесса родительский процесс находится в той же группе или в другом сеансе. (Это может случиться, если управляющая заданиями оболочка завершается при все еще работающих фоновых заданиях.) Запущенным процессам в висячей группе процессов разрешается работать до завершения. Если в такой группе на момент, когда она становится висячей, уже имеются остановленные процессы, ядро посылает этим процессам сигнал отсоединения, а затем сигнал продолжения. Это заставляет их пробудиться, чтобы они могли завершиться, вместо того, чтобы остаться остановленными навечно.




9.2.2. Идентификация группы процессов: 


 и 





Для совместимости с более старыми системами POSIX предоставляет множество способов получения сведений о группе процессов:


















Функция 


 возвращает ID группы процессов текущего процесса. 


 является расширением XSI. Она возвращает ID группы процессов для данного 


 группы процессов. 


, равный 0, означает «группа процессов текущего процесса». Таким образом, '


' является тем же самым, что и '


'. При обычном программировании следует использовать 


.

В BSD 4.2 и 4.3 также есть функция 


, но она действует как функция POSIX 


, требуя аргумент 


. Поскольку современные системы поддерживают POSIX, в новом коде следует использовать версию POSIX. (Если вы думаете, что это сбивает с толку, вы правы. Несколько способов для получения одного и того же результата является обычным итогом проектирования комитетом, поскольку комитет считает, что он должен удовлетворить каждого.)




9.2.3. Установка группы процесса: 


 и 





Две функции устанавливают группу процесса:


















Функция 


 проста: она устанавливает ID группы процесса равной ID процесса. Это создает новую группу процессов в том же сеансе, а вызывающий функцию процесс становится лидером группы процессов.

Функция 


 предназначена для использования управления заданиями. Она позволяет одному процессу устанавливать группу процесса для другого. Процесс может изменить лишь свой собственный ID группы процессов или ID группы процессов порожденного процесса, лишь если этот порожденный процесс не выполнил еще 


. Управляющая заданиями оболочка делает этот вызов после 


как в родительском, так и в порожденном процессах. Для одного из них вызов завершается успехом, и ID группы процессов изменяется. (В противном случае нет способа гарантировать упорядочение, когда родитель может изменить ID группы процессов порожденного процесса до того, как последний выполнит 


. Если сначала успешно завершится вызов родителя, он может перейти на следующую задачу, такую, как обработка других заданий или управление терминалом.)

При использовании 


 должна быть группой существующего процесса, которая является частью текущего сеанса, фактически подключая 


 к этой группе процессов. В противном случае 


 должна равняться 


, создавая новую группу процессов.

Имеется несколько значений для особых случаев как для 


, так и для 


:




В данном случае 


 изменяет группу процессов вызывающего процесса на 


. Это эквивалентно '


'.




Это устанавливает ID группы процессов для данного процесса равным его PID. Таким образом, '


' является тем же самым, что и '


'. Это делает процесс с PID, равным 


, лидером группы процессов.

Во всех случаях лидеры сеанса являются особыми; их PID, ID группы процессов и ID сеанса идентичны, a ID группы процессов лидера не может быть изменена. (ID сеанса устанавливаются посредством 


, а получаются посредством 


. Это особые вызовы: см. справочные страницы setsid(2) и getsid(2)).




9.3. Базовое межпроцессное взаимодействие: каналы и очереди FIFO



Межпроцессное взаимодействие (Interprocess communication — IPC) соответствует своему названию: это способ взаимодействия для двух отдельных процессов. Самым старым способом IPC на системах Unix является канал (pipe): односторонняя линия связи. Данные, записанные в один конец канала, выходят из другого конца.




9.3.1. Каналы



Каналы проявляют себя как обычные дескрипторы файлов. Без особого разбирательства вы не можете сказать, представляет ли дескриптор файла сам файл или канал. Это особенность; программы, которые читают из стандартного ввода и записывают в стандартный вывод, не должны знать или заботиться о том, что они могут взаимодействовать с другим процессом. Если хотите знать, каноническим способом проверки этого является попытка выполнить с дескриптором '


'; этот вызов пытается отсчитать 0 байтов от текущего положения, т е. операция, которая ничего не делает[94 - Такая операция часто обозначается no-op — «no operation» (нет операции) — Примеч. автора.]. Эта операция завершается неудачей для каналов и не наносит никакого вреда другим файлам.




9.3.1.1. Создание каналов


Системный вызов 


 создает канал:













Значение аргумента является адресом массива из двух элементов целого типа, 


 возвращает 0 при успешном возвращении и -1, если была ошибка.

Если вызов был успешным, у процесса теперь есть два дополнительных открытых дескриптора файла. Значение 


 является читаемым концом канала, a 


 — записываемым концом. (Удобным мнемоническим способом запоминания является то, что читаемый конец использует индекс 0, аналогичный дескриптору стандартного ввода 0, а записываемый конец использует индекс 1, аналогичный дескриптору стандартного вывода 1.)

Как упоминалось, данные, записанные в записываемый конец, считываются из читаемого конца. После завершения работы с каналом оба конца закрываются с помощью вызова 


. Следующая простая программа, 


, демонстрирует каналы путем создания канала, записи в него данных, а затем чтения этих данных из него:







































































































































































































































Строки 11–15 объявляют локальные переменные; наибольший интерес представляет 


, который представляет текст, проходящий по каналу.

Строки 17–21 создают канал с проверкой ошибок; строки 23–24 выводят значения новых дескрипторов файлов (просто для подтверждения, что они не равны 0, 1 или 2)

В строке 26 получают длину сообщения для использования с 


. Строки 27–31 записывают сообщение в канал, снова с проверкой ошибок.

Строки 33–37 считывают содержимое канала, опять с проверкой ошибок. Строка 39 предоставляет завершающий нулевой байт, так что прочитанные данные могут использоваться в качестве обычной строки. Строка 41 выводит данные, а строки 42–43 закрывают оба конца канала. Вот что происходит при запуске программы:
















Эта программа не делает ничего полезного, но она демонстрирует основы. Обратите внимание, что нет вызовов 


 или 


 и что программа не использует три своих унаследованных дескриптора. Тем не менее, 


 и 


 завершаются успешно, показывая, что дескрипторы файлов действительны и что данные, поступающие в канал, действительно выходят из него.[95 - Мы уверены, что вы не волновались. В конце концов, вы, возможно, используете конвейеры из оболочки десятки раз в день — Примеч. автора.] Конечно, будь сообщение слишком большим, наша программа не работала бы. Это происходит из-за того, что размер (памяти) каналов ограничен, факт, который мы обсудим в следующем разделе.

Подобно другим дескрипторам файлов, дескрипторы для каналов наследуются порожденным процессом после 


, и если они не закрываются, все еще доступны после 


. Вскоре мы увидим, как использовать это обстоятельство и сделать с каналами что-то интересное.




9.3.1.2. Буферирование каналов


Каналы буферируют свои данные, что означает, что записанные в канал данные хранятся ядром до тех пор, пока не будут прочитаны. Однако, канал может содержать лишь такое-то количество записанных, но еще не прочитанных данных. Мы можем называть записывающий процесс производителем, а читающий процесс потребителем. Как система управляет полными и пустыми каналами?

Когда канал полон, система автоматически блокирует производителя в следующий раз, когда он пытается осуществить запись данных в канал с помощью 


. Когда канал освобождается, система копирует данные в канал, а затем позволяет системному вызову 


 вернуться к производителю.

Подобным же образом, если канал пустой, потребитель блокируется в 


 до тех пор, пока в канале не появятся данные для чтения. (Блокирующее поведение можно отключить; это обсуждается в разделе 9.4.3.4 «Неблокирующий ввод/вывод для каналов и очередей FIFO».)

Когда производитель вызывает на записывающем конце канала 


, потребитель может успешно прочесть любые данные, все еще находящиеся в канале. После этого дальнейшие вызовы 


 возвращают 0, указывая на конец файла.

Напротив, если потребитель закрывает читаемый конец, 


 на записываемом конце завершается неудачей. В частности, ядро посылает производителю сигнал «нарушенный канал», действием по умолчанию для которого является завершение процесса.

Нашей любимой аналогией для каналов является то, как муж и жена вместе моют и сушат тарелки. Один супруг моет тарелки, помещая чистые, но влажные тарелки в сушилку на раковине. Другой супруг вынимает тарелки из сушилки и вытирает их. Моющий тарелки является производителем, сушилка является каналом, а вытирающий является потребителем.[96 - Что они ели на обед, остается не указанным. — Примеч. автора.]

Если вытирающий супруг оказывается быстрее моющего, сушилка становится пустой, и вытирающему приходится ждать, пока не будут готовы новые тарелки. Напротив, если быстрее вытирающий супруг, сушилка наполняется, и моющему приходится ждать, пока она не опустеет, прежде чем помещать в нее тарелки. Это изображено на рис. 9.3.




Рис. 9.3. Синхронизация процессов канала




9.3.2. Очереди FIFO


Для традиционных каналов единственным способом для двух различных программ получить доступ к одному и тому же каналу является наследование дескрипторов файлов. Это означает, что процессы должны быть порожденными от общего родителя или один должен быть предком другого.

Это может быть серьезным ограничением. Многие системные службы запускаются как демоны, отсоединенные долгоживущие процессы. Должен быть способ отправки данных таким процессам (и, возможно, получения данных от них). Файлы для этого не подходят; синхронизация трудна или невозможна, а каналы для выполнения задания не могут быть созданы, поскольку нет общих предков.

Для решения этой проблемы System III предложила идею о FIFO. FIFO,[97 - FIFO означает «first in, first out» — «первым вошел, первым вышел». Так работают каналы. — Примеч. автора.] или именованный канал, является файлом в файловой системе, который действует подобно каналу. Другими словами, один процесс открывает FIFO для записи, тогда как другой открывает его для чтения. Затем данные, записанные; в FIFO, читаются читателем. Данные буферируются ядром, а не хранятся на диске.

Рассмотрите спулер печати. Демон спулера управляет физическими принтерами, создавая задания для печати и печатая по одному заданию за раз. Для добавления в очередь задания программное обеспечение принтера на уровне пользователя должно сообщаться с демоном спулера. Одним способом для осуществления этого является создание спулером FIFO с хорошо известным именем файла. Программа пользователя может затем открыть FIFO, записать в него запрос и снова закрыть. Спулер находится в цикле, читая запросы из FIFO и обрабатывая их.

Функция mkfifo() создает файлы FIFO:


















Аргумент 


 является именем создаваемого FIFO, a 


 является данными ему правами доступа, аналогичными второму аргументу функции 


 или третьему аргументу функции 


 (см. раздел 4.6 «Создание файлов»). Файлы FIFO удаляются, как любые другие, с помощью 


 или 


 (см. раздел 5.1.5.1 «Удаление открытых файлов»).

Справочная страница GNU/Linux mkfifo(3) указывает, что FIFO должен быть открыт как для чтения, так и для записи в одно и то же время, до того, как может быть осуществлен ввод/вывод: «Открытие FIFO для чтения обычно блокирует до тех пор, пока какой-нибудь другой процесс не откроет тот же FIFO для записи, и наоборот». После открытия файла FIFO он действует подобно обычному каналу; т.е. это просто еще один дескриптор файла.

Команда 


 доставляет этот системный вызов на командный уровень. Это упрощает показ файла FIFO в действии:






















































9.4. Управление дескрипторами файлов



На данный момент части загадки почти полностью составлены, 


 и 


 создают процессы и запускают в них программы, 


 создает канал, который может использоваться для IPC. Чего до сих пор не хватает, так это способа помещения дескрипторов канала на место стандартных ввода и вывода для производителя и потребителя канала.

Системные вызовы 


 и 


, совместно с 


 дают вам возможность поместить (скопировать) открытый дескриптор файла на другой номер. Системный вызов 


 дает вам возможность то же самое и управлять несколькими важными атрибутами открытых файлов.




9.4.1. Дублирование открытых файлов: 


 и 





Два системных вызова создают копию открытого дескриптора файла:


















Функции следующие:






Возвращает наименьшее значение неиспользуемого дескриптора файла; это копия 


. 


 возвращает неотрицательное целое в случае успеха и -1 при неудаче.






Делает 


 копией 


; если 


 открыт, он сначала закрывается, как при использовании 


. 


 возвращает новый дескриптор или -1, если была проблема. Помните рис. 9.1, в котором два процесса разделяли общие указатели на один и тот же элемент файла в таблице файлов ядра? 


 и 


 создают ту же ситуацию внутри одного процесса. См. рис. 9.4.




Рис. 9.4. Разделение дескриптора файла как результат '


'

На этом рисунке процесс выполнил '


', чтобы сделать дескриптор файла 3-й копией стандартного вывода, дескриптора файла 1. Точно как описано ранее, эти два дескриптора разделяют общее смещение открытого файла.

В разделе 4.4.2 «Открытие и закрытие файлов» мы упомянули, что 


 (и 


) всегда возвращают наименьшее целое значение неиспользуемого дескриптора для открываемого файла. Этому правилу следуют почти все системные вызовы, которые возвращают новые дескрипторы файлов, а не только 


 и 


. (


 является исключением, поскольку он предусматривает способ получения конкретного нового дескриптора файла, даже если он не является наименьшим неиспользуемым дескриптором.)

При наличии правила «возвращения наименьшего неиспользуемого номера» в сочетании с функцией 


 теперь легко поместить дескрипторы файла канала на место стандартного ввода и вывода. В предположении, что текущим процессом является оболочка и что ей необходимо создать два порожденных процесса для образования двухступенчатого канала, вот эти шаги:

1. Создать канал с помощью 


. Это должно быть сделано сначала, чтобы два порожденных процесса могли унаследовать дескрипторы открытых файлов.

2. Создать то, что мы называем «левым потомком». Это процесс, стандартный вывод которого идет в канал. В данном процессе сделать следующее:

 a. Использовать '


', поскольку читаемый конец канала в левом потомке не нужен.

 b. Использовать '


', чтобы закрыть первоначальный стандартный вывод.

 c. Использовать '


' для копирования записываемого конца канала в дескриптор файла 1.

 d. Использовать '


', поскольку нам не нужны две копии открытого дескриптора.

 e. Выполнить 


 для запускаемой программы.

3. Создать то, что мы называем «правым потомком». Это процесс, стандартный ввод которого поступает из канала. Шаги для этого потомка являются зеркальным отражением шагов для левого потомка:

 a. Использовать '


', поскольку записываемый конец канала в правом потомке не нужен.

 b. Использовать '


', чтобы закрыть первоначальный стандартный ввод.

 c. Использовать '


' для копирования читаемого конца канала в дескриптор файла 0.

 d. Использовать '


', поскольку нам не нужны две копии открытого дескриптора.

 e. Выполнить 


 для запускаемой программы.

4. В родителе закрыть оба конца канала — '


'.

5. Наконец, использовать в родителе 


 для ожидания завершения обоих порожденных процессов.

Обратите внимание, как важно закрыть неиспользуемые копии дескрипторов файлов каналов. Как мы отмечали ранее, файл не закрывается до тех пор, пока не будет закрыт последний открытый для него дескриптор. Это верно, даже если дескрипторы файлов разделяют несколько процессов. Закрытие не использующихся дескрипторов файлов имеет значение, поскольку процесс, читающий из канала, не получит указания конца файла, пока все копии записываемого конца не будут закрыты.

В нашем случае после порождения двух потомков имеются три процесса, у каждого из которых есть копии двух дескрипторов файлов каналов: родительский и два порожденных. Родительский процесс закрывает оба конца, поскольку ему не нужен канал. Левый потомок записывает в канал, поэтому ему нужно закрыть читаемый конец. Правый потомок читает из канала, поэтому ему нужно закрыть записываемый конец. Это оставляет открытым ровно по одной копии дескриптора файла.

Когда левый потомок завершает работу, он заканчивается. Система после этого закрывает все его дескрипторы файлов. Когда это случается, правый потомок получает в конечном счете уведомление конца файла и тоже может завершить работу и выйти.

Следующая программа, 


, создает эквивалент следующего конвейера оболочки:











Вот программа:










































































































































































































































































Строки 22–25 создают канал. Это должно быть сделано в самом начале.

Строки 27–31 создают левого потомка, а строки 33–37 создают правого потомка. В обоих случаях родитель продолжает линейное исполнение ветви 


 до тех пор, пока порожденный процесс не вызовет соответствующую функцию для манипулирования дескрипторами файла и осуществления 


.

Строки 39–40 закрывают родительскую копию канала.

Строки 42–50 в цикле ожидают потомков, пока 


 не вернет ошибку.


















































































































































Строки 57–68 являются кодом для левого потомка. Процедура следует приведенным выше шагам, закрывая ненужный конец канала, закрывая первоначальный стандартный вывод, помещая с помощью 


 записываемый конец канала на номер 1 и закрывая затем первоначальный записываемый конец. В этот момент строка 66 вызывает 


, и если она завершается неудачей, строка 67 вызывает 


. (Помните, что строка 67 никогда не выполняется, если 


 завершается удачно.)

Строки 72–83 делают подобные же шаги для правого потомка. Вот что происходит при запуске:









































Обратите внимание, что порядок, в котором завершаются потомки, не является детерминированным. Он зависит от загрузки системы и многих других факторов, которые могут повлиять на планирование процессов. Вам следует проявить осторожность, чтобы избежать предположений о порядке действий при написании кода, создающего несколько процессов, в особенности для кода, который вызывает семейство функций 


.

Весь процесс показан на рис. 9.5.














Рис. 9.5. Создание конвейера родителем

На рис. 9.5 (а) изображена ситуация после создания родителем канала (строки 22–25) и двух порожденных процессов (строки 27–37).

На рис. 9.5 (b) показана ситуация после закрытия родителем канала (строки 39–40) и начала ожидания порожденных процессов (строки 42–50). Каждый порожденный процесс поместил канал на место стандартного вывода (левый потомок, строки 61–63) и стандартного ввода (строки 76–78).

Наконец, рис. 9.5 (с) изображает ситуацию после закрытия потомками первоначального канала (строки 64 и 79) и вызова 


 (строки 66 и 81).




9.4.2. Создание нелинейных конвейеров: 





Многие современные системы Unix, включая GNU/Linux, поддерживают в каталоге 


[98 - На системах GNU/Linux 


 является символической ссылкой на 


, но поскольку 


 является общеизвестным, в своем коде следует использовать именно его — Примеч. автора.] специальные файлы. Эти файлы представляют дескрипторы открытых файлов с именами 


, 


 и т.д. Передача такого имени функции 


 возвращает новый дескриптор файла, что в сущности является тем же самым, что и вызов 


 для данного номера дескриптора.

Эти специальные файлы находят свое применение на уровне оболочки: Bash, 


 (некоторые версии) и 


 предоставляют возможность замещения процесса (process substitution), что позволяет создавать нелинейные конвейеры. На уровне оболочки для входного конвейера используется запись '


', а для выходного конвейера запись '


'. Например, предположим, вам нужно применить команду 


 к выводу двух команд. Обычно вам пришлось бы использовать временные файлы:





















С замещением процессов это выглядит следующим образом:






Не надо никаких беспорядочных файлов для временного запоминания и удаления. Например, следующая команда показывает, что наш домашний каталог является ссылкой на другой каталог:


























Незамысловатая команда 


 является встроенной в оболочку: она выводит текущий логический путь, который управляется оболочкой с помощью команды 


. Программа 


 осуществляет обход физической файловой системы для вывода имени пути.

Как выглядит замещение процессов? Оболочка создает вспомогательные команды[99 - Хотя мы показали простые команды, допустимы произвольные конвейеры — Примеч. автора.] ('


' и '


'). Выход каждой из них подсоединяется к каналу, причем читаемый конец открыт в дескрипторе нового файла для главного процесса ('


'). Затем оболочка передает главному процессу имена файлов в


 в качестве аргументов командной строки. Мы можем увидеть это, включив в оболочке трассировку исполнения.



















































Это показано на рис. 9.6.




Рис. 9.6. Замещение процесса

Если на вашей системе есть 


, вы также можете использовать преимущества этой возможности. Однако, будьте осторожны и задокументируйте то, что вы делаете. Манипуляции с дескриптором файла на уровне С значительно менее прозрачны, чем соответствующие записи оболочки!




9.4.3. Управление атрибутами файла: 






Системный вызов 


 («управление файлом») предоставляет контроль над различными атрибутами либо самого дескриптора файла, либо лежащего в его основе открытого файла. Справочная страница GNU/Linux fcntl(2) описывает это таким способом:




























Другими словами, функция принимает по крайней мере два аргумента; в зависимости от второго аргумента, она может принимать и третий аргумент.

Последняя форма, в которой третий аргумент является указателем на 


, предназначена для блокировки файла. Блокировка файлов сама по себе представляет большую тему; мы отложим обсуждение до раздела 14.2 «Блокировка файлов».




9.4.3.1. Флаг close-on-exec


После вызова 


 и перед вызовом 


 следует убедиться, что новая программа наследует лишь те открытые файлы, которые ей нужны. Вы не захотите, чтобы порожденный процесс мешался в открытых файлах родителя, если только это так не задумано. С другой стороны, если у родителя множество открытых файлов, это будет искусственно ограничивать число новых файлов, которые может открыть порожденный процесс. (См. сопроводительную врезку.)

Организационно такое поведение может представлять проблему. Часть вашей программы, порождающая новый процесс, не должна особенно нуждаться в других частях программы, манипулирующей открытыми файлами. И цикл наподобие следующего неприятный, поскольку может не быть открытых файлов:
















Решением является флаг close-on-exec (закрытие при исполнении exec). Он является атрибутом самого дескриптора файла, а не лежащего в его основе открытого файла. Когда этот флаг установлен, система автоматически закрывает файл, когда процесс осуществляет 


. Установив этот флаг сразу после открытия файла, вам не нужно беспокоиться о том, что какой-нибудь порожденный процесс случайно его унаследует. (Оболочка автоматически устанавливает этот флаг для всех дескрипторов файлов, которые она открывает, начиная с номера 3 и выше.)

Аргумент 


 имеет два значения, относящиеся к флагу close-on-exec:






Получает флаги дескриптора файла. Возвращаемое значение является значением всех установленных флагов дескриптора или -1 при ошибке.






Устанавливает флаги дескриптора файла в содержащееся в 


 (третий аргумент) значение. Возвращаемое значение равно 0 при успехе или -1 при ошибке.

В настоящий момент определен лишь один «флаг дескриптора файла»: 


. Эта именованная константа является нововведением POSIX[100 - Стандарт POSIX умышленно не приписывает ей значение. Однако, чтобы старый код продолжал работать, единственным значением, которое могла бы разумно использовать любая реализация, является 1 — Примеч. автора.], а большая часть кода использует просто 1 или 0:





















Однако, определение POSIX допускает дальнейшее расширение, поэтому правильный способ написания такого кода больше соответствует этим строкам:






































ЗАМЕЧАНИЕ. Флаг close-on-exec является собственностью дескриптора, а не лежащего в его основе файла. Поэтому новый дескриптор, возвращенный функциями 


 или 


 (или 


 с 


, которую мы намереваемся посмотреть), не наследует установки флага close-on-exec первоначального дескриптора. Если вам нужно установить его также и для нового дескриптора файла, вы должны не забыть сделать это сами. Такое поведение имеет смысл: если вы просто вызвали 


, копируя один конец канала в 0 или 1, вы не захотите, чтобы система закрыла его вместо вас, как только процесс осуществит exec!





История борьбы close-on-exec от 




В языке awk операторы ввода/вывода используют обозначение перенаправления, сходное с обозначением для оболочки. Это включает односторонние каналы к и от подпроцесса:





















У интерпретатора 


 есть дескрипторы открытых файлов для всех перенаправлений файлов, а для обозначений каналов, создающих подпроцессы, интерпретатор 


 создает канал, а затем осуществляет 


 и 


 оболочки для запуска команды, приведенной в строке.

Теперь на современных системах часть стартового кода библиотеки С времени исполнения (который запускается до вызова 


) нуждается для управления использованием разделяемых библиотек во временно открытых файлах. Это означает, что для новой программы после исполнения 


 должны быть по крайней мере один или два неиспользуемых дескриптора файла, иначе программа просто не будет работать

Однажды один пользователь сообщил, что когда в программе было максимальное количество открытых файлов, ни один процесс, для которого она пыталась использовать для конвейера 


 и 


, не мог успешно начаться!

Вы, возможно, можете догадаться, что произошло. Порожденная оболочка унаследовала дескрипторы открытых файлов, которые 


 сама использовала для своих перенаправлений. Мы модифицировали 


 так, чтобы установить флаг close-on-exec для всех перенаправлений файлов и каналов, что и решило проблему.





9.4.3.2. Дублирование дескриптора файла


Когда аргумент 


 функции 


 равен 


, ее поведение похоже, но не идентично поведению 


. В этом случае 


 является дескриптором файла, представляющим наименьшее приемлемое значение для нового дескриптора файла:





















Вы можете имитировать поведение 


, которая возвращает наименьший свободный дескриптор файла, использовав '


'.

Если вы помните, что дескрипторы файлов являются просто индексами внутренней таблицы, работа этой функции должна быть ясна. Третий аргумент просто предоставляет индекс, с которого ядро должно начать поиск неиспользуемого дескриптора файла.

Использовать ли в собственном коде 


 с 


 или 


 или 


, в значительной степени является делом вкуса. Все три функции API являются частью POSIX и широко поддерживаются. У нас легкое пристрастие к 


 и 


, поскольку они более специфичны в своих действиях, поэтому являются самодокументирующимися. Но поскольку все они довольно просты, эта аргументация может вас не убедить.




9.4.3.3. Работа с флагами статуса файла и режимами доступа


В разделе 4.6.3 «Возвращаясь к 


» мы предоставили полный список флагов O_xx, которые принимает 


. POSIX разбивает их по функциям, классифицируя в соответствии с табл. 9.4.



Таблица 9.4. Флаги O_xx для 


, 


 и 







Помимо первоначальной установки различных флагов с помощью 


, вы можете использовать 


 для получения текущих установок, а также их изменения. Это осуществляется с помощью значений 





 и 


 соответственно. Например, вы можете использовать эти команды для изменения установки неблокирующего флага, 


, подобным образом:









































Помимо самих режимов именованная константа 


 является маской, которую вы можете использовать для выделения из возвращаемого значения режимов прав доступа.





























































POSIX требует, чтобы 


, 


 и 


 были побитово различными, таким образом, гарантируется, что код, подобный только что показанному, будет работать и является простым способом определения того, как был открыт произвольный дескриптор файла.

Используя 


 вы можете также изменить эти режимы, хотя по-прежнему применяется проверка прав доступа. Согласно справочной странице GNU/Linux fcnlt(2) флаг 


 не может быть сброшен, если он использовался при открытии файла.




9.4.3.4. Неблокирующий ввод/вывод для каналов и FIFO


Ранее для описания способа работы каналов мы использовали сравнение с двумя людьми, моющими и вытирающими тарелки с использованием сушилки; когда сушилка заполняется, останавливается моющий, а когда она пустеет, останавливается вытирающий. Это блокирующее поведение: производитель или потребитель блокируются в вызове 


 или 


, ожидая либо освобождения канала, либо появления в нем данных.

В действительности человек, ожидающий опустения или заполнения сушилки, не должен просто неподвижно стоять.[101 - Ну, мы игнорируем мысль, что два супруга могли бы хотеть поговорить друг с другом и насладиться компанией — Примеч. автора.] Вместо этого незанятый супруг мог бы пойти и найти другую работу по кухне (такую, как подметание всех крошек за детьми на полу), пока сушилка снова не будет готова.

На языке Unix/POSIX эта концепция обозначается термином неблокирующий ввод/вывод, т.е. запрошенный ввод/вывод либо завершается, либо возвращает значение ошибки, указывающее на отсутствие данных (для читающего) или отсутствие места (для записывающего). Неблокирующий ввод/вывод применяется к каналам и FIFO, а не к обычным файлам на диске. Он может применяться также и к определенным устройствам, таким как терминалы, и к сетевым соединениям, обе эти темы выходят за рамки данной книги.

С функцией 


 может использоваться флаг 


 для указания неблокирующего ввода/вывода, он может быть установлен и сброшен с помощью 


. Для 


 и 


 неблокирующий ввод/вывод прост.

Открытие FIFO с установленным или сброшенным 


 демонстрирует следующее поведение:






Блокируется до открытия FIFO для записи.






Открывает файл, возвращаясь немедленно.






Блокирует до открытия FIFO для чтения.






Если FIFO был открыт для чтения, открывает FIFO и немедленно возвращается. В противном случае возвращает ошибку (возвращаемое значение -1 и 


 установлен в 


).

Как описано для обычных каналов, вызов 


 для FIFO, который больше не открыт для чтения, возвращает конец файла (возвращаемое значение 0). Флаг 


 в данном случае неуместен. Для пустого канала или FIFO (все еще открытых для записи, но не содержащих данных) все становится интереснее:






Функция 


 блокируется до тех пор, пока в канал или FIFO не поступят данные.






Функция 


 немедленно возвращает -1 с установленным в 


.

В заключение, поведение 


 более сложно. Для обсуждения этого нам нужно сначала представить концепцию атомарной записи. Атомарная запись — это такая запись, при которой все данные записываются целиком, не чередуясь с данными от других записей. POSIX определяет в 


 константу 


. Запись в канал или FIFO данных размером менее или равным 


 байтов либо успешно завершается, либо блокируется в соответствии с подробностями, которые мы скоро приведем. Минимальным значением для 


 является 


, что равняется 512. Само значение 


 может быть больше; современные системы GLIBC определяют ее размер в 4096, но в любом случае следует использовать эту именованную константу и не ожидать, что 


 будет иметь то же значение на разных системах.

Во всех случаях для каналов и FIFO 


 добавляет данные в конец канала. Это происходит от того факта, что у каналов нет файловых смещений: в них нельзя осуществлять поиск.

Также во всех случаях, как упоминалось, записи размером вплоть до 


 являются атомарными: данные не перемежаются с данными от других записей. Данные записи размером более 


 байтов могут перемежаться с данными других записей в произвольных границах. Это последнее означает, что вы не можете ожидать, что каждая порция размером 


 большого набора данных будет записана атомарно. Установка 


 не влияет на это правило.

Как и в случае с 


, когда 


 не установлен, 


 блокируется до тех пор, пока все данные не будут записаны.

Наиболее все усложняется, когда установлен 


. Канал или FIFO ведут себя следующим образом:




Для файлов, не являющихся каналами и FIFO и к которым может быть применен 


, поведение следующее:

размер > 0 


 записывает, что может

размер = 0 


 возвращает 




Хотя есть ряд сбивающих с толку изменений поведения в зависимости от того, канал это или не канал, установлен 


 или сброшен, есть в канале место для записи или нет, а также в зависимости от размера предполагаемой записи, эти правила предназначены для упрощения программирования:

• Всегда можно отличить конец файла: 


 возвращает 0 байтов.

• Если нет доступных для чтения данных, 


 либо завершается успешно, либо возвращает указание «нет данных для чтения»: 


, что означает «попытайтесь снова позже».

• Если для записи нет места, 


 либо блокируется до успешного завершения (


 сброшен), либо завершается неудачей с ошибкой «в данный момент нет места для записи»: 


.

• Когда место есть, будет записано столько данных, сколько возможно, так что в конечном счете все данные будут переписаны.

Подводя итог, если вы собираетесь использовать неблокирующий ввод/вывод, любой код, который использует 


, должен быть способен обработать укороченную запись, когда успешно записан меньший объем данных, чем было затребовано. Устойчивый код в любом случае должен быть написан таким способом: даже в случае обычного файла диск может оказаться заполненным и 


 сможет записать лишь часть данных.

Более того, вы должны быть готовы обработать 


, понимая, что в этом случае неудача 


 не обязательно означает фатальную ошибку. То же верно для кода, использующего для чтения неблокирующий ввод/вывод: признайте, что и здесь 


 не является фатальным. (Однако, может стоит подсчитывать число таких отказов, оставив попытки, когда их слишком много.)

Неблокирующий ввод/вывод действительно усложняет вашу жизнь, в этом нет никакого сомнения. Но для многих приложений он является необходимостью, позволяющей выполнить задание. Снова рассмотрите спулер печати. Демон спулера не может позволить себе находиться в блокирующем 


 для файла FIFO, которому представлены входящие задания. Он должен иметь также возможность отслеживать запущенные задания и, возможно, периодически проверять состояние печатающих устройств (например, убедиться, что не заело бумагу).




9.4.3.5. Сводка fcntl()


Сводка для системного вызова 


 приведена в табл. 9.5.



Таблица 9.5. Сводка 







Флаги создания, статуса и прав доступа файла копируются, когда дескриптор файла дублируется. Флаг close-on-exec не копируется.




9.5. Пример: двусторонние каналы в 





Двусторонний канал соединяет два процесса двунаправленным образом. Обычно, по крайней мере для одного из процессов, на канал с другим процессом настраиваются как стандартный ввод, так и стандартный вывод. Оболочка Корна (


) ввела двусторонние каналы на уровне языка, обозначив термином сопроцесса (coprocess):
















Здесь движок базы данных представляет любую серверную программу, которая может управляться интерфейсной частью, в данном случае, сценарием 


. У движка базы данных стандартный ввод и стандартный вывод подсоединены к оболочке посредством двух отдельных односторонних каналов.[102 - В одно и то же время есть только один сопроцесс по умолчанию (доступный посредством '


' и '


'). Сценарии оболочки могут использовать команду 


 со специальной записью перенаправления для назначения дескрипторов файла сопроцесса определенным номерам. После этого можно запустить другой сопроцесс — Примеч. автора.] Это показано на рис. 9.7.




Рис. 9.7. Сопроцессы оболочки Корна

В обычном 


 каналы к или от подпроцесса являются односторонними: нет способа послать данные в программу и прочесть посланные от нее в ответ данные — нужно использовать временный файл. GNU 


 (


) заимствует обозначение '


' от 


 для расширения языка 


:














 использует запись '


' также для сокетов TCP/IP и порталов BSD, которые не рассматриваются в данной книге. Следующий код из 


 в дистрибутиве 


 3.1.3 является частью функции 


, которая устанавливает простой сопроцесс: она создает два канала, порождает новый процесс и осуществляет все манипуляции с дескриптором файла. Мы опустили ряд не относящихся к делу частей кода (эта функция занимает больше места, чем следовало бы):







































































































Первым шагом является создание двух каналов, 


 является каналом «от родителя к потомку», а 


 — «от потомка к родителю». Во время чтения держите в уме, что индекс 0 является читаемым концом, а 1 — записываемым.

Строки 1836–1837 создают первый канал, 


. Строки 1839–1845 создают второй канал, закрывая при неудачном создании и первый. Это важно. Небрежность в закрытии открытых, но не используемых каналов ведет к утечкам дескрипторов файлов. Как и память, дескрипторы файлов являются конечным ресурсом, и когда они иссякают, то теряются.[103 - Очевидно, вы можете их закрыть. Но если вы не знаете, что они открыты, они теряются с таким же успехом, как и память через утечку памяти — Примеч. автора.] То же верно и для открытых файлов: убедитесь, что ваш обрабатывающий ошибки код всегда закрывает все открытые файлы и каналы, которые не нужны, когда происходит ошибка.




 сохраняет значения 


, установленные 


, на тот редкий случай, когда 


 может завершиться неудачей (строка 1840). Затем 


 восстанавливается в строке 1843.




































Строки 1906–1912 порождают процесс, на этот раз закрывая оба канала, если 


 потерпит неудачу. Здесь также первоначальное значение 


 сохраняется и восстанавливается для последующего использования при диагностике.



























































































Строки 1914–1931 обрабатывают код потомка, с соответствующей проверкой ошибок и сообщениями на каждом шагу. Строка 1915 закрывает стандартный вывод. Строка 1918 копирует записываемый конец канала от потомка к родителю на 1. Строка 1920 закрывает стандартный ввод, а строка 1923 копирует читаемый конец канала от родителя к потомку на 0. Если это все работает, стандартные ввод и вывод теперь на месте и подключены к родителю.

Строки 1925–1926 закрывают все четыре первоначальные дескрипторы файлов каналов, поскольку они больше не нужны. Строка 1928 напоминает нам, что стандартная ошибка остается на месте. Это лучшее решение, поскольку пользователь увидит ошибки от сопроцесса. Программа 


, которая должна перехватить стандартную ошибку, может использовать в команде обозначение '


' для перенаправления стандартной ошибки сопроцесса или записи в отдельный файл.

Наконец, строки 1929–1930 пытаются запустить для оболочки 


 и соответственно выходят, если это не удается.





























































Первым шагом родителя является настройка входного конца от сопроцесса. Указатель 


 указывает на 


, которая содержит поле для сохранения PID порожденного процесса, 


 для вывода и указатель 


 с именем 


. 


 является внутренней структурой данных 


 для осуществления ввода. Она, в свою очередь, хранит копию нижележащего дескриптора файла.

Строка 1935 сохраняет значение ID процесса. Строка 1936 выделяет память для новой 


 для данных дескриптора файла и командной строки. Третий аргумент здесь равен 


: он позволяет при необходимости использовать предварительно выделенный 


.

Если выделение памяти потерпело неудачу, строки 1937–1942 производят очистку, закрывая каналы и посылая сигнал «kill» порожденным процессам, чтобы заставить их завершить работу. (Функция 


 описана в разделе 10.6.7 «Отправка сигналов 


 и 


».)












































[104 - Игра слов kill-overkill (избыточно — overkill) — Примеч. перев.]



















Строки 1946–1957 аналогичны. Они устанавливают вывод родителя на потомка, сохраняя дескриптор файла для записывающего конца канала от родителя к потомку в 


, используя функцию 


. Если это завершается неудачей, строки 1947–1957 предпринимают те же действия, что и ранее: закрывают все дескрипторы каналов и посылают сигнал порожденным процессам.

С этого момента записываемый конец канала от родителя к потомку и читаемый конец канала от потомка к родителю хранятся в более крупных структурах: 


 и 


 соответственно. Они автоматически закрываются обычными процедурами, которые закрывают эти структуры. Однако, остаются две задачи:



















































Строки 1960–1961 устанавливают флаг close-on-exec для двух дескрипторов, которые остались открытыми. 


 является простой функцией-оболочкой, которая выполняет эту работу на Unix- и POSIX-совместимых системах, но ничего не делает на системах, в которых нет флага close-on-exec. Это скрывает проблему переносимости в одном месте и позволяет избежать в коде множества запутывающих 


 здесь и в других местах 


.

Наконец, строки 1963–1964 закрывают концы каналов, которые не нужны родителю, а строка 1967 возвращает TRUE для обозначения успеха.




9.6. Рекомендуемая литература


Управление заданиями сложно, включает группы процессов, сеансы, механизмы ожидания, сигналы и манипулирование группой процессов терминала. По существу, мы решили не вдаваться в детали. Однако, вы можете захотеть взглянуть на следующие книги:

1. Advanced Programming in the UNIX Environment, 2nd edition, by W. Richard Stevens and Stephen Rago. Addison-Wesley, Reading Massachusetts, USA, 2004. ISBN: 0-201-43307-9.

Эта книга и полна, и основательна, охватывая элементарное и продвинутое программирование под Unix. Она превосходно освещает группы процессов, сеансы, управление заданиями и сигналы

2. The Design and Implementation of the 4.4 BSD Operating System, by Marshall Kirk McKusick, Keith Bostic, Michael J. Karels, and John S. Quarterman. Addison-Wesley, Reading, Massachusetts, USA, 1996. ISBN: 0-201-54979-4.

Эта книга дает хороший обзор того же материала, включая обсуждение структур данных ядра, которое можно найти в разделе 4.8 этой книги.




9.7. Резюме


• Новые процессы создаются с помощью 


. После этого оба процесса исполняют один и тот же код, причем единственным различием является возвращаемое значение: 0 в порожденном процессе и положительный номер PID в родительском. Порожденный процесс наследует копии почти всех атрибутов родителя, наиболее важными из которых являются, пожалуй, открытые файлы.

• Унаследованные разделяемые дескрипторы файлов делают возможным многое из высокоуровневой семантики Unix и элегантные управляющие структуры оболочки. Это одна из наиболее фундаментальных частей оригинального дизайна Unix. Из-за разделения дескрипторов файл на самом деле не закрывается до тех пор, пока не будет закрыт последний открытый дескриптор файла. Это в особенности касается каналов, но затрагивает также освобождение дисковых блоков для удаленных, но все еще открытых файлов.

• Вызовы 


 и 


 возвращают ID текущего и родительского процессов соответственно. Родителем процесса, первоначальный родитель которого завершается, становится специальный процесс 


 с PID 1. Таким образом, PPID может меняться, и приложения должны быть готовы к этому.

• Системный вызов 


 дает возможность настраивать приоритет вашего процесса. Чем приятнее вы по отношению к другим процессам, тем меньше ваш относительный приоритет, и наоборот. Лишь суперпользователь может иметь больший приоритет по сравнению с другими процессами. На современных системах, особенно однопользовательских, нет действительных причин для изменения знамения относительного приоритета.

• Системный вызов 


 начинает исполнение новой программы в существующем процессе. Шесть различных версий вызова предоставляют гибкость в установке списков аргументов и окружения ценой первоначальной путаницы по поводу того, какую из них лучше всего использовать. Два варианта имитируют механизм поиска оболочки и отступают к использованию оболочки для интерпретации файла в случае, если он не является двоичным исполняемым файлом; эти варианты должны использоваться с предусмотрительностью.

• Значение 


 для новой программы обычно происходит от имени исполняемого файла, но это лишь соглашение. Как и в случае с 


, значительный, но не идентичный набор атрибутов наследуется через 


. Другие атрибуты сбрасываются для использования подходящих значений по умолчанию.

• Функция 


 регистрирует функции обратного вызова для вызова в порядке LIFO при завершении программы. Функции 


, 


 и 


 все завершают программу, передавая статус завершения обратно родителю, 


 очищает открытые потоки 


 и запускает функции, зарегистрированные с помощью 


. Две другие функции завершаются немедленно и должны использоваться, лишь когда 


 в порожденном процессе завершилась неудачей. Возвращение из 


 подобно вызову 


 с данным возвращаемым значением. В C99 и C++ выпадение из 


 в конце функции дает тот же результат, что и '


', но является плохой практикой.

• 


 и 


 являются функциями POSIX для получения статуса завершения порожденного процесса. Различные макросы позволяют определить, завершился ли порожденный процесс нормально, и в таком случае определить статус его завершения, или же порожденный процесс претерпел сигнал завершения, и в этом случае определить совершивший этот проступок сигнал. Со специальными опциями 


 предоставляет также сведения о потомках, которые не завершились, но изменили состояние.

• Системы GNU/Linux и большинство Unix-систем поддерживают также функции BSD 


 и 


. GNU/Linux поддерживает также выходящий из употребления 


. Функции BSD предоставляют 


, давая доступ к сведениям об использовании времени процессора, что может быть удобным. Хотя если 


 будет достаточной, то это наиболее переносимый способ выполнения.

• Группы процессов являются частью более крупного механизма управления заданиями, который включает сигналы, сеансы и манипулирование состоянием терминала, 


 возвращает ID группы процессов текущего процесса, a 


 возвращает PGID определенного процесса. Сходным образом, 


 устанавливает PGID текущего процесса равным его PID, делая его лидером группы процессов; 


 дает возможность родительскому процессу установить PGID порожденного, который еще не выполнил 


.

• Каналы и FIFO предоставляют односторонний коммуникационный канал между двумя процессами. Каналы должны быть установлены общим предком, тогда как FIFO могут использоваться любыми двумя процессами. Каналы создаются с помощью 


, а файлы FIFO создаются с помощью 


. Каналы и FIFO буферируют свои данные, останавливая производителя или потребителя, когда канал заполняется или пустеет.

• 


 и 


 создают копии дескрипторов открытых файлов. В сочетании с 


 они дают возможность поместить дескрипторы файлов на место стандартного ввода и вывода для каналов. Чтобы каналы работали правильно, все копии неиспользуемых концов каналов до исполнения программой назначения exec должны быть закрыты. Для создания нелинейных каналов может быть использован 


, что демонстрируется возможностью замещения процессов оболочками Bash и Korn.

• 


 является функцией для выполнения различных работ. Она управляет атрибутами как самого дескриптора файла, так и лежащего в его основе файла. В данной главе мы видели, что 


 используется для следующего:

 • Дублирования дескриптора файла, имитирования 


 и почти имитирования 


.

 • Получения и установки флага close-on-exec. Флаг close-on-exec является в настоящее время единственным атрибутом дескриптора файла, но он важен. Он не копируется в результате действия 


, но должен явным образом устанавливаться для дескрипторов файлов, которые не должны оставаться открытыми после выполнения exec. На практике, это должно быть сделано для большинства дескрипторов файла.

 • Получение и установка флагов, управляющих нижележащим файлом. Из них 


 является, пожалуй, наиболее полезным, по крайней мере, для FIFO и каналов. Это определенно самый сложный флаг.




Упражнения


1. Напишите программу, которая выводит как можно больше сведений о текущем процессе: PID, PPID, открытые файлы, текущий каталог, значение относительного приоритета и т.д. Как вы можете сказать, какие файлы открыты? Если несколько дескрипторов файлов ссылаются на один и тот же файл, укажите это. (Опять-таки, как вы можете это узнать?)

2. Как вы думаете, 


 хранит указатели на функции обратного вызова? Реализуйте 


, держа в уме принцип GNU «никаких произвольных ограничений». Набросайте схему (псевдокод) для 


. Каких сведений (внутренностей библиотеки 


) вам не хватает, чтобы написать 


?

3. Программа 


 предназначена для многократных запусков команды и аргументов, когда аргументов слишком много для непосредственного набора в командной строке. Программа работает, считывая строки из стандартного ввода, рассматривая каждую строку в качестве отдельного аргумента для указанной команды, и упаковывая аргументы до тех пор, пока они остаются в пределах максимально допустимого для системы. Например:


























Константа 


 в 


 представляет сочетание общей памяти, используемой средой, и аргументов командной строки. Стандарт POSIX не говорит, включает ли это массивы указателей или просто сами строки.

Напишите простую версию 


, которая работает указанным способом. Не забудьте об окружении при вычислении размера необходимого пространства. Убедитесь, что тщательно управляете памятью.

4. Компоновка значения status, заполняемого функциями 


 и 


, стандартом POSIX не определяется. Хотя и историческое, это 16-разрядное значение, которое выглядит, как показано на рис. 9.8.




Рис. 9.8. Компоновка значения status функции 




 • Ненулевое значение в битах 0–7 указывает на завершение по сигналу.

 • Все единичные биты в поле сигнала указывает, что порожденный процесс остановлен. В этом случае биты 9-15 содержат номер сигнала.

 • Единичное значение бита 8 указывает завершение со снимком процесса.

 • Если биты 0–7 равны нулю, процесс завершился нормально. В этом случае биты 9–15 являются статусом завершения.

Напишите с данными сведениями макросы POSIX 


 и др.

5. Помня, что 


 сначала закрывает запрошенный дескриптор файла, реализуйте 


, используя 


 и 


. Как вы обработаете случай, когда 


 возвращает значение меньше запрошенного?

6. Есть ли на вашей системе каталог 


? Если есть, как он реализован?

7. Напишите новую версию 


, которая порождает лишь один процесс. После порождения родитель должен поменять дескрипторы своих файлов и сам выполнить exec для одной из новых программ.

8. (Трудное) Как вы можете узнать, вызывал ли ваш процесс когда-нибудь 


? Напишите программу, которая проверяет это и выводит сообщение с ответом да или нет. Можно ли обмануть вашу программу? Если да, как?

9. Есть ли на вашей системе каталог 


? Если да, доступ к какой информации о процессе он обеспечивает?




Глава 10

Сигналы



Данная глава освещает все подробности сигналов, важную, но сложную часть GNU/Linux API.




10.1. Введение


Сигнал является указанием, что случилось какое-то событие, например, попытка сослаться на адрес памяти, который не является частью адресного пространства вашей программы, или когда пользователь нажимает CTRL-C для выхода из программы (называется генерированием прерывания).

Программа может узнать лишь, что определенный сигнал был по крайней мере однажды. Обычно вы не можете сказать, случился ли один и тот же сигнал несколько раз. Вы можете отличить один сигнал от другого и управлять способом реагирования программы на различные сигналы.

Механизмы обработки сигналов развились с течением времени. Как бывает почти со всеми такими механизмами, стандартизованы и доступны как первоначальные, так и более новые API. Однако, из фундаментальных API обработка сигналов обнаруживает, возможно, самые широкие изменения; имеется множество возможностей обработки, чтобы преуспеть в использовании наиболее подходящего API. В результате, возможно, это самая трудная глава в книге. Мы сделаем всевозможное, чтобы сделать изложение более ясным, но если вы проработаете эту главу более тщательно, чем обычно, это поможет.

В отличие от большинства глав в данной книге, наше представление здесь историческое, связанное с освещением развития API, включая API, которые никогда не следует использовать в новом коде. Мы делаем это, потому что это упрощает изложение, делая понятным, почему функция POSIX API 


 поддерживает все те возможности, которые поддерживает.




10.2. Действия сигналов


Каждый сигнал (вскоре мы представим полный список) имеет связанное с ним действие по умолчанию. POSIX обозначает это как диспозицию (disposition) сигнала. Это то действие, которое ядро осуществляет для процесса, когда поступает определенный сигнал. Действие по умолчанию варьирует:

Завершение

Процесс завершается.

Игнорирование

Сигнал игнорируется. Программа никогда не узнает, что что-то случилось.

Снимок образа процесса

Процесс завершается, и ядро создает файл core (в текущем каталоге процесса), содержащий образ работавшей на момент поступления сигнала программы. Снимок процесса может впоследствии использоваться с отладчиком для исследования состояния программы (см. главу 15 «Отладка»).

По умолчанию системы GNU/Linux создают файлы с именем 


, где 


 является ID завершаемого процесса. (Это можно изменить; см. sysctl(8).) Такое именование позволяет хранить в одном и том же каталоге несколько файлов 


, за счет использования большего дискового пространства.[105 - По крайней мере один поставщик дистрибутивов GNU/Linux отменяет сознание файлов 


 «с иголочки». Для повторного подключения этой возможности поместите в свой файл 


 строку '


' — Примеч. автора.] Традиционные системы Unix называют файл 


, и это ваше дело сохранить какие-нибудь файлы 


 для последующего изучения, если есть шанс создания других таких же файлов в том же каталоге.

Остановка

Процесс останавливается. Впоследствии он может быть возобновлен. (Если вы использовали управление заданиями оболочки с помощью CTRL-Z, 


 и 


, вы понимаете остановку процесса.)




10.3. Стандартные сигналы С: 


 и 






Стандарт ISO С определяет первоначальный API управления сигналами V7 и новый API для посылки сигналов. Вы должны использовать их для программ, которым придется работать на не-POSIX системах, или в случаях, когда предоставляемые ISO С API возможности являются достаточными.




10.3.1. Функция 





Действие сигнала изменяется с помощью функции 


. Вы можете изменить действие на «игнорировать сигнал», «восстановить для сигнала действие системы по умолчанию» или «вызвать при появлении сигнала мою функцию с номером сигнала в качестве параметра».

Функция, которую вы предоставляете для распоряжения сигналом, называется обработчиком сигнала (или просто обработчиком), а установка ее в соответствующем месте осуществляет перехват (catch) сигнала.

Получив эти сведения, давайте перейдем к API. В заголовочном файле 


 представлены определения макросов для поддерживаемых сигналов и объявления функций управления сигналами, предоставляемыми стандартом С:













Это объявление для функции signal() почти невозможно прочесть. Поэтому справочная страница GNU/Linux signal(2) определяет ее таким способом:













Теперь это более вразумительно. Тип 


 является указателем на функцию с возвращаемым типом 


, которая принимает один целый аргумент. Это целое является номером поступающего сигнала.

Функция 


 принимает номер сигнала в качестве своего первого параметра, а указатель функции (новый обработчик) в качестве своего второго аргумента. Если последний не является указателем функции, он может быть лишь 


 что означает «восстановить действие по умолчанию», либо 


, что означает «игнорировать сигнал».




 изменяет действие для 


 и возвращает предыдущее действие. (Это дает вам возможность восстановить при желании предыдущее действие.) Возвращаемое значение может равняться также 


, что указывает на произошедшую ошибку. (Некоторые сигналы невозможно перехватить или игнорировать; предоставление для них обработчика сигнала или неверный 


 создают эту ошибку.) В табл. 10.1 перечислены сигналы, доступные под GNU/Linux, их числовые значения, действия по умолчанию для каждого, формальный стандарт или современная операционная система, которые их определяют, и смысл каждого.



Таблица 10.1. Сигналы GNU/Linux




Обозначения: Core: Завершить процесс и создать снимок образа процесса Ignr: Игнорировать сигнал Stop: Остановить процесс. Term: Завершить процесс. 

Более старые версии оболочки Борна (


) непосредственно связывали с номерами сигналов ловушки (traps), которые являются обработчиками сигналов на уровне оболочки. Таким образом, всесторонне образованному Unix-программисту нужно было знать не только имена сигналов для использования в коде С, но также и соответствующие номера сигналов! POSIX требует, чтобы команда 


 понимала символические имена сигналов (без префикса '


'), поэтому этого больше не требуется. Однако (главным образом для лучшего разбирательства), мы предоставили эти номера в интересах полноты из-за того, что однажды вам может понадобиться иметь дело со сценарием оболочки, созданным до POSIX, или с древним кодом на С, которые непосредственно используют номера сигналов.



ЗАМЕЧАНИЕ. Для некоторых более новых сигналов, от 16 и выше, соответствующие номера сигнала и их имена на различных платформах не обязательно совпадают! Проверьте заголовочные файлы и справочные страницы на своей системе. Табл. 10.1 верна для GNU/Linux


Некоторые системы определяют также и другие сигналы, такие, как 


, 


 и 


. Справочная страница GNU/Linux signal(7) предоставляет полный список; если ваша программа должна обработать сигналы, не поддерживаемые GNU/Linux, это можно сделать с помощью 


:
















За исключением 


, сигналы, перечисленные в табл. 10.1, широкодоступны и не нуждаются в заключении в 


.

Сигналы 


 и 


 нельзя перехватить или игнорировать (или блокировать, как описано далее в главе). Они всегда выполняют действие по умолчанию, указанное в табл. 10.1.

Чтобы увидеть список поддерживаемых сигналов, вы можете использовать '


'. На одной из наших систем GNU/Linux:






















































































Сигналы 


 являются сигналами реального времени, сложная тема, которую мы не будем рассматривать.




10.3.2. Программная отправка сигналов: 





Помимо внешнего генерирования, сигнал может быть отправлен непосредственно самой программой с использованием стандартной функции С 


:













Эта функция посылает сигнал 


 вызывающему процессу. (Это действие имеет свое применение; вскоре мы увидим пример.)

Поскольку 


 определена стандартом С, для процесса это наиболее переносимый способ отправить себе сигнал. Есть другие способы, которые мы обсудим далее в главе.




10.4. Обработчики сигналов в действии



Множество осложнений и отклонений обнаруживается после установки на место обработчика, после его вызова и впоследствии возвращения.




10.4.1. Традиционные системы


После помещения на место обработчика сигнала ваша программа развивается своим путем. Интересные вещи возникают лишь с появлением сигнала (например, пользователь нажал CTRL-C для прерывания вашей программы, или был сделан вызов 


).

По получении сигнала ядро останавливает процесс, где бы он ни был. Затем оно имитирует вызов процедуры обработчика сигнала, передавая ему номер сигнала в качестве ее единственного аргумента. Ядро устраивает все таким образом, что нормальный возврат из функции обработчика сигнала (либо посредством 


, либо в результате выпадения из конца функции) передает управление в ту точку программы, в которой она находилась в момент появления сигнала.

Что происходит после обработки сигнала, когда тот же самый сигнал появится в следующий раз снова? Остается ли обработчик на том же месте? Или же он сбрасывается, и для сигнала используется действие по умолчанию? Ответ, по историческим причинам, «зависит от». В частности, стандарт С оставляет это на усмотрение реализации.

На практике V7 и традиционные системы System V, такие, как Solaris, устанавливают для сигнала действие по умолчанию.

Давайте рассмотрим простой обработчик сигнала в действии под Solaris. Следующая программа, 


, перехватывает 


. Обычно вы генерируете этот сигнал, набирая на клавиатуре CTRL-C.





























































































































































































































Строки 9–22 определяют функцию обработки сигнала (остроумно названную 


[106 - Handler (англ.) — обработчик — Примеч. перев.]). Все, что эта функция делает, — выводит номер перехваченного сигнала и возвращается. Для вывода этого сообщения она выполняет множество ручной работы, поскольку 


 не является «безопасной» для вызова из обработчика сигнала. (Вскоре это будет описано в разделе 10.4.6 «Дополнительные предостережения».)

Функция 


 устанавливает обработчик сигнала (строка 38), а затем входит в бесконечный цикл (строки 40–41). Вот что происходит при запуске:














































Поскольку V7 и другие традиционные системы восстанавливают действие сигнала по умолчанию, поэтому когда вы хотите снова получить сигнал в будущем, функция обработчика должна немедленно переустановить саму себя:


































10.4.2. BSD и GNU/Linux


BSD 4.2 изменила способ работы 


.[107 - Изменение поведения было плохой мыслью, сильно критиковавшейся в свое время, но было слишком поздно. Изменение семантики определенного интерфейса всегда ведет к проблеме, как было в этом случае. Хотя это особенно относится к проектировщикам операционных систем, любой, кто разрабатывает библиотеки общего назначения, также должен помнить этот урок. — Примеч. автора.] На системах BSD обработчик сигнала после его возвращения остается на месте. Системы GNU/Linux следуют поведению BSD. Вот что происходит под GNU/Linux:




































На системе BSD или GNU/Linux обработчик сигнала не должен дополнительно использовать '


' для переустановки обработчика. Однако, лишний вызов не причиняет никакого вреда, поэтому сохраняется статус-кво.

В действительности, POSIX предоставляет функцию 


, которая идентична 


 за тем исключением, что она гарантирует, что обработчик сигнала останется установленным:













Это устраняет проблемы переносимости. Если вы знаете, что ваша программа будет работать лишь на системах POSIX, вы можете воспользоваться 


 вместо 


.

Одно предостережение — эта функция также помечена как «устаревающая», что означает возможность отказа от нее в будущем стандарте. На практике, даже если от нее откажутся, поставщики скорее всего долгое время будут ее поддерживать. (Как мы увидим, функция API POSIX 


 предоставляет достаточно возможностей для написания рабочей версии, если это вам нужно.)




10.4.3. Игнорирование сигналов


Более практично, когда вызывается обработчик сигнала, это означает, что программа должна завершиться и выйти. Было бы раздражающим, если бы большинство программ по получении 


 выводили бы сообщение и продолжали работу; смысл сигнала в том, что они должны остановиться!

Например, рассмотрите программу 


. 


, возможно, создала любое число временных файлов для использования на промежуточных этапах процесса сортировки. По получении 


, 


 должна удалить временные файлы и выйти. Вот упрощенная версия обработчика сигнала из GNU Coreutils 


:




































Установка действия 


 гарантирует, что все последующие появляющиеся сигналы 


 не повлияют на продолжающийся процесс очистки. Когда функция 


 завершит работу, восстановление действия 


 позволяет системе сделать снимок образа процесса, если это нужно возникшему сигналу. Вызов 


 восстанавливает сигнал. Затем восстановленный сигнал вызывает действие по умолчанию, которое, скорее всего, завершит программу. (Далее в этой главе мы полностью покажем обработчик сигнала 


.)




10.4.4. Системные вызовы, допускающие повторный запуск



Значение 


 для 


 (см. раздел 4.3 «Определение ошибок») указывает, что системный вызов был прерван. Хотя с этим значением ошибки может завершаться большое количество системных вызовов, двумя наиболее значительными являются 


 и 


. Рассмотрите следующий код:




































































Предположим, что система успешно прочла (и заполнила) часть буфера, когда возник 


. Системный вызов 


 еще не вернулся из ядра в программу, но ядро решает, что оно может доставить сигнал. Вызывается 


, запускается и возвращается в середину 


. Что возвратит 


?

В былые времена (V7, более ранние системы System V) 


 возвратила бы -1 и установила бы 


 равным 


. Не было способа сообщить, что данные были переданы. В данном случае V7 и System V действуют, как если бы ничего не случилось: не было перемещений данных в и из буфера пользователя, и смещение файла не было изменено. BSD 4.2 изменила это. Были два случая:

Медленные устройства

«Медленное устройство» является в сущности терминалом или почти всяким другим устройством, кроме обычного файла. В этом случае 


 могла завершиться с ошибкой 


, лишь если не было передано никаких данных, когда появился сигнал. В противном случае системный вызов был бы запущен повторно, и 


 возвратилась бы нормально.

Обычные файлы

Системный вызов был бы запущен повторно В этом случае 


 вернулась бы нормально; возвращенное значение могло быть либо числом запрошенных байтов, либо числом действительно прочитанных байтов (как в случае чтения вблизи конца файла).

Поведение BSD несомненно полезно; вы всегда можете сказать, сколько данных было прочитано.

Поведение POSIX сходно, но не идентично первоначальному поведению BSD. POSIX указывает, что 


[108 - Хотя мы описываем 


, эти правила применяются ко всем системным вызовам, которые могут завершиться с ошибкой 


, как, например, семейство функций 


 — Примеч. автора.] завершается с ошибкой 


 лишь в случае появления сигнала до начала перемещения данных. Хотя POSIX ничего не говорит о «медленных устройствах», на практике это условие проявляется именно на них.

В противном случае, если сигнал прерывает частично выполненную 


, возвращенное значение является числом уже прочитанных байтов. По этой причине (а также для возможности обработки коротких файлов) всегда следует проверять возвращаемое 


 значение и никогда не предполагать, что прочитано все запрошенное количество байтов. (Функция POSIX API 


, описанная позже, позволяет при желании получить поведение повторно вызываемых системных вызовов BSD.)




10.4.4.1. Пример: GNU Coreutils 


 и 





Для обработки случая EINTR в традиционных системах GNU Coreutils использует две функции, 


 и 


. Код несколько запутан из-за того, что один и тот же файл за счет включения #include и макросов реализует обе функции. Из файла 


 в дистрибутиве Coreutils:














































































































































































































Строки 57–67 обрабатывают определения, создавая соответствующим образом 


 и 


 (см. ниже 


).

Строки 77–84 указывают на разновидность осложнений, возникающих при чтении. Здесь один особый вариант Unix не может обработать значения, превышающие 


, поэтому строки 83–84 выполняют сразу две операции: уменьшают значение числа, чтобы оно не превышало 


, и сохраняют его кратным 8192. Последняя операция служит эффективности дисковых операций: выполнение ввода/вывода с кратным основному размеру дискового блока объемом данных более эффективно, чем со случайными размерами данных. Как отмечено в комментарии, код сохраняет семантику 


 и 


, где возвращенное число байтов может быть меньше затребованного.

Обратите внимание, что параметр 


 может и в самом деле быть больше 


, поскольку count представляет тип 


, который является беззнаковым (unsigned). 


 является чистым 


, который на всех современных системах является знаковым.

Строки 86–90 представляют действительный цикл, повторно осуществляющий операцию, пока она завершается ошибкой 


. Макрос 


 не показан, но он обрабатывает случай в системах, на которых 


 не определен. (Должен быть по крайней мере один такой случай, иначе код не будет возиться с установкой макроса; возможно, это было сделано для эмуляции Unix или POSIX в не-Unix системе.) Вот 


:































В строке 18 


 определяет 


; это связано со строками 57–60 в 


.




10.4.4.2. Только GLIBC: 





Файл <unistd.h> GLIBC определяет макрос TEMP_FAILURE_RETRY(), который вы можете использовать для инкапсулирования любого системного вызова, который может при неудачном вызове установить errno в EINTR. Его «объявление» следующее:













Вот определение макроса:









































Макрос использует расширение GCC к языку С (как обозначено ключевым словом 


), которое допускает заключенным в фигурные скобки внутри обычных скобок выражениям возвращать значение, действуя таким образом подобно простому выражению.

Используя этот макрос, мы могли бы переписать 


 следующим образом:












































10.4.5. Состояния гонок и 


 (ISO C)


Пока обработка одного сигнала за раз выглядит просто: установка обработчика сигнала в 


 и (не обязательная) переустановка самого себя обработчиком сигнала (или установка действия 


) в качестве первого действия обработчика.

Но что произойдет, если возникнут два идентичных сигнала, один за другим? В частности, что, если ваша система восстановит действие по умолчанию для вашего сигнала, а второй сигнал появится после вызова обработчика, но до того, как он себя восстановит?

Или предположим, что вы используете 


, так что обработчик остается установленным, но второй сигнал отличается от первого? Обычно обработчику первого сигнала нужно завершить свою работу до того, как запускается второй, а каждый обработчик сигнала не должен временно игнорировать все прочие возможные сигналы!

Оба случая относятся к состоянию гонки. Одним решением для этих проблем является как можно большее упрощение обработчиков сигналов. Это можно сделать, создав флаговые переменные, указывающие на появление сигнала. Обработчик сигнала устанавливает переменную в true и возвращается. Затем основная логика проверяет флаговую переменную в стратегических местах:

































































(Обратите внимание, что эта стратегия уменьшает окно уязвимости, но не устраняет его).

Стандарт С вводит специальный тип — 


 — для использования с такими флаговыми переменными. Идея, скрывающаяся за этим именем, в том, что присвоение значений переменным этого типа является атомарной операцией: т.е. они совершаются как одно делимое действие. Например, на большинстве машин присвоение значения 


 осуществляется атомарно, тогда как инициализация значений в структуре осуществляется либо путем копирования всех байтов в (сгенерированном компилятором) цикле, либо с помощью инструкции «блочного копирования», которая может быть прервана. Поскольку присвоение значения 


 является атомарным, раз начавшись, оно завершается до того, как может появиться другой сигнал и прервать его.

Наличие особого типа является лишь частью истории. Переменные 


 должны быть также объявлены как 


:











Ключевое слово 


 сообщает компилятору, что переменная может быть изменена извне, за спиной компилятора, так сказать. Это не позволяет компилятору применить оптимизацию, которая могла бы в противном случае повлиять на правильность кода

Структурирование приложения исключительно вокруг переменных 


 ненадежно. Правильный способ обращения с сигналами показан далее, в разделе 10.7 «Сигналы для межпроцессного взаимодействия».




10.4.6. Дополнительные предостережения


Стандарт POSIX предусматривает для обработчиков сигналов несколько предостережений:

• Что случается, когда возвращаются обработчики для 


, 


, 


 или любых других сигналов, представляющих «вычислительные исключения», не определено.

• Если обработчик был вызван в результате вызова 


, 


 или 


, он не может вызвать 


. 


 описана в разделе 12.4 «Совершение самоубийства: 


», a 


 описана далее в этой главе. (Описанная далее функция API 


 с обработчиком сигнала, принимающая три аргумента, дает возможность сообщить об этом, если это имеет место.)

• Обработчики сигналов могут вызвать лишь функции из табл. 10.2. В частности, они должны избегать функций 


. Проблема в том, что во время работы функции 


 может возникнуть прерывание, когда внутреннее состояние библиотечной функции находится в середине процесса обновления. Дальнейшие вызовы функций 


 могут повредить это внутреннее состояние.

Список в табл. 10.2 происходит из раздела 2.4 тома System Interfaces (Системные интерфейсы) стандарта POSIX 2001. Многие из этих функций относятся к сложному API и больше не рассматриваются в данной книге.



Таблица 10.2. Функции, которые могут быть вызваны из обработчика сигнала







10.4.7. Наша история до настоящего времени, эпизод 1


Сигналы являются сложной темой, и она становится еще более сбивающей с толку. Поэтому давайте на время сделаем остановку, сделаем шаг назад и подведем итог обсужденному до сих пор:

• Сигналы являются указанием того, что произошло некоторое внешнее событие.

• 


 является функцией ISO С для отправки сигнала текущему процессу. Как отправлять сигналы другим процессам, нам еще предстоит описать.

• 


 контролирует диспозицию сигнала, т.е. реакцию процесса на сигнал, когда он появляется. Сигнал можно оставить системе для обработки по умолчанию, проигнорировать или перехватить.

• Когда сигнал перехватывается, вызывается функция-обработчик. Вот где сложность начинает поднимать свою безобразную голову:

 • ISO С не определяет, восстанавливается ли диспозиция сигнала по умолчанию до вызова обработчика или она остается на месте. Первое является поведением V7 и современных систем System V, таких, как Solaris. Последнее является поведением BSD, используемым также в GNU/Linux. (Для форсирования поведения BSD может использоваться функция POSIX 


.)

• То, что случается при прерывании сигналом системного вызова, также различается в традиционной и BSD линейках. Традиционные системы возвращают -1 с errno, установленным в 


. BSD системы повторно запускают системный вызов после возвращения из обработчика. Макрос GLIBC 


 может помочь вам написать код для обработки системных вызовов, возвращающих -1 с 


, установленным в 


.

POSIX требует, чтобы частично выполненный системный вызов возвращал успешное завершение, указав, сколько работы было выполнено. Системный вызов, который еще не начал выполняться, вызывается повторно.

• Механизм 


 предоставляет плодотворную почву для появления условий гонки. В этой ситуации помогает тип данных ISO С 


, но он не решает проблему, и определенный таким способом механизм не может обезопасить от проявления условий гонки.

• Применяется ряд дополнительных предостережений, и в частности, из обработчика сигнала безопасно может вызываться лишь часть стандартных библиотечных функций.

Несмотря на эти проблемы интерфейса 


 для простых программ достаточно, и он все еще широко используется.




10.5. API сигналов System V Release 3: 


 и др.


BSD 4.0 (примерно с 1980 г.) ввел дополнительные функции API для предоставления «надежных» сигналов.[109 - Для использования API требуется компоновка с отдельной библиотекой, — 


 — Примеч. автора.] В частности, стало возможным блокировать сигналы. Другими словами, программа могла сообщить ядру: «Зависни на этих конкретных сигналах в течении следующего небольшого промежутка времени, затем доставь их мне, когда я буду готов их принять». Большим преимуществом является то, что эта особенность упрощает обработчики сигналов, которые автоматически запускаются со своим заблокированным сигналом (чтобы избежать проблемы одновременной обработки двух сигналов) и, возможно, также и с другими заблокированными сигналами.

System V Release 3 (примерно с 1984 г.) приняла эти API и популяризовала их, в большинстве связанных с Unix документации и книгах вы, возможно, увидите, что на эти API ссылаются, как ведущие начало от System V Release 3. Эти функции следующие:











































Стандарт POSIX для этих функций описывает их поведение в терминах маски сигналов процесса. Маска сигналов процесса отслеживает, какие сигналы (если они вообще есть) процесс заблокировал в настоящее время. Более подробно это описывается в разделе 10.6.2 «Наборы сигналов: 


 и связанные функции». В API System V Release 3 нет способа получить или изменить маску сигналов процесса в целом. Функции работают следующим образом:






Добавляет 


 к списку заблокированных процессов (маска сигналов процесса).






Удаляет 


 из маски сигналов процесса.






Игнорирует 


. Это вспомогательная функция.






Удаляет 


 из маски сигналов процесса, а затем приостанавливает процесс до появления сигнала (см. раздел 10.7 «Сигналы для межпроцессного взаимодействия»).






Это замена для signal(). (Здесь мы использовали обозначение из справочной страницы GNU/Linux, чтобы упростить восприятие объявления функции.)

Для 


 аргумент 


 может быть 


, 


 или указатель функции, как и для 


. Однако, он может равняться также и 


. В этом случае 


 добавляется к маске сигналов процесса, но связанное с ним действие никак не изменяется. (Другими словами, если бы у него был обработчик, он остается тем же; если было действие по умолчанию, оно не изменяется.)

Когда для установки обработчика сигнала используется 


 и появляется сигнал, ядро сначала добавляет сигнал к маске процессов сигнала, блокируя любой дальнейший прием этого сигнала. Запускается обработчик, а когда он возвращается, ядро восстанавливает маску сигналов процесса в то состояние, какое было до запуска обработчика. (В модели POSIX если обработчик сигнала изменяет маску сигнала, это изменение переписывается в процессе восстановления предыдущей маски, когда обработчик возвращается.)




 и 


 могут использоваться совместно для выделения так называемых критических секций кода: участков кода, который не должен прерываться определенным сигналом, чтобы структуры данных не повреждались кодом обработчика сигнала.



ЗАМЕЧАНИЕ. POSIX стандартизует эти API, поскольку главной целью POSIX является формализация существующей практики, где это возможно. Однако, функции 


, которые вскоре будут описаны, дают вам все, что делают эти API, и даже больше. В новых программах вам не следует использовать эти API Вместо этого используйте 


. (Мы заметили, что в справочной системе GNU/Linux нет даже страницы для sigset(2)!)





10.6. Сигналы POSIX



API POSIX основан на API 


 из BSD 4.2 и 4.3. С небольшими изменениями этот API можно было отнести к возможностям API как V7, так и System V Release 3. POSIX сделал эти изменения и переименовал API 


. Поскольку интерфейс 


 широко не использовался, мы не будем его описывать. Вместо этого в данном разделе описывается только 


, который вы и должны так или иначе использовать. (На самом деле руководства BSD 4.4 от 1994 г. помечают 


 как устаревшую, указывая читателю на 


.)




10.6.1. Обнажение проблемы


Что неладно с API System V Release 3? В конце концов, они предоставляют блокирование сигналов, так, что сигналы не теряются, и любой данный сигнал может быть надежно обработан.

Ответ в том, что этот API работает лишь с одним сигналом в одно и то же время. Программы обычно обрабатывают больше одного сигнала. И когда вы находитесь в середине процесса обработки одного сигнала, вы не хотите беспокоиться по поводу обработки еще и второго. (Предположим, вы только что начали отвечать по офисному телефону, когда зазвонил ваш мобильный телефон: вы бы предпочли, чтобы телефонная система ответила вызывающему, что в данный момент вы находитесь на другой линии и что скоро освободитесь, вместо того, чтобы проделывать все это самому.)

С API 


 каждый обработчик сигнала должен был бы временно блокировать все другие сигналы, сделать свою работу, а затем разблокировать их. Проблема в том, что в промежутке между любыми двумя вызовами 


 может появиться еще не заблокированный сигнал. Сценарий, еще раз, распространенный, создающий условия гонки.

Решением является обеспечение возможности автоматической работы с группами сигналов, т.е. с помощью одного системного вызова. Вы достигаете этого, работая с наборами сигналов и маской сигналов процесса.




10.6.2. Наборы сигналов: 


 и связанные функции


Маска сигналов процесса является списком сигналов, которые процесс в настоящее время заблокировал. Сила POSIX API в том, что маской сигналов процесса можно манипулировать атомарно, как единым целым.

Маска сигналов процесса программно представляется с помощью набора сигналов. Это тип 


. Концептуально он представляет собой просто битовую маску, причем значения 0 и 1 представляют отсутствие или наличие определенного сигнала в маске.
















Однако, поскольку в системе может быть больше сигналов, чем может содержаться в одной 


 или 


 и поскольку интенсивное использование побитовых операций тяжело для восприятия, для управления наборами сигналов существует несколько функций API.

































Эти функции следующие:






Освобождает набор сигналов. По возвращении 


 не содержит сигналов. Возвращает 0 в случае успеха и -1 при ошибке.






Полностью заполняет набор сигналов. По возвращении 


 содержит все сигналы, определенные системой. Возвращает 0 в случае успеха и -1 при ошибке.






Добавляет 


 к маске сигналов процесса в 


. Возвращает 0 в случае успеха и -1 при ошибке.






Удаляет 


 из маски сигналов процесса в 


. Возвращает 0 в случае успеха и -1 при ошибке.






Возвращает true/false, если 


 присутствует или не присутствует в 


.

Перед выполнением с переменной 


 каких-то действий всегда следует вызывать одну из функций 


 или 


. Существуют оба интерфейса, поскольку иногда бывает нужно начать с пустого набора и работать потом лишь с одним или двумя сигналами, а в другое время бывает нужно работать со всеми сигналами, возможно, убирая один или два сигнала.




10.6.3. Управление маской сигналов: 


 и др.


Маска сигналов процесса вначале пуста - заблокированных сигналов нет. (Это упрощение; см. раздел 10.9 «Сигналы, передающиеся через 


 и 


.) Три функции позволяют работать непосредственно с маской сигналов процесса:























Функции следующие:






Если 


 не равен 


, получается маска сигналов текущего процесса и помещается в 


. Затем маска сигналов процесса обновляется в соответствии с содержимым 


 и значением 


, который должен иметь одно из следующих значений:




Объединить сигналы в 


 с маской сигналов текущего процесса. Новая маска является объединением текущей маски и 


.




Удалить сигналы в 


 из маски сигналов процесса. Это не представляет проблемы, если 


 содержит сигнал, который не содержится в текущей маске сигналов процесса.




Заменить маску сигналов процесса содержимым 


.

Если 


 равен 


, a 


 — нет, значение 


 неважно. Эта комбинация получает маску сигналов текущего процесса, не меняя ее. (Это явно выражено в стандарте POSIX, но не ясно из справочной страницы GNU/Linux.)






Эта функция позволяет увидеть, какие сигналы ожидают решения; т.е. 


 заполнен этими сигналами, которые были посланы, но они еще не доставлены, поскольку заблокированы.






Эта функция временно заменяет маску сигналов процесса содержимым 


, а затем приостанавливает процесс, пока сигнал не будет получен. По определению, заставить функцию вернуться может только сигнал, не находящийся в 


 (см. раздел 10.7 «Сигналы для межпроцессного взаимодействия).




10.6.4. Перехват сигналов: 





Наконец мы готовы взглянуть на функцию 


. Эта функция сложна, и мы намеренно опускаем множество деталей, которые предназначены для специального использования. Стандарт POSIX и справочная страница sigaction(2) предоставляют все подробности, хотя вы должны тщательно прочесть и то, и другое, чтобы полностью все усвоить.













Аргументы следующие:






Интересующий сигнал, как в случае с другими функциями обработки сигналов.






Определение нового обработчика для сигнала 


.






Определение текущего обработчика. Если не 


, система до установки 


 заполняет 


. 


 может быть 


, в этом случае 


 заполняется, но больше ничего не меняется.

Таким образом, 


 и устанавливает новый обработчик, и получает старый за одно действие. 


 выглядит следующим образом.



















































Поля следующие:






Набор дополнительных сигналов для блокирования при запуске функции обработчика. Таким образом, когда вызывается обработчик, общий набор заблокированных сигналов является объединением сигналов в маске процесса, сигналов в 


 и, если 


 сброшен, 


.






Флаги, контролирующие обработку сигнала ядром. См. обсуждение далее.






Указатель на «традиционную» функцию обработчика. У нее такой же прототип (возвращаемый тип и список параметров), как у функции обработчика для 


, 


 и 


.






Указатель на функцию обработчика «нового стиля». Функция принимает три аргумента, которые вскоре будут описаны.

Которая из функций 


 и 


 используется, зависит от флага 


 в 


. Когда имеется, используется 


; в противном случае используется 


. Как POSIX, так и справочная страница GNU/Linux указывают, что эти два поля могут перекрываться в памяти (т. е. быть частью 


). Таким образом, никогда не следует использовать оба поля в одной и той же 


.

Поле 


 составляется с помощью побитового ИЛИ значений одного или более флагов, перечисленных в табл. 10.3.



Таблица 10.3. Значения флагов для 







Когда в 


 установлен флаг 


, поле 


 является указателем на функцию, объявленную следующим образом:
















Структура 


_t предоставляет изобилие сведений о сигнале:





























































Поля 


, 


 и 


 доступны для всех сигналов. Другие поля могут быть членами объединения, поэтому должны использоваться лишь для тех сигналов, для которых они определены. В структуре 


 могут быть также и другие поля.

Почти все поля предназначены для расширенного использования. Все подробности содержатся в стандарте POSIX и справочной странице sigaction(2). Однако, мы можем описать простое использование поля 


.

Для 


, 


, 


, 


, 


, 


 и 


 поле si_code может принимать любое из набора предопределенных значений, специфичных для каждого сигнала, указывая на причину появления сигнала. Откровенно говоря, детали несколько чрезмерны; повседневному коду на самом деле нет необходимости иметь с ними дела (хотя позже мы рассмотрим значения для 


). Для всех остальных сигналов член 


 имеет одно из значений из табл. 10.4.



Таблица 10.4. Значения происхождения сигнала для 







В особенности полезно значение 


; оно позволяет обработчику сигнала сообщить, был ли сигнал послан функциями 


 или 


 (описываются далее). Вы можете использовать эту информацию, чтобы избежать повторного вызова 


 или 


.

Третий аргумент обработчика сигнала с тремя аргументами, 


t, является расширенной возможностью, которая больше не обсуждается в данной книге.

Наконец, чтобы увидеть 


 в действии, исследуйте полный исходный код обработчика сигнала для 


:

























































































































Вот код в 


, который помещает обработчик на свое место:








































































































































Мы заметили, что строки 2216–2219 и 2221 могут быть замещены одним вызовом: 


;

Мы не знаем, почему код написан именно таким способом.

Интерес представляют также строки 2233–2234 и 2236–2237, которые показывают правильный способ проверки того, игнорируется ли сигнал, и для установки обработчика лишь в том случае, если сигнал не игнорируется.



ЗАМЕЧАНИЕ. Функции API 


 и 


 не должны использоваться вместе для одного и того же сигнала. Хотя POSIX идет на большие длинноты, чтобы сначала сделать возможным использование 


, получить 


, представляющую диспозицию 


, и восстановить ее, все равно это плохая мысль. Код будет гораздо проще читать, писать и понимать, если вы используете одну функцию или другую взаимоисключающим образам





10.6.5. Извлечение ожидающих сигналов: 





Описанный ранее системный вызов 


 позволяет получить набор ожидающих сигналов, т.е тех сигналов, которые появились, но еще не доставлены из-за блокировки:













Помимо разблокировки ожидающих сигналов, чтобы они могли быть доставлены, вы можете решить их игнорировать. Установка действия сигнала 


 вызывает сбрасывание сигнала (даже если он был заблокирован). Сходным образом для тех сигналов, действием по умолчанию для которых является их игнорирование, установка действия в 


 также вызывает сбрасывание таких ожидающих сигналов.




10.6.6. Создание возможности для прерывания функций: 





Чтобы сделать определенную функцию прерываемой или повторно запускаемой в зависимости от значения второго аргумента, в качестве удобного средства может использоваться функция 


. Объявление следующее:













В соответствии со стандартом POSIX поведение 


 эквивалентно следующему коду:





























































В случае успеха возвращаемое значение равно 0 и -1 при ошибке.




10.6.7. Передача сигналов: 


 и 





Традиционная функция Unix для передачи сигналов называется 


. Имя несколько неправильное; все, что она делает — отправляет сигнал. (Результатом этого часто является завершение получателя сигнала, но это не обязательно верно. Однако, теперь слишком поздно менять имя.) Функция 


 посылает сигнал определенной группе процессов. Объявления следующие:























Аргумент 


 является либо именем сигнала, либо 0. В последнем случае сигнал не посылается, но ядро все равно осуществляет проверку ошибок. В частности, это правильный способ проверки существования данного процесса или группы, а также проверки того, что у вас есть разрешение на передачу сигналов процессу или группе процессов 


 возвращает 0 в случае успеха и -1 при ошибке; 


 указывает на проблему.

Правила для значения 


 несколько запутаны:







 является номером процесса, и сигнал посылается этому процессу




Сигнал посылается каждому процессу в группе посылающего процесса.




Сигнал посылается каждому процессу в системе, за исключением специальных системных процессов. Применяется проверка прав доступа. На системах GNU/Linux исключается лишь процесс 


 (PID 1), но у других систем могут быть другие специальные процессы.




Сигнал посылается группе процессов, представленной абсолютным значением 


. Таким образом, вы можете отправить сигнал всей группе процессов, дублируя возможности 


. Эта неортогональность обеспечивает историческую совместимость.

Значение 


 для 


 сходно со значением для 


 (см. раздел 9.1.6.1 «Использование функций POSIX: 


 и 


»).

Стандартная функция С 


 в сущности эквивалентна
















Комитет по стандартизации С выбрал имя 


, поскольку С должен работать также в окружениях, не относящихся к Unix, a 


 была сочтена специфичной для Unix функцией. Представилась также возможность дать этой функции более описательное имя.




 посылает сигнал группе процессов. Пока значение 


 превышает 1, эта функция эквивалентна '


'. Справочная страница GNU/Linux killpg(2) утверждает, что если 


 равно 0, сигнал посылается группе отправляющего процесса (Это то же самое, что и 


.)

Как вы могли представить, нельзя послать сигнал произвольному процессу (если вы не являетесь суперпользователем, 


). Для обычных пользователей действительный или эффективный UID отправляющего процесса должен соответствовать действительному или сохраненному set-user-ID получающего процесса. (Различные UID описаны в разделе 11.1.1 «Действительные и эффективные ID».)

Однако 


 является особым случаем: пока получающий процесс является членом того же сеанса, что и отправляющий, сигнал пройдет. (Сеансы были кратко описаны в разделе 9.2.1 «Обзор управления заданиями».) Это особое правило позволяет управляющей заданиями оболочке продолжать остановленные процессы-потомки, даже если этот остановленный процесс имеет другой ID пользователя.




10.6.8. Наша история до настоящего времени, эпизод II


System V Release 3 API был предназначен для исправления различных проблем, представленных первоначальным API сигналов V7. В частности, важной дополнительной концепцией является понятие о блокировке сигналов.

Однако, этот API оказался недостаточным, поскольку он работал лишь с одним сигналом за раз, оставляя множество широко открытых окон, через которые могли поступать нежелательные сигналы. POSIX API, работая атомарно с множеством сигналов (маской сигналов процесса, программно представленной типом 


), решает эту проблему, закрывая окна.

Первый набор функций, который мы исследовали, манипулирует значениями 


: 


, 


, 


, 


 и 


.

Следующий набор работает с маской сигналов процесса: 


 устанавливает и получает маску сигналов процесса, 


 получает набор ожидающих сигналов, a 


 помещает процесс в состояние сна, временно заменяя маску сигналов процесса одним из своих параметров.

Функция POSIX API 


 (весьма) запутана из-за необходимости обеспечить:

• обратную совместимость: 


 и 


 в поле 


;

• выбор, блокировать также полученный сигнал или нет: 


 для sa


;

• возможность иметь два различных вида обработчиков сигналов: с одним или с тремя аргументами;

• выбор поведения для управления 


: 


 и 


 для 


.

Функция 


 является удобной для разрешения или запрещения повторного запуска системных вызовов для данного сигнала.

Наконец, для посылки сигналов не только текущему, но также и другим процессам могут использоваться 


 и 


 (конечно, с проверкой прав доступа).




10.7. Сигналы для межпроцессного взаимодействия


«ЭТО УЖАСНАЯ МЫСЛЬ! СИГНАЛЫ НЕ ПРЕДНАЗНАЧЕНЫ ДЛЯ ЭТОГО! Просто скажите НЕТ».

    - Джефф Колье (Geoff Collyer) -

Одним из главных механизмов межпроцессного взаимодействия (IPC) являются каналы, которые описаны в разделе 9.3 «Базовая межпроцессная коммуникация каналы и FIFO». Сигналы также можно использовать для очень простого IPC[111 - Наша благодарность Ульриху Дрепперу (Ulrich Drepper) за помощь в разъяснении, связанных с этим проблем — Примеч. автора.]. Это довольно грубо; получатель может лишь сказать, что поступил определенный сигнал. Хотя функция 


 позволяет получателю узнать PID и владельца процесса, пославшего сигнал, эти сведения обычно не очень помогают.



ЗАМЕЧАНИЕ. Как указывает цитата в начале, использование сигналов для IPC почти всегда является плохой мыслью. Мы рекомендуем по возможности избегать этого. Но нашей целью является научить вас, как использовать возможности Linux/Unix, включая их отрицательные моменты, оставляя за вами принятие информированного решения, что именно использовать.


Сигналы в качестве IPC для многих программ могут быть иногда единственным выбором. В частности, каналы не являются альтернативой, если две взаимодействующие программы не запущены общим родителем, а файлы FIFO могут не быть вариантом, если одна из взаимодействующих программ работает лишь со стандартными вводом и выводом. (Примером обычного использования сигналов являются определенные системные программы демонов, таких, как 


, которые принимают несколько сигналов, уведомляющих, что нужно повторно прочесть файл настроек, осуществить проверку непротиворечивости и т.д. См. xinetd(8) в системе GNU/Linux и inetd(8) в системе Unix.)

Типичная высокоуровневая структура основанного на сигналах приложения выглядит таким образом:





















Оригинальным интерфейсом V7 для ожидания сигнала является 


:
















 приостанавливает процесс; она возвращается лишь после того, как сигнал будет доставлен и его обработчик вернется из вызова. По определению, 


 полезна лишь с перехваченными сигналами — игнорируемые сигналы при их появлении игнорируются, а сигналы с действием по умолчанию, завершающим процесс (с созданием файла образа или без него), продолжают действовать так же.

Проблема в только что описанной высокоуровневой структуре приложения кроется в части «Обработка сигнала». Когда этот код запускается, вы не захотите обрабатывать другой сигнал; вы хотите завершить обработку текущего сигнала до перехода к следующему. Одним из возможных решений является структурирование обработчика сигнала таким образом, что он устанавливает флаг и проверяет его в главном цикле: 





















В основном коде флаг проверяется:














































К сожалению, этот код изобилует условиями гонки:































































Решением является блокирование интересующего сигнала в любое время, кроме ожидания его появления. Например, предположим, что интересующим нас сигналом является 


:












































































































































Ключом к использованию этого является то, что 


временно заменяет маску сигналов процесса маской, переданной в аргументе. Это дает 


 возможность появиться. При появлении он обрабатывается; обработчик сигнала возвращается, а вслед за ним возвращается также 


. Ко времени возвращения 


 первоначальная маска процесса снова на месте.

Вы легко можете расширить этот пример для нескольких сигналов, блокируя в 


 и в обработчике все интересующие сигналы и разблокируя их лишь в вызове 


.

При наличии всего этого не следует в новом коде использовать 


. 


 был стандартизован POSIX главным образом для поддержки старого кода. То же самое верно и для функции 


 System V Release 3. Вместо этого, если нужно структурировать свое приложение с использованием сигналов для IPC, используйте исключительно функции API 


 и 


.



ЗАМЕЧАНИЕ. Приведенный выше код предполагает, что маска сигналов процесса начинается пустой. Код изделия должен вместо этого работать с любой маской сигналов, имеющейся на момент запуска программы.





10.8. Важные сигналы специального назначения



Некоторые сигналы имеют особое назначение. Здесь мы опишем наиболее важные.




10.8.1. Сигнальные часы: 


, 


 и 






Часто бывает необходимо написать программу в виде
















Часто такая потребность возникает в сценариях оболочки, например, в ожидании регистрации определенного пользователя:





















Два механизма, один низкоуровневый, другой высокоуровневый, позволяют работающему процессу узнать, когда истекло заданное количество секунд.




10.8.1.1. Труднее, но с большим контролем: 


 и 





Основным строительным блоком является системный вызов 


:













После того, как 


 возвратится, программа продолжает работать. Однако, когда истекают 


 секунд, ядро посылает процессу 


. Действием по умолчанию является завершение процесса, но вы скорее всего вместо этого установите обработчик сигнала для 


.

Возвращаемое значение либо 0, либо, если был установлен предыдущий сигнальный интервал, число секунд, остающихся до его завершения. Однако, для процесса имеется лишь один такой сигнальный интервал; предыдущий отменяется, а новый помещается на его место.

Преимуществом здесь является то, что со своим установленным обработчиком вы можете делать при поступлении сигнала все, что хотите. Недостаток же в том, что приходится быть готовым к работе в нескольких контекстах: основном контексте и контексте обработчика сигнала.




10.8.1.2. Простой и легкий: 





Более легкий способ ожидания истечения фиксированного промежутка времени заключается в использовании функции 


:













Возвращаемое значение равно 0, если процесс проспал все отведенное время. В противном случае возвращается оставшееся для сна время. Это последнее значение может возникнуть в случае, если появился сигнал, пока процесс дремал.



ЗАМЕЧАНИЕ. Функция 


 часто реализуется через сочетание 


, 


 и 


. Такой подход делает опасным смешивание 


 с вашим собственным вызовом 


 (или расширенной функцией 


, описанной в разделе 14.3.3 «Интервальные таймеры 


 и 


») Чтобы теперь узнать о функции 


, см. раздел 14.3.4 «Более точные паузы: 


».





10.8.2. Сигналы, управляющие заданиями


Несколько сигналов используются для реализации управления заданиями — возможностью начинать и останавливать задания и перемещать их из фонового режима на передний план и обратно. На уровне пользователя вы, несомненно, проделывали это: использовали CTRL-Z для остановки задания, 


 для помещения его в фоновый режим, а иногда использовали 


 для перемещения фонового или остановленного задания на передний план.

Секция 9.2.1 «Обзор управления заданиями» описывает в общем, как осуществляется управление заданиями. Данный раздел завершает обзор, описав сигналы управления заданиями. поскольку иногда может понадобиться перехватить их непосредственно:






Этот сигнал осуществляет «остановку терминала». Это сигнал, который ядро посылает процессу, когда пользователь за терминалом (или окном, эмулирующим терминал) набирает определенный ключ. Обычно это CTRL-Z, аналогично тому, как CTRL-C обычно посылает 


.

Действием по умолчанию для 


 является остановка (переход в приостановленное состояние) процесса. Однако, вы можете перехватить этот сигнал, как любой другой. Хорошая мысль сделать это, если ваша программа изменяет состояние терминала. Например, рассмотрите экранные редакторы 


 или Emacs, которые переводят терминал в посимвольный режим. По получении 


, они должны восстановить терминал в его нормальный построчный режим, а затем приостановиться сами.






Этот сигнал также останавливает процесс, но он не может быть перехвачен, заблокирован или проигнорирован. Он может быть использован в качестве последнего средства вручную (посредством команды 


) или программным путем. Например, только что обсужденный обработчик 


 после восстановления состояния терминала мог бы затем использовать для остановки процесса '


'.




, 




Ранее эти сигналы были определены как «фоновое чтение из tty» и «фоновая запись в tty». tty является устройством терминала. В системах управления заданиями процессы, работающие в фоновом режиме, заблокированы от попыток чтения с терминала или записи в него. Когда процесс пытается осуществить любую из этих операций, ядро посылает ему соответствующий сигнал. Для обоих действием по умолчанию является остановка процесса. При желании можно перехватить эти сигналы, но для этого редко бывает необходимость.






Этот сигнал вновь запускает остановленный процесс. Если процесс не остановлен, он игнорируется. При желании его можно перехватить, но опять-таки для большинства программ мало причин для осуществления этого. Продолжая наш пример, обработчик 


 для экранного редактора должен перед возвращением вернуть терминал обратно в посимвольный режим.

Когда процесс остановлен, любые другие посланные ему сигналы становятся ожидающими. Исключением является 


, который всегда доставляется процессу и который не может быть перехвачен, заблокирован или проигнорирован. В предположении, что были посланы сигналы кроме 


, по получении 


 ожидающие сигналы доставляются, а процесс продолжает выполнение после того, как они будут обработаны.




10.8.3. Родительский надзор: три различные стратегии



Как описано в разделе 9.1.1 «Создание процесса: 


», одним побочным эффектом вызова 


 является создание между процессами отношений родитель-потомок. Родительский процесс может ждать завершения одного или более из своих потомков и получить статус завершения порожденного процесса посредством одного из семейства системных вызовов 


.

Завершившиеся порожденные процессы, которых никто не ожидал, называются зомби (zombies). Обычно каждый раз при завершении порожденного процесса ядро посылает родительскому процессу сигнал 


[112 - Исторически системы BSD использовали имя 


, которое используется и POSIX. В System V есть сходный сигнал с именем 


. GNU/Linux определяет последний через 


 как первый — см. табл. 10.1 — Примеч. автора.]. Действием по умолчанию является игнорирование этого сигнала. В этом случае процессы зомби накапливаются до тех пор, пока родитель не вызовет 


 или не закончится сам. В последнем случае процессы зомби получают в качестве нового родителя системный процесс 


 (PID 1), который получает от них результаты как часть своей обычной работы. Сходным образом, активные потомки также получают родителем 


, и их результаты будут собраны при их завершении.




 используется для большего, чем уведомление о завершении потомка. Каждый раз при остановке потомка (посредством одного из обсужденных ранее сигналов управления заданиями) родителю также посылается 


. Стандарт POSIX указывает, что 


 «может быть послан» также, когда помок вновь запускается; очевидно, среди оригинальных Unix-систем имеются различия.

Сочетание флагов для поля 


  в 


 и использование 


 в качестве действия для 


 позволяет изменить способ обработки ядром остановок, возобновления или завершения потомков.

Как и с сигналами в общем, описанные здесь интерфейсы и механизмы сложны, поскольку они развивались с течением времени.




10.8.3.1. Плохие родители: полное игнорирование потомков


Простейшим действием, которое вы можете сделать, является изменение действия для 


 на 


. В этом случае завершившиеся потомки не становятся зомби. Вместо этого статус их завершения отбрасывается, и они полностью удаляются из системы.

Другой возможностью, дающей такой же результат, является использование флага 


. В коде:


































10.8.3.2. Снисходительные родители: минимальный надзор


В качестве альтернативы можно беспокоиться лишь о завершении потомка и не интересоваться простыми изменениями состояния (остановке и возобновлении). В этом случае используйте флаг 


 и установите обработчик сигнала, вызывающий 


 (или родственную ей функцию) для получения данных процесса.

В общем вы не можете ожидать получать по одному сигналу 


 на каждого завершающегося потомка. Следует считать, что 


 означает «завершился по крайней мере один потомок» и быть готовым собрать при обработке 


 сведения о как можно большем числе потомков.

Следующая программа, 


, блокирует 


 до тех пор, пока не будет готова восстановить потомков.







































































Массив потомков отслеживает ID порожденных процессов. Если элемент содержит 


, он не представляет необработанного потомка. (Его инициализируют строки 89–90 внизу) 


 указывает, сколько значений в 


 следует проверить.

























































































































Поскольку обработчики сигналов не должны вызывать функции семейства 


, мы предусмотрели для преобразования десятичного сигнала или номера PID в строку простую «вспомогательную» функцию 


. Это примитивно, но работает.




































































































































































































Строки 51 и 58 выводят «входное» и «завершающее» сообщения, так что мы можем ясно видеть, когда вызывается обработчик сигнала. Другие сообщения начинаются с ведущего символа TAB.

Главной частью обработчика сигнала является большой цикл, строки 52–77. Строки 53–54 проверяют на 


 и продолжают цикл, если текущий слот не используется.

Строка 57 вызывает 


 с PID текущего элемента 


. Мы предусмотрели опцию 


, которая заставляет 


 возвращаться немедленно, если затребованный потомок недоступен. Этот вызов необходим, так как возможно, что не все потомки завершились.

Основываясь на возвращенном значении, код предпринимает соответствующее действие. Строки 57–62 обрабатывают случай обнаружения потомка, выводя сообщение и помещая в соответствующий слот в 


 значение 


.

Строки 63–67 обрабатывают случай, когда затребованный потомок недоступен. В этом случае возвращается значение 0, поэтому выводится сообщение, и выполнение продолжается.

Строки 68–70 обрабатывают случай, при котором был прерван системный вызов. В этом случае самым подходящим способом обработки является 


 обратно на вызов 


. (Поскольку 


 блокирует все сигналы при вызове обработчика сигнала [строка 96], это прерывание не должно случиться. Но этот пример показывает, как обработать все случаи.)

Строки 71–76 обрабатывают любую другую ошибку, выводя соответствующее сообщение об ошибке.





























































































































































































Строки 89–90 инициализируют 


. Строка 92 инициализирует 


. Строки 94–97 настраивают и устанавливают обработчик сигнала для 


. Обратите внимание на использование в строке 94 


, тогда как строка 96 блокирует все сигналы при вызове обработчика.

Строки 99–100 создают набор сигналов, представляющих 


, а строка 102 устанавливает их в качестве маски сигналов процесса для программы.

Строки 104–109 создают пять порожденных процессов, каждый из которых засыпает на три секунды. По ходу дела они обновляют массив 


 и переменную 


.

Строка 111 дает затем потомкам шанс завершиться, заснув на еще больший промежуток времени. (Это не гарантирует, что порожденные процессы завершатся, но шансы довольно велики.)

Наконец, строки 113–114 выводят сообщение и приостанавливаются, заменив маску сигналов процесса, блокирующую 


, пустой маской. Это дает возможность появиться сигналу 


, что в свою очередь вызывает запуск обработчика сигнала. Вот что происходит:














































Обработчик сигнала собирает сведения о потомках за один проход.

Следующая программа, 


, сходна с 


. Разница в том, что она допускает появление сигнала 


 в любое время. Такое поведение увеличивает шанс получения более одного 


, но не гарантирует это. В результате обработчик сигнала все равно должен быть готов обработать в цикле несколько потомков.


























































































































































































Это идентично предыдущей версии за тем исключением, что у нас есть новая переменная, 


, указывающая, сколько имеется не опрошенных потомков. Строки 15 и 64 помечают новый код.


















































































































































Здесь код также почти идентичен. Строки 104 и 114 закомментированы из предыдущей версии, а строки 111, 116 и 119 добавлены. Удивительно, при запуске поведение меняется в зависимости от версии ядра!






































































































































































В данном примере на каждый процесс поступает ровно один 


! Хотя это прекрасно и полностью воспроизводимо на этой системе, это также необычно. Как на более раннем, так и на более позднем ядре и на Solaris программа получает один сигнал для более чем одного потомка:


























































ЗАМЕЧАНИЕ. В коде для 


 есть один важный дефект — состояние гонки. Взгляните еще раз на строки 106–112 в 


. Что случится, если 


 появится при исполнении этого кода? Массив 


 и переменные 


 и 


 могут оказаться разрушенными: код в 


 добавляет новый процесс, но обработчик сигнала вычитает один.

Этот пример кода является отличным примером критического раздела; он не должен прерываться при исполнении. Правильным способом работы с этим кодом является заключение его между вызовами, которые сначала блокируют, а затем разблокируют 


.





10.8.3.3. Строгий родительский контроль


Структура 


 и перехватчик сигнала с тремя аргументами дают возможность узнать, что случилось с потомком. Для SIGCHLD поле 


 структуры 


 указывает причину посылки сигнала (остановка, возобновление, завершение порожденного процесса и т.д.). В табл. 10.5 представлен полный список значений. Все они определены в качестве расширения XSI стандарта POSIX.

Следующая программа, 


, демонстрирует использование структуры 


.































































Таблица 10.5. Значения 


 XSI для 







Строки 3–8 включают стандартные заголовочные файлы, строка 10 объявляет 


, которая имеет дело с изменениями состояния потомка, а функция 


 не изменилась по сравнению с предыдущим.



















































































































































































































Обработчик сигнала похож на показанные ранее. Обратите внимание на список аргументов (строка 39) и на то, что нет цикла.

Строки 49–54 обрабатывают завершение процесса, включая вызов 


 для вывода состояния.

Строки 55–60 обрабатывают случай неожиданного завершения потомка. Этого не должно происходить, поскольку обработчику сигнала передается специфическая для определенного порожденного процесса информация.

Строки 61–66 представляют для нас интерес: возвращаемое значение для изменений состояния равно 0. 


 имеет дело с деталями (строка 66).

Строки 67–69 обрабатывают прерывания, а строки 70–75 распоряжаются ошибками














































Функция 


 обрабатывает поведение порожденного процесса, предпринимая действия для уведомления родителя[113 - Возможно, лучшим именем для функции было бы 


 [ребенок_в_школе] — Примеч. автора.]. Строка 84 посылает 


, что может вызвать получение родителем события 


. Строка 85 посылает 


, который останавливает процесс (сигнал не может быть перехвачен) и вызывает для родителя событие 


. Когда родитель возобновляет порожденный процесс, последний выводит сообщение, что он снова активен, а затем завершается с известным статусом завершения.

































































































































































Программа 


 все устанавливает. Строки 100–103 помещают на место обработчик. Строка 100 устанавливает флаг 


 таким образом, что используется обработчик с тремя аргументами. Строки 105–108 блокируют 


.

Строка 110 создает порожденный процесс. Строки 113–117 продолжаются в родителе, используя для ожидания входящих сигналов 


.


























































































































































































Посредством функции 


 родитель обрабатывает изменение состояния в порожденном процессе, 


 вызывается, когда изменяется состояние и когда порожденный процесс завершился.

Строки 130–133 обрабатывают случай, когда потомок остановился; родитель возобновляет его, посылая 


.

Строки 135–137 выводят уведомление о возобновлении потомка. Это событие на системах GNU/Linux не происходит, и стандарт POSIX использует в этом случае невыразительный язык, просто говоря, что это событие может появиться, а не появится.

Строки 139–145 обрабатывают случай, когда порожденный процесс завершается, выводя статус завершения. Для этой программы родитель также все сделал, поэтому код завершается, хотя в более крупной программе это не то действие, которое должно быть сделано.

Другие случаи более специализированные. В случае события 


 для получения дополнительных сведений было бы полезным значение 


, заполненной функцией 


.

Вот что происходит при запуске:
























































К сожалению, поскольку нет способа гарантировать доставку по одному 


 на каждый процесс, ваша программа должна быть готова восстановить несколько потомков за один проход.




10.9. Сигналы, передающиеся через 


 и 





Когда программа вызывает 


, ситуация с сигналами в порожденном процессе почти идентична ситуации в родительском процессе. Установленные обработчики остаются на месте, заблокированные сигналы остаются заблокированными и т.д. Однако, любые ожидающие в родителе сигналы в потомке сбрасываются, включая установленный с помощью 


 временной интервал. Это просто, и это имеет смысл.

Когда процесс вызывает одну из функций 


, положение в новой программе следующее:

• Сигналы с установленным действием по умолчанию остаются с этим действием по умолчанию.

• Все перехваченные сигналы сбрасываются в состояние с действием по умолчанию.

• Сигналы, которые игнорируются, продолжают игнорироваться. Особым случаем является 


. Если 


 до вызова 


 игнорировался, он может игнорироваться также и после вызова. В качестве альтернативы для него может быть восстановлено действие по умолчанию. То, что происходит на самом деле, стандартом POSIX намеренно не определяется. (Справочные страницы GNU/Linux не определяют, что делает Linux, и поскольку POSIX оставляет это не определенным, любой код, который вы пишете для использования 


, должен быть подготовлен для обработки любого случая.)

• Сигналы, заблокированные до вызова 


, остаются заблокированными и после вызова. Другими словами, новая программа наследует маску сигналов существующего процесса.

• Любые ожидающие сигналы (те, которые появились, но были заблокированы) сбрасываются. Новая программа не может их получить.

• Временной интервал, остающийся для 


, сохраняется на своем месте. (Другими словами, если процесс устанавливает 


, а затем непосредственно вызывает 


, новый образ в конечном счете получит 


. Если он сначала вызывает 


, родитель сохраняет установки 


, тогда как потомок, вызывающий 


, не сохраняет.



ЗАМЕЧАНИЕ. Многие, если не все. программы предполагают, что сигналы инициализированы действиями по умолчанию и что заблокированных сигналов нет. Таким образом, особенно если не вы писали программу, запускаемую с помощью 


, можно разблокировать перед вызовам 


 все сигналы





10.10. Резюме


«Наша история до настоящего времени, эпизод III»

    - Арнольд Роббинс (Arnold Robbins) -

• Интерфейсы обработки сигналов развились от простых, но подверженных состояниям гонок, до сложных, но надежных. К сожалению, множественность интерфейсов затрудняет их изучение по сравнению с другими API Linux/Unix.

• У каждого сигнала есть связанное с ним действие. Действие может быть одним из следующих: игнорирование сигнала; выполнение действия системы по умолчанию или вызов предоставленного пользователем обработчика. Действие системы по умолчанию, в свою очередь, является одним из следующих: игнорирование сигнала, завершение процесса; завершение процесса с созданием его образа; остановка процесса или возобновление процесса, если он остановлен.

• 


 и 


 стандартизованы ISO С. 


 управляет действиями для определенных сигналов; 


 посылает сигнал текущему процессу. Остаются ли обработчики сигналов установленными после вызова или сбрасываются для действия по умолчанию, зависит от реализации, 


 и 


 являются простейшими интерфейсами, для многих приложений их достаточно.

• POSIX определяет функцию 


, которая подобна 


, но гарантирует, что обработчик остается установленным.

• Действия, происходящие после возвращения из обработчика, варьируют в зависимости от системы. Традиционные системы (V7, Solaris, возможно, и другие) восстанавливают действие сигнала по умолчанию. На этих системах прерванный системный вызов возвращает -1, устанавливая в 


 значение 


. Системы BSD оставляют обработчик установленным и возвращают -1 с 


, содержащим 


, лишь в случае, когда не было перемещения данных; в противном случае, системный вызов запускается повторно.

• GNU/Linux придерживается POSIX, который похож, но не идентичен с BSD. Если не было перемещения данных, системный вызов возвращает -1/


. В противном случае он возвращает объем перемещенных данных. Поведение BSD «всегда повторный запуск» доступно через интерфейс 


, но он не является действием по умолчанию.

• Обработчики сигналов, используемые с 


, подвержены состояниям гонок. Внутри обработчиков сигналов должны использоваться исключительно переменные типа 


. (В целях упрощения в некоторых из наших примеров мы не всегда следовали этому правилу.) Таким же образом, для вызова из обработчика сигналов безопасными являются лишь функции из табл. 10.2.

• Первоначальной попыткой создания надежных сигналов был API сигналов System V Release 3 (скопированный из BSD 4.0). Не используйте его в новом коде.

• POSIX API содержит множество компонентов:

  • маску сигналов процесса, перечисляющую текущие заблокированные сигналы;

  • тип 


 для представления масок сигналов, и функции 


, 


, 


, 


 и 


 для работы с ними;

  • функцию 


 для установки и получения маски сигналов процесса,

  • функцию 


 для получения набора ожидающих сигналов;

  • API 


 и 


 во всем их великолепии.

Все эти возможности вместе используют блокирование сигналов и маску сигналов процесса для предоставления надежных сигналов. Более того, через различные флаги можно получить повторно запускаемые системные вызовы и более подходящие обработчики сигналов, которые получают большую информацию о причине, вызвавшей определенный сигнал (структура 


).

• Механизмами POSIX для посылки сигналов являются 


 и 


. Они отличаются от 


 в двух отношениях: (1) одни процесс может послать сигнал другому процессу или целой группе процессов (конечно, с проверкой прав доступа), и (2) посылка сигнала 0 ничего не посылает, но осуществляет проверку. Таким образом, эти функции предоставляют способ проверки наличия определенного процесса или группы процессов и возможность посылки ему (им) сигнала.

• Сигналы могут использоваться в качестве механизма IPC, хотя такой способ является плохим способом структурирования приложения, подверженным состояниям гонок. Если кто-то держит приставленным к вашей голове ружье, чтобы заставить вас работать таким способом, для правильной работы используйте тщательное блокирование сигналов и интерфейс 


.

• 


 и системный вызов 


 предоставляют низкоуровневый механизм для уведомления о прошествии определенного числа секунд, 


 приостанавливает процесс, пока не появятся какие-нибудь сигналы, 


 использует их для помещения процесса в спящее состояние на заданный период времени: 


 и 


 не должны использоваться вместе. Сама 


 создает состояние гонки; вместо этого нужно использовать блокирование сигналов и 


.

• Сигналы управления заданиями реализуют управление заданиями для оболочки. Большую часть времени следует оставлять их с установленными действиями по умолчанию, но полезно понимать, что иногда имеет смысл их перехватывать.

• Перехват 


 позволяет родителю узнать, что делает порожденный им процесс. Использование '


' (или 


 с 


) вообще игнорирует потомков. Использование 


 с 


 предоставляет уведомления лишь о завершении. В последнем случае, независимо от того, заблокирован 


 или нет, обработчики сигналов для 


 должны быть готовы немедленно обработать несколько потомков. Наконец, использование 


 без 


 с обработчиком сигналов с тремя аргументами дает вам причину получения сигнала.

• После 


 положение сигналов в порожденном процессе остается тем же самым, за исключением сброса ожидающих сигналов и установленных интервалов таймера. После 


 положение несколько более сложно — в сущности, все, что может быть оставлено, остается; для всего остального восстанавливаются значения по умолчанию.




Упражнения


1. Реализуйте 


 с использованием 


.

2. Если у вас не установлен GNU/Linux, запустите на своей системе 


. Является ли ваша система традиционной или BSD?

3. Реализуйте функции System V Release 3 


, 


, 


, 


 и 


, использовав 


 и другие подходящие функции из POSIX API.

4. Потренируйте свои навыки в жонглировании битами. В предположении, что сигнал 0 отсутствует и что имеется не более 31 сигналов, предусмотрите 


 для 


 и напишите 


, 


, 


, 


 и 


.

5. Еще немного потренируйте свои навыки жонглирования битами. Повторите предыдущее упражнение, на этот раз предположив, что наибольшим сигналом является 42.

6. Теперь, когда вы сделали предыдущие два упражнения, найдите 


 и др. в своем заголовочном файле 


. (Может потребоваться поискать их; они могут быть в 


 файлах, указанных в 


.) Являются ли они макросами или функциями?

7. В разделе 10.7 «Сигналы для межпроцессного взаимодействия» мы упомянули, что код изделия должен работать с начальной маской сигналов процесса, добавляя и удаляя блокируемые сигналы в вызове 


. Перепишите пример, используя для этого соответствующие вызовы.

8. Напишите свою собственную версию команды 


. Интерфейс должен быть таким:






Если сигнал не указан, программа должна посылать 


.

9. Как вы думаете, почему в современных оболочках, таких, как Bash и ksh93, 


 является встроенной командой?

10. (Трудное) Реализуйте 


, используя 


, 


 и 


. Что случится, если обработчик сигнала для 


 уже установлен?

11. Поэкспериментируйте с 


, изменяя интервал времени, на который засыпает каждый потомок, и организуя достаточное число вызовов 


 для сбора сведений о всех потомках.

12. Попробуйте заставить 


 испортить информацию в 


, 


 и 


. Теперь добавьте вокруг критического раздела блокирование/разблокирование и посмотрите, есть ли разница.




Глава 11

Права доступа и ID пользователей и групп



Linux, вслед за Unix, является многопользовательской системой. В отличие от большинства операционных систем для персональных компьютеров,[114 - MacOS X и Windows XP обе являются многопользовательскими системами, но это довольно недавние разработки — Примеч. автора.] в которых имеется лишь один пользователь и в которых, кто бы ни находился перед компьютером, он имеет полный контроль, Linux и Unix различают файлы и процессы по владельцам и группам, которым они принадлежат. В данной главе мы исследуем проверку прав доступа и рассмотрим API для получения и установки идентификаторов владельцев и групп.




11.1. Проверка прав доступа



Как мы видели в разделе 5.4.2 «Получение информации о файлах», файловая система хранит идентификаторы владельца и группы файла в виде числовых значений; это типы 


 и 


 соответственно. Для краткости мы используем для «идентификатора владельца (пользователя)» и «идентификатора группы» сокращения UID и GID соответственно.

У каждого процесса есть несколько связанных с ним идентификаторов пользователя и группы. Для проверки прав доступа в качестве упрощения используется один определенный UID и GID; когда UID процесса совпадает с UID файла, биты прав доступа пользователя файла диктуют, что может сделать процесс с файлом. Если они не совпадают, система проверяет GID процесса с GID файла; при совпадении используются права доступа группы; в противном случае, используются права доступа для «остальных».

Помимо файлов, UID определяет, как один процесс может повлиять на другой путем посылки сигналов. Сигналы описаны в главе 10 «Сигналы».

Наконец, особым случаем является суперпользователь, 


. 


 идентифицируется по UID, равным 0. Когда у процесса UID равен 0, ядро позволяет ему делать все, что он захочет: читать, записывать или удалять файлы, посылать сигналы произвольным процессам и т.д. (POSIX в этом отношении более непонятный, ссылаясь на процессы с «соответствующими привилегиями». Этот язык, в свою очередь, просочился в справочные страницы GNU/Linux и справочное руководство GLIBC online Info manual. Некоторые операционные системы действительно разделяют привилегии пользователей, и Linux также движется в этом направлении. Тем не менее, в настоящее время «соответствующие привилегии» означает просто процессы с UID, равным 0.)




11.1.1. Действительные и эффективные ID


Номера UID и GID подобны персональным удостоверениям личности. Иногда вам может понадобиться более одного удостоверяющего документа. Например, у вас могут быть водительские права или правительственное удостоверение личности[115 - Хотя в Соединенных Штатах нет официальных удостоверений личности, во многих странах они имеются — Примеч. автора.]. Вдобавок, ваш университет или компания могли выдать вам свои удостоверения личности. То же самое относится и к процессам; они имеют при себе множество следующих номеров UID и GID:

Действительный ID пользователя

UID пользователя, породившего процесс.

Эффективный ID пользователя

UID, использующийся при большинстве проверок прав доступа. В большинстве случаев эффективный и действительный UID являются одним и тем же. Эффективный UID может отличаться от действительного при запуске, если установлен бит setuid файла исполняемой программы и файл не принадлежит пользователю, запускающему программу. (Вскоре будут дополнительные сведения.)

Сохраненный set-user ID

Первоначальный эффективный UID при запуске программы (после выполнения exec.) Имеет значение при проверке прав доступа, когда процессу нужно менять действительный и эффективный UID в ходе работы. Эта концепция пришла из System V.

Действительный ID группы

GID пользователя, создавшего процесс, аналогично действительному UID.

Эффективный ID группы

GID, использующийся для проверки прав доступа, аналогично эффективному GID.

Сохраненный set-group ID

Первоначальный эффективный GID при запуске программы, аналогично сохраненному set-user ID.

Набор дополнительных групп

4.2 BSD ввело понятие набора групп. Помимо действительного и эффективного GID. у каждого процесса есть некоторый набор дополнительных групп, которым он принадлежит в одно и то же время. Таким образом, когда проверка прав доступа осуществляется для группы файла, ядро проверяет не только эффективный GID, но также и все GID в наборе групп.

Каждый процесс может получить все из этих значений. Обычный (не принадлежащий суперпользователю) процесс может переключать свои действительные и эффективные ID пользователя и группы. Процесс 


 (с эффективным UID, равным 0) может также устанавливать значения таким образом, как ему нужно (хотя это может оказаться односторонней операцией)




11.1.2. Биты Setuid и Setgid


Биты setuid и setgid[116 - Денис Ричи (Dennis Ritchie), создатель С и соавтор Unix, получил патент для бита setuid: Protection of Data File Contents (Защита содержимого файла данных), номер патента США 4135240. См. 


, а также 


. AT&T передала патент общественности, разрешив всем использовать свою технологию — Примеч. автора.] в правах доступа к файлу заставляют процесс принять эффективный UID или GID, который отличается от действительного. Эти биты накладываются на файл вручную с помощью команды 


:





















Наличие символа s в месте, где обычно находится символ x, указывает на присутствие битов setuid/setgid.

Как упоминалось в разделе 8.2.1 «Использование опций монтирования», опция 


 команды mount для файловой системы предотвращает обращение ядра к битам setuid и setgid. Это мера безопасности; например, пользователь с домашней системой GNU/Linux мог бы вручную изготовить гибкий диск с копией исполняемого файла оболочки с setuid, устанавливающей в 


. Но если система GNU/Linux в офисе или лаборатории монтирует файловые системы с гибкими дисками с опцией 


, запуск этой оболочки не предоставит доступа с правами 


[117 - Безопасность для систем GNU/Linux и Unix является глубокой темой сама по себе. Это просто пример. см. раздел 11.9 «Рекомендуемая литература» — Примеч. автора.].

Каноническим (и возможно, злоупотребляемым) примером программы с setuid является игровая программа. Представьте, что вы написали по-настоящему крутую игру и хотите позволить пользователям системы играть в нее. Игра содержит файл счета, в котором перечислены высшие достижения.

Если вы не являетесь системным администратором, вы не можете создать отдельную группу только для тех пользователей, которым разрешено играть в игру и тем самым записывать в файл счета. Но если вы сделаете файл доступным для записи любому, чтобы каждый смог поиграть в игру, тогда каждый сможет также сжульничать и поместить наверх любое имя.

Однако, заставив программу устанавливать setuid на вас, пользователи, запускающие игру, получат ваш UID в качестве своего эффективного UID. Игровая программа сможет при этом открывать и обновлять файл счета по мере необходимости, но произвольные пользователи не смогут прийти и отредактировать его. (Вы подвергаете себя также большинству опасностей при программировании setuid; например, если в игровой программе есть дыра, которую можно использовать для запуска оболочки, действующей от вашего имени, все ваши файлы оказываются доступными для удаления или изменения. Это действительно устрашающая мысль.)

Та же логика применяется к программам setgid, хотя на практике программы с setgid используются гораздо реже, чем с setuid (Это также плохо; многие вещи, которые делаются программами с setuid 


, легко могут быть сделаны программами с setgid или программами, которые вместо этого устанавливают setuid на обычного пользователя[118 - Одной из программ, разработанных с этой целью, является GNU userv (


) — Примеч. автора.]).




11.2. Получение ID пользователя и группы


Получение от системы сведений о UID и GID просто. Функции следующие:

































Функции:






Возвращает действительный UID.






Возвращает эффективный UID.






Возвращает действительный GID.






Возвращает эффективный GID.






Заполняет до 


 элементов массива 


 из набора дополнительных групп процесса. Возвращаемое значение является числом заполненных элементов или -1 при ошибке. Включается ли в набор также эффективный GID, зависит от реализации. На системах, совместимых с POSIX, можно передать в size нулевое значение; в этом случае 


 возвращает число групп в наборе групп процесса. Затем можно использовать это значение для динамического выделения массива достаточного размера. На не-POSIX системах константа 


 определяет максимально допустимый размер для массива 


. Эту константу можно найти в современных системах в 


, а в старых системах в 


. Вскоре мы представим пример.

Возможно, вы заметили, что для получения сохраненных значений set-user ID или set-group ID нет вызовов. Это просто первоначальные значения эффективных UID и GID. Таким образом, для получения шести значений в начале программы вы можете использовать код наподобие этого:
















































Вот пример получения набора групп. В качестве расширения 


 предоставляет доступ на уровне 


 к значениям действительных и эффективных UID и GID и дополнительному набору групп. Для этого он должен получить набор групп. Следующая функция из 


 в дистрибутиве 


 3.1.3:


















































































































































Переменные 


 и 


 глобальные; их объявления не показаны. Макрос 


 (строка 1102) является типом для использования со вторым аргументом: на системе POSIX это 


, в противном случае 


.

Строки 1085 и 1107 заключают в скобки все тело функции; на древних системах, в которых вообще нет наборов групп, тело функции пустое.

Строки 1086–1088 обрабатывают не-POSIX системы; до компиляции программы механизмом конфигурации определяется 


. В этом случае код использует 


, как описано выше. (Даже а 2004 г. такие системы все еще существуют и используются; хотя, слава богу, число их уменьшается.)

Строки 1089–1094 для систем POSIX, причем нулевой параметр 


 используется для получения числа групп.

Строки 1096–1099 осуществляют проверку ошибок. Если возвращаемое значение 0, дополнительных групп нет, поэтому 


 просто сразу возвращается.

Наконец, строка 1102 для выделения массива достаточного размера использует 


 (посредством проверяющего ошибки макроса-оболочки, см. раздел 3.2.1.8 «Пример: чтение строк произвольной длины»). Затем строка 1104 заполняет этот массив.




11.3. Проверка для действительного пользователя: 





В большинстве случаев значения эффективного и действительного UID и GID являются одними и теми же. Таким образом, не имеет значения, что проверка прав доступа к файлу осуществляется по эффективному ID, а не по действительному.

Однако, при написании приложения с setuid или setgid вы можете иногда захотеть проверить, является ли операция, разрешенная для эффективных UID и GID, также разрешенной для действительных UID и GID. В этом заключается задача функции 


:













Аргумент 


 является путем к файлу для проверки действительных UID и GID. 


 содержит объединение побитовым ИЛИ одного или нескольких из следующих значений:




Действительный UID/GID разрешает чтение файла.




Действительный UID/GID разрешает запись в файл.




Действительный UID/GID разрешает исполнение файла или, в случае каталога, поиск в каталоге.




Проверка существования файла.

Проверяется каждый компонент в имени пути, а на некоторых реализациях при проверке для 


 может действовать, как если бы был установлен 


, даже если в правах доступа к файлу не установлены биты, разрешающие исполнение. (Странно, но верно: в этом случае предупрежденный вооружен.) В Linux нет такой проблемы.

Если 


 является символической ссылкой, 


 проверяет файл, на который указывает символическая ссылка.

Возвращаемое значение равно 0, если операция для действительных UID и GID разрешена, и -1 в противном случае. Соответственно, если 


 возвращает -1, программа с setuid может запретить доступ к файлу, с которым в противном случае эффективный UID/GID смог бы работать:


























По крайней мере для серии ядра Linux 2.4, когда тест X_OK применяется к файловой системе, смонтированной с опцией 


 (см. раздел 8.2.1 «Использование опций монтирования»), тест успешно проходится, если права доступа к файлу имеют разрешение на исполнение. Это верно, несмотря на то, что попытка выполнить файл завершилась бы неудачей.



ЗАМЕЧАНИЕ. Хотя использование 


 перед открытием файла является обычной практикой, существует состояние гонки открываемый файл может быть сброшен при подкачке между проверкой функцией 


 и вызовом 


. Необходимо осмотрительное программирование, такое, как проверка владельца и прав доступа с помощью 


 и 


 до и после вызовов 


 и 


.


Например, программа 


 проверяет действительность имен путей. GNU версия использует 


 для проверки того, что компоненты каталога данного пути действительны. Из Coreutils 


:

































































































































































Код прост. Строки 252–253 проверяют, существует ли файл. Если 


 завершится неудачей, файл не существует. Строки 255–259 удостоверяют, что файл в самом деле является каталогом.

Комментарий в строках 261–264 объясняет использование 


. Проверки битов 


 недостаточно: файл может находиться в файловой системе, которая смонтирована только для чтения, в удаленной файловой системе или в файловой системе, не принадлежащей Linux или Unix, или у файла могут быть атрибуты, предотвращающие доступ. Таким образом, лишь ядро может в действительности сказать, будет ли работать 


. Строки 265–272 осуществляют проверку, выдавая сообщение об ошибке, определяемое значением 


 (строки 267–270).




11.4. Проверка для эффективного пользователя: 


 (GLIBC)


GLIBC предоставляет дополнительную функцию, которая работает подобно 


, но проверяет в соответствии с эффективными UID, GID и набором групп:













Аргументы и возвращаемое значение имеют тот же смысл, как для 


. Когда равны эффективный и действительный UID и эффективный и действительный GID, 


 вызывает для осуществления теста 


. Это имеет то преимущество, что ядро может проверить файловую систему только для чтения или другие условия, которые не отражаются в правах доступа и владении файлами.

В противном случае 


 сравнивает значения владельца и группы файла со значениями эффективных UID и GID и набора групп, используя соответствующие биты прав доступа. Этот тест основан на сведениях о файле от 


.

Если вы пишете переносимую программу, но предпочитаете использовать этот интерфейс, достаточно просто извлечь исходный файл из архива GLIBC и приспособить его для общего использования.




11.5. Установка дополнительных битов доступа для каталогов



На современных системах setgid и «липкий» биты имеют особое значение при применении к каталогам.




11.5.1. Группа по умолчанию для новых файлов и каталогов


В оригинальной системе Unix, когда 


 или 


 создавали новый файл, он получал эффективные UID и GID создавшего их процесса.

V7, BSD вплоть до BSD 4.1 и System V вплоть до Release 3 все трактовали каталоги как файлы. Однако, с добавлением дополнительного набора групп в BSD 4.2 способ создания новых каталогов изменился: новые каталоги наследовали группу родительского каталога. Более того, новые файлы также наследовали ID группы родительского каталога, а не эффективный GID создающего процесса.

Идея, лежащая в основе множества групп и каталогов, которые работают таким способом, была в усилении группового взаимодействия. У каждого проекта организации, использующего систему, была бы отдельная назначенная ему группа. Для каждой такой группы в группе этого проекта был бы каталог верхнего уровня, и все файлы проекта имели бы доступ на чтение и запись (а при необходимости и на исполнение). Вдобавок, новые файлы автоматически получают группу родительского каталога. Состоя одновременно в нескольких группах (наборе групп), пользователь мог бы как угодно перемещаться между проектами с помощью простой команды 


, а все файлы и каталоги сохраняли бы свою надлежащую группу.

Что происходит на современных системах? Ну, это еще один из немногих случаев, когда можно поймать двух зайцев. SunOS 4.0 придумал механизм, который был включен в System V Release 4; сегодня он используется по крайней мере в Solaris и GNU/Linux. Эти системы придают биту setgid родительского каталога нового файла или каталога следующее значение:

Бит setgid родительского каталога сброшен

Новые файлы и каталоги получают эффективный GID создающего процесса.

Бит setgid родительского каталога установлен

Новые файлы и каталоги получают GID родительского каталога. Новые каталоги наследуют также установленный бит setgid.

(До SunOS 4.0 бит setgid для каталогов не имел определенного значения.) Следующий сеанс показывает бит setgid в действии:










































































































Файловые системы 


 и 


 для GNU/Linux работают указанным способом. Вдобавок они поддерживают специальные опции монтирования 


 и 


, которые делают «использование группы родительского каталога» семантикой по умолчанию. (Два имени означают одно и то же.) Другими словами, когда используются эти опции монтирования, в родительских каталогах не нужно устанавливать свои биты seigid.

Противоположными опциями монтирования являются 


 и 


. Это поведение по умолчанию; однако, бит setgid. если он есть, все равно учитывается. (Здесь также оба имени означают одно и то же.)

POSIX устанавливает, что новые файлы и каталоги наследуют либо эффективный GID создающего процесса, либо группу родительского каталога. Однако, реализации должны предусмотреть способ заставить новые каталоги наследовать группу родительского каталога. Более того, стандарт рекомендует, чтобы приложения не полагались на то или иное поведение, но в случаях, когда это имеет значение, использовали 


 для принудительного назначения желательного GID для группы нового файла или каталога.




11.5.2. Каталоги и «липкий» бит


«Шерман, установите машину времени для 1976 г.»

    - М-р Пибоди (Mr. Peabody) -

«Липкий» бит ведет начало от версий Unix для PDP-11, он использовался с обычными исполняемыми файлами[119 - На ум приходят образы счастливых юных программ их лица и руки, запачканные шоколадом — Примеч. автора.]. Этот бит использовался с программами, которые предназначались для интенсивного использования, такими, как оболочка и редактор. Когда у программы был установлен этот бит, ядро хранило копию исполняемого кода программы на устройстве подкачки, из которого ее можно было быстро загрузить в память для повторного использования. (Загрузка из файловой системы занимает больше времени образ на устройстве подкачки хранился в смежных дисковых блоках, тогда как образ в файловой системе мог быть разбросан по всему диску). Исполняемые образы были «приклеены» к устройству подкачки, отсюда и название.

Таким образом, даже если программа в настоящее время не использовалась, предполагалось, что она вскоре могла быть использована другим пользователем, поэтому она могла быть быстро загружена.

В современных системах значительно более быстрые дисковое оборудование и память, чем в давнишней PDP-11. Они используют также методику, называемую подкачка по требованию, для загрузки в память лишь тех частей исполняемой программы, которые выполняются. Таким образом, сегодня «липкий» бит обычных исполняемых файлов не служит никаким целям и на самом деле ни на что не влияет.

Однако, в разделе 1.1.2 «Каталоги и имена файлов» мы упомянули, что «липкий» бит в каталоге, запись в который в других отношениях разрешена, предотвращает удаление файлов из этого каталога и их переименование любым пользователем, кроме владельца файла или 


. Вот пример:







































































Основным назначением этой особенности является как раз использование в таких каталогах, как 


, куда хотят помещать свои файлы множество пользователей. С одной стороны, каталог должен иметь права записи для всех, чтобы каждый мог создавать там свои файлы. С другой стороны, раз запись разрешена для всех, любой пользователь может удалять файлы всех остальных пользователей! «Липкий» бит каталога красиво решает эту проблему. Для добавления к файлу или каталогу «липкого» бита используйте '


':





















В заключение, обратите внимание, что владелец каталога также может удалить файлы, даже если они не принадлежат ему.




11.6. Установка действительных и эффективных ID



Все становится интереснее, когда процессу приходится менять значения UID и GID. Установка набора групп проста. Изменение значений действительных и эффективных UID и GID сложнее.




11.6.1. Изменение набора групп


Функция 


 устанавливает новый набор групп:























Параметр 


 указывает, сколько элементов в массиве 


. Возвращаемое значение равно 0, если все было нормально, и -1 с установленным errno в противном случае.

В отличие от функций для манипулирования значениями действительных и эффективных UID и GID, эту функцию может вызвать лишь процесс, действующий как 


. Это один пример того, что POSIX называет привилегированной операцией; сама она как таковая не стандартизуется POSIX.




 используется любой программой, которая осуществляет регистрацию в системе, такой как 


 для регистрации в консоли и 


 для удаленной регистрации с помощью 


.




11.6.2. Изменение действительного и эффективного ID


Работа с двумя различными ID пользователей представляет для программиста приложения проблему. Могут быть вещи, которые программе нужно сделать, работая с эффективным UID, а другие вещи — работая с действительным UID.

Например, до того, как в системах Unix появилось управление заданиями, многие программы предоставляли переходы в оболочку, т.е. способ запуска команды или интерактивной оболочки из текущей программы. Хорошим примером этого является редактор 


: набор командной строки, начинающейся с '


', запускает оставшуюся часть строки в качестве команды оболочки. Набрав '


', вы получаете интерактивную оболочку. (Это работает до сих пор — попробуйте!) Предположим, описанная ранее гипотетическая игровая программа также предоставляет переход в оболочку: она должна быть запущена от имени действительного пользователя, а не эффективного. В противном случае, редактирование файла счета или многие гораздо худшие вещи становятся для игрока тривиальной задачей!

Таким образом, имеется явная потребность в возможности замены эффективного UID действительным UID. Более того, полезна возможность обратного переключения эффективного UID на первоначальный. (В этом причина необходимости наличия сохраненного set-user ID; появляется возможность восстановления первоначальных привилегий, которые были у процесса при его запуске.)

Как и для множества Unix API, различные системы решили проблему разными способами, иногда с использованием одного и того же API, но с другой семантикой, а иногда введением другого API. Погружение в исторические подробности годится лишь для создания головной боли, поэтому мы не будем с этим беспокоиться. Вместо этого мы рассмотрим, что предоставляет POSIX и как работает каждый API. Более того, наше обсуждение фокусируется на значениях действительных и эффективных UID; значения GID работают аналогичным образом, поэтому мы не будем хлопотать с повторением подробностей для этих системных вызовов. Функции следующие:

























































Есть три набора функций. Первые два были созданы POSIX:






Эта функция устанавливает лишь эффективный UID. Обычный пользователь (не 


) может установить в качестве ID лишь в значения действительного, эффективного или сохраненного set-user ID. Приложения, которые будут переключать эффективный UID. должны использовать исключительно эту функцию.

Процесс с эффективным UID, равным нулю, может установить в качестве эффективного UID любое значение. Поскольку в качестве значения эффективного UID можно установить также сохраненный set-user ID, процесс может восстановить свои привилегии root с помощью другого вызова 


.






Эта функция делает для эффективного ID группы то, что 


 делает для эффективного ID пользователя.

Следующий набор функций предлагает первоначальный API Unix для изменения действительных и эффективных UID и GID. В модели POSIX эти функции являются тем. что должна использовать программа с setuid-root для постоянного изменения действительного или эффективного UID:






Для обычного пользователя эта функция также устанавливает лишь эффективный UID. Как и для 


, значением эффективного UID может быть любое из текущих значений действительного, эффективного иди сохраненного set-user ID. Изменение не постоянно; эффективный UID может быть изменен последующим вызовом на другое значение (из того же исходного набора).

Однако, для 


 эта функция устанавливает в данное значение все три значения для действительного, эффективного и сохраненного set-user ID. Более того, изменение постоянно; прежнее ID нельзя восстановить. (Это имеет смысл: раз изменился сохраненный set-user ID, нет другого ID для восстановления.)






Эта функция делает для эффективного ID группы то же, что 


 делает для эффективного ID пользователя. Используется то же разграничение между обычными пользователями и 


.



ЗАМЕЧАНИЕ. Возможность изменения ID группы зависит от эффективного ID пользователя. Эффективный GID, равный 0, не имеет особых привилегий.


Наконец, POSIX представляет для исторической совместимости две функции из BSD 4.2. В новом коде их лучше не использовать. Однако, поскольку вы, вероятно, увидите использующий эти функции старый код, мы их здесь опишем.






Устанавливает данные значения в качестве действительного и эффективного UID. Значение -1 для 


 или 


 оставляет соответствующие ID без изменения. (Это похоже на 


; см. раздел 5.5.1 «Смена владельца файла: 


, 


 и 


».)




 может устанавливать в качестве действительного и эффективного ID любое значение. В соответствии с POSIX пользователи, не являющиеся 


, могут изменять лишь эффективный ID; то, что случится, если обычный пользователь попытается изменить действительный UID, «не определено». Однако, справочная страница GNU/Linux setreuid(2) разъясняет поведение Linux, в качестве действительного UID может быть установлено значение действительного или эффективного UID, а в качестве эффективного UID может быть значение действительного, эффективного или сохраненного set-user ID. (Для других систем см. справочную страницу setreuid(2).)






Делает для действительных и эффективных ID групп то же, что 


 делает для действительных и эффективных ID пользователя. Используется то же разграничение между обычными пользователями и 


.

Сохраненный set-user ID в модели BSD не существует, поэтому лежащей в основе 


 и 


 идеей было упростить переключение между действительным и эффективным ID:






Однако, с принятием POSIX модели сохранения set-user ID и функций 


 и 


 функции BSD не следует использовать в новом коде. Даже документация BSD 4.4 помечает эти функции как устаревшие, рекомендуя вместо них 


/


 и 


/


.




11.6.3. Использование битов setuid и setgid


Есть важные случаи, в которых действующая как 


 программа должна безвозвратно изменить все три значения действительного, эффективного и сохраненного set-user ID на ID обычного пользователя. Наиболее очевидным случаем является программа 


, которую вы используете (либо непосредственно, либо удаленно) каждый раз при регистрации в системе GNU/Linux или Unix. Имеется иерархия программ, как очерчено на рис. 11.1.




Рис. 11.1. От 


 через 


 через 


 к shell

Код для 


 слишком сложен, чтобы показать здесь, поскольку он имеет дело с рядом задач, не имеющих отношения к текущему обсуждению. Но мы можем очертить шаги, которые происходят во время регистрации, следующим образом:

1. 


 является самым первым процессом. Его PID равен 1. Все другие процессы являются его потомками. Ядро вручную создает процесс 1 во время загрузки и запускает в нем 


. Он действует с действительным и эффективным UID, равными нулю, т.е. как 


.

2. 


 читает 


, который, помимо прочих вещей, сообщает 


 о том, на каких устройствах он должен запустить процесс 


. Для каждого такого устройства (такого, как консоль, последовательные терминалы или виртуальные консоли в системе GNU/Linux) 


 порождает новый процесс. Этот новый процесс использует затем 


 для запуска 


 (от «get tty» («получить tty», т.е. терминал)). На многих системах GNU/Linux эта команда называется 


. Программа открывает устройство, сбрасывает его состояние и выводит приглашение '


'.

3. По получении регистрационного имени 


 выполняет 


. Программа 


 ищет имя пользователя в файле паролей, запрашивает пароль и проверяет его. Если пароль подходит, процесс 


 продолжается.

4. 


 изменяет домашний каталог пользователя, устанавливает начальное окружение, а затем устанавливает начальный набор открытых файлов. Он закрывает дескрипторы файлов, открывает терминал и использует 


 для копирования дескрипторов файла терминала в 0, 1 и 2. Вот откуда происходят дескрипторы уже открытых файлов стандартного ввода, стандартного вывода и стандартной ошибки.

5. Затем 


 использует 


 для установки дополнительного набора групп, 


 для установки значений действительного, эффективного и сохраненного set-group ID в соответствующее значение группы пользователя, и наконец, 


 для установки всех трех значений действительного, эффективного и сохраненного set-user ID в соответствующие значения для регистрирующегося пользователя. Обратите внимание, что вызов 


 должен быть последним для того, чтобы другие два вызова завершились успешно.

6. Наконец, 


 вызывает зарегистрированную оболочку пользователя. Оболочки в стиле Борна после этого читают файлы 


 и 


, если они существуют. Затем оболочка выводит приглашение.

Обратите внимание, как один процесс меняет свою сущность от системного процесса до процесса пользователя. Каждый потомок 


 начинается как копия 


. Используя 


, тот же самый процесс выполняет различные задания. Вызвав 


 для перехода от 


 к обычному пользователю, процесс в конечном счете поступает непосредственно для работы пользователя. Когда вы выходите из оболочки (посредством CTRL-D или 


), процесс попросту завершается. Затем 


 возобновляет цикл, порождая новый 


, который выводит новое приглашение '


'.



ЗАМЕЧАНИЕ. Открытые файлы остаются открытыми и доступными для использования, даже после изменения процессом своих UID или GID. Таким образом, программы с setuid должны заранее открыть все нужные файлы, изменить их ID на ID действительного пользователя и продолжить оставшуюся часть работы без дополнительных привилегий


В табл. 11.1 приведена сводка шести стандартных функций для манипулирования значениями UID и GID.



Таблица 11.1. Сводка API для установки действительных и эффективных ID[120 - E (Effective) эффективный ID, R (Real) действительный ID и S (Saved) сохраненный ID — Примеч. науч. ред.]







11.7. Работа со всеми тремя ID: 


 и 


 (Linux)


Linux предоставляет дополнительные системные вызовы, посредством которых вы можете непосредственно работать с действительными, эффективными и сохраненными ID пользователя и группы:



































Функции следующие:






Получает значения действительного, эффективного и сохраненного set-user ID. Возвращаемое значение 0 в случае успеха и -1 при ошибке, 


 указывает проблему.






Получает значения действительного, эффективного и сохраненного set-group ID. Возвращаемое значение 0 в случае успеха и -1 при ошибке, 


 обозначает проблему.






Устанавливает значения действительного, эффективного и сохраненного set-user ID соответственно. Когда значение параметра равно -1, соответствующий UID остается без изменения.

Когда процесс действует как 


, параметрами могут быть любые произвольные значения. Однако, использование ненулевого значения для 


 вызывает постоянную, безвозвратную утерю привилегии 


). В противном случае параметры должны быть одним из значений действительного, эффективного или сохраненного set-user ID.






Устанавливает значения действительного, эффективного и сохраненного set-group ID соответственно. Когда значение параметра равно -1, соответствующий GID остается без изменений.

Эта функция аналогична 


.

Функции 


 и 


 особенно ценны, поскольку их семантика ясно определена. Программист точно знает, каким может быть результат их вызова.

Более того, вызовы являются операциями типа «все или ничего»: они либо полностью успешны в осуществлении нужного изменения, либо терпят полную неудачу, оставляя текущее состояние как есть. Это повышает надежность, поскольку, опять-таки можно быть точно уверенным в том, что случилось.




11.8. Пересечение минного поля безопасности: setuid 





Настоящие минные поля трудно, но не невозможно перейти. Однако, это не является чем-то, что можно сделать легко, без тренировки или опыта

Точно также написание программ, которые используют setuid 


, является трудной задачей. Имеется много, очень много проблем, о которых нужно знать, и почти все может иметь неожиданные последствия в плане безопасности. Такая попытка должна предприниматься очень осторожно.

В частности, стоит специально изучить проблемы безопасности Linux/Unix и потратить время на обучение написанию программ setuid root. Если вы сразу нырнете в эту проблему, прочитав лишь эту книгу и ничего более, можно быть уверенным, что ваша система будет взломана, легко и сразу. Маловероятно, что вы или ваши клиенты будут довольны.

Вот несколько руководящих принципов:

• Как можно меньше действуйте в качестве 


. Скупо используйте свои чрезвычайные полномочия, лишь тогда, когда это абсолютно необходимо

• Соответствующим образом проектируйте свою программу. Разделите программу на составные части таким образом, чтобы все операции 


 были выполнены заранее, а оставшаяся программа работала в качестве обычного пользователя.

• При изменении или сбрасывании привилегий используйте 


, если она у вас есть. В противном случае используйте 


 поскольку у этих функций самая чистая семантика. Используйте 


, лишь когда вы хотите сделать постоянное изменение.

• Переходите от 


 к обычному пользователю в соответствующем порядке: сначала установите набор групп и значения GID, затем значения UID. Будьте особенно осторожны с 


 и 


; действительные и эффективные UID при их вызове не изменяются, если вы не измените их явным образом.

• Рассмотрите использование прав доступа setgid и особой группы для вашего приложения. Если это будет работать, это убережет вас от большой головной боли.

• Рассмотрите отказ от наследуемого окружения. Если вам нужно сохранить некоторые переменные окружения, сохраните как можно меньше. Убедитесь в предоставлении подходящих значений для переменных окружения 


 и 


.

• Избегайте 


 и 


, которые зависят от значения переменной окружения 


 (хотя это менее проблематично, если вы сами восстанавливаете 


).

Это просто некоторые из множества тактик по пересечению опасной зоны, известной своими подвохами, минами-ловушками и фугасами. Ссылки на другие источники информации см. в следующем разделе.




11.9. Рекомендуемая литература


Безопасность Unix (а следовательно, и GNU/Linux) является темой, требующей знаний и опыта для того, чтобы справиться с ней должным образом. В Эпоху Интернета она стала лишь труднее, не проще.

1. Practical UNIX & Internet Security, 3rd edition, by Simson Garfinkel, Gene Spafford, and Alan Schwartz, O'Reilly & Associates, Sebastopol, CA, USA, 2003. ISBN: 0-596-00323-4.

Это стандартная книга по безопасности Unix.

2. Building Secure Software. How to Avoid Security Problems the Right Way, by John Viega and Gary McGraw. Addison-Wesley, Reading, Massachusetts, USA, 2001. ISBN: 0-201-72152-X.

Это хорошая книга по написанию безопасного программного обеспечения, она включает проблемы setuid. Предполагается, что вы знакомы с основными API Linux/Unix; к моменту прочтения данной книги вы должны быть готовы к ее прочтению.

3. "Setuid Demystified," by Hao Chen, David Wagner, and Drew Dean. Proceedings of the 11th USENIX Security Symposium, August 5–9, 2002 http://www.cs.berkeley.edu/~daw/papers/setuid-usenix02.pdf.

Гарфинкель, Спаффорд и Шварц (Garfinkel, Spafford, Schwartz) рекомендуют прочтение этого материала «до того, как вы даже подумаете о написании кода, который пытается сохранять и восстанавливать привилегии». Мы всецело согласны с ними.




11.10. Резюме


• Использование значений ID пользователя и группы (UID и GID) для идентификации файлов и процессов — вот что превращает Linux и Unix в многопользовательские системы. Процессы имеют значения как действительных, так и эффективных UID и GID, а также набор дополнительных групп. Обычно именно эффективный UID определяет, как один процесс может повлиять на другой, и эффективные UID, GID и набор групп проверяются на соответствие с правами доступа к файлу. Пользователи с эффективным UID, равным нулю, известные как 


 или суперпользователи, могут делать все, что захотят; система не использует для такого пользователя проверку прав доступа.

• Концепции сохраненных set-user ID и set-group ID пришли из System V и были приняты POSIX с полной поддержкой в GNU/Linux. Наличие этих отдельных значений ID дает возможность легко и безошибочно переключать при необходимости действительные и эффективные UID (и GID).

• Программы setuid и setgid создают процессы, в которых действительные и эффективные ID различаются. Программы как таковые помечаются дополнительными битами прав доступа к файлу. Биты setuid и setgid должны быть добавлены к файлу после его создания.

• 


 и 


 получают значения действительного и эффективного UID соответственно, a 


 и 


 получают значения действительного и эффективного GID соответственно, 


 получает набор дополнительных групп, а в среде POSIX может запросить у системы, сколько членов содержит набор групп.

• Функция 


 осуществляет проверку прав доступа к файлу для действительного пользователя, давая возможность программе setuid проверить полномочия реального пользователя. Обратите внимание, что часто проверка возвращаемых 


 сведений может не представить полной картины при условии, что файл может находиться на не родной или сетевой файловой системе.

• Функция GLIBC 


 сходна с 


, но осуществляет проверку на основе значений эффективных UID и GID.

• «Липкий» бит и бит setgid при использовании с каталогами привносят дополнительную семантику. Когда для каталога установлен бит setgid, новые файлы в этом каталоге наследуют группу этого каталога. Новые каталоги делают то же самое, они также автоматически наследуют установку бита setgid. Без установленного бита setgid новые файлы и каталоги получают эффективный GID создающего их процесса. «Липкий» бит, установленный для каталогов, в которые в других отношениях разрешена запись, ограничивает право на удаление файла владельцем файла, владельцем каталога и 


.

• Набор групп изменяется с помощью 


. Эта функция не стандартизована POSIX, но существует на всех современных системах Unix. Ее может использовать лишь 


.

• Изменение UID и GID довольно сложно. Семантика различных системных вызовов с течением времени изменилась. Новые приложения, которые будут изменять лишь свои эффективные UID/GID, должны использовать 


 и 


. Приложения, не действующие от имени 


, могут также устанавливать свои эффективные ID с помощью 


 и 


. Вызовы 


 и 


 от BSD были предназначены для обмена значениями UID и GID; их использование в новых программах не рекомендуется.

• Приложения, действующие как 


, могут перманентно заменить значения действительного, эффективного и сохраненного ID с помощью 


 и 


. Одним из таких примеров является 


, которая должна превратиться из программы, выполняющейся как 


 в не непривилегированную зарегистрированную оболочку, выполняющуюся от имени обычного пользователя.

• Функции Linux 


 и 


 следует использовать всегда, когда они доступны, поскольку они обеспечивают самое чистое и наиболее надежное поведение

• Написание приложений setuid-


 не является задачей для новичка. Если вам нужно сделать такую вещь, сначала специально изучите проблемы безопасности. Для этого можно воспользоваться приведенными выше превосходными источниками.




Упражнения


1. Напишите простую версию команды 


. Ее назначением является отображение в стандартный вывод ID пользователя и группы с указанием имен групп. Когда эффективный и действительный ID различаются, выводятся оба. Например:











Ее использование:





















При указанном пользователе выводятся сведения об этом пользователе; в противном случае 


 выводит сведения о пользователе, вызвавшем программу. Опции следующие:




Выводит все значения групп в виде чисел, без имен.




Выводит лишь имена, без числовых значений. Применяется с значениями пользователя и группы.




Выводит лишь эффективный GID.




Выводит лишь эффективный UID.

2. Напишите простую программу с именем 


 и установите setuid на себя. Она должна запрашивать пароль (см. getpass(3)), который в целях данного примера может быть жестко вшит в исходный код программы. Если лицо, запустившее программу, вводит пароль правильно, 


 должна выполнить exec оболочки. Попросите другого пользователя помочь вам ее протестировать.

3. Как вы относитесь к тому, чтобы сделать 


 доступной для ваших друзей? Для ваших приятелей студентов или сотрудников? Для каждого пользователя на вашей системе?




Глава 12 Общие библиотечные интерфейсы — часть 2



В главе 6, «Общие библиотечные интерфейсы — часть 1», был представлен первый набор API библиотеки общего пользования. В некотором смысле, эти API поддерживают работу с фундаментальными объектами, которыми управляют системы Linux и Unix: время дня, пользователи и группы для файлов, сортировка и поиск.

Данная глава более эклектична; функции API, рассмотренные здесь, не особо связаны друг с другом. Однако, все они полезны в повседневном программировании под Linux/Unix. Наше представление движется от простых, более общих функций API к более сложным и более специализированным.




12.1. Операторы проверки: 





Оператор проверки (assertion) является утверждением, которое вы делаете о состоянии своей программы в определенный момент времени ее исполнения. Использование операторов проверок для программирования было первоначально разработано Хоаром (C.A.R. Hoare)[121 - Однако, в своей лекции в честь присуждения премии Тьюринга Ассоциации по вычислительной технике в 1981 г. д-р Хоар утверждает, что эту идею выдвинул сам Алан Тьюринг — Примеч. автора.]. Общая идея является частью «верификации программы»: так же, как вы проектируете и разрабатываете программу, вы можете показать, что она правильна, делая тщательно аргументированные утверждения о проявлениях кода вашей программы. Часто такие утверждения делаются об инвариантах — фактах о состоянии программы, которые, как предполагается, остаются верными на протяжении исполнения куска программы.

Операторы проверки особенно полезны для описания двух разновидностей инвариантов: предусловий и постусловий: условий, которые должны быть истинными соответственно перед и после исполнения сегмента кода. Простым примером предусловий и постусловий является линейный поиск:





























































Этот пример определяет условия, используя комментарии. Но не было бы лучше проверить условия с использованием кода? Это является задачей макроса 


:













Когда скалярное выражение ложно, макрос 


 выводит диагностическое сообщение и завершает программу (с помощью функции 


; см. раздел 12.4 «Совершение самоубийства: 


»). 


 снова предоставляет функцию 


, на этот раз с оператором проверки и функцией 


:



















































































































































































































После компиляции и запуска оператор проверки в строке 12 «выстреливает»:
















Сообщение от 


 варьирует от системы к системе. Для GLIBC на GNU/Linux сообщение включает имя программы, имя файла с исходным кодом и номер строки, имя функции, а затем текст завершившегося неудачей условия. (В этом случае именованная константа 


 проявляется в виде своего макрорасширения '


.)

Сообщение '


' означает, что 


 создала файл 


; т.е. снимок адресного пространства процесса непосредственно перед его завершением.[122 - Как упоминалось в разделе 10.2 «Действия сигналов», некоторые дистрибутивы GNU/Linux запрещают создание файлов 


. Чтобы снова разрешить их, поместите в свой файл 


 строку '


' — Примеч. автора.] Этот файл может быть использован впоследствии с отладчиком; см. раздел 15.3 «Основы GDB». Создание файла 


 является намеренным побочным результатом 


; предполагается, что произошла решительная ошибка, и вы хотите исследовать процесс с помощью отладчика для ее определения.

Вы можете отменить оператор проверки, компилируя свою программу с помощью опции командной строки '


'. Когда этот макрос определен до включения 


, макрос 


 расширяется в код, который ничего не делает. Например:
















Здесь мы получили настоящий дамп ядра! Мы знаем, что операторы проверки были запрещены; сообщения «failed assertion» нет. Что же случилось? Рассмотрите строку 15 


 при вызове из строки 37 


. В этом случае переменная 


 равна 


. Доступ к памяти через указатель 


 является ошибкой. (Технически различные стандарты оставляют «неопределенным» то, что происходит при разыменовывании указателя 


. Наиболее современные системы делают то же, что и GNU/Linux; они завершают процесс, посылая ему сигнал 


; это, в свою очередь, создает дамп ядра. Этот процесс описан в главе 10 «Сигналы».

Этот случай поднимает важный момент относительно операторов проверки. Часто программисты ошибочно используют операторы проверки вместо проверки ошибок времени исполнения. В нашем случае тест '


' должен был быть проверкой времени исполнения:






Тест '


' (строка 13) менее проблематичен; если 


 равен 0 или меньше 0, цикл никогда не исполнится, и 


 (правильно) возвратит -1. (По правде, этот оператор проверки не нужен, поскольку код правильно обрабатывает случай '


'.)

Логика, стоящая за отменой оператора проверки, заключается в том, что дополнительные проверки могут снизить производительность программы и поэтому должны быть запрещены в заключительной версии программы. Хоар[123 - Hints On Programming Language Design, C.A.R. Hoare Stanford University Computer Science Technical Report CS-73-403 (


). December, 1973 — Примеч. автора.], однако, сделал такое замечание:



«В конце концов, абсурдно делать тщательные проверки безопасности при отладочных запусках, когда к результатам нет никакого доверия, а затем удалять их из финальных версий, когда ошибочный результат может быть дорогим или катастрофическим. Что бы мы подумали об энтузиасте-мореплавателе, который надевает свой спасательный жилет при тренировке на сухой земле и снимает его, как только выходит в море?»


С такими мнениями, наша рекомендация заключается во внимательном использовании операторов проверки- во-первых, для любого данного оператора проверки рассмотрите возможность использования вместо него проверки времени исполнения. Во-вторых, тщательно разместите свой оператор проверки, чтобы не было возражений против их оставления на своем месте лаже в финальной версии вашей программы.

Наконец, отметим следующее из раздела «Ошибки» справочной страницы GNU/Linux assert(3):






 реализован как макрос: если у проверяемого выражения есть побочные результаты, поведение программы может меняться в зависимости от того, определен ли 


. Это может создавать гейзенберговские ошибки, которые исчезают при отключении режима отладки.


Знаменитый принцип неопределенности Гейзенберга из физики указывает, что чем более точно вы определите скорость частицы, тем менее точно вы определите ее положение, и наоборот. В терминах непрофессионала это означает что простой факт наблюдения частицы влияет на нее.

Сходное явление совершается в программировании, не связанном с физикой частиц: действие компилирования программы для отладки или запуска ее а режиме отладки может изменить поведение программы. В частности, первоначальная ошибка может исчезнуть. Такие ошибки в разговоре называют гейзенберговскими.

Справочная страница предостерегает нас от использования при вызовах 


 выражений с побочными эффектами:






Здесь побочным эффектом является увеличение указателя p как часть теста. Когда определен 


, аргумент выражения исчезает из исходного кода; он никогда не исполняется. Это может привести к неожиданной неудаче. Однако, как только при подготовке к отладке запрет на операторы проверки отменяется, все начинает снова работать! Такие проблемы трудно отследить.




12.2. Низкоуровневая память: функции 






Несколько функций предоставляют возможность для работы с произвольными блоками памяти низкоуровневые службы. Все их имена начинаются с префикса '


':









































12.2.1. Заполнение памяти: 





Функция 


 копирует значение val (интерпретируемое как 


) в первые 


 байтов буфера 


. Она особенно полезна для обнуления блоков динамической памяти:
















Однако 


 может использоваться с любой разновидностью памяти, не только с динамической. Возвращаемым значением является первый аргумент: 


.




12.2.2. Копирование памяти: 


, 


 и 





Три функции копируют один блок памяти в другой. Первые две функции отличаются в обработке перекрывающихся областей памяти; третья копирует память, но останавливается при встрече с определенным значением.






Это простейшая функция. Она копирует 


 байтов из 


 в 


. Она не обрабатывает перекрывающиеся области памяти. Функция возвращает 


.






Подобно 


, она также копирует 


 байтов из 


 в 


. Однако, она обрабатывает перекрывающиеся области памяти. Функция возвращает 


.






Эта копирует байты из 


 в 


, останавливаясь либо после копирования 


 в 


, либо после копирования 


 байтов. Если она находит 


, то возвращает указатель на положение в 


 сразу за 


. В противном случае возвращается 


.

Теперь, в чем проблема с перекрывающейся памятью? Рассмотрим рис. 12.1.




Рис. 12.1. Перекрывающиеся копии

Целью является скопировать четыре экземпляра 


 от 


 до 


 в участок от 


 до 


. Здесь проблемой является 


, побайтовое копирование с перемещением в памяти из 


 затрет 


 до того, как он будет безопасно скопирован в 


! (Может возникнуть также сценарий, когда копирование в памяти в обратном направлении разрушит перекрывающиеся данные.)

Функция 


 была первоначальной функцией в System V API для копирования блоков памяти; ее поведение для перекрывающихся блоков памяти не была подробно определена тем или иным способом. Для стандарта С 1989 г. комитет почувствовал, что это отсутствие определенности является проблемой, поэтому они придумали 


. Для обратной совместимости 


 была оставлена, причем поведение для перекрывающейся памяти было специально отмечено как неопределенное, а в качестве процедуры, корректно разрешающей проблемные случаи, была предложена 


.

Какую из них использовать в своем коде? Для библиотечной функции, которая не знает, какие области памяти ей передаются, следует использовать 


. Таким способом вы гарантируете, что не будет проблем с перекрывающимися областями. Для кода приложения, который «знает», что две области не перекрываются, можно безопасно использовать 


.

Как для 


, так и для 


 (как и для 


) буфер назначения является первым аргументом, а источник — вторым. Чтобы запомнить это, обратите внимание на порядок, который тот же самый, как в операторе присваивания:






(Справочные страницы во многих системах не помогают, предлагая прототип в виде '


' и полагаясь на то, что текст объяснит, что есть что. К счастью, справочная страница GNU/Linux использует более осмысленные имена.)




12.2.3. Сравнение блоков памяти: 





Функция 


 сравнивает 


 байтов из двух произвольных буферов данных. Возвращаемое ею значение подобно 


: отрицательное, нулевое или положительное, если первый буфер меньше, равен или больше второго.

Вы можете поинтересоваться: «Почему бы не использовать для такого сравнения 


?» Разница между двумя функциями в том, что 


 не принимает во внимание нулевые байты (завершающий строку '


'.) Таким образом, 


 является функцией, которая используется, когда вам нужно сравнить произвольные двоичные данные.

Другим преимуществом 


 является то, что она быстрее типичной реализации на C:





























































Скорость может быть достигнута в результате использования специальных инструкций «блочного сравнения памяти», которые поддерживают многие архитектуры, или в результате сравнения единиц, превышающих байты. (Эта последняя операция коварна, и лучше оставить ее автору библиотеки.)

По этим причинам всегда следует использовать вашу библиотечную версию 


 вместо прокручивания своей собственной. Велика вероятность, что автор библиотеки знает машину лучше вас




12.2.4. Поиск байта с данным значением: 





Функция 


 сходна с функцией 


: она возвращает местоположение определенного значения внутри произвольного буфера. Как и в случае 


 против 


, основной причиной для использования 


 является использование произвольных двоичных данных.

GNU 


 использует 


 при подсчете лишь строк и байтов[124 - См. wс(1). 


 подсчитывает строки, слова и символы — Примеч. автора.], и это позволяет 


 быть быстрой. Из 


 в GNU Coreutils:




















































































































Внешний цикл (строки 261–278) читает блоки данных из входного файла. Внутренний цикл (строки 272–276) использует 


 для поиска и подсчета символов конца строки. Сложное выражение '


' сводится к числу оставшихся байтов между текущим значением p и концом буфера.

Комментарии в строках 259–260 нуждаются в некотором объяснении. Вкратце, современные системы могут использовать символы, занимающие более одного байта в памяти и на диске. (Это несколько более подробно обсуждается в разделе 13.4 «Не могли бы вы произнести это для меня по буквам?».) Таким образом, 


 должна использовать другой код, если она различает байты и символы: этот код имеет дело со случаем подсчета байтов.




12.3. Временные файлы



Временный файл является в точности тем, что звучит в его названии: файл, в котором при исполнении программы хранятся данные, которые больше не нужны после завершения программы. 


 читает со стандартного ввода, если в командной строке не указаны файлы или вы используете в качестве имени файла '


'. Тем не менее, 


 должна прочесть 


 свои входные данные, прежде чем сможет вывести отсортированные результаты. (Подумайте об этом немного, и вы увидите, что это так.) Когда читается стандартный ввод, данные должны быть где-то сохранены, прежде чем 


 сможет их отсортировать; это отличное применение для временного файла. 


 использует временные файлы также для хранения промежуточных результатов сортировки.

Удивительно, но имеются пять различных функций для создания временных файлов. Три из них работают посредством создания строк, представляющих (предположительно) уникальные имена файлов. Как мы увидим, их обычней следует избегать. Оставшиеся две работают путем создания и открытия временного файла; эти функции предпочтительнее для использования.




12.3.1. Создание временных имен файлов (плохо)


Имеются три функции, назначением которых является создание имени уникального, не существующего файла. Получив такое имя, вы можете использовать его для создания временного файла. Поскольку имя уникально, вам «гарантируется» исключительное использование файла. Вот объявления функций:























Все эти функции предусматривают различные вариации одной и той же темы они заполняют или создают буфер с путем уникального временного имени файла. Файл уникален в том, что создаваемое имя не существует во время создания и возвращения его функциями. Функции работают следующим образом:






Генерирует уникальное имя файла. Если 


 не равен 


, он должен быть размером по крайней мере 


 байтов, и в него копируется уникальное имя. Если 


 равен 


, имя генерируется во внутреннем статическом буфере, который может быть переписан при последующих вызовах. Префикс каталогов в пути будет 


. Как 


, так и 


 определены в 


.






Подобно 


 дает вам возможность указать префикс каталогов. Если 


 равен 


, используется 


. Аргумент 


, если он не равен 


, определяет до пяти символов для использования в качестве начальных символов имени файла 


 выделяет память для имен файлов, которые она генерирует. Возвращенный указатель может впоследствии использоваться с 


 (и это следует сделать, если хотите избежать утечек памяти).






Генерирует уникальные имена файлов на основе шаблона. Последними шестью символами 


 должны быть '


'; эти символы замещаются уникальным суффиксом.



ЗАМЕЧАНИЕ. Аргумент 


 функции 


 переписывается. Поэтому он не должен быть строковой константой. Многие компиляторы, предшествовавшие стандарту С, помещают строковые константы в сегмент данных вместе с обычными глобальными переменными. Хотя в исходном коде они определены как константы, их можно переписать, таким образом, нередко встречался такой код:
















На современных системах такой код. вероятно, завершится неудачей, в наши дни строковые константы находятся в сегментах памяти только для чтения.


Использование этих функций довольно просто. Файл 


 демонстрирует 


; нетрудно изменить его для использования других функций:

































































































































































Переменная 


 (строка 10) определяет шаблон имени файла; '


' будет заменен уникальным значением. Строка 16 копирует шаблон в 


, которая не является константой: ее можно изменить. Строка 18 вызывает 


 для генерирования имени файла, а строка 21 выводит ее, так, чтобы мы могли видеть, что это такое. (Вскоре мы объясним комментарии в строках 19 и 23.)

Строка 25 открывает файл, создавая его при необходимости. Строка 26 записывает сообщение в 


, а строка 27 закрывает файл. В программе, в которой файл должен быть удален после завершения работы с ним, строка 29 была бы не закомментирована. (Иногда временный файл не следует удалять; например, если файл после полной записи будет переименован.) Мы закомментировали ее, чтобы можно было запустить эту программу и посмотреть на файл впоследствии. Вот что происходит при запуске программы:


































































Все кажется работающим замечательно, 


 возвращает уникальное имя, 


 создает файл с нужными правами доступа, и содержание то самое, которое ожидалось. Так в чем же проблема со всеми этими функциями?

Исторически 


 использовала простой, предсказуемый алгоритм для создания замещающих символов для '


' в шаблоне. Более того, интервал между временем, когда генерируется имя файла, и временем, когда создается сам файл, создает состояние гонки.

Как? Ну, Linux и Unix являются системами с квантованием времени, методикой, которая разделяет время процессора между всеми исполняющимися процессами. Это означает, что, хотя программа кажется выполняющейся все время, в действительности есть моменты, когда процессы спят, т.е. ожидают выполнения на процессоре.

Теперь рассмотрите программу профессора для отслеживания оценок студентов. Как профессор, так и злоумышленный студент в одно и то же время используют сильно нагруженную многопользовательскую систему. Программа профессора использует для создания временных файлов 


, видевший в прошлом, как оценивающая программа создает и удаляет временные файлы, выяснил алгоритм, который использует 


. (В версии GLIBC нет этой проблемы, но не все системы используют GLIBC!) Рис 12.2 иллюстрирует состояние гонки и то, как студент его использует.




Рис. 12.2. Состояние гонки с 




Вот что случилось.

1. Оценивающая программа использует 


 для создания имени файла. По возвращении из 


 открыто окно состояния гонки (строка 19 в 


).

2. Ядро останавливает оценивающую программу, чтобы могли поработать другие программы в системе. Это происходит до вызова 


.

Пока оценивающая программа остановлена, студент создает файл с тем же самым именем, которое вернула 


. (Помните, выяснить алгоритм было просто.) Студент создает файл с дополнительной ссылкой, так что когда оценивающая программа удаляет файл, он все еще будет доступен для прочтения.

3. Теперь оценивающая программа открывает файл и записывает в него данные. Студент создал файл с правами доступа 


, поэтому это не представляет проблему.

4. Когда оценивающая программа завершает работу, она удаляет временный файл. Однако, у студента все еще есть копия. Например, может быть возможность получения прибыли при заблаговременной продаже своим товарищам их оценок.

Наш пример упрощенный; помимо простого похищения данных с оценками умный (хотя и аморальный) студент мог бы вместо этого изменить данные. Если бы профессор не проверял результаты работы своей программы дважды, никто бы ничего не узнал.



ЗАМЕЧАНИЕ. Мы не рекомендуем делать что-либо из этого! Если вы студент, не пытайтесь сделать что-либо подобное. Первое и самое главное, это неэтично. Во-вторых, вас могут выгнать из школы. В-третьих, ваши профессора, наверное, не сталь наивны, чтобы использовать 


 в своих программах. Этот пример лишь для иллюстрации!


По приведенным и другим причинам, все три описанные в данном разделе функции не следует никогда использовать. Они существуют в POSIX и GLIBC лишь для поддержки старых программ, которые были написаны до того, как была осознана опасность этих процедур С этой целью системы GNU/Linux генерируют во время компоновки сообщение:
















(Мы рассмотрим 


 в следующем подразделе.)

Если бы в вашей системе не было 


, подумайте, как вы могли бы использовать эти интерфейсы для ее эмулирования. (См. также «Упражнения» для главы 12 в конце.)




12.3.2. Создание и открывание временных файлов (хорошо)


Есть две функции, не имеющие проблем состояния гонки. Одна из них предназначена для использования с библиотекой 


:













Другая функция для использования с системными вызовами на основе дескрипторов файлов:
















 возвращает значение 


, представляющее уникальный открытый временный файл. Файл открывается в режиме "


". 


 означает «открыть для чтения и записи, сначала урезав файл», a b означает двоичный, а не текстовый режим. (На системах GNU/Linux или Unix нет разницы, но на других системах есть.) Файл автоматически удаляется, когда закрывается указатель файла; нет способа получить имя файла, чтобы сохранить его содержимое. Программа в 


 демонстрирует 


:


























































































Возвращенное значение 


 не отличается от любого другого 


, возвращенного 


. При запуске получаем ожидавшиеся результаты:











Ранее мы видели, что авторы GLIBC рекомендуют использование функции 


:
















Эта функция похожа на 


 в том, что она принимает имя файла, оканчивающееся на '


', и заменяет эти символы уникальным суффиксом для создания уникального имени файла. Однако, она идет на один шаг дальше. Она создает и открывает файл. Файл создается с доступом 0600 (т.е. 


). Таким образом, доступ к файлу может получить только пользователь, запустивший программу.

Более того, и это то, что делает 


 более безопасной, файл создается с флагом 


, который гарантирует, что файл не существует, и не дает никому больше открыть файл.

Возвращаемое значение является дескриптором открытого файла, который может использоваться для чтения и записи. Для удаления файла после завершения работы с ним должно использоваться имя пути, сохраненное теперь в переданном 


 буферу. Все это демонстрируется в 


, который является простой модификацией 


:


































































































































При запуске получаем ожидавшиеся результаты:



















12.3.3. Использование переменной окружения 





Многие стандартные утилиты обращают внимание на переменную окружения 


, используя обозначенный в ней каталог в качестве места для помещения временных файлов. Если 


 не установлена, каталогом по умолчанию для временных файлов обычно является 


, хотя на многих современных системах есть также и каталог 


. 


 обычно очищается от всех файлов и каталогов административными сценариями оболочки при запуске.

Многие системы GNU/Linux предоставляют каталог 


, использующий файловую систему типа 





























Тип файловой системы 


 предоставляет электронный (RAM) диск: часть памяти, которая используется, как если бы она была диском. Более того, файловая система 


 использует механизмы виртуальной памяти ядра Linux для его увеличения сверх фиксированного размера. Если на вашей системе уйма оперативной памяти, этот подход может обеспечить заметное ускорение. Чтобы протестировать производительность, мы начали с файла 


, который является отсортированным списком правильно написанных слов, по одному в строке. Затем мы перемешали этот файл, так что он больше не был сортированным, и создали больший файл, содержащий 500 копий спутанной версии файла:





















Затем мы отсортировали файл, используя сначала каталог 


, а затем с 


, установленным в 


[125 - Такое использование 


 на самом деле является злоупотреблением,, он предназначен для использования в реализации разделяемой памяти, а не в качестве электронного диска. Тем не менее, это полезно для иллюстрации нашей мысли — Примеч. автора.]:



















































Интересно, использование электронного диска было лишь незначительно быстрее, чем использование обычных файлов. (В некоторых дальнейших тестах оно было даже в действительности медленнее!) Мы предполагаем, что в игру вступил буферный кэш ядра (см. раздел 4.6.2 «Создание файлов с помощью 


»), весьма эффективно ускоряя файловый ввод/вывод[126 - На нашей системе 512 мегабайтов оперативной памяти, что для старых чудаков вроде автора кажется порядочным. Однако цены на память упали, и вполне обычны системы с одним или более гигабайтами оперативной памяти, по крайней мере, для разработчиков программного обеспечения — Примеч. автора.].

У электронного диска есть важный недостаток: он ограничен сконфигурированным для вашей системы размером пространства для подкачки.[127 - Пространство для подкачки состоит из одного или более выделенных участков диска, используемых для хранения частей исполняющегося процесса, который не находится в настоящее время в памяти — Примеч. автора.] Когда мы попытались отсортировать файл, содержащий 1000 копий файла с перемешанными словами, место на электронном диске закончилось, тогда как обычный sort завершился благополучно.

Использовать TMPDIR для своих программ просто. Мы предлагаем следующую схему.
































































































В зависимости от потребностей вашего приложения, вы можете захотеть немедленно удалить файл после его открытия, вместо его удаления как части завершающей очистки.




12.4. Совершение самоубийства: 





Бывают моменты, когда программа просто не может продолжаться. Обычно лучше всего при этом выдать сообщение об ошибке и вызвать 


. Однако, особенно для ошибок, являющихся проблемами программирования, полезно не только завершиться, но и создать дамп ядра, который сохраняет в файле состояние работающей программы для последующего исследования в отладчике. В этом заключается работа функции 


:













Функция 


 посылает сигнал 


 самому процессу. Это случится, даже если 


 заблокирован или игнорируется. После этого осуществляется обычное для 


 действие, которое заключается в создании дампа ядра.

Примером 


 в действии является макрос 


, описанный в начале данной главы. Когда 


 обнаруживает, что его выражение ложно, он выводит сообщение об ошибке, а затем вызывает 


 для создания дампа ядра.

В соответствии со стандартом С, осуществляет 


 очистку или нет, зависит от реализации. Под GNU/Linux она выполняет очистку: все потоки 


 перед завершением программы закрываются. Обратите, однако, внимание, что для открытых файлов, использующих системные вызовы на основе дескрипторов файлов, ничего не делается. (Если открыты лишь файлы или каналы, ничего не нужно делать. Хотя мы не обсуждали это, дескрипторы файлов используются также для сетевых соединений, и оставление их открытыми является плохой практикой.)




12.5. Нелокальные переходы


«Идите прямо в тюрьму. Не проходите GO. Не забирайте 200$».

    - Монополия -


Вы, без сомнения, знаете, чем является 


: передачей потока управления на метку где-то в текущей функции. Операторы 


 при скупом употреблении могут послужить удобочитаемости и правильности функции (Например, когда все проверки ошибок используют 


 для перехода на метку в конце функции, такую, как 


, код с этой меткой проводит очистку [закрывая файлы и т.п.] и возвращается.) При плохом использовании операторы 


 могут привести к так называемой «лапше» в коде, логику которого становится невозможно отследить.

Оператор 


 в языке С ограничен переходом на метку в текущей функции. Многие языки в семействе Алгола, такие, как Паскаль, допускают использование 


 для выхода из вложенной функции в предшествующую вызывающую функцию. Однако в С нет способа, в пределах синтаксиса самого языка, перейти в определенную точку другой функции, пусть даже и вызывающей. Такой переход называется нелокальным переходом.

Почему полезен нелокальный переход? Рассмотрите интерактивную программу, которая считывает и выполняет программы. Предположим, пользователь запускает длительное задание, разочаровывается или меняет мнение о данном задании и нажимает CTRL-С для генерирования сигнала 


. Когда запускается обработчик сигнала, он может перейти обратно в начало главного цикла чтения и обработки команд. Строковый редактор ed представляет простой пример этого:


































































Внутри себя 


 устанавливает перед циклом команд точку возврата, и обработчик сигнала осуществляет нелокальный переход на эту точку возврата.




12.5.1. Использование стандартных функций: 


 и 





Нелокальные переходы осуществляются с помощью функций 


 и 


. Эти функции используются в двух разновидностях. Традиционные процедуры определены стандартом ISO С:


















Тип 


 определен через 


 в 


. 


 сохраняет текущее «окружение» в 


. 


 обычно является глобальной или статической на уровне файла переменной, так что она может использоваться из вызванной функции. Это окружение включает любую информацию, необходимую для перехода на местоположение, из которого была вызвана 


. Содержание 


 по своей природе машинно-зависимо; таким образом, 


 является непрозрачным типом: тем, что вы используете, не зная, что находится внутри него.




 возвращает 0, когда она вызывается для сохранения в 


 текущего окружения. Ненулевое значение возвращается, когда с использованием окружения осуществляется нелокальный переход:







































 осуществляет переход. Первым параметром является 


, который должен быть инициализирован с помощью 


. Второй является целым ненулевым значением, которое 


 возвращает в первоначальное окружение. Это сделано так, что код, подобный только что показанному, может различить установку окружения и прибытие путем нелокального перехода.

Стандарт С утверждает, что даже если 


 вызывается со вторым аргументом, равным 0, 


 по-прежнему возвращает ненулевое значение. В таком случае она возвращает 1.

Возможность передать целое значение и вернуться обратно из 


 полезна; это позволяет коду уровня пользователя различать причину перехода. Например, 


 использует эту возможность для обработки операторов 


 и 


 внутри циклов. (Язык awk осознанно сделан похожим на С в своем синтаксисе для циклов, с использованием 


, 


, 


, 


 и 


.) Использование 


 выглядит следующим образом (из 


 в дистрибутиве 


 3.1.3):










































































































Этот фрагмент кода представляет цикл 


. Строка 508 управляет вложенными циклами посредством стека сохраненных переменных 


. Строки 511–524 выполняют цикл 


 (используя цикл С 


!). Строка 511 проверяет условие цикла. Если оно истинно, строка 513 выполняет 


 на возвращаемое значение 


. Если оно равно 0 (строки 514–516), строка 515 выполняет тело оператора. Однако, когда 


 возвращает 


 или 


, оператор 


 обрабатывает их соответствующим образом (строки 517–518 и 519–521 соответственно).

Оператор 


 на уровне 


 передает 


 функции 


, a 


 уровня 


 передает 


. Снова из 


 с некоторыми пропущенными не относящимися к делу подробностями:
























































Вы можете думать о 


 как об установке метки, а о 


 как выполнении 


 с дополнительным преимуществом возможности сказать, откуда «пришел» код (по возвращаемому значению).




12.5.2. Обработка масок сигналов: 


 и 





По историческим причинам, которые, скорее всего, утомили бы вас до слез, стандарт С 1999 г. ничего не говорит о влиянии 


 и 


 на состояние сигналов процесса, а POSIX явно констатирует, что их влияние на маску сигналов процесса (см. раздел 10.6 «Сигналы POSIX») не определено.

Другими словами, если программа изменяет свою маску сигналов процесса между первым вызовом 


 и вызовом 


, каково состояние маски сигналов процесса после 


? Та ли эта маска, когда была впервые вызвана 


? Или это текущая маска? POSIX явно утверждает, что «нет способа это узнать».

Чтобы сделать обработку маски сигналов процесса явной, POSIX ввел две дополнительные функции и один 


:























Главным отличием является аргумент 


 функции 


. Если он не равен нулю, текущий набор заблокированных сигналов сохраняется в 


 вместе с остальным окружением, которое сохраняется функцией 


. 


 с 


, в которой 


 содержала true, восстанавливает сохраненную маску сигналов процесса



ЗАМЕЧАНИЕ. POSIX также ясен в том, что если 


 равен нулю (false), сохраняется ли маска сигналов процесса или восстанавливается, не определено, как в случае с 


/


. Это, в свою очередь, предполагает, что если собираетесь использовать '


', вы также можете не беспокоиться: все дело в том, чтобы иметь контроль над сохранением и восстановлением маски сигналов процесса!





12.5.3. Важные предостережения


Есть несколько технических предостережений, о которых нужно знать.

Во-первых, поскольку сохранение и восстановление среды может быть беспорядочной машинно-зависимой задачей, 


 и 


 могут быть макросами

Во-вторых, стандарт С ограничивает использование 


 следующими ситуациями.

• В качестве единственного контролирующего выражения в операторе цикла или условном операторе (


, 


).

• В качестве одного операнда выражения сравнения (


, 


 и т.д.), с целой константой в качестве другого операнда. Выражение сравнения может быть единственный контролирующим выражением цикла или условного оператора.

• В качестве операнда унарного оператора '


', причем результирующее выражение является единственным контролирующим выражением цикла или условного оператора.

• В качестве всего выражения оператора-выражения, возможно, приведенного к типу 


. Например:






В-третьих, если вы хотите изменить локальную переменную в функции, которая вызывает 


, после вызова и хотите, чтобы эта переменная сохранила свое последнее присвоенное после 


 значение, нужно объявить эту переменную как 


. В противном случае все локальные переменные, не являющиеся 


 и изменившиеся после того, как была первоначально вызвана 


, имеют неопределенные значения. (Обратите внимание, что сама переменная 


 не должна объявляться как 


.) Например:

































































































































































В этом примере сохранение своего значения ко второму вызову 


 гарантируется 


 j (строка 21). Значение (строка 20) в соответствии со стандартом С 1999 г. не определено. Это может быть 6, может быть 5, а может даже какое-нибудь другое значение!

В-четвертых, как описано в разделе 12.5.2 «Обработка масок сигналов: 


 и 


», стандарт С 1999 г. не делает никаких утверждений о влиянии, если оно есть, 


 и 


 на состояние сигналов программы. Если это важно, вам придется вместо них использовать 


 и 


.

В-пятых, эти процедуры содержат поразительные возможности для утечек памяти! Рассмотрим программу, в которой 


 вызывает 


, а затем вызывает несколько вложенных функций, каждая из которых выделяет с помощью 


 динамическую память. Если наиболее глубоко вложенная функция делает 


 обратно в 


, указатели на динамическую память теряются. Взгляните на 


:
































































































































































































































































Эта программа устанавливает бесконечный цикл, используя 


 и 


. Строка 20 использует для нахождения текущего начала кучи 


 (см. раздел 3.2.3 «Системные вызовы: 


 и 


»), а затем строка 22 вызывает 


. Строка 25 получает текущее начало кучи; это место каждый раз изменяется, поскольку 


 повторно входит в код. Строки 27–28 вычисляют, сколько было выделено памяти, и выводят это количество. Вот что происходит при запуске:


































































Память утекает из программы, как через решето. Она работает до тех пор, пока не будет прервана от клавиатуры или пока не закончится память (в этом случае образуется основательный дамп ядра).

Каждая из функций 


 и 


 выделяют память, a 


 выполняет 


 обратно в 


 (строка 51). Когда это происходит, локальные указатели (строки 39 и 48) на выделенную память пропали! Такие утечки памяти может оказаться трудно отследить, поскольку часто выделяются небольшие размеры памяти, и как таковые, они могут оставаться незамеченными в течение ряда лет[128 - Такая утечка была у нас в 


 К счастью, она исправлена — Примеч. автора.].

Этот код явно патологический, но он предназначен для иллюстрации нашей мысли: 


 и 


 могут вести к трудно обнаруживаемым утечкам памяти. Предположим, что 


 правильно вызвал 


. Было бы далеко неочевидно, что память никогда не будет освобождена. В более крупной и более реалистичной программе, в которой 


 мог быть вызван лишь посредством 


, найти такую утечку становится даже еще труднее.

Таким образом, при наличии 


 и 


 динамическая память должна управляться посредством глобальных переменных, а у вас должен быть код, который обнаруживает вход через 


 (посредством проверки возвращаемого значения 


). Такой код должен затем освободить динамически выделенную память, которая больше не нужна.

В-шестых, 


 и 


 не следует использовать из функций, зарегистрированных посредством 


 (см. раздел 9.1.5.3 «Функции завершения»).

В-седьмых, 


 и 


 могут оказаться дорогими операциями на машинах с множеством регистров.

При наличии всех этих проблем вы должны строго рассмотреть дизайн своей программы. Если вам не нужно использовать 


 и 


, то, может, стоит обойтись без их использования. Однако, если их использование является лучшим способом структурировать свою программу, продолжайте и используйте их, но делайте это осмотрительно.




12.6. Псевдослучайные числа



Многим приложениям нужны последовательности случайных чисел. Например, игровые программы, имитирующие бросание костей, раздачу карт или вращение барабанов игровой машины, нуждаются в возможности случайного выбора одного из возможных значений. (Подумайте о программе 


, содержащей большую коллекцию афоризмов; каждый раз при запуске она «случайно» выдает новое высказывание.) Многие криптографические алгоритмы также требуют наличия случайных чисел «высокого качества». В данном разделе описываются различные способы получения последовательностей случайных чисел.



ЗАМЕЧАНИЕ. Природа случайности, генерация случайных чисел и их «качество» являются обширными темами, выходящими за рамки данной книги. Мы предоставляем введение в доступные функции API, но это все, что мы можем сделать Другие источники с более подробной информацией см в разделе 12.9 «Рекомендуемая литература»


Компьютеры по своему строению являются детерминистическими. Одно и то же вычисление с одними и теми же входными данными всегда должно давать одни и те же результаты. Соответственно, они не годятся для генерации истинно случайных чисел, то есть последовательностей чисел, в которых каждое число в последовательности полностью независимо от числа (или чисел), идущих перед ним. Вместо этого разновидности чисел, обычно используемых на программном уровне, называются псевдослучайными числами. То есть в любой данной последовательности номера выглядят независимыми друг от друга, но сама последовательность в целом повторяющаяся. (Эта повторяемость может быть ценным качеством; она обеспечивает детерминизм для программы в целом.)

Многие методы предоставления последовательностей псевдослучайных чисел работают посредством осуществления каждый раз одного и того же вычисления с начальным значением (seed). Сохраненное начальное значение затем обновляется для использования в следующий раз. API предоставляет способ указания нового начального значения. Каждое начальное значение дает одну и ту же последовательность псевдослучайных чисел, хотя различные начальные числа дают (должны давать) различные последовательности.




12.6.1. Стандартный С: 


 и 





Стандартный С определяет две связанные функции для псевдослучайных чисел.





















 каждый раз после вызова возвращает псевдослучайное число в диапазоне от 0 до 


 (включительно, насколько мы можем судить по стандарту C99). Константа 


 должна быть по крайней мере 32 767; она может быть больше.




 дает генератору случайных чисел в качестве начального значения 


. Если 


 никогда не вызывался приложением, 


 ведет себя так, как если бы seed был равен 1.

Следующая программа, 


, использует 


 для вывода граней игральных костей.


















































































































































































































































































































Эта программа использует простую ASCII-графику для распечатывания подобия грани игральной кости. Вы вызываете ее с числом граней для вывода. Это вычисляется в строке 44 с помощью 


. (В общем, 


 следует избегать в коде изделия, поскольку она не осуществляет проверку на ошибки или переполнение, также как не проверяет вводимые данные.)

Ключевой является строка 53, которая преобразует возвращаемое значение 


 в число от нуля до пяти, используя оператор остатка, 


. Значение '


' действует в качестве начального индекса массива 


 для трех строк, составляющих каждую грань кости. Строки 55 и 56 выводят саму грань. При запуске появляется вывод наподобие этого:
























































Интерфейс 


 восходит еще к V7 и PDP-11. В частности, на многих системах результатом является лишь 16-разрядное число, что значительно ограничивает диапазон чисел, которые могут быть возвращены. Более того, используемый им алгоритм по современным стандартам считается «слабым». (Версия 


 GLIBC не имеет этих проблем, но переносимый код должен быть написан со знанием того, что 


 не является лучшим API для использования.)




 использует для получения значения в определенном интервале простую методику: оператор 


. Эта методика использует младшие биты возвращенного значения (как при десятичном делении, когда остаток отделения на 10 или 100 использует одну или две младшие десятичные цифры). Оказывается, исторический генератор 


 производил лучшие случайные значения в средних и старших битах по сравнению с младшими битами. Поэтому, если вы должны использовать 


, постарайтесь избежать младших битов. Справочная страница GNU/Linux rand(3) цитирует «Числовые рецепты на С»[129 - Numerical Recipes in С. The Art of Scientific Computing,, 2nd edition, by William H. Press, Brian P. Plannery, Saul A. Teukolsky, and William T. Vetterling. Cambridge University Press, USA, 1993, ISBN 0-521-43108-5 — Примеч. автора.], которая рекомендует эту методику:









12.6.2. Функции POSIX: 


 и 





BSD 4.3 ввело random() и сопровождающие ее функции. Эти функции используют намного более подходящий генератор случайных чисел, который возвращает 31-разрядное значение. Теперь они входят в расширение XSI, стандартизованное POSIX:




























Первые две функции близко соответствуют 


 и 


 и могут использоваться сходным образом. Однако, вместо одного начального значения, которое дает последовательность псевдослучайных чисел, эти функции используют начальное значение вместе с массивом состояния: массивом байтов, который хранит сведения о состоянии для вычисления псевдослучайных чисел. Последние две функции дают возможность управлять массивом состояния.






Возвращает число в диапазоне от 0 до 2


-1. (Хотя справочная страница GNU/Linux random(3) говорит между 0 и 


, это верно лишь для систем GLIBC, где 


 равен 2


-1. На других системах 


 может быть меньше. POSIX явно называет диапазон от 0 до 2


-1.)






Устанавливает начальное число. Если 


 никогда не вызывается, по умолчанию используется 1.






Инициализирует массив 


 информацией для использования при генерации случайных чисел, 


 является начальным значением, как для 


, а 


 является числом байтов в массиве 


.




 должен равняться одному из значений 8, 32, 64, 128 или 256. Большие значения дают лучшие последовательности случайных чисел. Значения меньше 8 заставляют 


 использовать простой генератор случайных чисел, сходный с 


. Значения больше 8, не равные одному из значений в списке, округляются до ближайшего подходящего значения.






Устанавливает внутреннее состояние в соответствии с массивом 


, который должен быть инициализирован посредством 


. Это позволяет переключаться по желанию между различными состояниями, предоставляя множество генераторов случайных чисел.

Если 


 и 


 никогда не вызывались, 


 использует массив внутреннего состояния размером 128.

Массив 


 непрозрачен; вы инициализируете его с помощью 


 и передается функции 


 посредством 


, но в другом отношении вам не нужно заглядывать в него. Если вы используете 


 и 


. 


 вызывать не нужно, поскольку начальное значение включено в информацию о состоянии. 


 использует эти процедуры вместо 


. Используется также обычная методика, которая заключается в использовании в качестве начального значения генератора случайных чисел времени дня, добавленного к PID.





















































































































































































Включение PID в состав начального значения гарантирует, что вы получите различные результаты, даже если две программы будут запушены в течение одной и той же секунды.

Поскольку она создает последовательности случайных чисел лучшего качества, 


 является более предпочтительной по сравнению с 


, и GNU/Linux и все современные системы Unix ее поддерживают.




12.6.3. Особые файлы 


 и 





Как 


, так и 


 являются генераторами псевдослучайных чисел. Их вывод для одного и того же начального значения является воспроизводимой последовательностью чисел. Некоторым приложениям, подобным криптографическим, необходимо, чтобы их случайные числа были действительно (более) случайными. С этой целью ядро Linux, также как различные BSD и коммерческие Unix системы предусматривают специальные файлы устройств, которые предоставляют доступ к «энтропийному пулу» случайных битов, которые ядро собирает от физических устройств и других источников. Из справочной страницы random(4):






[Байты, прочитанные из этого файла, находятся] внутри предполагаемого числа шумовых битов в энтропийном пуле, 


 должен подходить для использования в случаях, когда необходим высокий уровень случайности, таких, как одноразовая генерация ключа или блока памяти. Когда энтропийный пул пустой, чтение 


 будет блокироваться до тех пор, пока не будет собран дополнительный шум окружения.






[Это устройство будет] возвращать столько байтов, сколько затребовано. В результате, если нет достаточной энтропии в энтропийном пуле, возвращаемые значения теоретически уязвимы для криптографической атаки алгоритма, использованного драйвером. Знание того, как это сделать, недоступно в современной не секретной литературе, но теоретически возможно существование подобной атаки. Если для вашего приложения это представляет проблему, вместо этого используйте 


.

Для большинства приложений чтения из 


 должно быть вполне достаточно. Если вы собираетесь написать криптографические алгоритмы высокого качества, следует сначала почитать о криптографии и случайности; не полагайтесь здесь на поверхностное представление! Вот еще одна наша программа для бросания костей, использующая 


:







































































































































































































































Строки 35–47 предоставляют интерфейс вызова функции для 


, читая каждый раз данные 


. Издержками является один дескриптор файла, который остается открытым в течение жизни программы.




12.7. Расширения метасимволов



Три набора функции возрастающей сложности предусматривают возможность сопоставления с шаблонами групповых символов оболочки. Многим программам нужны такие библиотечные функции. Одним примером является 


: '


'. Другим примером является опция 


 во многих программах, которая принимает шаблон файлов с групповыми символами для исключения из того или иного действия. В данном разделе по очереди рассматривается каждый набор функций.




12.7.1. Простое сопоставление с шаблоном: 





Мы начинаем с функции 


 («filename match» — сопоставление имени файла»).













Эта функция сопоставляет 


 с 


, который является обычным шаблоном групповых символов оболочки. Значение флагов (которое вскоре будет описано) изменяет поведение функции. Возвращаемое значение равно 0, если 


 соответствует 


, 


, если не соответствует, и ненулевое значение, если возникла ошибка. К сожалению, POSIX не определяет каких-либо специфических ошибок; соответственно, вы можете лишь сказать, что что-то пошло не так, но не можете сказать, что.

Переменная 


 является побитовым ИЛИ одного или более флагов, перечисленных в табл. 12.1.



Таблица 12.1. Значения флагов для 










 работает со строками из любого источника; сопоставляемые строки не обязательно должны быть действительными именами файлов. Хотя на практике 


 используется в коде, читающем каталог с помощью 


 (см раздел 5.3.1 «Базовое чтение каталогов»):



















































GNU 


 использует 


 для реализации своей опции 


. Вы можете предоставить несколько игнорируемых шаблонов (с помощью нескольких опций). 


 сопоставляет каждое имя файла со всеми шаблонами. Она делает это с помощью функции 


 в 


:





































































































Цикл в строках 2276–2278 сопоставляет имя файла со списком шаблонов для игнорируемых файлов. Если один из шаблонов подходит, файл не интересен и 


 возвращает false (то есть 0).

Переменная 


 соответствует опции 


, которая показывает файлы, имена которых начинаются с точки, но не являются '


' и '


'. Переменная 


 соответствует опции 


, которая предполагает 


, а также показывает '


' и '


'. При наличии таких сведений, условие в строках 228–2284 может быть представлено следующим псевдокодом:






































ЗАМЕЧАНИЕ. 


 может оказаться дорогостоящей функцией, если она используется в локали с многобайтным набором символов. Обсудим многобайтные наборы символов в разделе 13.4 «Можете произнести это для меня по буквам?»





12.7.2. Раскрытие имени файла: 


 и 





Функции 


 и 


 более разработанные, чем 


:























Функция 


 осуществляет просмотр каталога и сопоставление с шаблонами, возвращая список всех путей, соответствующих 


. Символы подстановки могут быть включены в нескольких местах пути, а не только в качестве последнего компонента (например, '


'). Аргументы следующие:






Шаблон для раскрывания.






Флаги, управляющие поведением 


, вскоре будут описаны.






Указатель на функцию для использования при сообщениях об ошибках. Это значение может равняться 


. Если нет и если 


 возвращает ненулевое значение или в 


 установлен 


, 


 прекращает обработку. Аргументами 


 являются путь, вызвавший проблему, и значение errno, установленное функциями 


, 


 или 


.






Указатель на структуру 


, использующуюся для хранения результатов. Структура 


 содержит список путей, которые выдает 


:































Число путей, которые подошли.






Массив подходящих путей. 


 всегда равен 


.






«Зарезервированные слоты» в 


. Идея заключается в резервировании слотов спереди от 


 для заполнения их приложением впоследствии, как в случае с именем команды и опциями. Список затем может быть передан непосредственно 


 или 


 (см. раздел 9.1.4 «Запуск новой программы: семейство 


»). Зарезервированные слоты устанавливаются в 


. Чтобы все это работало, в 


 должен быть установлен 


.

В табл. 12.2 перечислены стандартные флаги для 


.



Таблица 12.2. Флаги для 







GLIBC версия структуры 


 содержит дополнительные члены:







































































Члены структуры следующие:






Копия флагов. Включает также 


, если 


 включал какие-либо метасимволы.






Указатель на альтернативную версию 


.






Указатель на альтернативную версию 


.






Указатель на альтернативную версию 


.






Указатель на альтернативную версию 


.






Указатель на альтернативную версию 


.

Указатели на альтернативные версии стандартных функций предназначены главным образом для использования в реализации GLIBC; крайне маловероятно, что вы когда-нибудь их используете. Поскольку GLIBC предусматривает поле 


 и дополнительные значения флагов, справочная страница и руководство Info документируют оставшуюся часть структуры GLIBC 


. В табл. 12.3 перечислены дополнительные флаги.



Таблица 12.3. Дополнительные флаги GLIBC для 







Флаг 


 действует в качестве подсказки реализации, потому что вызывающий интересуется лишь каталогами. Главным его предназначением является использование другими функциями в GLIBC, а вызывающий по-прежнему должен быть готов обрабатывать файлы, не являющиеся каталогами. Вам не следует использовать этот флаг в своих программах.




 может быть вызвана более одного раза: при первом вызове флаг 


не должен быть указан, при всех последующих вызовах он должен быть указан. Вы не можете между вызовами изменять 


, а если вы изменили какие-нибудь значения в 


 или 


, нужно их восстановить перед последующим вызовом 


.

Возможность многократного вызова 


 позволяет накапливать результаты в одном списке. Это довольно практично, приближается к мощным возможностям раскрывания групповых символов оболочки, но на уровне языка программирования С.




 возвращает 0, если не было проблем, или одно из значений из табл. 12.4, если были.



Таблица 12.4. Возвращаемые 


 значения







 освобождает всю память, которую динамически выделила 


 Следующая программа, 


, демонстрирует 


:





































































































































































































































































Строка 7 определяет 


, которая указывает на имя программы; эта переменная для сообщений об ошибках от 


, определенной в строках 11–15.

Строки 33–45 являются основой программы. Они перебирают в цикле шаблоны, приведенные в командной строке, вызывая для каждого 


 для добавления к списку результатов. Большую часть цикла составляет обработка ошибок (строки 36–44). Строки 47–48 выводят результирующий список, а строки 50–51 проводят завершающую очистку и возвращаются.

Строки 39–41 не являются хорошими; нужно было использовать отдельную функцию, преобразующую целые константы в строки; мы сделали это главным образом ради экономии места. Код наподобие этого может быть сносным для небольших программ, но более крупные должны использовать функцию.

Если вы подумаете о работе, происходящей под капотом (открытие и чтение каталогов, сопоставление шаблонов, динамическое выделение памяти для увеличения списка, сортировка списка), можете качать ценить, как много для вас делает 


! Вот некоторые результаты:









































Обратите внимание, что нам пришлось взять аргументы в кавычки, чтобы предотвратить их разворачивание оболочкой!




Универсализация имен? Что это?

В былые времена, около V6 Unix, для осуществления разворачивания символов подстановки оболочка использовала за кулисами отдельную программу. Эта программа называлась 


, и согласно исходному коду V6[130 - См 


 в дистрибутиве V6], имя «glob» было сокращением от «global».

Таким образом глагол «to glob» проник в лексикон Unix со значением «осуществлять разворачивание символов подстановки». Это, в свою очередь, дает нам имена функций 


 и 


. Так что обычно недооцениваемое чувство юмора, время от времени проглядывающее из руководства Unix, все еще живо, официально сохраненное в стандарте POSIX. (Можете ли вы представить кого-нибудь в IBM в 70-х или 80-х годах XX века, называющего системную процедуру 


?)





12.7.3. Разворачивание слов оболочкой: 


 и 





Многие члены комитета POSIX чувствовали, что 


 делает недостаточно: им нужна была библиотечная процедура, способная делать все, что может делать оболочка разворачивание тильды ('


'), разворачивание переменных оболочки ('


') и подстановку команд ('


'). Многие другие чувствовали, что 


 не подходила для этой цели. Чтобы «удовлетворить» каждого, POSIX предоставляет две дополнительные функции, которые делают все:


















Эти функции работают сходным с 


 и 


 образом, но со структурой 


:


























Члены структуры полностью аналогичны описанным ранее для 


; мы не будем здесь повторять все описание.

Как и для 


, поведение 


 управляется несколькими флагами. Флаги перечислены в табл. 12.5.



Таблица 12.5. Флаги для 







Возвращаемое значение равно 0, если все прошло хорошо, или одно из значений из табл. 12.6, если нет.



Таблица 12.6. Возвращаемые значения ошибок для 







Мы оставляем вам в качестве упражнения (см. далее) модификацию 


 для использования 


 и 


. Вот наша версия в действии:



































































































12.8. Регулярные выражения


Регулярные выражения являются способом описания текстовых шаблонов для сопоставления. Если вы вообще сколько-нибудь использовали GNU/Linux или Unix, вы без сомнения знакомы с регулярными выражениями: они являются фундаментальной частью инструментария программиста Unix. Они неотъемлемы от таких повседневных программ, как 


, 


, 


, 


, Perl, а также редакторы 


, 


, 


 и Emacs. Если вы вообще не знакомы с регулярными выражениями, мы рекомендуем ознакомиться с некоторыми из книг или URL, указанных в разделе 12.9 «Рекомендуемая литература».

POSIX определяет два вида регулярных выражений: базовый и расширенный. Программы типа 


, 


 и строчный редактор 


 используют базовые регулярные выражения. Программы типа 


 и 


 используют расширенные регулярные выражения. Следующие функции дают вам возможность использовать в своих программах любой вид.











































Чтобы сопоставить регулярное выражение, нужно сначала откомпилировать строчную версию регулярного выражения. Компиляция преобразует регулярное выражение во внутренний формат. Затем откомпилированная форма исполняется для строки для проверки, совпадает ли она с первоначальным регулярным выражением. Функции следующие.






Компилирует регулярное выражение 


 во внутреннее представление, сохраняя его в структуре 


, на которую указывает 


. 


 контролирует процесс компиляции; ее значение равно 0 или побитовому ИЛИ одного или более флагов из табл. 12.7











Выполняет откомпилированное регулярное выражение в 


 в строке 


 контролирует способ выполнения; ее значение равно 0 или побитовому ИЛИ одного или более флагов из табл. 12.8. Вскоре мы обсудим другие аргументы.











Преобразует ошибку, возвращенную 


 или 


, в удобочитаемую строку.






Освобождает динамическую память, используемую откомпилированным регулярным выражением в 


.

Заголовочный файл 


 определяет ряд флагов. Некоторые используются с 


; другие используются с 


. Однако, все они начинаются с префикса '


'. В табл. 12.7 перечислены флаги для компиляции регулярных выражений с помощью 


.



Таблица 12.7. Флаги для 







Флаги для сопоставления регулярных выражений с помощью 


 приведены в табл. 12.8.



Таблица 12.8. Флаги дли 







Флаги 


, 


 и 


 взаимодействуют друг с другом. Это немного запутано, поэтому мы будем продвигаться небольшими шажками.

• Когда в 


 не включен 


, символ конца строки действует в качестве обычного символа. С ним может быть сопоставлен метасимвол '


' (любой символ), а также дополненные списки символов ('


'). При этом 


 не сопоставляется немедленно с началом вставленного символа новой строки, а 


 не сопоставляется немедленно с его концом.

• Когда в 


 установлен 


, оператор 


 не соответствует началу строки. Это полезно, когда параметр 


 является адресом символа в середине сопоставляемого текста.

• Сходным образом, когда в 


 установлен 


, оператор 


 не соответствует концу строки.

• Когда в 


 включен 


, то:

 • Символ конца строки не соответствует '


' или дополненному списку символов.

 • Оператор 


 всегда соответствует положению непосредственно за вставленным символом конца строки независимо от установки 


.

 • Оператор 


 всегда соответствует положению непосредственно перед вставленным символом конца строки независимо от установки 


.

Когда вы осуществляете построчный ввод/вывод, как в случае с 


, можно не включать 


 в 


. Если в буфере несколько строк, и каждую из них нужно рассматривать как отдельную, с сопоставлением 


 и 


, тогда следует включить 


.

Структура 


 по большей части непрозрачна. Код уровня пользователя может исследовать лишь один член этой структуры; остальное предназначено для внутреннего использования процедурами регулярных выражений:


























В структуре 


 есть по крайней мере два члена для использования кодом уровня пользователя:































Как поле 


, так и структура 


 предназначены для сопоставления вложенных выражений. Рассмотрим такое регулярное выражение: 






Каждое из двух вложенных выражений в скобках могут соответствовать одному или более символам. Более того, текст, соответствующий каждому вложенному выражению, может начинаться и заканчиваться в произвольных участках строки.




 устанавливает в поле 


 число вложенных выражений в скобках внутри регулярного выражения, 


 заполняет массив 


 структур 


 смещениями начальных и конечных байтов текста, соответствующих этим вложенным выражениям. Вместе эти данные позволяют заменять текст — удалять его или заменять другим текстом, точно так же, как в текстовом редакторе




 описывает часть строки, соответствующую всему регулярному выражению. Участок от 


 до 


 описывает ту часть, которая соответствует каждому вложенному выражению в скобках. (Таким образом, вложенные выражения нумеруются начиная с 1.) Элементы 


 и 


 не используемых элементов массива 


 установлены в -1.




 заполняет не более 


 элементов 


; поэтому следует убедиться, что имеется по крайней мере на 1 элемент больше, чем в 


.

Наконец, флаг 


 для 


 означает, что начальная и завершающая информация не нужна. Этот флаг следует использовать, когда эти сведения не нужны; это потенциально может довольно значительно повысить производительность 


.

Другими словами, если все, что вам нужно знать, это «соответствует ли?», включите 


. Однако, если нужно также знать, «где находится соответствующий текст?», этот флаг следует опустить.

В заключение, как 


, так и 


 возвращают 0, если они успешны, или определенный код ошибки, если нет. Коды ошибок перечислены в табл. 12.9.



Таблица 12.9. Коды ошибок 


 и 







Для демонстрации регулярных выражений 


 предусматривает базовую реализацию стандартной программы 


, которая отыскивает соответствие шаблону. Наша версия использует по умолчанию базовые регулярные выражения. Для использования вместо этого расширенных регулярных выражений она принимает опцию 


, а для игнорирования регистра символов опцию 


. Как и настоящая 


, если в командной строке не указаны файлы, наша 


 читает со стандартного ввода, а для обозначения стандартного ввода, как и в настоящей 


, может быть использовано имя файла '


'. (Эта методика полезна для поиска в стандартном вводе наряду с другими файлами.) Вот программа:
































































































Строки 10–15 объявляют глобальные переменные программы. Первый набор (строки 10–13) для опций и сообщений об ошибках. Строка 15 объявляет 


, в которой хранится откомпилированный шаблон. Строки 17–19 объявляют другие функции программы.




























































































































































В строке 29 устанавливается значение 


, а строки 30–45 анализируют опции. Строки 47–51 компилируют регулярное выражение, помещая результаты в 


, 


 увеличивает значение 


, если была проблема. (Соединение функций посредством глобальной переменной, как здесь, обычно считается плохой манерой. Для небольших программ, подобным этой, это сойдет, но для более крупных программ такое сопряжение может стать проблемой.) Если не было ошибок, строка 51 увеличивает значение 


 так, что оставшиеся аргументы представляют файлы для обработки.










































































































Строки 53–69 обрабатывают файлы, отыскивая соответствующие шаблону строки. Строки 53–54 обрабатывают случай, когда файлы не указаны: программа читает со стандартного ввода. В противном случае, строки 57–68 обрабатывают в цикле файлы. Строка 58 обрабатывает особый случай '


', обозначающий стандартный ввод, строки 60–62 обрабатывают обычные файлы, а строки 63–67 обрабатывают ошибки.










































































































Строки 75–95 определяют функцию 


. Она сначала устанавливает 


 в 


, поскольку нам нужно знать лишь «подходит ли строка?», а не «где в строке располагается подходящий текст?»

Строки 84-85 добавляют дополнительные флаги в соответствии с опциями командной строки. Строка 89 компилирует шаблон, а строки 90–94 сообщают о возникших ошибках

























































































































Строки 97–120 определяют функцию 


, которая читает файл и выполняет сопоставление с регулярным выражением. Внешний цикл (строки 106–119) читает строки ввода. Для избежания проблем с длиной строки мы используем 


 (см. раздел 3.2.1.9 «Только GLIBC: чтение целых строк: 


 и 


»). Строка 107 вызывает 


. Ненулевое возвращаемое значение означает либо неудачное сопоставление, либо какую-нибудь другую ошибку. Строки 109–115 соответственно проверяют 


 и выводят ошибку лишь тогда, когда возникла какая-нибудь другая проблема — неудачное сопоставление не является ошибкой

Если возвращаемое значение равно 0, строка совпала с шаблоном и соответственно строка 117 выводит имя файла и совпавшую строку.




































Функция 


 выводит сообщение об использовании и завершает программу. Она вызывается, когда предоставлены недействительные аргументы или не предоставлен шаблон (строки 38–40 и 44–45).

Вот и все! Скромная, но тем не менее полезная версия 


 в 130 строк кода.




12.9. Рекомендуемая литература


1. Programming Pearls, 2nd edition, by Jon Louis Bentley Addison-Wesley, Reading, Massachusetts, USA, 2000. ISBN- 0-201-65788-0. См. также веб-сайт этой книги.[131 - 


 — Примеч. автора.]

Проектирование программы с операторами проверки является одной из главных тем в этой книге.

2. Building Secure Software How to Avoid Security Problems the Right Way, by John Viega and Gary McGraw Addison-Wesley, Reading, Massachusetts, USA, 2001. ISBN: 0-201-72152-X.

Состояния гонки являются одной из многих проблем, о которых нужно побеспокоиться при написании безопасного программного обеспечения. Другой проблемой являются случайные числа. Данная книга рассматривает наряду с другими обе эти проблемы (Мы упоминали о ней в предыдущей главе.)

3. The Art of Computer Programming. Volume 2. Seminumerical Algorithms, 3


 edition, by Donald E. Knuth Addison-Wesley, Reading, Massachusetts, USA, 1998. ISBN- 0-201-89684-2.[132 - Русский перевод: Дональд E. Кнут. Искусство программирования. Том 2. Получисленные алгоритмы (3-е издание). Москва - Санкт-Петербург - Киев. Вильямс. 2000 — Примеч. науч. ред.] См также веб-сайт этой книги.[133 - 


 — Примеч. автора.]

Это классическое справочное руководство по генерации случайных чисел.

4. Random Number Generation and Monte Carlo Methods, 2nd edition, by James E. Gentle Springer-Verlag, Berlin, Germany. 2003. ISBN: 0-387-00178-6.

Данная книга широко освещает методы генерации и тестирования псевдослучайных чисел. Хотя для неё также требуется математическая и статистическая подготовка, уровень не такой высокий, как в книге Кнута. (Благодарим Nelson H.F. Beebe за указание этой ссылки.)

5. sed & awk, 2nd edition, by Dale Dougherty and Arnold Robbins. O'Reilly and Associates, Sebastopol, California, USA, 1997. ISBN: 1-56592-225-5.

Эта книга осторожно вводит в регулярные выражения и обработку текста, начиная с 


 и продвигаясь к более мощным инструментам 


 и 


.

6. Mastering Regular Expressions, 2nd edition, by Jeffrey E.F. Friedl. O'Reilly and Associates, Sebastopol, California, USA, 2002.[134 - Русский перевод — Дж. Фридл. Регулярные выражения (2-е издание). C.-Петербург, Питер, 2003 — Прим. науч. ред.] ISBN: 0-59600-289-0.

Регулярные выражения являются важной частью Unix. Чтобы научиться заменять, вырезать и распределять текст с использованием регулярных выражений, мы рекомендуем эту книгу

7. Руководство для GNU 


 также объясняет регулярные выражения. На системе GNU/Linux для просмотра локальной копии вы можете использовать '


'. Или использовать браузер для прочтения онлайн-документации проекта GNU для 


.[135 - 


 — Примеч. автора.]




12.10. Резюме


• Операторы проверки предоставляют способ сделать утверждения о предполагаемом состоянии программы. Они являются полезным инструментом для проектирования и отладки и обычно должны оставаться в коде изделия. Однако, будьте внимательны, чтобы не перепутать операторы проверки с проверками возможных ошибок времени исполнения.

• Функции 


 являются аналогичными более известным функциям 


. Самой большой их ценностью является то. что они могут работать с двоичными данными; нулевые байты не отличаются от других байтов. Больше известна 


 против 


, обрабатывающей перекрывающиеся копии.

• Временные файлы полезны во многих приложениях. Функции API 


 и 


 являются предпочтительными способами создания временных файлов, в то же время позволяя избежать состояния гонки и связанных с ней проблем безопасности. Многие программы для указания местоположения своих временных файлов используют переменную окружения 


, а если она не определена, приемлемое значение по умолчанию (обычно 


). Это хорошее соглашение, которое следует принять на вооружение в своих программах.

• Функция 


 посылает вызывающему процессу сигнал 


. Результатом является завершение процесса и создание дампа ядра, предположительно для отладки.

• 


 и 


 обеспечивают нелокальный переход. Это мощная возможность, которая должна использоваться с осторожностью. 


 и 


 сохраняют и восстанавливают маску сигналов процесса, когда программа осуществляет нелокальный переход. Проблемы с нелокальными переходами иногда перевешивают их преимущества, соответственно используйте эти процедуры лишь когда нет лучшего способа структурировать ваше приложение.

• Случайные числа полезны для множества приложений. Большинство программ используют псевдослучайные числа — последовательности номеров, которые кажутся случайными, но которые могут быть воспроизведены с помощью одного и того же начального значения. 


 и 


 являются первоначальными функциями API, стандартизованными языком С. На многих системах 


 использует низкокачественный алгоритм, 


 и 


 используют лучший алгоритм, включены в стандарт POSIX и являются предпочтительными по сравнению с 


 и 


. Используйте специальные файлы 


 и 


, если (а) они доступны и (б) если вам нужны случайные числа высокого качества.

• Три функции API предоставляют все более мощные возможности для развертывания метасимволов (подстановки символов).

  • 


 является простейшей, возвращающей true/false, если данная строка соответствует или не соответствует шаблону символов подстановки оболочки.

  • 


 просматривает файловую систему, возвращая список путей, которые соответствуют данному шаблону. Когда требуются стандартные возможности 


, следует использовать эту функцию. Хотя GLIBC версия 


 имеет некоторые расширения, переносимые программы, которым нужны дополнительные возможности, должны вместо этого использовать 


. (Программы, которые будут работать лишь на системах GNU/Linux, не должны стесняться использовать полную мощь GLIBC 


.)

  • 


 не только делает то, что делает 


, но также выполняет полное развертывание слов в стиле оболочки, включая развертывание тильды, развертывание переменных оболочки и подстановку команд.

• Функции 


 и 


 обеспечивают доступ к базовым и расширенным регулярным выражениям POSIX. Используя одну из этих функций, можно заставить свою программу вести себя идентично со стандартными утилитами, значительно упрощая использование программы пользователями, знакомыми с GNU/Linux и Unix.




Упражнения


1. Используйте 


 и 


 для написания простой версии программы 


, которая сравнивает два файла. Вашей версии не нужно поддерживать какие-нибудь опции.

2. Используйте макрос 


 и прямое сравнение каждого прочитанного символа для написания другой версии 


, которая сравнивает два файла. Сравните производительность этой версии с производительностью написанной в предыдущем упражнении.

3. (Средней трудности) Рассмотрите функции 


 и GLIBC 


. Полезна ли 


 для их реализации? Набросайте с ее использованием возможную реализацию 


.

4. (Трудное) Найдите исходный код GLIBC версии 


. Он должен быть на одном из CD-ROM с исходным кодом в вашем дистрибутиве GNU/Linux, или же вы можете найти его в сети. Исследуйте код и объясните его.

5. Проверьте свою память. Как 


 организует удаление файла, когда закрыт указатель файла?

6. Используя 


 и 


, а также другие необходимые функции или системные вызовы, напишите свою версию 


. Протестируйте ее тоже.

7. Опишите преимущества и недостатки использования 


 для имени файла, созданного 


, непосредственно после возвращения 


.

8. Напишите свою версию 


, используя 


 и 


. Как вы можете обеспечить те же гарантии уникальности, которые обеспечивает 


?

9. Программы, использующие 


, должны обеспечивать удаление файла при завершении. (Предположим, что файл не удаляется сразу же после открытия по тем или иным причинам.) Это включает в себя случай, когда может поступить сигнал завершения. Поэтому удаление файла должно быть частью перехватчика сигнала. Как вы это сделаете?

10. (Трудное) Даже с урезанной очисткой при обработке сигнала все еще имеется состояние гонки. Есть небольшое окно между созданием временного файла функцией 


 и возвращением и записью его имени в переменной (для использования функцией обработки сигнала). Если в это окно попадает не перехваченный сигнал, программа завершается и оставляет временный файл. Как вы закроете это окно? (Спасибо Jim Meyering.)

11. Попробуйте откомпилировать и запустить 


 на как можно большем количестве различных систем с использованием как можно большего количества различных компиляторов, к каким у вас есть доступ. Попробуйте компилировать с различными уровнями оптимизации. Какие изменения поведения вы видели (если они были)?

12. Посмотрите файл 


 в дистрибутиве исходного кода V7 Unix. Он содержит реализацию функции 


, описанную в разделе 10.8.1 «Сигнальные часы: 


, 


 и 


». Распечатайте ее и прокомментируйте в стиле наших примеров, чтобы объяснить ее работу.

13. Посмотрите справочную страницу lrand48(3) на системе GNU/Linux или System V. Выглядит ли этот интерфейс более простым или трудным для использования, чем 


?

14. Возьмите 


 из раздела 8.4.3 «Перемещение по иерархии: 


» и добавьте опцию 


. Файлы, соответствующие паттерну, не должны выводиться.

15. (Трудное) Почему GLIBC нужны указатели на альтернативные версии функций стандартных каталогов и 


? Не может ли она вызывать их непосредственно?

16. Измените 


 для использования функции 


. Поэкспериментируйте с ней, проделав несколько дополнительных вещей, которые она предоставляет. Не забудьте взять аргументы командной строки в кавычки, чтобы 


 на самом деле выполнила свою работу!

17. Стандартная 


 выводит имя файла, лишь когда в командной строке указано больше одного файла. Сделайте так, чтобы 


 действовала таким же образом.

18. Посмотрите справочную страницу grep(1). Добавьте к 


 стандартные опции 


, 


 и 


.

19. Напишите простую замещающую программу:






Она должна читать текстовые строки из указанных файлов или из стандартного ввода, если они не указаны. Каждая строка должна сравниваться на соответствие шаблону. Если обнаружено соответствие, оно должно замещаться подстановкой.

Если указана опция 


, замещаться должно не только первое совпадение, но и все остальные совпадения в строке.




Глава 13

Интернационализация и локализация



Ранние вычислительные системы обычно для своего вывода (приглашений, сообщений об ошибках) и ввода (ответы на запросы, такие, как «да» и «нет») использовали английский язык. Это было верно для систем Unix вплоть до середины 1980-х. В конце 80-х, начиная с первого стандарта ISO для С и продолжая стандартами POSIX 1990-х и современным стандартом POSIX, были разработаны возможности для работы программ на нескольких языках без необходимости поддержки нескольких версий одной и той же программы. Данная глава описывает, как современные программы должны справляться с многоязычными проблемами.




13.1. Введение


Центральной концепцией является окружение, место, в котором работает программа. Локали содержат в себе следующие сведения: локальный набор символов; сведения о формате отображения даты и времени; форматирование и отображение денежных сумм; форматирование и отображение числовых значений (с или без разделителей тысяч, какой символ используется в качестве разделителя дробной части числа и т.д.).

Интернационализация является процессом написания (или изменения) программы таким образом, что она может работать с различными локалями. Локализация является процессом приспособления интернационализированной программы для определенной локали. Часто вместо этих терминов используют сокращения i18n и l10n соответственно. (Числовое значение указывает, сколько букв в середине слова, а эти сокращения имеют небольшое сходство с полными терминами.[136 - От английских слов i(nternationalizatio)n и l(ocalizatio)n —Примеч. перев.] Их также гораздо легче набирать.) Другим часто встречающимся термином является поддержка родного языка, обозначаемая как NLS[137 - NLS — native language support — Примеч. перев.]; NLS обозначает программную поддержку для i18n и l10n.

Кроме того, некоторые люди используют термин глобализация (сокращенно g10n) для обозначения процесса подготовки всех возможных локализаций для интернационализированной программы. Другими словами, подготовки программы для глобального использования.

Возможности NLS существуют на двух уровнях. Первым уровнем является библиотека С. Она предоставляет сведения о локали; процедуры для обработки большей части низкоуровневых подробностей работы по форматированию даты/времени, числовых и денежных значений; и процедуры для корректного для данной локали сопоставления регулярных выражений и классификации символов и сравнений. Именно возможности библиотеки появляются в стандартах С и POSIX.

На уровне приложения GNU 


 предоставляет команды и библиотеку для локализации программы: т.е. для возможности вывода сообщений на одном или более естественных языках. GNU 


 основана на плане, первоначально разработанном Sun Microsystems для Solaris[138 - Существует более ранний дизайн, известный как 


. Хотя он стандартизован POSIX, его гораздо сложнее использовать, и мы его не рекомендуем — Примеч. автора.]; однако, она была реализована с нуля и теперь предоставляет расширения к первоначальному 


 Solaris. GNU 


 является стандартом де-факто для локализации программ, особенно в мире GNU.

В дополнение к локалям и 


 стандарт С предоставляет возможности для работы с несколькими наборами символов и с их кодировками — способом представления больших наборов символов с помощью меньшего числа байтов. Мы кратко затронем эти проблемы в конце главы.




13.2. Локали и библиотека С



Специфичное для локали поведение управляется посредством установки переменных окружения, описывающих, какую локаль (локали) использовать для той или иной информации. Число доступных локалей, предлагаемых каждой конкретной операционной системой, колеблется от менее чем десяти на некоторых коммерческих системах Unix до сотен локалей на системах GNU/Linux. ('


' выводит полный список доступных локалей.)

Гарантируется существование двух локалей, «С» и «POSIX». Они действуют в качестве локали по умолчанию, предоставляя окружение 7-разрядного ASCII, поведение которого такое же, как на традиционных системах Unix без поддержки локалей. В противном случае, локали обозначают язык, страну, а также могут включать сведения о наборе символов. Например, '


' используется для итальянского языка в Италии с использованием системного набора символов по умолчанию, a '


' использует кодировку UTF-8 для набора символов Unicode.

Дополнительные подробности об именах локалей можно найти в справочной странице GNU/Linux setlocale(3). Обычно дистрибутивы GNU/Linux устанавливают для системы локаль по умолчанию при ее установке, основываясь на языке, выбранном тем кто устанавливал ее, и пользователям больше не приходится об этом беспокоиться.




13.2.1. Категории локалей и переменные окружения


Заголовочный файл 


 определяет функции и структуры локали. Категории локали определяют разновидности информации, которые будут для программы зависимы от локали. Категории доступны в виде набора именованных констант. Они перечислены в табл. 13.1.



Таблица 13.1. Константы категорий локалей ISO С, определенные в 







Эти категории определены различными стандартами. Некоторые системы могут поддерживать дополнительные категории, такие, как 


 или 


. Однако, они не стандартизованы; любой программе, которой нужно их использовать, но которая все равно должна быть переносимой, следует использовать 


 для окружения соответствующих разделов.

По умолчанию, программы С и библиотека С ведут себя так, как если бы они находились в локали «С» или «POSIX» для обеспечения обратной совместимости со старыми системами. Однако, вызвав 


 (как описано ниже), программа может включить действие локали. После того, как программа это сделала, пользователь может, установив переменные окружения, включать и выключать возможности локали, которые будет иметь программа.

Переменные окружения имеют те же самые имена, что и перечисленные в табл. 13.1 категории локалей. Таким образом, команда —






— определяет, что числа должны выводиться в соответствии с локалью '


' (английский язык в Дании), но что значения даты и времени должны выводиться в соответствии с обычной локалью '


'. (Этот пример просто иллюстрирует, что вы можете указывать для различных категорий различные локали; это не является чем-то обязательным, что вы должны делать.)

Переменная окружения 


 перекрывает все другие переменные 


. Если 


 не установлена, библиотека ищет определенные переменные (


, 


 и т.д.). Наконец, если ни одна из них не установлена, библиотека ищет переменную 


. Вот небольшая демонстрация с использованием 


:



























































































Для 


 стандарт POSIX констатирует, что числовые константы в исходном коде всегда используют в качестве десятичного разделителя '


' тогда как числовой вывод следует правилам локали).

Почти все GNU версии стандартных утилит Unix могут использовать локали. Таким образом, особенно на системах GNU/Linux, установка этих переменных позволяет вам контролировать поведение системы[139 - Программисты, долгое время работавшие на С и Unix, могут предпочесть использовать локаль '


', даже если их родной язык английский, английские локали дают другой результат по сравнению с тем, что ожидают эти седые, понюхавшие пороху ветераны Unix — Примеч. автора.].




13.2.2. Установка локали: 





Как уже упоминалось, если вы ничего не делаете, программы на С и библиотека С ведет себя так, как если бы использовалась локаль «С». Функция 


 устанавливает соответствующую локаль:













Аргумент 


 является одной из категорий, описанных в разделе 13.2.1 «Категории локалей и переменные окружения». Аргумент 


 является строкой, именующей используемую для этой категории локаль. Когда 


 является пустой строкой (


), 


 проверяет соответствующие переменные окружения.

Если 


 равно 


, сведения о локали не изменяются. Вместо этого функция возвращает строку, представляющую текущую локаль для данной категории.

Поскольку каждая категория может быть установлена индивидуально, автор приложения решает, насколько будет программа использовать локаль. Например, если 


 делает лишь это —











— тогда, независимо от установленных в окружении других переменных 


, локали подчиняются лишь функции времени и даты. Все остальные действуют так, как если бы программа по-прежнему работала в локали «С». Сходным образом вызов:






заменяет переменную окружения 


 (также, как 


), заставляя программу использовать для вычислений времени/даты данные для Италии. (Хотя Италия может быть прекрасным местом, программам лучше использовать 


, чтобы они могли корректно работать везде; этот пример предназначен лишь для объяснения того, как работает 


.)

Можно индивидуально вызывать 


 для каждой категории, но простейшим способом является установка всего одним махом:











Возвращаемое 


 значение является текущей установкой локали. Это либо строковое значение, переданное в предыдущем вызове, либо непрозрачное значение, представляющее используемую вначале локаль. Это самое значение может быть затем передано обратно 


. Для последующего использования возвращаемое значение должно быть скопировано в локальное хранилище, поскольку это указатель на внутренние данные.





















Здесь мы сохранили копию, использовав функцию POSIX 


 (см. раздел 3.2.2 «Копирование строк: 


»).




13.2.3. Сравнение строк: 


 и 


()


Знакомая функция 


 сравнивает две строки, возвращая отрицательное, нулевое или положительное значения, если первая строка меньше, равна или больше второй. Это сравнение основано на числовых значениях символов в машинном наборе символов. Из-за этого результаты 


никогда не изменяются.

Однако, при наличии локалей простого числового сравнения недостаточно. Каждая локаль определяет для содержащихся в ней символов последовательность сортировки, другими словами, относительный порядок символов внутри локали. Например, в простом 7-битном ASCII у двух символов '


' и '


' десятичные значения равны 65 и 97 соответственно. Соответственно, во фрагменте









 имеет отрицательное значение. Однако, в локали "


" '


' идет после '


', а не перед ним. Таким образом, использование 


 для приложений, использующих локаль, является плохой мыслью, мы могли бы сказать, что она возвращает игнорирующий локаль ответ.

Функция 


 (string collate — сортировка строк) существует для сравнения строк с использованием локали:













Она возвращает такие же отрицательные/нулевые/положительные значения, что и 


. Следующая программа, 


, интерактивно демонстрирует разницу:




































































































































































































Программа читает входные строки, состоящие из двух сравниваемых слов и необязательной локали, использующейся для сравнения. Если локаль дана, она становится локалью для последующих элементов. Программа начинает с любой локалью, которая установлена в окружении.

Массив 


 сохраняет текущую локаль для вывода результатов; 


 и 


 являются левым и правым сравниваемыми словами (строки 10–11). Основную часть программы составляет цикл (строки 19–36), который читает строки и выполняет работу. Строки 20–23 разделяют входную строку, 


 инициализируется пустой строкой, если третья строка не предусмотрена.

Строки 25–28 устанавливают новую локаль, если она приведена. Строки 30–33 выводят результаты сравнения, а строка 35 приглашает для дальнейшего ввода. Вот демонстрация:













































































Эта программа ясно показывает различие между 


 и 


. Поскольку 


 работает в соответствии с числовыми значениями символов, она всегда возвращает тот же самый результат, 


 понимает проблемы сортировки, и ее результат меняется в соответствии с локалью. Мы видим, что в обеих локалях 


 заглавные буквы идут после строчных.



ЗАМЕЧАНИЕ. Специфическая для локали сортировка строк является проблемой также и для сопоставления регулярных выражений. Регулярные выражения допускают диапазоны символов внутри выражений со скобками, такие, как '


' или '


'. Точное значение такой конструкции (символы, численно располагающиеся между начальной и конечной точками включительно) определено лишь для локалей «С» и «POSIX»

Для локалей, не являющихся ASCII, такие диапазоны как '


' могут соответствовать также и заглавным буквам, а не только строчным! Диапазон '


' действителен в ASCII, но не в "


".

Долговременным наиболее переносимым решением является использование классов символов POSIX, таких, как '


' и '


'. Если вам кажется, что нужно использовать выражения с диапазонами на системах, использующих локали, и на более старых системах, не использующих их, без изменения своей программы, решение заключается в применении грубой силы и индивидуальном перечислении каждого символа внутри скобок. Это неприятно, но это работает.


Основанная на локалях сортировка потенциально дорогостоящая. Если вы ожидаете большого числа сравнений, где по крайней мере одна из строк не будет изменяться или где значения строк будут сравниваться друг с другом по несколько раз (как при сортировке списка), следует рассмотреть использование функции 


 для преобразования своих строк для использования с 


. Функция 


 объявлена следующим образом:













Идея в том, что 


 преобразует первые n символов 


, помещая их в 


. Возвращаемое значение является числом символов, необходимых для сохранения преобразованных символов. Если она превышает n, содержимое 


 «неопределенно».

Стандарт POSIX явным образом разрешает устанавливать в 


 ноль, а в 


. В этом случае 


 возвращает размер массива, необходимого для сохранения преобразованной версии 


 (не включая завершающий символ '


'). Предполагается, что это значение впоследствии будет использовано с 


 для создания массива 


 или для проверки размера предопределенных границ массива (При этом, очевидно, 


 должен иметь завершающий нулевой байт.) Этот фрагмент иллюстрирует использование 


:

































































































Для одноразовых сравнений, возможно, быстрее непосредственно использовать 


. Но если строки будут сравниваться несколько раз, более быстрым будет использование сначала 


, а затем 


 с преобразованными значениями. Функций для локали, соответствующих 


 или 


, нет.




13.2.4. Числовое и денежное низкоуровневое форматирование: 





Корректное форматирование числовых и денежных значений требует значительной низкоуровневой информации. Указанная информация доступна в 


, которую получают с помощью функции 


:













Подобно функции 


, эта функция возвращает указатель на внутренние статические данные. Следует сделать копию возвращенных данных, поскольку последующие вызовы могут возвратить другие значения, если локаль изменилась. Вот 


 (слегка сжатая), непосредственно из GLIBC 


:




















































































































































































































































































Комментарии показывают довольно ясно, что происходит. Давайте посмотрим на несколько первых полей 


:






Используемый символ разделителя десятичной дроби. В Соединенных Штатах и других англоязычных странах это точка, но во многих странах используется запятая.






Символ, используемый для разделения каждых 3 цифр значения.






Массив однобайтных целых значений. Каждый элемент указывает, сколько цифр в группе. Как сказано в комментарии, 


 означает, что дальше группировка не используется, а 0 означает повторное использование последнего элемента (Далее в главе мы покажем пример кода.)






Это международный символ для местной валюты. Например, 'USD' для доллара США.






Локальный символ для местной валюты. Например, $ для доллара США.




, 


, 




Соответствуют предыдущим полям, предоставляя те же сведения, но для денежных сумм.

Большая часть оставшихся значений не имеет значения для повседневного программирования. Следующая программа, 


, выводит некоторые из этих значений, чтобы дать вам представление, для какого рода сведений они используются:















































































































Неудивительно, при запуске в различных локалях мы получаем различные результаты.





































































































Обратите внимание, что значение 


 в локали "


" включает завершающий символ пробела, который служит для отделения символа от последующего денежного значения.




13.2.5. Высокоуровневое числовое и денежное форматирование: 


 и 





После рассмотрения всех полей 


 вы можете поинтересоваться: «Нужно ли мне на самом деле выяснять, как использовать все эти сведения, просто для форматирования денежного значения?» К счастью, ответом является «нет».[140 - Мы так же счастливы, как и вы, поскольку нам не нужно представлять код, использующий эту полнофункциональную структуру — Примеч. автора.] Функция 


 делает за вас всю работу:













Эта функция во многом подобна 


 (см. раздел 6.1.3.2 «Сложное форматирование времени: 


»), используя 


 для копирования символов букв и форматированных числовых значений в 


, помещая в нее не более max символов. Следующая простая программа, 


, демонстрирует работу 


:

































































При запуске в двух различных локалях она выдает такой результат:





















Как вы можете видеть, 


 подобна 


, копируя обычные символы в буфер назначения без изменений и форматируя аргументы в соответствии со своими собственными спецификациями форматирования. Их всего три.




Вывести национальное (т.е. местное) представление значения валюты.




Вывести международное представление значения валюты.




Вывести символ '


'.

Форматируемые значения должны иметь тип 


. Разницу между 


 и 


 мы видим в локали "


": 


 использует символ 


, тогда как 


 использует USD, которая означает «доллары США».

Гибкость — и соответственно определенная сложность — сопровождают многие функции API, разработанные для POSIX, и 


 не является исключением. Как и с 


, несколько необязательных элементов, которые могут быть между 


 и 


 или 


, обеспечивают повышенный контроль. Полные формы следующие:
















Флаги перечислены в табл. 13.2.



Таблица 13.2. Флаги для 







Ширина поля является строкой десятичных цифр, представляющих минимальную ширину. По умолчанию использует столько символов, сколько необходимо, основываясь на оставшейся части спецификации. Значения, меньшие ширины поля, дополняются пробелами слева (или справа, если указан флаг '


').

Точность слева состоит из символа 


 и строки десятичных цифр. Она указывает минимальное число цифр, которые должны быть слева от десятичного символа-разделителя дробной части[141 - В стандарте используется технический термин radix point (позиционный разделитель), поскольку числа с другим основанием счисления также могут иметь дробные части. Однако, для денежных значений можно довольно безопасно использовать термин 'decimal point' (десятичный разделитель) — Примеч. автора.]; если преобразованное значение меньше этого, результат выравнивается символом числового заполнения. По умолчанию используется пробел, однако для его изменения можно использовать флаг 


. Символы группировки не включаются в общий счет.

Наконец, точность справа состоит из символа '


' и строки десятичных цифр. Она указывает, с каким числом значащих цифр округлить значение до форматирования. По умолчанию используются поля 


 и 


 в 


. Если это значение равно 0, десятичная точка не выводится.




 возвращает число символов, помещенных в буфер, не включая завершающий нулевой байт. Если недостаточно места, функция возвращает -1 и устанавливает 


 в 


.

Помимо 


, POSIX (но не ISO С) предусматривает специальный флаг — символ одинарной кавычки, 


 — для форматов 





, 


, 


, 


, 


, 


 и 


. В локалях, имеющих разделитель тысяч, этот флаг добавляет и его. Следующая простая программа, 


, демонстрирует вывод:











































Вот что происходит для двух различных локалей: в одной есть разделитель тысяч, в другой нет:





















На время написания лишь GNU/Linux и Solaris поддерживают флаг 


. Дважды проверьте справочную страницу printf(3) на своей системе.




13.2.6. Пример: форматирование числовых значений в 








 реализует свои собственные версии функций 


 и 


. Для полного использования локали 


 должен поддерживать флаг 


, как в С. Следующий фрагмент из файла 


 в 


 3.1.4 показывает, как 


 использует 


 для числового форматирования:



































































































































(Номера строк даны относительно начала фрагмента.) Некоторые части кода, не имеющие отношения к обсуждению, были опущены, чтобы облегчить фокусировку на важных частях.

Переменная 


, используемая в строках 13–17, представляет 


. Она инициализируется в 


. Здесь для нас интерес представляет 


, который является символом разделителя тысяч, и 


, который является массивом, описывающим число цифр между разделителями. Нулевой элемент означает «использовать для всех последующих цифр значение предыдущего элемента», а значение 


 означает «прекратить вставку разделителей тысяч».

С таким введением, давайте посмотрим на код. Строка 7 устанавливает 


, которая является беззнаковой версией форматируемого значения. 


 и 


 отслеживают положение в 


 и число цифр в текущей группе, которые были преобразованы, соответственно[142 - Нам, вероятно, следовало выбрать более осмысленные имена вместо простых 


 и 


, поскольку использующий их код короткий, отсутствие у нас воображения не представляет значительной проблемы — Примеч. автора.]. 


 равен true, когда в спецификации преобразования был отмечен символ 


.

Цикл 


 генерирует символы цифр в обратном порядке, заполняя буфер с конца к началу. Каждая цифра создается в строке 11. Затем строка 25 делится на 10 путем смещения значения вправо на одну десятичную цифру.

Нас интересуют строки 12–24. Эта работа осуществляется только на системе, поддерживающей локали, на что указывает наличие заголовочного файла 


. Именованная константа 


 в такой системе будет равна true[143 - Это устанавливается механизмом Autoconf и Automake. Autoconf и Automake являются мощными программными наборами, дающими возможность поддержки широкого круга Unix-систем систематическим образом — Примеч. автора.].

Когда условие в строке 13 истинно, настало время добавить символ разделителя тысяч. Это условие можно прочесть как «если требуется группировка и текущее положение в 


 указывает нужное для группировки количество и текущее число цифр равно группируемому количеству». Если это условие истинно, строка 14 добавляет символ разделителя тысяч. Комментарий обращает внимание на предположение, которое, вероятно, истинно, но которое может вновь появиться позже. ('XXX' является традиционным способом выделения опасного или сомнительного кода. Его легко отыскать, и он весьма заметен для читателя кода.)

После использования текущего положения в 


 строки 15–22 заглядывают в значение в следующем положении. Если это 0, продолжает использоваться значение текущего положения. Мы указываем на это, восстанавливая 0 в 


 (строка 16). С другой стороны, если в следующем положении 


, группировка должна быть прекращена, и строка 18 убирает ее, устанавливая 


 в false. В противном случае, следующее значение является значением группировки, поэтому строка 20 восстанавливает 0 в 


, а строка 21 увеличивает значение 


.

Это низкоуровневый, подробный код. Однако, поняв один раз, как представляется информация в 


, код читать просто (и его было просто писать).




13.2.7. Форматирование значений даты и времени: 


 и 





В разделе 6.1 «Времена и даты» описаны функции для получения и форматирования значений времени и даты. Функция 


 также может использовать локаль, если 


 была вызвана должным образом. Это демонстрирует следующая простая программа, 


:


























































































При запуске программы мы видим, что результаты 


 в самом деле варьируют, тогда как результаты 


 — нет:














































Причина отсутствия изменений в том, что 


 (и 


, на которой основана 


) является традиционным интерфейсом; он существует для поддержки старого кода, 


, будучи более новым интерфейсом (первоначально разработанным для C89), свободен использовать локали.




13.2.8. Другие данные локали: 





Хотя ранее мы сказали, что API 


 трудно использовать, одна часть этого API обычно полезна: 


. Она предоставляет дополнительные связанные с локалью сведения, помимо тех, которые доступны из 


:


















Заголовочный файл 


 определяет тип 


. (Это скорее всего 


 или 


.) Параметр 


 является одной из именованных констант, определенных в 


. Возвращаемое значение является строкой, которую можно при необходимости использовать либо непосредственно, либо в качестве форматирующей строки для 


.

Доступная информация поступает из нескольких категорий локали. В табл. 13.3 перечислены константы элементов, соответствующие категории локали и их значения.



Таблица 13.3. Значения элементов для 







Эра является определенным временем в истории. Поскольку она имеет отношение к датам и временам, она имеет наибольший смысл в странах, управляемых императорами и династиями.[144 - Хотя американцы часто ссылаются на эры определенных президентов, они не являются частью национального календаря в том же смысле, как в Японии до Второй мировой войны или в докоммунистическом Китае — Примеч. автора.]

Спецификации эр POSIX могут определять эры ранее 1 г. н.э. В таких случаях у начальной даты большее абсолютное числовое значение, чем у конечной даты. Например, Александр Великий правил с 336 г. до н.э. по 323 г до н.э.

Значение, возвращенное '


', если оно не равно 


, состоит из одной или более спецификаций эр. Каждая спецификация отделена от следующей символом '


'. Компоненты спецификации каждой эры отделяются друг от друга символом '


'. Компоненты описаны в табл. 13.4.



Таблица 13.4. Компоненты спецификации эры




Значение 


 также нуждается в некотором объяснении. Некоторые локали предоставляют «альтернативные цифры». (Рассмотрите арабский язык, в котором используется десятичная система счисления, но изображения для цифр 0–9 другие. Или рассмотрите гипотетическую локаль «Древнего Рима», использующую римские цифры.) Они появляются, например, в различных спецификациях преобразования 


 в функции 


. Возвращаемое значение для '


' является разделяемым точками с запятой списком строк символов для альтернативных цифр. Первая должна использоваться для 0, следующая для 1 и т.д. POSIX утверждает, что могут быть предоставлены до 100 альтернативных символов. Сущность в том, чтобы избежать ограничения локалей использованием символов цифр ASCII, когда у локали есть собственная система счисления.

Наконец, '


' возвращает символ местной валюты. Первый символ возвращаемого значения, если это '


', '


' или '


', указывает, как должен использоваться символ:




Символ должен быть перед значением.




Символ должен быть после значения.




Символ должен заменить символ основания (разделитель десятичной дроби).




13.3. Динамический перевод сообщений программ



Только что освещенные интерфейсы стандартной библиотеки С решают простые части проблемы локализации. Для денежных, числовых значений, значений времени и даты, также, как для проблем сортировки строк, применяется управление посредством таблиц специфичных для локали данных (таких, как списки названий месяцев и дней).

Однако, большая часть взаимодействия пользователя с текстовой программой осуществляется в виде выводимых сообщений, таких, как приглашения или сообщения об ошибках. Проблема заключается в необходимости избежания множества версий одной и той же программы, которые отличаются лишь содержанием строк сообщений. Решением де-факто в мире GNU является GNU 


. (GNU программы сталкиваются с подобными проблемами с элементами меню; обычно у каждого большого инструментария пользовательского интерфейса свой способ решения этой проблемы.)

GNU 


 дает возможность перевода сообщений программы на другие языки во время исполнения. Внутри кода программы этот перевод включает несколько шагов, каждый из которых использует свои библиотечные функции. Когда сама программа должным образом подготовлена, несколько утилит на уровне оболочки дают возможность подготовить переводы на другие языки. Каждый такой перевод называется списком сообщений (message catalog).




13.3.1. Установка текстового домена: 





Законченное приложение может содержать множество компонентов: отдельные исполняемые файлы, написанные на С или C++ или на языках сценариев, которые также могут получить доступ к возможностям 


, таких, как 


 или оболочка Bash Все компоненты приложения разделяют один и тот же текстовый домен, который является строкой, уникально идентифицирующей приложение. (Примерами могут быть «


» или «


»; первое является простой программой, а последнее — целым набором программ.) Текстовый домен устанавливается функцией 


:













Каждый компонент должен вызывать эту функцию со строкой, указывающей на текстовый домен, в составе первоначальной инициализации в 


. Возвращаемое значение является текущим текстовым доменом. Если аргумент 


 равен 


, возвращается текущий домен; в противном случае, он устанавливается в указанное значение, а последнее возвращается. Возвращаемое значение 


 указывает на какую-нибудь разновидность ошибки.

Если текстовый домен не установлен с помощью 


, по умолчанию используется «


».




13.3.2. Перевод сообщений: 





Следующим после установки текстового домена шагом является использование функции 


 (или ее разновидности) для каждой строки, которая должна быть переведена. Несколько функций предоставляют службы перевода:























Аргументы, используемые в этих функциях, следующие:






Переводимая строка. Она действует в качестве ключа к базе данных переводов.






Текстовый домен, из которого нужно получить перевод. Таким образом, хотя 


 вызвала 


 для установки собственного домена приложения, сообщения могут быть получены из других текстовых доменов. (Это наиболее применимо к сообщениям, которые могли бы быть, например, в текстовом домене библиотеки от третьей стороны.)






Одна из описанных ранее категорий доменов (


 и т.п.). Доменом по умолчанию является то, что было раньше установлено с помощью 


 («


», если 


 никогда не вызывалась). Категорией по умолчанию является 


. Предположим, 


 делает следующий вызов:






Тогда '


' эквивалентно '


'. Обе функции, в свою очередь, эквивалентны '


'.

В 99,9% времени бывает нужно использовать 


. Однако, другие функции обеспечивают гибкость при работе с другими текстовыми доменами или категориями локалей. Скорее всего, эта гибкость потребуется при программировании библиотек, поскольку автономная библиотека почти наверняка будет использовать свой собственный текстовый домен.

Все функции возвращают строки. Строка является либо переводом данного 


, либо, если перевода не существует, первоначальной строкой. Таким образом, всегда имеется какой-нибудь вывод, даже если это первоначальное сообщение (предположительно на английском). Например:
















































Хотя сообщение является простой строкой, мы не используем ее непосредственно в форматирующей строке 


, поскольку в общем перевод может содержать символы 


.

Вскоре, в разделе 13.3.4 «Упрощение использования 


», мы увидим, как облегчить использование 


 в крупномасштабных, реальных программах.




13.3.3. Работа с множественными числами: 





Перевод во множественном числе доставляет дополнительные трудности. Простой код мог бы выглядеть примерно так:
















Это подходит для английского языка, но перевод становится трудным. Во-первых, во многих языках множественное число не образуется с такой же легкостью, как в английском (добавлением суффикса 


 для большинства слов). Во-вторых, во многих языках, особенно в Восточной Европе, имеются несколько форм множественного числа, каждая из которых указывает на то, сколько объектов обозначает форма. Соответственно даже код наподобие следующего не будет достаточным:





















Решением является параллельный набор процедур специально для форматирования множественных значений:











































Помимо первоначального аргумента 


, эти функции принимают дополнительные аргументы:






Строка по умолчанию для использования в качестве множественного числа. Вскоре будут примеры.






Число имеющихся элементов.

Список сообщений каждой локали указывает, как переводить множественные числа.[145 - Подробности приведены в документации GNU 


. Здесь мы концентрируемся на потребностях разработчика, а не переводчика — Примеч. автора.] Функция 


 (и ее варианты) проверяет 


 и на основании спецификации в списке сообщений возвращает соответствующий перевод 


. Если в списке нет перевода для 


, или находясь в локали «С», 


 возвращает 


, если '


'; в противном случае она возвращает 


. Таким образом, наш пример ошибочных слов выглядит следующим образом:






Обратите внимание, что 


 должен быть передан 


 для выбора форматирующей строки, а затем 


 для форматирования. Вдобавок, будьте осмотрительны и не используйте макрос или выражение, значение которого каждый раз изменяется, как в случае '


'! Такое может случиться, если вы осуществляете глобальное редактирование, добавляя вызовы 


 и не обращая на это внимания.




13.3.4. Упрощение использования 






Вызов 


 в исходном коде программы служит двум целям. Во-первых, он осуществляет перевод во время исполнения, что является в конце концов главным. Однако, он служит также для отметки строк, которые нужно перевести. Утилита 


 читает исходный код программы и извлекает все оригинальные строки, которые нужно перевести. (Далее в главе мы кратко рассмотрим это.)

Рассмотрим все-таки случай, когда статические строки не используются непосредственно:


























































Здесь мы хотели бы иметь возможность вывести переводы строк об авторских правах, если они доступны. Однако, как извлекающее устройство 


 предполагает найти эти строки? Мы не можем заключить их в вызовы 


, поскольку это не будет работать во время компиляции:

/





































13.3.4.1. Переносимые программы: "


"


Здесь мы предполагаем, что вы хотите написать программу, которая может использоваться вместе с библиотекой GNU 


 на любой системе Unix, а не только GNU/Linux. Следующий раздел описывает, что сделать для программ только для GNU/Linux.

Пометка строк включает два шага. Первый заключается в использовании вспомогательного заголовка 


, который поставляется с дистрибутивом GNU 


. Этот файл обрабатывает несколько проблем переносимости и компиляции, упрощая использование 


 в ваших собственных программах:











Если макрос 


 не определен[146 - Этот макрос обычно определяется автоматически программой 


, либо в специальном заголовке, либо в командной строке компилятора 


 создается с помощью Autoconf и Automake — Примеч. автора.] или установлен в ноль, 


 развертывает вызовы 


 в первый аргумент. Это делает возможным перенос кода, использующего 


, на системы, в которых не установлены ни GNU 


, ни собственная их версия. Помимо прочего, этот заголовочный файл определяет следующий макрос:









































Комментарий самодостаточен. С помощью этого макроса мы можем теперь перейти ко второму шагу. Мы перепишем код следующим образом:























































Обратите внимание, что мы сделали два изменения. Во-первых, 


 теперь является одной длинной строкой, созданной с использованием возможности конкатенации строк стандартного C. Эта простая строка затем включена в вызов 


. Нам нужна одна строка, чтобы легальности могли быть переведены в виде одного элемента

Второе изменение заключается в непосредственном выводе перевода в виде одной строки в 


.

К этому времени вы, возможно, думаете: «Вот здорово, набирать каждый раз '


' довольно неприятно». Ну, вы правы. Это не только создает лишнюю работу по набиванию, но также и затрудняет чтение исходного кода. Соответственно, когда вы используете заголовочный файл 


, руководство GNU 


 рекомендует включить два других макроса с именами 


 и 


 следующим образом:





















Такой подход снижает накладные расходы по использованию 


 всего лишь тремя дополнительными символами для переводимой строковой константы и всего лишь четырьмя символами для статических строк:









































































































Эти макросы скромны, и на практике все GNU программы, использующие GNU 


, следуют этому соглашению. Если вы собираетесь использовать GNU 


, вам тоже нужно следовать этому соглашению.




13.3.4.2. Только GLIBC: 





Для программ, которые будут использоваться лишь на системах с GLIBC, использование заголовочных файлов и макросов похоже, но проще:


























Как мы видели ранее, заголовочный файл 


 объявляет 


 и другие функции. Вам все равно нужно определять 


 и 


, но не нужно беспокоиться о 


 или включении с исходным кодом вашей программы файла 


.




13.3.5. Перестановка порядка слов с помощью 





Иногда при переводах порядок слов, естественный для английского языка, не подходит в других языках. Например, на английском прилагательные идут перед определяемыми существительными, а на многих других языках — после. Таким образом, следующий код представляет проблему:





















































Здесь форматирующая строка, 


 и 


 неудачно включены в вызов 


. Однако, после перевода утверждение будет неверным, поскольку порядок аргументов не может быть изменен во время исполнения.

Чтобы обойти это, версия семейства 


 POSIX (но не ISO С) допускает использовать в описателе формата указатель положения. Он принимает форму десятичного числа, за которым следует символ 


, сразу после начального символа 


. Например 


;

Указатель положения обозначает аргумент из списка, который следует использовать, отсчет начинается с 1 и не включает саму форматирующую строку. Этот пример выводит знаменитое сообщение '


' в правильном порядке.

GLIBC и Solaris реализуют эту возможность. Поскольку это часть POSIX, если 


 вашего поставщика Unix не реализует ее, она вскоре должна появиться.

За указателем положения могут следовать любые обычные флаги 


, указатели ширины полей и точности. Вот правила для использования указателей положения:

• Форма с указателем положения не может смешиваться с формой без нее. Другими словами, или каждый указатель формата включает указатель положения, или ни один его не включает. Конечно, 


 может использоваться всегда.

• Если в форматирующей строке используется N-й аргумент, в этой строке должны использоваться также все аргументы до N. Соответственно, следующее неверно 


;

• Ссылка на определенный аргумент может быть сделана указателем положения несколько раз. Не позиционные спецификаторы формата всегда движутся через список аргументов последовательно.

Эта возможность не предназначена для непосредственного использования программистами приложений, она скорее для переводчиков. Например, перевод предыдущей форматирующей строки, 


, на французский мог бы быть:






(Даже этот перевод не совершенен: артикль «Le» имеет род. Подготовка программы к переводу трудная задача!)




13.3.6. Тестирование переводов в персональном каталоге


Коллекция сообщений в программе называется списком сообщений (message catalog). Этот термин применяется также к каждому из переводов сообщений на другой язык. Когда программа установлена, каждый перевод также устанавливается в стандартное место, где 


 может во время исполнения найти нужный перевод.

Может оказаться полезным разместить переводы не в стандартном, а в другом каталоге, особенно для тестирования программы. Особенно на больших системах, у обычного пользователя может не быть необходимых разрешений для установки файлов в системные каталоги. Функция 


 дает 


 альтернативное место для поиска переводов:


















Полезные каталоги включают '


' для текущего каталога и 


. Может оказаться удобным также получить каталог из переменной окружения, подобно этому:





























 должна быть вызвана до вызовов любой из функций из семейства 


. Мы увидим пример ее использования в разделе 13.3.8 «Создание переводов»




13.3.7. Подготовка интернационализированных программ


К настоящему моменту мы рассмотрели все компоненты, из которых состоит интернационализированная программа. Данный раздел подводит итоги.

1. Включите в свое приложение заголовочный файл 


, добавьте определения для макросов 


 и 


 в заголовочный файл, который включается во все ваши исходные файлы на С. Не забудьте определить именованную константу 


.

2. Вызовите соответствующим образом 


. Проще всего вызвать '


', но иногда приложению может потребоваться быть более разборчивым в отношении используемых категорий локали.

3. Выберите для приложения текстовый домен и установите его с помощью 


.

4. При тестировании свяжите текстовый домен с определенным каталогом при помощи 


.

5. Используйте соответствующим образом 


, 


 и флаг 


. Если нужна другая информация о локали, используйте 


, особенно в сочетании с 


.

6. Пометьте все строки, которые должны быть переведены, соответствующими вызовами 


 или 


.

Хотя некоторые не следует так помечать. Например, если вы используете 


 (см. раздел 2.1.2 «Длинные опции GNU»), вы, вероятно, не захотите, чтобы имена длинных опций были помечены для перевода. Не требуют перевода и простые форматирующие строки наподобие "


", также как отладочные сообщения.

7. В нужных местах используйте 


 (или ее варианты) для значений, которые могут быть 1 или больше 1.

8. Упростите жизнь для своих переводчиков, используя строки с полными предложениями вместо замены слов с помощью 


 и 


. Например:









































Это лучше, чем


























Как только что показано, хорошей мыслью является включение комментария, сообщающего о намеренном использовании нескольких строк, чтобы упростить перевод сообщений.




13.3.8. Создание переводов


После интернационализации программы необходимо подготовить переводы. Это осуществляется с помощью нескольких инструментов уровня оболочки. Мы начнем с интернационализированной версии 


 из раздела 6.1.4 «Преобразование разложенного времени в 


»:













































































































































Мы намеренно использовали 


, а не 


. Если наше приложение поставляется с отдельной копией библиотеки 


, тогда 


 найдет ее, избежав использования системной копии. С другой стороны, если имеется лишь системная копия, она будет найдена, если локальной копии нет. Общеизвестно, что ситуация усложнена фактом наличия на системах Solaris библиотеки 


, которая не имеет всех возможностей версии GNU.

Переходя к созданию переводов, первым шагом является извлечение переводимых строк. Это осуществляется программой 


:











Опции 


 сообщает 


, что нужно искать макросы 


 и 


. Программа уже знает, как извлекать строки из 


 и ее вариантов, а также из 


.

Вывод 


 называется переносимым объектным файлом. Имя файла по умолчанию 


, что соответствует текстовому домену по умолчанию 


. Опция 


 обозначает текстовый домен для использования в имени выходного файла. В данном случае, файл назван 


. Вот его содержание:


































































































































Этот первоначальный файл используется повторно для каждого перевода. Таким образом, это шаблон для переводов, и по соглашению, для отображения этого факта он должен быть переименован с расширением 


 (portable object template — переносимый объектный шаблон):






He владея свободно несколькими языками, мы решили перевести сообщения на свинский латинский. Следующим шагом является создание перевода. Это осуществляется копированием файла шаблона и добавлением к новой копии перевода:











Имя по соглашению должно быть 


, где 


 является стандартным международным сокращением из двух или трех букв для обозначения языка. Иногда используется форма 


: например, 


 для португальского в Бразилии. Поскольку свинский латинский не является настоящим языком, мы назвали файл 


.[147 - Pig — свинья, поросенок (англ.) — Примеч. перев.] Вот содержание после добавления перевода:





























































































































Хотя можно было бы произвести линейный поиск в переносимом объектном файле, такой поиск был бы медленным. Например, в 


 имеется примерно 350 отдельных сообщений, а в GNU Coreutils — свыше 670. Линейный поиск в файле с сотнями сообщений был бы заметно медленным. Поэтому GNU 


 использует для быстрого поиска сообщений двоичный формат. Сравнение осуществляет 


, выдавая объектный файл сообщений:






При сопровождении программы изменяются строки, используемые программой: добавляются новые, другие удаляются или изменяются. По крайней мере, может измениться положение строки в исходном файле. Таким образом, файлы переводов 


, вероятно, устареют. Программа 


 объединяет старые файлы переводов с новым файлом 


. Затем результат может быть обновлен. Этот пример выполняет объединение и повторное компилирование:





















Откомпилированные файлы 


 помещаются в файл 


. На системах GNU/Linux 


 является 


. 


 является обозначением языка, например, '


', '


' и т.д. 


 является категорией локали; для сообщений это 


. 


 является текстовым доменом программы, в нашем случае это 


. В качестве реального примера в 


 находится перевод GNU Coreutils на испанский.

Функция 


 изменяет в местоположении часть 


. В 


 мы меняем ее на '


'. Таким образом, нужно создать соответствующие каталоги и поместить туда перевод на свинский латинский:











Должна использоваться реальная локаль[148 - Мы тщетно потратили 30 или 45 минут, пытаясь использовать каталог 


 и установку 


' без всякого успеха, пока не выяснили это — Примеч. автора.]; мы «притворяемся» использующими "


". Разместив перевод, устанавливаем соответствующим образом 


, скрещиваем пальцы и запускаем программу:
















Последнюю версию GNU 


 можно найти в каталоге дистрибутива GNU 


.[149 - 


 — Примеч. автора.]

Этот раздел лишь слегка коснулся поверхности процесса локализации. GNU 


 предоставляет множество инструментов для работы с переводами, и в особенности для облегчения поддержания современности переводов по мере развития исходного кода программы. Процесс ручного обновления переводов осуществим, но утомителен. Эта задача легко автоматизируется с помощью 


; в частности, GNU 


 хорошо интегрируется для обеспечения этой возможности с Autoconf и Automake, снимая с программиста значительный груз по разработке.

Рекомендуем прочесть документацию GNU 


, чтобы больше узнать как об этих проблемах в частности, так и о GNU 


 в общем.




13.4. Не могли бы вы произнести это для меня по буквам?



В самые ранние дни вычислительной техники различные системы назначали различные соответствия между числовыми значениями и глифами (glyphs) — символами, такими, как буквы, цифры и знаки пунктуации, используемыми для общения с людьми. В конечном счете появились два широко использующихся стандарта: кодировка EBCDIC, используемая IBM и подобными ей мэйнфреймами, и ASCII, использующаяся для всего остального. Сегодня, за исключением мэйнфреймов, ASCII является основой для всех других использующихся наборов символов.

Оригинальный семиразрядный набор символов ASCII достаточен для американского английского и большинства знаков пунктуации и специальных символов (таких, как 


, но нет символа для «цента»). Однако, имеется много языков и много стран, которым нужны другие наборы символов. ASCII не оперирует версиями романских символов с надстрочными значками, использующимися в Европе, а во многих азиатских языках тысячи символов. Для устранения этих недостатков были разработаны новые технологии.

Литература по интернационализации изобилует ссылками на три фундаментальных термина. Определив их и взаимоотношения между ними, мы сможем представить общее описание соответствующих функций API С.

Набор символов (character set)

Определение значений, присваиваемых различным целым величинам; например того, что A равно 65. Любой набор символов, использующий более восьми битов на символ, называется многобайтным набором символов.

Представление набора символов (character set encoding)

ASCII использует для представления символов один байт. Таким образом, целое значение хранится само по себе, непосредственно в дисковых файлах. Более современные наборы символов, особенно различные версии Unicode[150 - 


 — Примеч. автора.], используют для представления символов 16-разрядные или даже 32-разрядные целые значения. Для большинства определенных символов один, два или даже три старших байта целого значения равны нулю, что делает непосредственное хранение таких значений на диске неэффективным. Представление набора символов описывает механизм для преобразования 16- или 32-разрядных значений в последовательности от одного до шести байтов для сохранения на диске таким образом, что в целом наблюдается значительная экономия дисковой памяти.

Язык

Правила данного языка определяют использование набора символов. В частности, правила влияют на сортировку символов. Например, на французском е, &#233; и &#232; все должны находиться между d и f, независимо от назначенных этим символам числовых значений. Различные языки могут назначить (и назначают) одним и тем же глифам различный порядок сортировки.

Со временем для поддержки многобайтных наборов символов были разработаны различные технологии. Вычислительная практика медленно стремится к Unicode и соответствующим его представлениям, но стандартный С и POSIX поддерживают как старые, так и современные технологии. В данном разделе представлен концептуальный обзор различных возможностей. Нам самим не приходилось их использовать, поэтому мы предпочитаем просто познакомить с ними и предоставить ссылки на дополнительную информацию.




13.4.1. Широкие символы


Мы начнем с концепции широких символов (wide character). Широкий символ является целым типом, в котором может храниться любое значение из определенного используемого многобайтного набора символов.

Широкие символы представлены на С типом 


. C99 предоставляет соответствующий тип 


, в котором может находиться любое значение, допустимое для 


, а также специальное значение 


, аналогичное обычному 


 из 


. В заголовочном файле 


> определены различные типы. Ряд функций, сходных с функциями в 


, такие, как 


 и др., определены в заголовочном файле 


.

Широкие символы могут быть от 16 до 32 битов размером в зависимости от реализации. Как упоминалось, они нацелены на манипулирование данными в памяти и обычно не хранятся в файлах непосредственно.

Стандарт C предусматривает для широких символов большое число функций и макросов, соответствующих традиционным функциям, работающим с данными 


. Например, 


, 


 и т.д. Они документированы в справочных страницах GNU/Linux и в книгах по стандартному С.




13.4.2. Представления многобайтных символов


Строки широких символов сохраняются на диске путем преобразования их в памяти в многобайтное представление набора символов с последующей записью в дисковый файл. Сходным образом, такие строки считываются с диска через низкоуровневый блочный ввод/вывод, а затем конвертируются в памяти из многобайтной версии в версию широких символов.

Многие описанные кодировки используют для представления многобайтных символов состояния регистра (shift states). Другими словами, в данном потоке байтов значения байтов представляют самих себя до тех пор, пока не встретится специальное управляющее значение. В этот момент интерпретация изменяется в соответствии с текущим состоянием регистра. Таким образом, одно и то же восьмибитовое значение может иметь два значения: одно для обычного состояния, без использования регистра, и другое для использования регистра. Предполагается, что правильно закодированные строки начинаются и заканчиваются с одним и тем же состоянием регистра.

Значительным преимуществом Unicode является то, что его представления являются самокорректирующимися; кодировки не используют состояния регистров, поэтому потеря данных в середине не может повредить последующим закодированным данным.

Первоначальные версии функций преобразования многобайтных символов в широкие и широких в многобайтные поддерживали закрытую копию состояния преобразования (например, состояние регистра, а также все остальное, что могло понадобиться) Такая модель ограничивает использование функции лишь одним видом преобразования в течение жизни программы. Примерами являются 


 (определение длины многобайтной строки), 


 (преобразование многобайтного символа в широкий), 


 (преобразование широкого символа в многобайтный), 


 (преобразование многобайтной строки в строку широких символов), 


 (преобразование строки широких символов в многобайтную строку).

Новые версии этих процедур называются повторно запускаемыми (restartable). Это означает, что код уровня пользователя сохраняет состояние преобразования в отдельном объекте типа 


. Соответствующими примерами являются 


, 


, 


, 


 и 


. (Обратите внимание на 


 в их именах, это означает «restartable».)




13.4.3. Языки


Языковые проблемы управляются локалью. Ранее в главе мы уже видели 


 POSIX предоставляет продуманный механизм для определения правил, посредством которых работает локаль; некоторые подробности см. в справочной странице GNU/Linux locale(5), а полностью — в самом стандарте POSIX.

Правда в том, что подробности на самом деле не нужны. Вам, как разработчику программ, не нужно беспокоиться о них; как заставить все работать, зависит от разработчиков библиотек. Все, что нужно, это понять концепции и использовать в своем коде соответствующие функции, такие, как 


 (см. раздел 13.2.3 «Сравнение строк: 


 и 


»).

Современные системы GLIBC предоставляют отличную поддержку локалей, включая поддерживающие локали процедуры сопоставления регулярных выражений. Например, расширенное регулярное выражение POSIX 


 соответствует букве, за которой следуют одна или более букв или цифр (алфавитный символ, за которым следуют один или более алфавитно-цифровых символов). Определение того, какие символы соответствуют этим классам, зависит от локали. Например, это регулярное выражение соответствовало бы двум символам '


', тогда как регулярное выражение 


 традиционного, ориентированного на ASCII Unix — скорее всего нет. Классы символов POSIX перечислены в табл. 13.5.



Таблица 13.5. Классы символов регулярных выражений POSIX







13.4.4. Заключение


Возможно, вам никогда не придется иметь дело с различными наборами символов и их представлениями. С другой стороны, мир быстро становится «глобальным сообществом», и авторы программ не могут позволить себе быть ограниченными. Следовательно, стоит знать о проблемах интернационализации и наборов символов, а также способах их влияния на поведение вашей системы. По крайней мере, уже один из поставщиков дистрибутивов GNU/Linux устанавливает для систем в Соединенных Штатах локаль по умолчанию 


.




13.5. Рекомендуемая литература


1. С, A Reference Manual, 5th edition, by Samuel P. Harbison III and Guy L. Steele, Jr., Prentice-Hall, Upper Saddle River, New Jersey, USA, 2002. ISBN: 0-13-089592-X.

Мы уже упоминали эту книгу раньше. Она дает точное и исчерпывающее описание развития и использования возможностей стандартной библиотеки С для работы с многобайтными и широкими символами. Это особенно ценно для современных систем, поддерживающих C99, поскольку библиотека была значительно усовершенствована для стандарта С 1999 г.

2. GNU gettext tools, by Ulrich Drepper, Jim Meyering, Fran&#231;ois Pinard, and Bruno Haible. Это руководство по GNU 


. На системе GNU/Linux вы можете посмотреть локальную копию через '


'. Или загрузить и распечатать последнюю версию (по адресу 


).




13.6. Резюме


• Интернационализация и локализация программ подпадают под общее название поддержки родного языка. Широко распространенными сокращениями являются i18n, l10n и NLS. Центральным является понятие локали, которая позволяет настраивать набор символов, отображение даты, времени, денежных и числовых величин в соответствии с принятыми для данного языка и в данной стране нормами.

• Использование локали устанавливается с помощью функции 


. Различные категории локали предоставляют доступ к различным видам информации локали. Не использующие локаль программы действуют, как если бы они находились в локали «С», которая выдает типичные для систем Unix до NLS результаты: 7-разрядный ASCII, английские названия месяцев и дней и т.д. Локаль «POSIX» эквивалентна локали «С».

• Сравнение строк с учетом локали осуществляется функцией 


 или комбинацией 


 и 


. Возможности библиотеки предоставляют доступ к сведениям о локали (


 и 


), а также к специфического для локали форматирования (


, 


 и 


).

• Обратной стороной получения относящейся к локали информации является вывод сообщений на местном языке. Модель 


 System V, хотя и стандартизована POSIX, трудна для использования и поэтому не рекомендуется.[151 - GNU/Linux ее поддерживает, но лишь для совместимости — Примеч. автора.] Вместо этого GNU 


 реализует и расширяет оригинальный замысел Solaris.

• При использовании 


 оригинальная строка сообщения на английском действует в качестве ключа в двоичном файле перевода, из которого получается перевод строки. Каждое приложение указывает уникальный текстовый домен таким образом, чтобы 


 могла найти нужный файл с переводом (известный как «список сообщений»). Текстовый домен устанавливается с помощью функции 


. При тестировании или иной надобности местоположение списка сообщений можно изменить с помощью функции 


.

• 


 и ее варианты предоставляют доступ к переводам в различных текстовых доменах или различных категориях локалей. Вдобавок, функция 


 и ее варианты дают возможность делать правильные переводы множественных чисел, не перегружая разработчика. Указатель положения в спецификаторе формата 


 дает возможность перевода форматирующих строк, аргументы которых должны выводиться в другом порядке, чем они располагаются в строке.

• На практике GNU программы используют для пометки переводимых строк в исходных файлах заголовочный файл 


 и макросы 


 и 


. Такая практика обеспечивает удобочитаемость исходного кода и возможность его поддержки, предоставляя в то же время преимущества интернационализации и локализации.

• GNU 


 предоставляет многочисленные инструменты для создания и управления базами данных переводов (переносимых объектных файлов) и их двоичными эквивалентами (объектными файлами сообщений).

• Наконец, стоит быть в курсе проблем наборов символов и их представлений. Поставщики программного обеспечения не могут больше позволить себе предполагать, что их пользователи хотят работать лишь на одном языке.




Упражнения


1. Поддерживает ли ваша система локали? Если да, какая локаль используется по умолчанию?

2. Просмотрите справочную страницу locale(1), если она у вас есть. Сколько имеется локалей, если вы посчитаете их с помощью '


'?

3. Поэкспериментируйте с 


, 


, 


, 


 и 


 в различных локалях. Какая из найденных локалей самая «необычная» и почему?

4. Возьмите одну из своих программ. Интернационализируйте ее с использованием GNU 


. Постарайтесь найти кого-нибудь, кто говорит на другом языке, чтобы перевести для вас сообщения. Откомпилируйте перевод и протестируйте его, использовав 


. Какова была реакция вашего переводчика при виде использования перевода?




Глава 14

Расширенные интерфейсы



В данной главе описываются несколько расширенных API. Они сходны по своей природе с описанными ранее в книге или предоставляют дополнительные возможности. Некоторые из них трудно было свободно обсуждать, пока не были освещены предварительные темы.

Порядок представления здесь соответствует порядку глав в первой половине книги. В другом отношении темы не связаны друг с другом. Мы освещаем следующие вопросы: динамическое выделение выровненной памяти; блокировку файлов; ряд функций, работающих со значениями долей секунды; и более развитый набор функций для сохранения и получения произвольных значений данных. Если не указано противное, все API в данной главе включены в стандарт POSIX.




14.1. Выделение выровненной памяти: 


 и 





Для большинства задач отлично подходят стандартные процедуры выделения памяти — 


, 


 и т.д. Но иногда может понадобиться память, которая выровнена тем или иным способом. Другими словами, адрес первого выделенного байта является кратным какого-нибудь числа. (Например, на некоторых системах копирование памяти осуществляется значительно быстрее, если используются буфера, выровненные по границе слова.) Такую службу предоставляют две функции:


























 является более новой функцией; она является частью другого необязательного расширения, «Консультативной информации» («Advisory Information»). Работа функции отличается от других функций выделения памяти Linux. При наличии проблемы она не возвращает -1. Вместо этого возвращаемое значение равно 0 при успехе или значению


в случае неудачи. Аргументы следующие:






Указатель на переменную 


. Указываемая переменная будет содержать адрес выделенного блока памяти. Выделенная память освобождается с помощью 


.






Требуемое выравнивание. Оно должно быть кратно 


 и быть степенью двойки.






Число выделяемых байтов.




 является нестандартной, но широко доступной функцией, которая работает сходным образом. Возвращаемое значение равно 


 в случае неудачи и запрошенному блоку памяти при успехе, причем 


 (степень двойки) обозначает выравнивание, a 


 — затребованный размер памяти.

Традиционно выделенная 


 память не могла быть освобождена с помощью 


, поскольку 


 использовала для выделения памяти 


 и возвращала указатель на выровненный подходящим образом байт где-то внутри блока. Версия GLIBC не имеет этой проблемы. Из этих двух функций следует использовать 


, если она у вас есть.




14.2. Блокировка файлов



Современные системы Unix, включая GNU/Linux, дают вам возможность заблокировать часть файла или весь файл для чтения или записи. Подобно многим частям Unix API, которые были разработаны после V7, имеется несколько несовместимых способов осуществить блокировку файлов. Данный раздел рассматривает эти возможности.




14.2.1. Концепции блокировки файлов


Также, как замок на вашей двери предотвращает нежелательные проникновения в ваш дом, блокировка файла предотвращает доступ к данным в файле. Блокировка файлов была добавлена в Unix после разработки V7 (от которой происходят все современные системы Unix), и соответственно в течение некоторого времени в различных системах Unix были доступны и использовались несколько несовместимых механизмов блокировки файлов. Как в BSD Unix, так и в System V были собственные несочетающиеся вызовы для блокировки. В конечном счете POSIX формализовал способ осуществления блокировки файлов System V. К счастью, названия функций в System V и BSD были различны, так что GNU/Linux, в попытке угодить всем, поддерживает обе разновидности блокировок.

Табл. 14.1 суммирует различные виды блокировок.



Таблица 14.1. Функции блокировки файлов




Имеются следующие аспекты блокировки файлов:

Блокировка записей

Блокировка записи является блокировкой части файла. Поскольку файлы Unix являются просто потоками байтов, было бы корректнее использовать термин блокировка диапазона (range lock), поскольку осуществляется блокировка диапазона байтов. Тем не менее, термин «блокировка записей» общеупотребительный.

Блокировка всего файла

Блокировка всего файла, как предполагает название, блокирует весь файл, даже если его размер меняется в блокированном состоянии. Интерфейс BSD предусматривает блокирование лишь всего файла. Для блокирования всего файла с использованием интерфейса POSIX указывают нулевую длину. Это интерпретируется особым образом как «весь файл».

Блокировка чтения

Блокировка чтения предотвращает запись в читаемую область. В файле может быть несколько заблокированных для чтения участков, даже в одной области файла, не мешающих друг другу, поскольку к данным осуществляется лишь доступ и они не изменяются.

Блокировка записи

Блокировка записи предоставляет исключительный доступ к записываемой области. Если эта область заблокирована также и для чтения, попытка получения блокировки записи либо блокируется, либо завершается неудачей в зависимости от запрошенного типа блокировки. После получения блокировки записи попытка получить блокировку чтения завершается неудачей.

Вспомогательная блокировка

Вспомогательная блокировка (advisory lock) тесно соответствует замку на двери. Говорят, «замки существуют для честных людей», что означает, что если кто-нибудь на самом деле захочет вломиться в ваш дом, он, возможно, найдет способ это сделать, несмотря на наличие замка в двери. То же и со вспомогательной блокировкой; она работает лишь тогда, когда тот, кто пытается получить доступ к заблокированному файлу, сначала пытается получить блокировку. Однако, программа может совершенно игнорировать вспомогательные блокировки и делать с файлом, что захочет (конечно, пока это разрешается правами допуска файла).

Обязательная блокировка

Обязательная блокировка является более строгой: когда установлена обязательная блокировка, ни один другой процесс не может получить доступ к заблокированному файлу. Любой процесс, который пытается игнорировать это, либо сам блокируется до снятия блокировки файла, либо его попытка завершится неудачей. (Под GNU/Linux по крайней мере это включает 


!)

Вспомогательная блокировка достаточна для взаимодействующих программ, разделяющих индивидуальный файл, когда не предполагается использование этого файла ни одним другим приложением. Обязательная блокировка подходит в ситуации, когда избежание конфликта в использовании файла является критическим, как в коммерческих системах баз данных.

POSIX стандартизует лишь вспомогательную блокировку. Обязательная блокировка доступна на GNU/Linux, а также в ряде коммерческих систем Unix, но детали варьируют. Далее в данном разделе мы рассмотрим детали для GNU/Linux.




14.2.2. Блокировка POSIX: 


 и 






Системный вызов 


 (file control — управление файлом) используется для блокировки файла. (Другое использование 


 было описано в разделе 9.4.3 «Управление атрибутами файла: 


».) Он объявлен следующим образом:




























Аргументы следующие:




 Дескриптор файла для открытого файла.




 Одна или более именованных констант, определенных в 


. Ниже они описаны более подробно.




 Указатель на 


, описывающую нужный блок.




14.2.2.1. Описание блокировки


Прежде чем рассмотреть осуществление блокировки, давайте исследуем описание блокировки в операционной системе. Это делается при помощи структуры 


, которая описывает диапазон блокируемых байтов и вид нужной блокировки. Стандарт POSIX утверждает, что 


 содержит «по крайней мере» определенные члены. Это позволяет разработчикам предоставлять при желании дополнительные члены структуры. Из слегка отредактированной справочной страницы fcntl(3):
























































Поле 


 является смешением начального байта блокируемого участка. 


 является длиной блокируемого участка, т. е. общим числом блокируемых байтов. 


 указывает место в файле, относительно которого отсчитывается 


, значения те же, что и для аргумента 


 функции 


 (см раздел 4.5 «Произвольный доступ: перемещения внутри файла»), отсюда и название поля. Эта структура самодостаточна: смещение 


 и значение 


не связаны с текущим файловым указателем для чтения или записи. Пример кода мог бы выглядеть таким образом:




































Используя 


 или 


, вы можете заблокировать участки, начиная от текущего смещения в файле или относительно конца файла соответственно. Для этих двух случаев 


 может быть отрицательным, пока абсолютное начало не меньше нуля. Таким образом, чтобы заблокировать последнюю запись в файле:


























Установка 


 в 0 является особым случаем. Он означает блокировку файла от начального положения, указанного с помощью 


 и 


, и до конца файла. Сюда входят также любые области за концом файла. (Другими словами, если заблокированный файл увеличивается в размере, область блокировки расширяется таким образом, чтобы продолжать охватывать весь файл.) Таким образом, блокирование всего файла является вырожденным случаем блокирования одной записи:
















Справочная страница fnctl(3) имеет примечание:



POSIX 1003.1-2001 допускает отрицательные значения 


. (И если это так, описываемый блоком интервал охватывает байты с 


 вплоть до 


 включительно.) Однако, в этой ситуации системный вызов Linux для современных ядер возвращает 


.


(Мы заметили, что справочная страница относится к версиям ядер 2.4.x; стоит проверить текущую справочную страницу, если ваша система новее.)

Теперь, когда мы знаем, как описать где блокируется файл, мы можем описать тип блокировки с помощью 


. Возможные значения следующие:




Блокировка чтения. Для применения блокировки чтения файл должен быть открыт для чтения.




Блокировка записи. Для применения блокировки записи файл должен быть открыт для записи.




Освобождение предыдущей блокировки.

Таким образом, полная спецификация блокировки включает установку в структуре 


 значений четырех полей: трех для указания блокируемой области и четвертого для описания нужного типа блока.

Значение 


 для 


 снимает блокировку. В общем, это простейший способ снять те самые блоки, которые были установлены ранее, но можно «расщепить» блок, освободив диапазон байтов в середине ранее установленного более крупного блока. Например:





































































14.2.2.2. Установка и снятие блокировок


После заполнения структуры 


 следующим шагом является запрос блокировки. Этот шаг осуществляется с помощью соответствующего значения аргумента 


 функции 


:




Узнать, можно ли установить блокировку.




Установить или снять блокировку.




Установить блокировку, подождав, пока это будет возможным.

Команда 


 является командой «Мама, можно мне?» Она осведомляется, доступна ли описанная 


 блокировка. Если она доступна, блокировка не устанавливается; вместо этого операционная система изменяет поле 


 на 


. Другие поля остаются без изменений.

Если блокировка недоступна, операционная система заполняет различные поля сведениями, описывающими уже установленные блокировки, которые препятствуют установке новой. В этом случае 


 содержит PID процесса, владеющего соответствующей блокировкой.[152 - Справочная страница GNU/Linux fcntl(3) указывает, что этих сведений может быть недостаточно, процесс может находиться на другой машине! При блокировках по сети есть и другие проблемы, в общем, использование блокировки в файловых системах, смонтированных для удаленных компьютеров, не является удачной мыслью — Примеч. автора.] Если блокировка уже установлена, нет другого выбора, кроме ожидания в течение некоторого времени и новой попытки установки блокировки или вывода сообщения об ошибке и отказа от дальнейших попыток.

Команда 


 пытается установить указанную блокировку. Если 


 возвращает 0, блокировка была успешно установлена. Если она возвращает -1, блокировку установил другой процесс. В этом случае в errno устанавливается либо 


 (попытайтесь снова позже) или 


 (нет доступа). Возможны два значения, чтобы удовлетворить старым системам.

Команда 


 также пытается установить указанную блокировку. Она отличается от 


 тем, что будет ждать, пока установка блокировки не окажется возможной.

Выбрав соответствующее значение для аргумента 


, передайте его в качестве второго аргумента 


 вместе с указателем на заполненную структуру 


 в качестве третьего аргумента:































Функция 


[153 - В системе GNU/Linux 


 реализована в виде «оболочки» вокруг 


 — Примеч. автора.] предоставляет альтернативный способ установки блокировки в текущем положении файла.













Дескриптор файла 


 должен быть открыт для записи. 


 указывает число блокируемых байтов: от текущего положения (назовем его 


) до 


 байтов, если 


 положительно, или от 


 до 


, если len отрицательно. Команды следующие:




Устанавливает исключительную блокировку диапазона. Вызов блокируется до тех пор, пока блокировка диапазона не станет возможной.




Пытается установить блокировку. Это похоже на 


, но если блокировка недоступна, 


 возвращает ошибку.




Разблокирует указанный раздел. Это может вызвать расщепление блокировки, как описано выше.




Проверяет, доступна ли блокировка. Если доступна, возвращает 0 и устанавливает блокировку. В противном случае возвращает -1 и устанавливает в 





.

Возвращаемое значение равно 0 в случае успеха и -1 при ошибке, с соответствующим значением в 


. Возможные значения ошибок включают:




 Файл заблокирован, для 


 или 


.




 Для 


 эта операция создала бы тупик.[154 - Тупик (deadlock) является ситуацией, при которой оба процесса блокируются, причем каждый из них ждёт, пока другой освободит определенный ресурс — Примеч. автора.]




 Операционная система не смогла выделить блок.

Полезна комбинация 


 и 


: если вы знаете, что тупик не может возникнуть никогда, используйте 


. В противном случае, стоит обезопасить себя и использовать 


. Если блокировка доступна, она осуществляется, но если нет, у вас появляется возможность восстановления вместо блокирования в ожидании, возможно, навечно.

Завершив работу с заблокированным участком, его следует освободить. Для 


 возьмите первоначальную 


, использованную для блокирования, и измените поле 


 на 


. Затем используйте 


 в качестве аргумента 


:









































Код, использующий 


, несколько проще. Для краткости мы опустили проверку ошибок:




































Если вы не освободите блокировку явным образом, операционная система сделает это за вас в двух случаях. Первый случай, когда процесс завершается (либо при возвращении из 


, либо с использованием функции 


, которую мы рассматривали в разделе 9.1.5.1 «Определение статуса завершения процесса»). Другим случаем является вызов 


 с дескриптором файла: больше об этом в следующем разделе.




14.2.2.3. Предостережения по поводу блокировок


Имеется несколько предостережений, о которых нужно знать при блокировках файлов:

• Как описано ранее, вспомогательная блокировка является именно этим. Не взаимодействующий процесс может делать все, что хочет, за спиной (так сказать) процесса, осуществляющего блокировку.

• Эти вызовы не следует использовать в сочетании с библиотекой 


. Эта библиотека осуществляет свое собственное буферирование. Хотя вы можете получить с помощью 


 дескриптор нижележащего файла, действительное положение в файле может быть не там, где вы думаете. В общем, стандартная библиотека ввода/вывода не понимает блокировок файлов.

• Держите в уме, что блокировки после 


не наследуются порожденными процессами, но они остаются на своем месте после 


.

• Вызов 


 с любым открытым для файла дескриптором удаляет все блокировки файла процессом, даже если другие дескрипторы для файла остаются открытыми.

То, что 


 работает таким образом, является неудачным, но поскольку так была реализована первоначальная блокировка в 


, POSIX ее стандартизует. Стандартизация такого поведения позволяет избежать порчи существующего кода для Unix.




14.2.3. Блокирование BSD: 





4.2 BSD представило свой собственный механизм блокировки, 


[155 - Удачно, что название 


 отличается от 


, поскольку их семантика различна. Это также страшно сбивает с толку. Держите свое руководство под рукой. — Примеч. автора.]. Функция объявлена следующим образом:













Дескриптор 


 представляет открытый файл. Имеются следующие операции:




Создает совместную блокировку. Может быть несколько совместных блокировок.




Создает исключительную блокировку. Может быть лишь одна такая блокировка.




Удаляет предыдущую блокировку.




При использовании побитового ИЛИ с 


 или 


 позволяет избежать блокирования функции, если блокировка файла невозможна.

По умолчанию запросы блокировки файла будут блокировать функцию (не давать ей вернуться), если существует конкурирующая блокировка. Запрашивающая функция возвращается, когда конкурирующая блокировка файла снимается и осуществляется запрошенная функцией блокировка файла. (Это предполагает, что по умолчанию имеется возможность возникновения тупика.) Чтобы попытаться заблокировать файл без блокирования функции, добавьте посредством побитового ИЛИ значение 


 к имеющемуся значению 


.

Отличительными моментами 


 являются следующие:

• Блокировка с помощью 


 является вспомогательной; программа, не использующая блокировку, может прийти и испортить без всяких сообщений об ошибках файл, заблокированный с помощью 


.

• Блокируется весь файл. Нет механизма для блокировки только части файла.

• То, как был открыт файл, не влияет на тип блокировки, который может быть использован. (Сравните это с 


, при использовании которой файл должен быть открыт для чтения для получения блокировки чтения, или для записи для блокировки записи.)

• Несколько открытых для одного и того же файла дескрипторов используют совместную блокировку. Для удаления блокировки может использоваться любой из них. В отличие от 


, когда нет явного разблокирования, блокировка не удаляется до тех пор, пока не будут закрыты все открытые дескрипторы файла.

• Процесс может иметь лишь одну блокировку файла с помощью 


; последовательный вызов 


 с двумя различными типами блокировок изменяет тип блокировки на новый.

• На системах GNU/Linux блокировки 


 совершенно независимы от блокировок 


. Многие коммерческие системы Unix реализуют 


 в виде «оболочки» поверх 


, но их семантика различается.

Мы не рекомендуем использовать 


 в новых программах, поскольку ее семантика не такая гибкая и поскольку она не стандартизована POSIX. Поддержка ее в GNU/Linux осуществляется главным образом для обратной совместимости с программным обеспечением, написанным для старых систем BSD Unix.



ЗАМЕЧАНИЕ. Справочная страница GNU/Linux flock(2) предупреждает, что блокировки 


 не работают для смонтированных удаленных файлов. Блокировки 


 работают, при условии, что у вас достаточно новая версия Linux и сервер NFS поддерживает блокировки файлов





14.2.4. Обязательная блокировка


Большинство коммерческих систем Unix поддерживают в дополнение к вспомогательной обязательную блокировку файлов. Обязательная блокировка работает лишь с 


. Обязательная блокировка файла контролируется установками прав доступа файла, в частности, путем добавления к файлу бита setgid с помощью команды 


.































Бит права на исполнение группой должен быть оставлен сброшенным. 


 показывает, что бит setgid установлен, но что бит права на исполнение — нет; если бы были установлены оба бита, была бы использована строчная буква 


.

Комбинация установленного бита setgid и сброшенного бита права на исполнение группой обычно бессмысленно. По этой причине, она была выбрана разработчиками System V для обозначения «использования обязательного блокирования». И в самом деле, добавления этого бита достаточно, чтобы заставить коммерческую систему Unix, такую как Solaris, использовать блокировку файлов.

На системах GNU/Linux несколько другая история. Для обязательных блокировок файл должен иметь установленный бит setgid, но этого одного недостаточно. Файловая система, содержащая файл, также должна быть смонтирована с опцией 


 в команде 


.

Мы уже рассмотрели файловые системы, разделы диска, монтирование и команду mount, главным образом, в разделе 8.1 «Монтирование и демонтирование файловых систем». Мы можем продемонстрировать обязательную блокировку с помощью небольшой программы и файловой системой для тестирования на гибком диске. Для начала, вот программа:


























































































































































































































































































































































Программа устанавливает права доступа и создает файл, указанный в командной строке (строки 25 и 26). Затем она записывает в файл некоторые данные (строка 34). Строка 41 добавляет к правам доступа бит setgid, а строка 43 изменяет их. (Системный вызов 


 обсуждался в разделе 5.5.2 «Изменение прав доступа: 


 и 


».)

Строки 51–55 устанавливают 


 для блокировки всего файла, а затем блокировка осуществляется реально в строке 57. Выполнив блокировку, программа засыпает, используя системный вызов 


 (см. раздел 10.7 «Сигналы для межпроцессного взаимодействия»). После этого программа закрывает дескриптор файла и завершается. Вот расшифровка с комментариями, демонстрирующая использование обязательной блокировки файлов:













































































































































Пока выполняется 


, она владеет блокировкой. Поскольку это обязательная блокировка, перенаправления ввода/вывода оболочки завершаются неудачей. После завершения 


 блокировки освобождаются, и перенаправление ввода/вывода достигает цели. Как упоминалось ранее, под GNU/Linux даже 


 не может аннулировать обязательную блокировку файла.

Немного отклоняясь в сторону, гибкие диски представляют отличный испытательный стенд для изучения того, как использовать инструменты, работающие с файловыми системами. Если вы сделаете что-то, что разрушит данные на гибком диске, это вряд ли будет катастрофическим, тогда как экспериментирование с действующими разделами на обычных жестких дисках значительно более рискованно.




14.3. Более точное время



Системный вызов 


 и тип 


 представляют время в секундах в формате отсчета с начала Эпохи. Разрешения в одну секунду на самом деле недостаточно, сегодняшние машины быстры, и часто бывает полезно различать временные интервалы в долях секунды. Начиная с 4.2 BSD, Berkley Unix представил ряд системных вызовов, которые сделали возможным получение и использование времени в долях секунд. Эти вызовы доступны на всех современных системах Unix, включая GNU/Linux.




14.3.1. Время в микросекундах: 





Первой задачей является получение времени дня:
















 позволяет получить время дня.[156 - В справочной странице gettimeofday(2) документирована соответствующая функция 


 для использования суперпользователем (


) для установки времени дня всей системы — Примеч. автора.] В случае успеха возвращается 0, при ошибке -1. Аргументы следующие:






Этот аргумент является указателем на 


, которая вскоре будет описана и в которую система помещает текущее время.






Это аргумент больше не используется; он имеет тип 


, поэтому он всегда должен равняться 


. (Справочная страница описывает, для чего он использовался, а затем утверждает, что он устарел. Прочтите, если интересуетесь подробностями.)

Время представлено структурой 


:





















Значение 


 представляет секунды с начала Эпохи; 


 является числом микросекунд в секунде.

Справочная страница GNU/Linux gettimeofday(2) документирует также следующие макросы:































Эти макросы работают со значениями 


; то есть указателями на структуры, и их использование должно быть очевидным из их названий и кода. Особенно интересен макрос 


: третьим аргументом является оператор сравнения для указания вида сравнения. Например, рассмотрим определение того, является ли одна 


 меньше другой:





















Макрос развертывается в
















Это значит: «если 


 меньше, чем 


, ИЛИ если они равны и 


 меньше, чем 


, тогда…».




14.3.2. Файловое время в микросекундах: 





В разделе 5.5.3 «Изменение временных отметок: 


» был описан системный вызов 


 для установки времени последнего обращения и изменения данного файла. Некоторые файловые системы хранят эти временные отметки с разрешением в микросекунды (или еще точнее). Такие системы предусматривают системный вызов 


 (обратите внимание на завершающую s в названии) для установки времени обращения к файлу и его изменения с точностью до микросекунд:













Аргумент 


 должен указывать на массив из двух структур 


, значения используются для времени доступа и изменения соответственно. Если 


 равен 


, система использует текущее время дня.

POSIX обозначает ее как «традиционную» функцию, что означает, что она стандартизуется лишь для поддержки старого кода и не должна использоваться для новых приложений. Главная причина, пожалуй, в том, что нет определенного интерфейса для получения времени доступа и изменения файла в микросекундах; 


 содержит лишь значения 


, а не значения 


.

Однако, как упоминалось в разделе 5.4.3 «Только Linux: указание файлового времени повышенной точности», Linux 2.6 (и более поздние версии) действительно предоставляет доступ к временным отметкам с разрешением в наносекунды при помощи функции 


. Некоторые другие системы (такие, как Solaris) также это делают.[157 - К сожалению, по-видимому, в настоящее время нет стандарта для названий членов 


, что делает такую операцию непереносимой — Примеч. автора.] Таким образом, 


 полезнее, чем кажется на первый взгляд, и несмотря на ее «традиционный» статус, нет причин не использовать ее в своих программах.




14.3.3. Интервальные таймеры: 


 и 





Функция 


 (см. раздел 10.8.1 «Сигнальные часы: 


, 


 и 


») организует отправку сигнала 


 после истечения данного числа секунд. Ее предельным разрешением является одна секунда. Здесь также BSD 4.2 ввело функцию и три различных таймера, которые используют время в долях секунды.

Интервальный таймер подобен многократно использующимся сигнальным часам. Вы устанавливаете начальное время, когда он должен «сработать», а также как часто это должно впоследствии повторяться. Оба этих значения используют объекты 


; т.е. они (потенциально) имеют разрешение в микросекундах. Таймер «срабатывает», доставляя сигнал; таким образом, нужно установить для таймера обработчик сигнала, желательно до установки самого таймера.

Существуют три различных таймера, описанных в табл. 14.2.



Таблица 14.2. Интервальные таймеры




Использование первого таймера, 


, просто. Таймер работает в реальном времени, посылая 


 по истечении заданного количества времени. (Поскольку посылается 


, нельзя смешивать вызовы 


 с вызовами 


, а смешивание их с вызовом 


 также опасно; см. раздел 10.8.1 «Сигнальные часы, 


, 


 и 


».)

Второй таймер, 


, также довольно прост. Он действует, когда процесс исполняется, но лишь при выполнении кода пользователя (приложения) Если процесс заблокирован во время ввода/вывода, например, на диск, или, еще важнее, на терминал, таймер приостанавливается.

Третий таймер, 


, более специализированный. Он действует все время, пока выполняется процесс, даже если операционная система делает что-нибудь для процесса (вроде ввода/вывода). В соответствии со стандартом POSIX, он «предназначен для использования интерпретаторами при статистическом профилировании выполнения интерпретируемых программ». Установив как для 


, так и для 


 идентичные интервалы и сравнивая разницу времени срабатывания двух таймеров, интерпретатор может узнать, сколько времени проводится в системных вызовах для выполняющейся интерпретируемой программы[158 - Корректное выполнение профилировки нетривиальная задача, если вы думаете о написании интерпретатора, стоит сначала провести свои исследования — Примеч. автора.]. (Как сказано, это довольно специализировано.) Двумя системными вызовами являются:























Аргумент 


 является одной из перечисленных ранее именованных констант, указывающих таймер, 


 заполняет 


, на которую указывает 


, текущими установками данного таймера, 


 устанавливает для данного таймера значение в 


. Если имеется 


, функция заполняет ее текущим значением таймера. Используйте для 


, если не хотите беспокоиться о текущем значении. Обе функции возвращают в случае успеха 0 и -1 при ошибке, 


 состоит из двух членов 


:





















Прикладным программам не следует ожидать, что таймеры будут с точностью до микросекунд. Справочная страница getitimer(2) дает следующее объяснение:



Таймеры никогда не срабатывают раньше заданного времени, вместо этого срабатывая спустя небольшой постоянный интервал времени, зависящий от разрешения системного таймера (в настоящее время 10 мс). После срабатывания будет сгенерирован сигнал, а таймер будет сброшен. Если таймер срабатывает, когда процесс выполняется (для таймера 


 это всегда верно), сигнал будет доставлен немедленно после создания. В противном случае, доставка будет сдвинута на небольшой промежуток времени, зависящий от загрузки системы.


Из этих трех таймеров 


 кажется наиболее полезным. Следующая программа, 


, показывает, как читать данные с терминала, но с тайм-аутом, чтобы программа не зависала на бесконечное время, ожидая ввода:


































































































































































































































Строки 10–18 представляют обработчик сигнала для 


; вызов 


 гарантирует, что обработчик сигнала был установлен соответствующим образом. Тело обработчика выводит сообщение и выходит, но оно может делать что-нибудь более подходящее для крупномасштабной программы.

В функции 


 строки 27–28 очищают два члена 


 структуры 


. Затем строка 30 устанавливает тайм-аут в 10 секунд. Установка 


 в 0 означает, что нет повторяющегося сигнала; он срабатывает лишь однажды. Строка 32 устанавливает обработчик сигнала, а строка 34 выводит приглашение.

Строка 36 устанавливает таймер, а строки 37–42 выводят соответствующие сообщения, основываясь на действиях пользователя. Реальная программа выполняла бы в этот момент свою задачу. Важно здесь обратить внимание на строку 38, которая отменяет таймер, поскольку были введены действительные данные.



ЗАМЕЧАНИЕ. Между строками 37 и 38 имеется намеренное состояние гонки. Все дело в том, что если пользователь не вводит строку в течение отведенного таймером времени, будет доставлен сигнал, и обработчик сигнала выведет сообщение «you lose».


Вот три успешных запуска программы:

































































POSIX оставляет неопределенным, как интервальные таймеры взаимодействуют с функцией 


, если вообще взаимодействуют. GLIBC не использует для реализации 


 функцию 


, поэтому на системах GNU/Linux 


 не взаимодействует с интервальным таймером. Однако, для переносимых программ, вы не можете делать такое предположение.




14.3.4. Более точные паузы: 





Функция 


 (см. раздел 10.8.1 «Сигнальные часы: 


, 


 и 


») дает программе возможность приостановиться на указанное число секунд. Но, как мы видели, она принимает лишь целое число секунд, что делает невозможным задержки на короткие периоды, она потенциально может также взаимодействовать с обработчиками 


. Функция 


 компенсирует эти недостатки:













Эта функция является частью необязательного расширения POSIX «Таймеры» (TMR). Два аргумента являются запрошенным временем задержки и оставшимся числом времени в случае раннего возвращения (если 


 не равен 


). Оба являются значениями 


:





















Значение 


 должно быть в диапазоне от 0 до 999 999 999. Как и в случае со 


, время задержки может быть больше запрошенного в зависимости оттого, когда и как ядро распределяет время для исполнения процессов.

В отличие от 


, 


 не взаимодействует ни с какими сигналами, делая ее более безопасной и более простой для использования.

Возвращаемое значение равно 0, если выполнение процесса было задержано в течение всего указанного времени. В противном случае оно равно -1, с 


, указывающим ошибку. В частности, если 


 равен 


, 


 была прервана сигналом. В этом случае, если 


 не равен 


, 


, на которую она указывает, содержит оставшееся время задержки. Это облегчает повторный вызов 


 для продолжения задержки.

Хотя это выглядит немного странным, вполне допустимо использовать одну и ту же структуру для обоих параметров:



















 и 


 сходны друг с другом, отличаясь лишь компонентом долей секунд. Заголовочный файл GLIBC 


 определяет для их взаимного преобразования друг в друга два полезных макроса:


















Вот они:
















































ЗАМЕЧАНИЕ. To, что некоторые системные вызовы используют микросекунды, а другие — наносекунды, в самом деле сбивает с толку. Причина этого историческая: микросекундные вызовы были разработаны на системах, аппаратные часы которых не имели более высокого разрешения, тогда как наносекундные вызовы были разработаны более недавно для систем со значительно более точными часами. C'est la vie. Почти все, что вы можете сделать, это держать под руками ваше руководство.





14.4. Расширенный поиск с помощью двоичных деревьев



В разделе 6.2 «Функции сортировки и поиска» мы представили функции для поиска и сортировки массивов. В данном разделе мы рассмотрим более продвинутые возможности.




14.4.1. Введение в двоичные деревья


Массивы являются почти простейшим видом структурированных данных. Их просто понимать и использовать. Хотя у них есть недостаток, заключающийся в том, что их размер фиксируется во время компиляции. Таким образом, если у вас больше данных, чем помещается в массив, вам не повезло. Если у вас значительно меньше данных, чем размер массива, память расходуется зря. (Хотя на современных системах много памяти, подумайте об ограничениях программистов, пишущих программы для внедренных систем, таких, как микроволновые печи и мобильные телефоны. С другого конца спектра, подумайте о проблемах программистов, имеющих дело с огромными объемами ввода, таких, как прогнозирование погоды.

В области компьютерных наук были придуманы многочисленные динамические структуры данных, структуры, которые увеличивают и уменьшают свой размер по требованию и которые являются более гибкими, чем простые массивы, даже массивы, создаваемые и изменяемые динамически с помощью 


 и 


. Массивы при добавлении или удалении новых элементов требуется также повторно сортировать.

Одной из таких структур является дерево двоичного поиска, которое мы для краткости будем называть просто «двоичным деревом» («binary tree»). Двоичное дерево хранит элементы в сортированном порядке, вводя их в дерево в нужном месте при их появлении. Поиск по двоичному дереву также осуществляется быстро, время поиска примерно такое же, как при двоичном поиске в массиве. В отличие от массивов, двоичные деревья не нужно каждый раз повторно сортировать с самого начала при добавлении к ним элементов.

У двоичных деревьев есть один недостаток. В случае, когда вводимые данные уже отсортированы, время поиска в двоичном дереве сводится ко времени линейного поиска. Техническая сторона этого вопроса должна иметь дело с тем, как двоичные деревья управляются внутренне, что вскоре будет описано.

Теперь не избежать некоторой формальной терминологии, относящейся к структурам данных. На рис. 14.1 показано двоичное дерево. В информатике деревья изображаются, начиная сверху и расширяясь вниз. Чем ниже спускаетесь вы по дереву, тем больше его глубина. Каждый объект внутри дерева обозначается как вершина (node). На вершине дерева находится корень дерева с глубиной 0. Внизу находятся концевые вершины различной глубины. Концевые вершины отличают по тому, что у них нет ответвляющихся поддеревьев (subtrees), тогда как у внутренних вершин есть по крайней мере одно поддерево. Вершины с поддеревьями иногда называют родительскими (parent), они содержат порожденные вершины (children).




Рис. 14.1. Двоичное дерево

Чистые двоичные деревья отличаются тем, что каждая вершина содержит не более двух порожденных вершин. (Деревья с более чем двумя вершинами полезны, но не существенны для нашего обсуждения.) Порожденные вершины называются в этом случае левой и правой соответственно.

Деревья двоичного поиска отличаются еще и тем, что значения, хранящиеся в левой порожденной вершине, всегда меньше значения в родительской вершине, а значения, хранящиеся в правой порожденной вершине, всегда больше значения в родительской вершине. Это предполагает, что внутри дерева нет повторяющихся значений. Этот факт также объясняет, почему деревья не эффективны при работе с предварительно отсортированными данными: в зависимости от порядка сортировки, каждый новый элемент данных сохраняется либо только слева, либо только справа от находящегося впереди него элемента, образуя простой линейный список.

К двоичным деревьям применяют следующие операции:

Ввод

Добавление к дереву нового элемента.

Поиск

Нахождение элемента в дереве.

Удаление

Удаление элемента из дерева.

Прохождение (traversal)

Осуществление какой-либо операции с каждым хранящимся в дереве элементом. Прохождение дерева называют также обходом дерева (tree walk). Есть разнообразные способы «посещения» хранящихся в дереве элементов. Обсуждаемые здесь функции реализуют лишь один из таких способов. Мы дополнительно расскажем об этом позже.




14.4.2. Функции управления деревьями


Только что описанные операции соответствуют следующим функциям:



































































Эти функции были впервые определены для System V, а теперь формально стандартизованы POSIX. Они следуют структуре других, которые мы видели в разделе 6.2 «Функции сортировки и поиска»: использование указателей 


 для указания на произвольные типы данных и предоставляемые пользователем функции сравнения для определения порядка. Как и для 


 и 


, функции сравнения должны возвращать отрицательное/нулевое/положительное значение, когда 


 сравнивается со значением в вершине дерева.




14.4.3. Ввод элемента в дерево: 





Эти процедуры выделяют память для вершин дерева. Для их использования с несколькими деревьями нужно предоставить им указатель на переменную 


, в которую они заносят адрес корневой вершины. При создании нового дерева инициализируйте этот указатель в 


:














































Как показано, в переменной 


 должен быть 


 лишь в первый раз, после чего нужно оставить ее как есть. При каждом последующем вызове 


 использует ее для управления деревом.

Когда разыскиваемый 


 найден, как 


, так и 


 возвращают указатель на содержащую его вершину. Поведение функций различно, когда 


 не найден: 


 возвращает 


, a 


 вводит в дерево новое значение и возвращает указатель на него. Функции 


 и 


 возвращают указатели на внутренние вершины дерева. Они могут использоваться в последующих вызовах в качестве значения root для работы с поддеревьями. Как мы вскоре увидим, значение key может быть указателем на произвольную структуру; он не ограничен символьной строкой, как можно было бы предположить из предыдущего примера.

Эти процедуры сохраняют лишь указатели на данные, использующиеся в качестве ключей. Соответственно это ваше дело управлять памятью для хранения значений данных, обычно с помощью 


.



ЗАМЕЧАНИЕ. Поскольку функции деревьев хранят указатели, тщательно позаботьтесь о том, чтобы не использовать 


 для значений, которые были использованы в качестве ключей! 


 может переместить данные, вернув новый указатель, но процедуры деревьев все равно сохранят висящие (dangling) указатели на старые данные.





14.4.4. Поиск по дереву и использование возвращенного указателя: 


 и 





Функции 


 и 


 осуществляют поиск в двоичном дереве по данному ключу. Они принимают тот же самый набор аргументов: ключ для поиска 


. указатель на корень дерева, 


; и 


, указатель на функцию сравнения. Обе функции возвращают указатель на вершину, которая соответствует 


.

Как именно использовать указатель, возвращенный 


 и 


? Во всяком случае, на что именно он указывает? Ответ заключается в том, что он указывает на вершину в дереве. Это внутренний тип; вы не можете увидеть, как он определен. Однако, POSIX гарантирует, что этот указатель может быть приведен к указателю на указатель на что бы то ни было, что вы используете в качестве ключа. Вот обрывочный код для демонстрации, а затем мы покажем, как это работает:






































































































Как можно указатель на вершину использовать как указатель на указатель данных? Рассмотрим, как была бы реализована вершина двоичного дерева. В каждой вершине хранится по крайней мере указатель на элемент данных пользователя и указатели на потенциальные порожденные вершины справа и слева. Поэтому она должна выглядеть примерно так.































С и C++ гарантируют, что поля внутри структуры располагаются в порядке возрастания адресов. Таким образом, выражение '


' истинно. Более того, адрес структуры является также адресом ее первого поля (другими словами, игнорируя проблемы типов, '


').

Следовательно, концептуально '


' означает:

1. 


 является 


, то есть общим указателем. Это адрес внутренней вершины дерева, но это также адрес части вершины (скорее всего, другого 


), которая указывает на данные пользователя.

2. '


' приводит адрес внутреннего указателя к нужному типу; он остается указателем на указатель, но в этот раз на 


. Помните, что приведение одного типа указателя к другому не изменяют значения (паттерна битов); оно меняет лишь способ интерпретации компилятором значения для анализа типов.

3. '


' разыменовывает вновь созданный 


, возвращая годный к употреблению указатель 


.

4. '


 сохраняет это значение в 


 для непосредственного использования позже.

Идея проиллюстрирована на рис. 14.2.




Рис. 14.2. Вершины дерева и их указатели

Для упрощения использования возвращенного указателя вы могли бы рассмотреть определение макроса:



















































14.4.5. Обход дерева: 





Функция 


 объявлена в 


 следующим образом:





















Первый параметр является корнем дерева (не указателем на корень). Второй является указателем на функцию обратного вызова, которая вызывается с тремя аргументами, указателем на исследуемую вершину дерева; типом перечисления, указывающим, как осуществляется обход данной вершины; и целого, обозначающего глубину текущей вершины (корень находится на глубине 0, как объяснялось ранее).

Использование функции обратного вызова здесь такое же, как для 


 (см. раздел 8.4.3.2 «Функция обратного вызова 


»). Там функция обратного вызова вызывается для каждого объекта в файловой системе. Здесь функция обратного вызова вызывается для каждого объекта, хранящегося в дереве.

Есть несколько способов прохождения, или «обхода», двоичного дерева:

• Левая вершина, родительская вершина, правая вершина.

• Родительская вершина, левая вершина, правая вершина.

• Левая вершина, правая вершина, родительская вершина.

Функция GLIBC 


 использует второй способ: сначала родительская вершина, затем левая, затем правая. Каждый раз при встрече с вершиной говорят, что она посещается.[159 - В голову приходят образы, как маленькие двоичные структуры данных сидят друг рядом с другом за чаем и пирожными. По крайней мере, такое бывает, если вы проводите слишком много времени перед своим компьютером. — Примеч. автора.] В ходе посещения порожденной вершины функция должна посетить и родительскую. Соответственно, значения типа 


 указывают, на какой стадии произошла встреча с этой вершиной:




До посещения порожденных.




После посещения первой, но до посещения второй порожденной вершины.




После посещения обеих порожденных.




 Эта вершина является концевой, не имеющей порожденных вершин.



ЗАМЕЧАНИЕ. Использованная здесь терминология не соответствует точно той, которая используется в формальных руководствах по структурированию данных. Там используются термины inorder, preorder и postorder для обозначения соответствующих трех перечисленных ранее способов прохождения дерева. Таким образом, 


 использует прохождение по типу 


, но использует именованные константы preorder и т.д. для обозначения того, на какой стадии была посещена вершина. Это может сбивать с толку.


Следующая программа, 


, демонстрирует построение и обход дерева. Она повторно использует структуру 


 и функцию 


 из раздела 6.2 «Функции сортировки и поиска».

























































































































































































































































































Строки 7–12 определяют 


, а строки 14–38 определяют 


.

Строки 40–56 определяют 


, функцию обратного вызова, которая выводит 


 наряду с глубиной дерева в текущей вершине. Обратите внимание на магическое приведение типа в строке 44 для получения указателя на сохраненные данные.



































































































































Целью вывода дерева является вывод содержащихся в нем элементов в отсортированном порядке. Помните, что 


 посещает промежуточные вершины по три раза и что левая вершина меньше родительской, тогда как правая больше. Таким образом, оператор 


 выводит сведения о вершине, лишь если 


 равно 


, является концевой вершиной, или 


, что означает, что была посещена левая вершина, а правая еще не была посещена.

Используемые данные представляют собой список президентов, тоже из раздела 6.2 «Функции сортировки и поиска». Чтобы освежить вашу память, полями являются фамилия, имя, номер сотрудника и время начала работы в виде временной отметки в секундах с начала Эпохи:































Данные сортируются на основе сначала фамилии, затем имени, а затем старшинства. При запуске[160 - Этот вывод для часового пояса U.S. Eastern Time zone — Примеч. автора.] программа выдает следующий результат:



































































14.4.6. Удаление вершины дерева и удаление дерева: 


 и 





Наконец, вы можете удалить элементы из дерева и, на системах GLIBC, удалить само дерево целиком:





















Аргументы для 


 те же, что и для 


: ключ, адрес корня дерева и функция сравнения. Если в дереве найден данный элемент, он удаляется, и 


 возвращает указатель на родительскую вершину. В противном случае возвращается 


. С этим поведением следует обращаться в своем коде осмотрительно, если вам нужен первоначальный удаляемый элемент, например, для освобождения занимаемой им памяти.














































Хотя это и не указано в справочных страницах или стандарте POSIX, под GNU/Linux, если вы удаляете элемент, хранящийся в корневой вершине, возвращается значение новой корневой вершины. Для переносимого кода не следует полагаться на это поведение

Функция 


 является расширением GLIBC. Она позволяет удалить дерево целиком. Первый аргумент является корнем дерева. Второй является указателем на функцию, которая освобождает данные, на которые указывает каждая вершина дерева. Если с этими данными ничего не надо делать (например, они хранятся в обычном массиве, как в примере нашей программы), эта функция ничего не должна делать. Не передавайте указатель 


! Это приведет к аварийной ситуации.




14.5. Резюме


• Иногда бывает необходимо выделить память, выровненную по определенной границе. Это осуществляет 


. Ее возвращаемое значение отличается от большинства из рассмотренных в данной книге функций. 


 также выделяет выровненную память, но не все системы поддерживают освобождение памяти с помощью 


.

• Блокирование файлов с помощью 


 предусматривает блокировку диапазонов, вплоть до блокирования отдельных байтов в файле. Блокировки чтения предотвращают запись в заблокированную область, а блокировки записи предотвращают чтение и запись другими процессами в заблокированную область. По умолчанию используется вспомогательная блокировка, и POSIX стандартизует лишь вспомогательную блокировку. Большинство современных систем Unix поддерживают обязательную блокировку, используя для файла бит setgid прав доступа, а также возможные дополнительные опции монтирования файловой системы.

• GNU/Linux функция 


 действует в качестве оболочки вокруг блокировки POSIX с помощью 


; блокировки функции BSD 


 совершенно независимы от блокировок 


. Блокировки BSD 


 используются лишь для всего файла в целом и не работают на удаленных файловых системах. По этим причинам использование блокировки 


 не рекомендуется.

• 


() получает время дня в виде пар (секунды, микросекунды) в 


. Эти значения используются 


 для обновления времени доступа и модификации файла. Системные вызовы 


 и 


 используют пары 


l в 


 для создания интервальных таймеров — сигнальных часов, которые «срабатывают» в установленное время и продолжают срабатывать впоследствии с заданным интервалом. Три различных таймера обеспечивают контроль тех состояний, когда таймер продолжает действовать.

• Функция 


 использует 


, которая указывает время в секундах и наносекундах, чтобы приостановить выполнение процесса в течение определенного интервала времени. У нее есть удачная особенность не взаимодействовать вообще с механизмами сигналов.

• Три API являются стандартным набором функций для хранения и поиска данных, которые сохраняют данные в двоичных деревьях в отсортированном виде. Эти три API очень гибкие, позволяя использовать множество деревьев и произвольные данные.




Упражнения


1. Напишите функцию 


, используя 


 для осуществления блокировки.

2. Каталог 


 содержит набор файлов, которые описывают различные аспекты поведения операционной системы. Прочитайте файлы 


 и 


, чтобы получить больше сведений об обработке Linux блокировок файлов.

3. Запустите на своей системе программу 


 без обязательной блокировки и посмотрите, сможете ли изменить файл-операнд.

4. Если у вас не-Linux система, поддерживающая обязательную блокировку, попробуйте исполнить на ней программу 


.

5. Напишите функцию 


 следующего вида:











Она должна вести себя подобно стандартной функции 


 за тем исключением, что должна использовать 


 для обозначения «текущего числа микросекунд».

6. Используя только что написанную функцию 


, напишите расширенную версию date, которая принимает форматирующую строку, начинающуюся с ведущего 


, и форматирует текущие дату и время (см. date(1)).

7. Обработка тайм-аута в 


 довольно примитивна. Перепишите программу с использованием 


 после вывода приглашения и 


 из обработчика сигнала. Улучшает ли это структуру или ясность программы?

8. Мы заметили, что 


 содержит намеренное состояние гонки. Предположим, пользователь вводит ответ в нужное время, но 


 приостановлена, прежде чем сигнал может быть отменен. Какой вызов вы сделаете, чтобы уменьшить размер проблемного окна?

9. Нарисуйте дерево, как показано в выводе 


 в разделе 14.4.5 «Обход дерева: 


».

10. Исследуйте файл 


 на системе GNU/Linux. (Это словарь проверки правописания для 


; на различных системах он может находиться в разных местах.) В файле слова размешены в отсортированном порядке, по одному в строке.

Для начала используйте программу 


 для создания нового списка в случайном порядке:











Далее, напишите две программы. Каждая должна читать новый список и сохранять каждое прочитанное слово в дереве и массиве соответственно. Вторая программа должна использовать для сортировки массива 


, а для поиска — 


. Получите из дерева или массива слово '


'. Вычислите время работы двух программ, чтобы увидеть, какая быстрее. Вам может потребоваться заключить получение слова внутрь цикла, повторяющегося множество раз (скажем, 1000), чтобы получить достаточное для определения разницы время.

Используйте вывод 


, чтобы посмотреть, сколько памяти используют программы

11. Повторно запустите обе программы, использовав оригинальный отсортированный словарный файл, и посмотрите, как изменятся временные результаты (если они вообще изменятся).




Часть 3

Отладка и заключительный проект





Глава 15

Отладка



Имеется множество правил, начиная с логики программы и расположения данных, через организацию и расположение кода и кончая реализацией, которые могут минимизировать ошибки и проблемы. Мы рекомендуем вам изучить их; найдите хорошие книги по проектированию и дизайну программного обеспечения и реализуйте содержащиеся там советы на практике! Каждая программа, размером превышающая несколько сот строк кода, должна быть тщательно продумана и спроектирована, а не обтяпана, пока не начнет работать.

Однако, поскольку программисты люди, ошибки программирования неизбежны. Отладка является процессом обнаружения и устранения ошибок в программах. Даже хорошо спроектированные и хорошо реализованные программы иногда не работают; когда что-то идет не так и вы не можете выяснить, почему, хорошей мыслью является нацелить на код отладчик и понаблюдать за появлением ошибки.

Данная глава охватывает ряд тем, начиная с общих методик и советов по отладке (компилирование для отладки и элементарное использование GDB, отладчика GNU), переходя к ряду методик для использования при разработке и отладке программы, упрощающих отладку, и затем рассмотрением ряда инструментов, помогающих в процессе отладки. Глава завершается краткими сведениями по тестированию программного обеспечения и великолепным набором «правил отладки», извлеченных из книги, которую мы весьма рекомендуем.

Большая часть наших советов основана на нашем долгосрочном опыте участия в качестве добровольца в проекте GNU по поддержке 


 (GNU 


). Большинство, если не все, специфические примеры, которые мы представляем, происходят от этой программы. На протяжении главы особые рекомендации помечены словом Рекомендация.




15.1. Сначала главное


Когда программа ведет себя неправильно, вы можете быть в затруднении, что делать сначала. Часто странное поведение возникает из-за неправильного использования памяти — использования неинициализированных значений, чтения или записи за пределами динамической памяти и т.д. Поэтому вы можете быстрее получить результаты, попробовав средства отладки памяти до того, как заведете отладчик.

Довод заключается в том, что утилиты памяти могут указать вам непосредственно на вызывающую сбой строку кода, тогда как использование отладчика больше напоминает миссию «найти и уничтожить», в которой вам нужно сначала изолировать проблему, а затем исправить ее. Убедившись, что дело не в проблемах памяти, можно переходить к использованию отладчика.

Поскольку отладчик является более универсальным средством, мы рассмотрим его вначале. Далее в главе мы обсудим ряд инструментов для отладки памяти.




15.2. Компиляция для отладки


Для использования отладчика исходного кода, отлаживаемый исполняемый файл должен быть откомпилирован с опцией компилятора 


. Эта опция заставляет компилятор внедрять в объектный код дополнительные отладочные идентификаторы; то есть дополнительные сведения, содержащие имена и типы переменных, констант, функций и так далее. Отладчик затем использует эту информацию для приведения в соответствие местоположения исходного кода с исполняемым кодом и получения или сохранения значений переменных в работающей программе.

На многих системах Unix опция компилятора 


 является взаимно исключающей с опцией 


, которая включает оптимизацию. Это потому, что оптимизации могут вызвать перестановку битов и участков объектного кода, так что больше не будет прямого соответствия с тем, что исполняется, и линейным прочтением исходного кода. Отменив оптимизации, вы значительно облегчаете отладчику установление связи между объектным и исходным кодом, и в свою очередь, пошаговое прохождение программы работает очевидным образом. (Пошаговое исполнение вскоре будет описано.)

GCC, GNU Compiler Collection (коллекция компиляторов GNU), на самом деле допускает совместное использование 


 и 


. Однако, это привносит как раз ту проблему, которую мы хотим избежать при отладке: следование исполнению в отладчике становится значительно более трудным. Преимуществом совместного использования опций является то, что вы можете оставить отладочные идентификаторы в конечном оптимизированном исполняемом модуле. Они занимают лишь дисковое пространство, а не память. После этого установленный исполняемый файл все еще можно отлаживать при непредвиденных случаях.

По нашему опыту, если нужно использовать отладчик, лучше перекомпилировать приложение с самого начала, использовав лишь опцию 


. Это значительно упрощает трассировку; имеется достаточно деталей, за которыми нужно следить при простом прохождении написанной программы, не беспокоясь о том, как компилятор переставляет код.

Есть одно предостережение: убедитесь, что поведение программы все еще неправильное. Воспроизводимость является ключевой при отладке; если вы не можете воспроизвести проблему, гораздо труднее ее выследить и исправить. В редких случаях компиляция без опции 


 может устранить ошибку[161 - Оптимизации компилятора являются общеизвестным козлом отпущения для логических ошибок. В прошлом обвинения компиляторов были более оправданы. Судя по нашему опыту, используя современные системы и компиляторы, очень редко можно обнаружить случаи, в которых оптимизации компилятора привносят ошибки в работающий код — Примеч. автора.]. Обычно проблема остается при компиляции без использования опции 


, что означает, что на самом деле действительно имеется какая-то разновидность логической ошибки, ждущая своего обнаружения.




15.3. Основы GDB



Отладчик является программой, позволяющей контролировать исполнение другой программы и исследовать и изменять состояние подчиненной программы (такое, как значения переменных). Имеются два вида отладчиков: отладчики машинного уровня, работающие на уровне машинных инструкций, и отладчики исходного кода, работающие на основе исходного кода программы. Например, в отладчике машинного уровня для изменения значения переменной вы указываете адрес в памяти. В отладчике исходного уровня вы просто используете имя переменной.

Исторически в V7 Unix был 


, который являлся отладчиком машинного уровня В System III был 


, который являлся отладчиком исходного кода, a BDS Unix предоставляла dbx, также отладчик исходного кода. (Обе продолжали предоставлять 


.) 


 продолжает существовать на некоторых коммерческих системах Unix.

GDB, отладчик GNU, является отладчиком исходного кода. У него значительно больше возможностей, он значительно более переносим и более практичен, чем любой из 


 или 


[162 - Мы говорим об оригинальном BSD 


. В течение десяти лет мы использовали исключительно GDB — Примеч. автора.].

Как и его предшественники, GDB является отладчиком командной строки. Он выводит по одной строке исходного кода за раз, выдает приглашение и читает одну строку ввода, содержащего команду для исполнения.

Имеются графические отладчики; они предоставляют больший обзор исходного кода и обычно предоставляют возможность манипулировать программой как из окна командной строки, так и через компоненты GUI, такие, как кнопки и меню. Отладчик 


[163 - 


 поставляется со многими системами GNU/Linux. Исходный код доступен на FTP-сайте проекта GNU 


 (


) — Примеч. автора.] является одним из таких; он построен поверх GDB, так что если вы изучите GDB, вы сразу же сможете начать использовать 


. (У 


 есть собственное руководство, которое следует прочесть, если вы собираетесь интенсивно его использовать.) Другим графическим отладчиком является Insight[164 - 


— Примеч. автора.], который использует для предоставления поверх GDB графического интерфейса Tcl/Tk. (Следует использовать графический отладчик, если он доступен и нравится вам. Поскольку мы собираемся предоставить введение в отладчики и отладку, мы выбрали использование простого интерфейса, который можно представить в напечатанном виде.)

GDB понимает С и С++, включая поддержку восстановления имен (name demangling), что означает, что вы можете использовать для функций-членов классов и перегруженных функций обычные имена исходного кода С++. В частности, GDB распознает синтаксис выражений С, что полезно при проверке значения сложных выражений, таких, как '


'. Он понимает также Fortran 77, хотя вам может понадобиться добавить к имени функции или переменной Фортрана символ подчеркивания GDB также частично поддерживает Modula-2 и имеет ограниченную поддержку Паскаля.

Если вы работаете на системе GNU/Linux или BSD (и установили средства разработки), у вас, вероятно, уже установлена готовая к использованию последняя версия GDB. Если нет, исходный код GDB можно загрузить с FTP-сайта проекта GNU для GDB[165 - 


 — Примеч. автора.] и самостоятельно его построить.

GDB поставляется с собственным руководством, которое занимает 300 страниц. В каталоге исходного кода GDB можно сгенерировать печатную версию руководства и самостоятельно его распечатать. Можно также купить в Free Software Foundation (FSF) готовые печатные экземпляры; ваша покупка поможет FSF и непосредственно внесет вклад в производство большего количества свободного программного обеспечения. (Информацию для заказа см. на веб-сайте FSF)[166 - 


 — Примеч. автора.]. Данный раздел описывает лишь основы GDB; мы рекомендуем прочесть руководство, чтобы научиться использовать все преимущества возможностей GDB.




15.3.1. Запуск GDB


Основное использование следующее:






Здесь исполняемый файл является отлаживаемой программой. Имя файла дампа, если оно имеется, является именем файла 


, созданном при завершении программы операционной системой с созданием снимка процесса. Под GNU/Linux такие файлы (по умолчанию) называются 


[167 - Если вы хотите изменить такое поведение, см. sysctl(8) — Примеч. автора.], где 


 является ID процесса запущенной программы, которая была завершена. Расширение 


 означает, что в одном каталоге могут находиться несколько дампов ядра, что бывает полезно, но также занимает дисковое пространство!

Если вы забыли указать в командной строке имена файлов, для сообщения GDB имени исполняемого файла можно использовать '


', а для имени файла дампа — '


'.

При наличии дампа ядра GDB указывает место завершения программы. Следующая программа, 


, делает несколько вложенных вызовов функций, а затем намеренно завершается посредством 


, чтобы создать дамп ядра:





















































































Вот небольшой сеанс GDB с этой программой:























































































































































Команда 


 выводит трассировку стека, то есть список всех вызванных функций, начиная с самых недавних. Обратите внимание, что имеется три вызова функции 


. Команда 


, означающая 'back trace' (обратная трассировка), является другим названием для 


; ее легче набирать.

Вызов каждой функции в стеке называется фреймом. Этот термин пришел из области компиляторов, в которой параметры, локальные переменные и адреса возврата каждой функции, сгруппированные в стеке, называются фреймом стека. Команда 


 GDB дает вам возможность исследовать определенный фрейм. В данном случае нам нужен фрейм 3. Это последний вызов 


, который вызвал 


:





































































































Как показано, нажатие ENTER повторяет последнюю команду, в данном случае 


, для отображения строк исходного кода. Это простой способ прохождения исходного кода.

Для редактирования командной строки GDB использует библиотеку 


, поэтому для повторения и редактирования ранее введенных команд можно использовать команды Emacs или 


. Оболочка Bash использует ту же самую библиотеку, поэтому если вам более знакомо редактирование командной строки в приглашении оболочки, GDB работает таким же образом. Эта особенность дает возможность избежать утомительного ручного ввода.




15.3.2. Установка контрольных точек, пошаговое выполнение и отслеживаемые точки


Часто при ошибках программ создается дамп ядра. Первым шагом является использование GDB с файлом core для определения процедуры, в которой произошло завершение программы. Если оригинальный двоичный файл не был откомпилирован для отладки (т.е. без 


), все, что может сообщить GDB, это имя функции, но больше никаких деталей.

Следующим шагом является перекомпилирование программы с возможностью отладки и без оптимизации, а также проверка того, что она все еще содержит ошибку. Предположив, что это так, можно запустить программу под контролем отладчика и установить контрольную точку в процедуре, вызывающей ошибку.

Контрольная точка (breakpoint) является точкой, в которой исполнение должно прерваться, остановиться. Контрольные точки можно установить по имени функции, номеру строки исходного файла, файлу исходного файла совместно с номером строки, а также другими способами.

После установки контрольной точки программа запускается с использованием команды 


, за которой могут следовать аргументы командной строки, которые должны быть переданы отлаживаемой программе. (GDB удобным образом запоминает за вас аргументы; если нужно снова запустить программу с начала, все что нужно — это напечатать лишь саму команду 


, и GDB запустит новую копию с теми же аргументами, как и ранее). Вот короткий сеанс с использованием 


:





































































































По достижении контрольной точки вы проходите программу в пошаговом режиме. Это означает, что GDB разрешает программе исполнять лишь по одному оператору исходного кода за раз. GDB выводит строку, которую собирается выполнить, и выводит приглашение. Чтобы выполнить оператор, используется команда 


:




































Команда 


 является альтернативной командой для пошагового исполнения. Между 


 и 


 есть важное различие, 


 выполняет следующий оператор. Если этот оператор содержит вызов функции, эта функция вызывается и возвращается до того, как GDB вернет себе управление от работающей программы.

С другой стороны, когда вы используете с содержащим вызов функции оператором 


, GDB входит в вызываемую функцию, позволяя вам продолжить пошаговое исполнение (или трассировку) программы. Если оператор не содержит вызов функции, 


 аналогична 


.



ЗАМЕЧАНИЕ. Легко забыть, какая команда была использована, и продолжать нажимать ENTER для выполнения последующих операторов. Если вы используете 


, вы случайно можете войти в библиотечную функцию, такую как 


 или 


, с которой на самом деле не хотите возиться. В таком случае можно использовать команду 


, которая вызывает исполнение программы до возврата из текущей функции


Вывести содержимое памяти можно с использованием команды 


. GDB распознает синтаксис выражений С, что упрощает и делает естественным проверку структур, на которые ссылаются указатели:














































В заключение, команда 


 (continue — продолжить) дает возможность продолжить выполнение программы. Она будет выполняться до следующей контрольной точки или до нормального завершения, если других контрольных точек нет. Этот пример продолжается с того места, на котором остановился предыдущий:

































Отслеживаемая точка (watchpoint) подобна контрольной точке, но используется для данных, а не для кода. Отслеживаемые точки устанавливаются для переменной (или поля структуры или объединения или элемента массива), при их изменении GDB посылает уведомления. GDB проверяет значение отслеживаемой точки по мере пошагового исполнения программы и останавливается при изменении значения. Например, переменная 


 в 


 равна true, когда была использована опция 


. Эта переменная устанавливается в true функцией 


. (Мы рассмотрели 


 в разделе 2.1.2 «Длинные опции GNU»). В файле 


 программы 


:









































Вот пример сеанса, показывающего отслеживаемую точку в действии:



































































































































GDB может делать гораздо больше, чем мы здесь показали. Хотя руководство GDB большое, его стоит прочесть целиком хотя бы один раз, чтобы ознакомиться с его командами и возможностями. После этого, возможно, будет достаточно просмотреть файл 


 в каждом новом дистрибутиве GDB, чтобы узнать, что нового или что изменилось.

Стоит также распечатать справочную карточку GDB, которая поставляется в дистрибутиве GDB в файле 


. Создать печатную версию справочной карточки для PostScript после извлечения исходника и запуска configure можно с помощью следующих команд:











Предполагается, что справочная карточка будет распечатана с двух сторон листа бумаги 8,5&#215;11 дюймов[168 - Примерно 213&#215;275 мм — Примеч. перев.] (размер «letter») в горизонтальном (landscape) формате. В ней на шести колонках предоставлена сводка наиболее полезных команд GDB. Мы рекомендуем распечатать ее и поместить под своей клавиатурой при работе с GDB.




15.4. Программирование для отладки



Имеется множество методик для упрощения отладки исходного кода, от простых до сложных. В данном разделе мы рассмотрим ряд из них.




15.4.1. Код отладки времени компилирования



Несколько методик относятся к самому исходному коду.




15.4.1.1. Использование отладочных макросов


Возможно, простейшей методикой времени компилирования является использование препроцессора для создания условно компилируемого кода. Например:





















Добавление 


 к командной строке компилятора вызывает 


 при выполнении программы.

Рекомендация: сообщения отладки посылайте в 


, чтобы они не были потеряны в канале и чтобы их можно было перехватить при помощи перенаправления ввода/вывода. Убедитесь, что использовали 


, чтобы сообщения были выведены как можно скорее



ЗАМЕЧАНИЕ. Идентификатор 


, хотя он и очевидный, также часто злоупотребляется. Лучшей мыслью является использование специфического для вашей программы идентификатора, такого как 


. Можно даже использовать различные идентификаторы для отладки кода в различных частях программы, таких, как файловый ввод/вывод, верификация данных, управление памятью и т.д.


Разбрасывание больших количеств операторов 


 по всему коду быстро становится утомительным. Большое количество 


 скрывают также логику программы. Должен быть лучший способ, и в самом деле, часто используется методика с условным определением специального макроса для вывода:



















































































Имеется несколько макросов, по одному на каждый имеющийся аргумент, число которых определяете вы сами. Когда определен 


, вызовы макросов 


 развертываются в вызовы 


. Когда 


 не определен, эти вызовы развертываются в ничто. (Так, в сущности, работает 


; мы описали 


 в разделе 12.1 «Операторы проверки: 


».)

Эта методика работает; мы сами ее использовали и видели, как ее рекомендуют в учебниках. Однако, она может быть усовершенствована и дальше с уменьшением количества макросов до одного:





















































Обратите внимание на то, как макрос извлекается с двумя наборами скобок! Поместив весь список аргументов для 


 в один аргумент, вам больше не нужно определять произвольное число отладочных макросов.

Если вы используете компилятор, удовлетворяющий стандарту С 1999 г., у вас есть дополнительный выбор, который дает наиболее чистый отладочный код:





















































Стандарт С 1999 г. предусматривает варьирующий макрос (variadic macros); т.е. макрос, который может принимать переменное число аргументов. (Это похоже на варьирующую функцию, наподобие 


). В макроопределении три точки '


' означают, что будет ноль или более аргументов. В теле макроса специальный идентификатор 


 замещается предусмотренными аргументами, сколько бы их ни было.

Преимуществом этого механизма является то, что при извлечении отладочного макроса необходим лишь один набор скобок, что делает чтение кода значительно более естественным. Это также сохраняет возможность использовать всего одно имя макроса вместо нескольких, которые меняются в соответствии с числом аргументов. Недостатком является то, что компиляторы C99 пока еще доступны не так широко, что снижает переносимость этой конструкции. (Однако, эта ситуация будет со временем улучшаться.)

Рекомендация: Текущие версии GCC поддерживают варьирующие макросы. Таким образом, если вы знаете, что никогда не будете использовать для компилирования своих программ что-то, кроме GCC (или какого-нибудь другого компилятора C99), можете использовать механизм C99. Однако, на момент написания, компиляторы C99 все еще не являются обычным явлением. Поэтому, если ваш код должен компилироваться разными компиляторами, следует использовать макрос в стиле с двумя парами скобок.




15.4.1.2. По возможности избегайте макросов с выражениями


В общем, макросы препроцессора С являются довольно острой палкой с двумя концами. Они предоставляют вам большую мощь, но также и большую возможность пораниться самому.[169 - Bjarne Stroustrup, создатель С++, настойчиво работал над тем, чтобы сделать использование препроцессора С совершенно ненужным в С++. По нашему мнению, он не вполне добился успеха: 


 нужен до сих пор, но не обычные макросы. Для С препроцессор остается ценным и инструментом, но он должен использоваться благоразумно — Примеч. автора.]

Обычно для эффективности или ясности можно видеть такие макросы:
















На первый взгляд, он выглядит замечательно. Условие '


' ясно и просто для понимания и абстрагирует внутренние детали проверки. Проблема возникает, когда вы пытаетесь вывести значение в GDB:











В таком случае нужно разыскать определение макроса и вывести развернутое значение.

Рекомендация: Для представления важных условий в своей программе используйте переменные, значения которых при изменении условий явным образом меняется в коде.

Вот сокращенный пример из 


 в дистрибутиве 


:



















































После установки и сохранения 


 ее можно протестировать в коде и вывести из-под отладчика.



ЗАМЕЧАНИЕ. Начиная с GCC 3.1 и версии 5 GDB, если вы компилируете свою программу с опциями 


 и 


, вы можете использовать макросы из-под GDB. В руководстве по GDB утверждается, что разработчики GDB надеются найти в конце концов более компактное представление для макросов, и что опция 


 будет отнесена к группе 


.

Однако, использовать макросы таким способам позволяет лишь комбинация GCC, GDB и специальных опций: если вы не используете GCC (или если вы используете более старую версию), у вас все еще есть проблема. Мы придерживаемся своей рекомендации избегать по возможности таких макросов.


Проблема с макросами распространяется также и на фрагменты кода. Если макрос определяет несколько операторов, вы не можете установить контрольную точку в середине макроса. Это верно также для inline-функций C99 и С++: если компилятор заменяет тело inline-функции сгенерированным кодом, снова невозможно или трудно установить внутри него контрольную точку. Это имеет связь с нашим советом компилировать лишь с одной опцией 


; в этом случае компиляторы обычно не используют inline-функции.

Обычно с такими строками используется переменная, представляющая определенное состояние. Довольно просто, и это рекомендуется многими книгами по программированию на С, определять с помощью 


 для таких состояний именованные константы. Например:




































































На уровне исходного кода это выглядит замечательно. Но опять-таки, есть проблема, когда вы пытаетесь просмотреть код из GDB:











Здесь вы также вынуждены возвращаться обратно и смотреть в заголовочный файл, чтобы выяснить, что означает 2. Какова же альтернатива?

Рекомендация: Для определения именованных констант используйте вместо макросов перечисления (enum). Использование исходного кода такое же, а значения enum может выводить также и отладчик.

Пример, тоже из 


 в 


:









































Теперь при просмотре state из GDB мы видим что-то полезное:














15.4.1.3. При необходимости переставляйте код


Довольно часто условие в 


 или 


 состоит из нескольких проверок, разделенных 


 или 


. Если эти проверки являются вызовами функций (или даже не являются ими), невозможно осуществить пошаговое прохождение каждой отдельной части условия. Команды GDB 


 и 


 работают на основе операторов (statements), а не выражений (expressions). (Разнесение их по нескольким строкам все равно не помогает).

Рекомендация: перепишите исходный код, явно используя временные переменные, в которых сохраняются значения или условные результаты, так что вы можете проверить их в отладчике. Первоначальный код должен быть сохранен в комментарии, чтобы вы (или программист после вас) могли сказать, что происходит.

Вот конкретный пример: функция 


 из файла 


:











































































































































































(Номера строк приведены относительно начала этой процедуры, а не файла.) Эта функция является основой главного цикла обработки 


. Внешний цикл (строки 12 и 33) проходит через файлы данных командной строки. Комментарий в строках 13–19 показывает оригинальный код, который читает из текущего файла каждую запись и обрабатывает ее

Возвращаемое 


 значение 0 означает, что все в порядке, тогда как ненулевое возвращаемое значение 


 означает, что все в порядке. Когда мы попытались пройти через этот цикл, проверяя процесс чтения записей, возникла необходимость выполнить каждый шаг отдельно.

Строки 20–30 представляют переписанный код, который вызывает каждую функцию отдельно, сохраняя возвращаемые значения в локальных переменных, чтобы их можно было напечатать из отладчика. Обратите внимание, как в строке 23 этим переменным каждый раз присваиваются известные, ошибочные значения: в противном случае они могли бы сохранить свои значения от предыдущих итераций цикла. Строка 27 является тестом завершения, поскольку код изменился, превратившись в бесконечный цикл (сравните строку 22 со строкой 16), тест завершения цикла является противоположным первоначальному.

В качестве отступления, мы признаемся, что нам пришлось тщательно изучить переделку, когда мы ее сделали, чтобы убедиться, что она точно соответствует первоначальному коду; она соответствовала. Теперь нам кажется, что, возможно, вот эта версия цикла была бы ближе к оригиналу:




































Правда в том, что обе версии труднее воспринимать, чем оригинал, и поэтому, возможно, содержат ошибки. Однако, поскольку текущий код работает, мы решили оставить как есть.

Наконец, мы обращаем внимание, что не все программисты-эксперты согласились бы здесь с нашим советом. Когда каждый компонент условия является вызовом функции, можно установить на каждую контрольную точку, использовать 


 для входа в каждую функцию, а затем использовать 


 для ее завершения. GDB сообщит вам возвращаемое функцией значение, и с этого места вы можете использовать для продолжения 


 или 


. Нам нравится наш подход, поскольку результаты сохраняются в переменных, которые можно проверить (и неоднократно) после вызова функции и даже спустя несколько операторов.




15.4.1.4. Используйте вспомогательные функции отладки


Типичной методикой, применимой во многих случаях, является использование набора значений флагов; когда флаг установлен (т.е. равен true), имеет место определенный факт или применяется определенное условие. Обычно это осуществляется при помощи именованных констант 


 и битовых операторов С. (Использование битовых флагов и операторы работы с битами мы обсуждали во врезке к разделу 8.3.1 «Стиль POSIX: 


 и 


».)

Например, главная структура данных 


 называется 


. У нее большое количество полей, последнее из которых является набором значений флагов. Из файла 


:



























































































Причина для использования значений флагов заключается в том, что они значительно экономят пространство данных. Если бы структура 


 для каждого флага использовала отдельное поле 


, потребовалось бы 12 байтов вместо 2, используемых 


. Текущий размер 


 (на Intel x86) 32 байта. Добавление лишних 10 байтов увеличило бы ее до 42 байтов. Поскольку 


 может потенциально выделять сотни и тысячи (или даже миллионы) 


[170 - Серьезно! Часто люди пропускают через 


 мегабайты данных. Помните, никаких произвольных ограничений! — Примеч. автора.], сохранение незначительного размера является важным.

Что это должно делать с отладкой? Разве мы не рекомендовали только что использовать для именованных констант 


? Ну, в случае объединяемых побитовыми ИЛИ значений 


 не помогают, поскольку они больше не являются индивидуально распознаваемыми!

Рекомендация: предусмотрите функцию для преобразования флагов в строки. Если у вас есть несколько независимых флагов, установите процедуру общего назначения.



ЗАМЕЧАНИЕ. Необычность этих функций отладки заключается в том, что код приложения никогда их не вызывает. Они существуют лишь для того, чтобы их можно было вызывать из отладчика. Такие функции всегда должны быть откомпилированы с кодом, даже без окружающих 


, чтобы их можно было использовать. не предпринимая никаких дополнительных шагов. Увеличение (обычно минимальное) размера кода оправдывается экономией времени разработчика


Сначала мы покажем вам, как мы это делали первоначально. Вот (сокращенная версия) 


 из ранней версии 


 (3.0.6):




























































































































































(Номера строк даны относительно начала функции.) Результатом является строка, что- то наподобие "


". Каждый флаг тестируется отдельно, и если он присутствует, действие каждый раз одно и то же: проверка того, что он не в начале буфера и что можно добавить символ '


', скопировать строку на место и обновить указатель. Сходные функции существовали для форматирования и отображения других видов флагов в программе.

Этот код является повторяющимся и склонным к ошибкам, и для 


 3.1 мы смогли упростить и обобщить его. Вот как 


 делает это сейчас. Начиная с этого определения в 


:


























Эту структуру можно использовать для представления любого набора флагов с соответствующими строковыми значениями. Каждая отдельная группа флагов имеет соответствующую функцию, которая возвращает печатное представление флагов, которые установлены в настоящее время. Из 


:







































































































 определяет массив сопоставлений флагов со строками. По соглашению, значение флага 0 означает конец массива. Код вызывает для осуществления работы 


 («общий флаг в строку»). 


 является процедурой общего назначения, которая преобразует значение флага в строку. Из 


:











































































































































































(Номера строк приведены относительно начала функции, а не файла.) Как и в предыдущей версии, идея заключалась в заполнении статического буфера строковыми значениями, такими, как "


", и возвращении адреса этого буфера. Мы вскоре обсудим причины использования статического буфера; сначала давайте исследуем код.

Указатель 


 отслеживает положение следующего пустого слота в буфере, тогда как 


 отслеживает количество оставшегося места; это уберегает нас от переполнения буфера.

Основную часть функции составляет цикл (строка 12), проходящий через массив значений флагов. Когда флаг найден (строка 13), код вычисляет, сколько места требуется строке (строка 18) и проверяет, осталось ли столько места (строки 19–20).

Тест '


' для первого значения флага завершается неудачей, возвращая 0. Для последующих флагов тест дает значение 1. Это говорит нам, что между значениями должен быть вставлен разделительный символ '


'. Добавляя результат (1 или 0) к длине строки, мы получаем правильное значение 


. Тот же тест с той же целью проводится в строке 22 для проверки строк 23 и 24, которые вставляют символ '


'.

В заключение строки 26–29 копируют значение строки, выверяют количество оставшегося места и обновляют указатель 


. Строка 33 возвращает адрес буфера, который содержит печатное представление строки.

Теперь несколько слов относительно статического буфера. Обычно хорошая практика программирования не одобряет использование функций, возвращающих адреса статических буферов: множественные вызовы таких функций каждый раз переписывают буфер, вынуждая вызывающего копировать возвращенные данные.

Более того, статический буфер по определению является буфером фиксированного размера. Что случилось с принципом GNU «никаких произвольных ограничений»?

Для ответа на эти вопросы нужно вспомнить, что это отладочная функция. Обычный код никогда не вызывает 


; она вызывается лишь человеком, использующим отладчик. Ни у одного вызывающего нет указателя на буфер; как разработчику, осуществляющему отладку, нам нет дела до того, что буфер каждый раз переписывается при вызове функции.

На практике фиксированный размер также не является проблемой; мы знаем, что размер 


 достаточен для представления всех флагов, которые мы используем. Тем не менее, поскольку мы опытные и знаем, что вещи могут измениться, в 


 есть код, предохраняющий себя от переполнения буфера. (Переменная 


 и код в строках 18–20.)

В качестве отступления, использование 


 спорно. Эта константа должна использоваться исключительно для буферов ввода/вывода, но часто она используется также для общих строковых буферов. Такой код лучше убрать, определив явные константы, такие, как 


, и использовав в строке 11 '


'.

Вот сокращенный сеанс GDB, показывающий использование 


:





















































































































































































Надеемся, вы согласитесь, что настоящий механизм общего назначения значительно более элегантный и более простой в использовании, чем первоначальный.

Тщательное проектирование и использование массивов структур часто может заменить или слить воедино повторяющийся код.




15.4.1.5. По возможности избегайте объединений


«Не бывает бесплатных обедов»

    - Lazarus Long -




 С относительно эзотерическая возможность. Она помогает экономить память, сохраняя различные элементы в одном и том же физическом пространстве; как программа интерпретирует его, зависит от способа доступа:




























































Вот что происходит, когда программа запускается на системе Intel x86 GNU/Linux:











Программа выводит битовый паттерн, который представляет число с плавающей точкой в виде шестнадцатеричного целого. Оба поля занимают одно и то же место в памяти; разница в том, как этот участок памяти интерпретируется: 


 действует, как число с плавающей точкой, тогда как эти же биты в 


 действуют, как целое число.

Объединения особенно полезны в компиляторах и интерпретаторах, которые часто создают древовидные структуры, представляющие структуру файла с исходным кодом (которая называется деревом грамматического разбора (parse tree)). Это моделирует то, как формально описаны языки программирования: операторы 


, операторы 


, операторы присваивания и так далее для всех экземпляров более общего типа «оператора». Таким образом, в компиляторе могло бы быть нечто подобное этому:
























































































Вместе с объединением удобно использовать макрос, который представляет компоненты объединения, как если бы они были полями структуры. Например:





















На только что представленном уровне это кажется разумным и выглядит осуществимым. В действительности, однако, все сложнее, и в реальных компиляторах и интерпретаторах часто есть несколько уровней вложенных структур и объединений. Сюда относится и 


, в котором определение 


, значение его флагов и макросов для доступа к компонентам объединения занимают свыше 120 строк![171 - Мы унаследовали эту схему. В общем, она работает, но все же есть проблемы. Целью данного раздела является передача накопленного нами в ходе работы с объединениями опыта — Примеч. автора.] Здесь достаточно определений, чтобы дать вам представление о том, что происходит:




































































































































































































































































































В 


 есть объединение внутри структуры внутри объединения внутри структуры! (Ой.) Поверх всего этого многочисленные «поля» макросов соответствуют одним и тем же компонентам 


/


 в зависимости от того, что на самом деле хранится в 


! (Снова ой.)

Преимуществом такой сложности является то, что код С сравнительно ясный. Нечто вроде '


' читать просто.

У такой гибкости, которую предоставляют объединения, конечно, есть своя цена. Когда отладчик находится глубоко во внутренностях вашего кода, вы не можете использовать симпатичные макросы, которые имеются в исходном коде. Вы должны использовать развернутое значение.[172 - Опять-таки, GCC 3.1 или более новый и GDB 5 дают возможность непосредственного использования макросов, но только лишь если вы используете их совместно, с определенными опциями. Это было описано ранее в разделе 15.4.1.2 «По возможности избегайте макросов с выражениями». — Примеч. автора.] (А для этого придется найти в заголовочном файле соответствующее определение.)

Например, сравните '


' с развернутой формой: '


'! Чтобы увидеть значение данных, вы должны набрать последнее в GDB. Взгляните снова на это извлечение из приведенного ранее сеанса отладки GDB:



















































Это куча вязкой массы. Однако, GDB все же несколько упрощает ее обработку. Вы можете использовать выражения вроде '


', чтобы пройти через дерево и перечислить структуры данных.

Есть другие причины для избегания объединений. Прежде всего, объединения не проверяются. Ничто, кроме внимания программиста, не гарантирует, что когда вы получаете доступ к одной части объединения, вы получаете доступ к той части, которая была сохранена последней. Мы видели это в 


, в котором доступ к обоим «элементам» объединения осуществлялся одновременно.

Вторая причина, связанная с первой, заключается в осторожности с перекрытиями вложенных комбинаций 


/


. Например, в предыдущей версии 


[173 - Эта часть кода была с тех пор пересмотрена, поэтому там больше нет этих строк из примера. — Примеч. автора.] был такой код.
















Первоначально 


 не было, был только вызов 


, которая освобождает 


, на которую указывает 


. Однако, в этот момент 


 могла создать аварийную ситуацию. Можете себе представить, сколько времени потребовало отслеживание в отладчике того факта, что то, что рассматривалось как указатель, на самом деле было размером массива!

В качестве отступления, объединения значительно менее полезны в С++. Наследование и объектно-ориентированные возможности создают при управлении структурами данных совсем другую ситуацию, которая значительно безопаснее.

Рекомендация: по возможности избегайте объединений (


). Если это невозможно, тщательно проектируйте и программируйте их!




15.4.2. Отлаживаемый код времени исполнения



Помимо тех вещей, которые вы добавляете к своему коду для времени компиляции, можно также добавить дополнительный код для обеспечения возможностей отладки времени исполнения. Это особенно полезно для приложений, которые устанавливаются в полевых условиях, когда в системе клиента не будет установленного исходного кода (а может быть, даже и компилятора!)

В данном разделе представлены некоторые методики отладки, которые мы использовали в течение ряда лет, от простых до более сложных. Обратите внимание, что наше рассмотрение ни в коем случае не является исчерпывающим. Это область, в которой стоит иметь некоторое воображение и использовать его!




15.4.2.1. Добавляйте отладочные опции и переменные


Простейшей методикой является наличие опции командной строки, делающих возможным отладку. Такая опция может быть условно откомпилированной для отладки. Однако более гибким подходом является оставить опцию в готовой версии программы. (Вы можете также решить, оставлять или не оставлять эту опцию не документированной. Здесь есть различные компромиссы: ее документирование может дать возможность вашим покупателям или клиентам больше изучить внутренности вашей системы, чего вы можете не хотеть С другой стороны, не документирование ее кажется довольно подлым. Если вы пишете для Open Source или Free Software, лучше документировать опцию.)

Если ваша программа большая, отладочная опция может принимать аргумент, указывающий, какую подсистему следует отлаживать. На основе этого аргумента можно установить различные флаговые переменные или, возможно, различные флаговые биты в одной отладочной переменной. Вот схема этой методики:































































































Функция 


 считывает строку аргументов. Например, это может быть строка разделенных запятыми или пробелами подсистем, вроде "


". Для каждого действительного имени подсистемы функция устанавливает бит в отладочной переменной:



























































































В конечном счете код приложения может затем проверить флаги:


















Использовать ли одну переменную с флаговыми битами, различные переменные или даже отладочный массив, индексируемый именованными константами (желательно из 


), зависит от вас.

Ценой оставления отладочного кода в исполняемом файле изделия является увеличение размера программы. В зависимости от размещения отладочного кода он может быть также более медленным, поскольку каждый раз осуществляются проверки, которые все время оказываются ложными, пока не будет включен режим отладки. И, как упоминалось, кто-нибудь может изучить вашу программу, что может быть неприемлемым для вас. Или еще хуже, недоброжелательный пользователь может включить столько отладочных возможностей, что программа замедлится до невозможности работать с ней! (Это называется атакой отказа в обслуживании (denial of service attack).)

Преимуществом, которое может быть большим, является то, что вашу уже установленную программу можно запустить с включенным режимом отладки без необходимости сначала построить, а затем загрузить специальную версию на сайт заказчика. Когда программное обеспечение установлено в удаленных местах, в которых может не быть людей и все, что вы можете сделать, это получить удаленный доступ к системе через Интернет (или, еще хуже, через медленное модемное соединение!), такая возможность может оказаться спасительным средством.

Наконец, можно использовать смешанную методику: условно компилируемый отладочный код для детальной, точной отладки, а постоянно присутствующий код для более грубого вывода.




15.4.2.2. Используйте специальные переменные окружения


Другой полезной уловкой является проверка вашим приложением специальных переменных окружения (документированных или иных). Это может быть особенно полезным для тестирования. Вот другой пример из нашего опыта с 


, но сначала немного основ.




 использует функцию с названием 


 для получения оптимального размера буфера для ввода/вывода. Для небольших файлов функция возвращает размер файла. В противном случае, если файловая система определяет размер для использования при вводе/выводе, возвращается это значение (член 


 структуры 


, см. раздел 5.4.2 «Получение информации о файле»). Если этот член недоступен, 


 возвращает константу 


 из 


. Оригинальная функция (в 


) выглядела следующим образом:

































































































































































Константа 


 является «размером блока по умолчанию»; то есть значением из 


 или 


. Для терминалов (строка 23) или файлов, которые не являются обычными файлами (


 завершается неудачей, строка 27) возвращаемое значение также равно 


. Для небольших обычных файлов используется размер файла. Во всех других случаях возвращается 


. Знание «оптимального» размера буфера особенно полезно в файловых системах, в которых размер блока больше


.

У нас была проблема, когда один из наших контрольных примеров отлично работал на нашей рабочей системе GNU/Linux и на любой другой системе Unix, к которой у нас был доступ. Однако, этот тест последовательно терпел неудачу на других определенных системах.

В течение длительного времени мы не могли получить непосредственный доступ к терпящей неудачу системе, чтобы запустить GDB. В конце концов, мы смогли, однако, ухитриться воспроизвести проблему. Она оказалась связана с размером буфера, который 


 использовал для чтения файлов данных: на терпящих неудачи системах размер буфера был больше, чем на нашей системе разработки.

Нам был нужен способ воспроизведения проблемы на своей машине разработки, система с неудачей находилась в стороне за девять часовых поясов, а интерактивный запуск GDB через Атлантический океан мучителен. Мы воспроизвели проблему, заставив 


 проверять значение специальной переменной окружения 


. Когда ее значение равно 


, 


 всегда возвращает размер файла, каким бы он ни был. Если значением 


 является какое-нибудь целое число, функция возвращает это число. В противном случае, функция возвращается к прежнему алгоритму. Это дает нам возможность запускать тесты, не требуя постоянной перекомпиляции 


. Например,






Это запускает тестовый набор 


 с использованием размера буфера в 42 байта. (Тестовый набор проходит.) Вот модифицированная версия 


:












































































































































































































































































































































































































Комментарий в строках 3–23 объясняет алгоритм. Поскольку поиск переменных окружения может быть затратным и его нужно осуществить лишь однажды, функция использует для сбора соответствующих сведений в первый раз несколько статических переменных.

Строки 42–54 выполняются лишь при первом вызове функции. Строка 43 обеспечивает это условие, устанавливая в 


 значение 


. Строки 45–54 обрабатывают переменную окружения, разыскивая либо строку 


, либо число. В последнем случае оно преобразуется из строкового значения в десятичное, сохраняясь в 


. (Возможно, нам следовало бы использовать здесь 


; в свое время это не пришло нам на ум.)

Строка 55 выполняется каждый раз, кроме первого. Если было представлено числовое значение, условие будет истинным, и возвращается это значение (строка 56). В противном случае, исполнение переходит к оставшейся части функции.

Строки 60–70 определяют 


; эта часть не изменилась. Наконец, строки 72–76 возвращают размер файла, если это приемлемо. Если нет (строка 78), возвращается 


.

Мы действительно устранили проблему[174 - Переписав код управления буфером! — Примеч. автора.], но между тем оставили на месте новую версию 


, чтобы можно было убедиться, что проблема не возникнет вновь.

Незначительное увеличение размера кода и его сложности более чем компенсируется возросшей гибкостью, которая есть теперь у нас для тестирования. Более того, поскольку это код изделия, пользователь в полевых условиях может с легкостью использовать эту особенность для тестирования, чтобы определить, не появилась ли сходная проблема. (До сих пор нам не приходилось просить проделать этот тест, но приятно осознавать, что мы могли бы это сделать, если бы пришлось.)




15.4.2.3. Добавьте код журналирования


Часто бывает так, что программа вашего приложения работает на системе, на которой вы не можете использовать отладчик (как в случае сайта клиента). В таком случае вашей целью является возможность проверки внутреннего состояния программы, но извне. Единственным способом сделать это является заставить саму программу предоставить для вас эту информацию. Для этого существует множество способов.

• Всегда записывайте сведения в специфический файл. Это простейший способ: программа всегда записывает регистрационную информацию. Затем вы можете при возможности просмотреть файл.

Недостаток в том, что в какой-то момент регистрационный файл займет все дисковое пространство. Следовательно, у вас должны быть несколько файлов журналов, причем программа периодически должна переключаться между ними. Брайан Керниган рекомендует называть файлы журнала по дням недели: 


, 


 и т.д. Преимуществом здесь является то, что вам не придется вручную удалять старые файлы; вы бесплатно получаете недельную стоимость файлов журналов.

• Записывайте в файл журнала лишь тогда, когда он уже существует. При запуске ваша программа записывает сведения в файл журнала, если он существует. В противном случае записи не происходит. Чтобы включить журналирование, сначала создайте пустой файл журнала.

• Используйте для сообщений фиксированный формат, который можно легко анализировать с помощью языков сценариев, таких, как 


 или Perl, для создания сводок и отчетов.

• В качестве альтернативы можно создать какую-нибудь разновидность XML, который является самоописывающимся и допускающим преобразование в другие форматы. (Мы не являемся большими поклонниками XML, но вас это не должно останавливать).

• Для журналирования используйте 


; конечное расположение сообщений журналирования может контролироваться системным администратором, (


 является довольно продвинутым интерфейсом; см. справочную страницу syslog(3)).

Выбор того, как регистрировать сведения, является, конечно, легкой частью. Трудной частью является выбор того, что регистрировать. Как и в остальных случаях разработки программ, стоит подумать, прежде чем программировать. Записывайте сведения о критических переменных. Проверьте их значения, чтобы убедиться, что они в приемлемом диапазоне или в других отношениях ведут себя, как ожидается. Записывайте исключительные условия; если появляется что-то, что не должно было, зарегистрируйте это и при возможности продолжайте исполнение.

Ключом является регистрация лишь тех сведений, которые вам нужны для отслеживания проблем, не больше и не меньше.




15.4.2.4. Файлы отладки времени исполнения


В предыдущей жизни мы работали для начинающей компании с двоичными исполняемыми файлами продукта, установленными на сайтах клиентов. Подключить отладчик к запущенной копии программы или запустить ее из отладчика на системе клиента было невозможно. Главный компонент продукта запускался не непосредственно из командной строки, а опосредованно, через сценарии оболочки, которые проделывали значительную первоначальную настройку.

Чтобы заставить программу выдавать при запуске журналируемые сведения, мы пришли к идее специальных отладочных файлов. Когда файл с определенным именем находился в определенном каталоге, программа выдавала бы информационные сообщения в файл журнала, который мы могли бы затем загрузить и проанализировать. Такой код выглядит следующим образом:
















































Вызов 


 происходил для каждого задания, которое выполняла программа. Таким образом, мы могли динамически включать и отключать журналирование без необходимости останавливать и повторно запускать приложение!

Как и в случае с отладочными опциями и переменными, в этом предмете имеется множество вариаций: различные файлы, которые запускают журналирование информации о различных подсистемах, директивы отладки, добавляемые в сам отладочный файл и т.д. Как и со всеми возможностями, следует планировать схему того, что вам будет нужно, а затем чисто ее реализовывать, вместо того, чтобы набросать какой-нибудь быстрый и грязный код в 3 часа пополудни (к сожалению, довольно типичная возможность в начинающих компаниях).



ЗАМЕЧАНИЕ. Не все то золото, что блестит. Специальные отладочные файлы являются лишь одним примером методик, известных как лазейки (back doors) — один или более способов выполнения разработчиками недокументированных вещей с программой, обычно с бесчестными намерениями. В нашем примере лазейка была исключительно доброкачественной. Но беспринципный разработчик легко мог бы устроить создание и загрузку скрытой копии списка клиентов, картотеки персонала или других важных данных. По одной этой причине вы должны серьезно подумать, применима ли эта методика в вашем приложении.





15.4.2.5. Добавьте специальные ловушки для контрольных точек


Часто проблема может быть воспроизводимой, но лишь после того, как программа сначала обработает многие мегабайты вводимых данных. Или, хотя вы и знаете, какая функция вызывает сбой, он возникает лишь после вызова этой функции сотни или даже тысячи раз.

Это большая проблема, когда вы работаете в отладчике. Если вы установите контрольную точку на вызывающую сбой процедуру, вам придется набирать команду continue и нажимать ENTER сотни или тысячи раз, чтобы привести программу в состояние перед сбоем. Это по меньшей мере утомительно и способствует появлению ошибок! Это может оказаться даже таким трудным, что вы захотите отказаться от этого, даже не начав.

Решение заключается в добавлении специальных отладочных функций «ловушек» («hook»), которые ваша программа может вызвать при приближении к интересующему вас состоянию.

Например, предположим, что вы знаете, что функция 


 вызывает сбой, но лишь когда она вызвана 1427 раз. (Мы не смеемся над вами; в свое время нам пришлось наблюдать довольно странные вещи.)

Чтобы перехватить 


 до того, как она завершится неудачей, создайте специальную фиктивную функцию, которая ничего не делает и просто возвращается, затем сделайте так, чтобы 


 вызывала ее как раз перед 1427-м своим вызовом:
















































Теперь из GDB установите контрольную точку в 


, а затем запустите программу обычным способом:
















По достижении контрольной точки для 


 вы можете установить вторую контрольную точку для 


 и продолжить исполнение:











































По достижении второй контрольной точки программа готова завершиться неудачей, и вы можете пошагово ее пройти, делая все необходимое для отслеживания проблемы.

Вместо использования фиксированной константы ('


') можно использовать глобальную переменную, которая устанавливается отладчиком в любое нужное вам значение. Это дает возможность избежать перекомпилирования программы

Для 


 мы пошли на один шаг дальше и внесли возможность отладочной ловушки в язык, так что функция ловушки могла быть вызвана из программы 


. При компилировании для отладки доступна специальная ничего не делающая функция 


. Эта функция, в свою очередь, вызывает функцию С с тем же названием. Это позволяет нам поместить вызовы 


 в завершающуюся неудачей программу 


 непосредственно перед сбойным участком. Например, если 


 выдает ошибочные результаты для программы 


 в 1200-й вводимой записи, мы можем добавить в программу 


 строку, подобную этой:











Затем из GDB мы можем установить контрольную точку на функции С 


 и запустить программу 


. Когда контрольная точка срабатывает, мы можем затем установить контрольные точки на другие части 


, где, как мы ожидаем, находится действительная проблема.

Методика функции-ловушки полезна сама по себе. Однако, возможность переместить ее на уровень приложения умножает ее полезность, и она сохранила нам бесчисленное число часов отладки при отслеживании непонятных проблем.




15.5. Отладочные инструменты



Помимо GDB и различных ловушек в исходном коде, которые вы используете для общей отладки, имеется ряд полезных пакетов, которые могут помочь обнаружить определенные разновидности проблем. Поскольку управление динамической памятью является в крупномасштабных программах такой трудной задачей, многие инструменты фокусируются на этой области, часто действуя в качестве замещающих 


 и 


 элементов

Имеются коммерческие инструменты, которые делают множество (или все) из тех вещей, что и описываемые нами программы, но не все они доступны для GNU/Linux, а многие довольно дороги. Все пакеты, обсуждающиеся в данном разделе, являются свободно доступными.




15.5.1. Библиотека 


 — усовершенствованный 





Первым пакетом, который мы исследуем, является библиотека 


. Она основана на идее условно компилируемого отладочного кода, которую мы представили ранее в данной главе, но идет намного дальше, предоставляя сравнительно сложную трассировку времени исполнения и условный вывод отладки. Она реализует многие из описанных нами советов, избавляя вас от хлопот по собственной их реализации.

Библиотека 


, написанная Фредом Фишем (Fred Fish) в начале 1980-х, была с тех пор несколько усовершенствована. Теперь она явным образом является общим достоянием, поэтому ее можно использовать без всяких проблем как в свободном, так и частном программном обеспечении. Она доступна через архив FTP Фреда Фиша[175 - 


 — Примеч. автора.] как в виде сжатого файла tar, так и в виде архива ZIP. Документация хорошо резюмирует 


:






 является примером внутреннего отладчика. Поскольку она требует внутренней поддержки программы и ее использование не зависит от каких бы то ни было особых возможностей среды исполнения, она всегда доступна и будет выполняться в любом окружении, в котором будет выполняться сама программа. Вдобавок, поскольку это законченный пакет с особым интерфейсом пользователя, все программы, которые ее используют, будут иметь сходные возможности отладки. Это резко контрастирует с другими формами внутренней поддержки, где у каждого разработчика своя собственная, обычно менее квалифицированная, форма внутреннего отладчика...

Пакет 


 лишь незначительно снижает скорость выполнения программ, обычно значительно менее 10%, и немного увеличивает их размеры, обычно от 10 до 20%. Определив особый идентификатор препроцессора С, можно снизить оба этих показателя до нуля без необходимости изменений в исходном коде.

Следующий список является кратким изложением возможностей пакета 


. Каждую возможность можно отдельно включать или отключать во время запуска программы, указав соответствующие аргументы командной строки.

• Трассировка исполнения, отображающая уровень потока управления полуграфическим способом с использованием отступов, обозначающих глубину вложения

• Вывод значений всех или любого набора ключевых внутренних переменных.

• Ограничение действий определенным набором указанных функций.

• Ограничение трассировки функций указанной глубиной вложения.

• Пометку каждой выводимой строки названием исходного файла и номером строки.

• Пометку каждой выводимой строки названием текущего процесса.

• Сохранение в стеке или восстановление состояния отладки для обеспечения исполнения со встроенными значениями по умолчанию для отладки.

• Перенаправление потока вывода отладки в стандартный вывод (


) или указанный файл. По умолчанию поток вывода направляется в стандартную ошибку (


). Механизм перенаправления полностью независим от обычного перенаправления командной строки, чтобы избежать конфликтов вывода.


Пакет 


 требует от вас использования определенного порядка при написании своего кода. В частности, нужно использовать его макросы при возвращении из функции или вызове 


 и 


. Нужно добавлять один вызов макроса в качестве первого исполняемого оператора каждой функции и вызвать несколько дополнительных макросов из 


. Наконец, нужно добавить отладочную опцию командной строки, по соглашению, это 


, которая редко используется в качестве действительной опции, если вообще используется. В обмен на дополнительную работу вы получаете все только что очерченные преимущества. Давайте взглянем на пример в руководстве:


















































































































































Эта программа иллюстрирует большинство важных моментов. Макрос 


 (строка 12) должен быть вызван после объявлений переменных и перед любым другим кодом. (Это потому, что он сам объявляет несколько частных переменных.[176 - В C99, который допускает смешивание объявлений переменных с исполняемым кодом, это составляет меньшую проблему, но помните, что этот пакет был разработан для K&R С — Примеч. автора.])

Макрос 


 (строка 13) устанавливает имя программы, главным образом, для использования в выводимых библиотекой сообщениях. Этот макрос должен вызываться лишь однажды, из 


.

Макрос 


 (строка 14) заставляет библиотеку проверить указанную переменную окружения (в данном случае 


) на предмет управляющей строки (Управляющие строки 


 вскоре будут рассмотрены.) Библиотека может, сохранив свое текущее состояние и использовав новое, создавать стек сохраненных состояний. Таким образом, этот макрос помещает в стек сохраненных состояний полученное от данной переменной окружения состояние. В данном примере использован случай, когда макрос создает первоначальное состояние. Если такой переменной окружения нет, ничего не происходит. (В качестве отступления, 


 является довольно общей переменной, возможно, 


 было бы лучше [для 


].)

Макрос 


 (строка 18) передает значение управляющей строки, полученной из опции командной строки 


. (Новый код должен использовать 


 или 


 вместо ручного анализа аргументов.) Таким образом обычно включается режим отладки, но использование переменной окружения предоставляет также дополнительную гибкость.

Макрос 


 (строка 23) осуществляет вывод. Второй аргумент использует методику, которую мы описали ранее (см. раздел 15.4.1.1 «Используйте отладочные макросы»), по включению в скобки всего списка аргументов 


, делая его простым аргументом, насколько это касается препроцессора С. Обратите внимание, что завершающий символ конца строки в форматирующей строке не указывается; библиотека 


 вставляет его за вас.

При печати 


 по умолчанию выводит все операторы 


. Первый аргумент является строкой, которая может использоваться для ограничения вывода лишь теми макросами 


, которые используют эту строку.

Наконец, макрос 


 (строка 28) используется вместо обычного оператора 


 для возврата значения. Для использования с функциями 


 имеется соответствующий макрос 


.

Оставшаяся часть программы заполнена функцией 


:







































































Когда программа откомпилирована и скомпонована вместе с библиотекой 


, ее можно запустить обычным способом. По умолчанию, программа не создает вывод отладки. Но со включенной отладкой доступны различные виды вывода:

































































































































































Опция 


 управляет библиотекой 


. Она «особая» в том смысле, что 


 будет принимать всю строку, игнорируя ведущие символы '


', хотя вы могли бы использовать при желании другую опцию, передав 


 лишь строку аргументов опций (если вы используете 


, это 


).

Управляющая строка состоит из набора опций и аргументов. Каждая группа опций и аргументов отделяется от других символом двоеточия. Каждая опция представлена одной буквой, а аргументы этой опции отделяются от нее запятыми. Например:






Опция 


 включает вывод 


, но лишь если первая строка аргумента является "


" или "


". (Если аргументов нет, выводятся все сообщения 


.) Сходным образом опция 


 ограничивает трассировку вызовов функций лишь указанными функциями, 


 и 


.

Следующий список опций и аргументов воспроизведен из руководства библиотеки 


. Квадратные скобки заключают необязательные аргументы. Мы включаем здесь лишь те, которые находим полезными; полный список см. в документации.






Разрешает вывод от макросов с указанными ключевыми словами. Пустой список ключевых слов предполагает, что выбраны все ключевые слова.






Помечает каждую строку вывода отладки именем исходного файла, содержащего макрос, осуществляющий вывод.






Идентифицирует процесс, выводящий каждую отладочную или трассировочную строку номером ID для этого процесса.






Помечает каждую строку вывода отладчика номером строки исходного файла, в котором находится осуществляющий вывод макрос.






Перенаправляет поток вывода отладчика в указанный файл. Потоком вывода по умолчанию является 


. Пустой список аргументов перенаправляет вывод в 


.






Включает трассировку потока управления функций. Максимальная глубина вложения определяется 


, по умолчанию используется 200.

Для завершения нашего обсуждения вот остальные макросы, определенные библиотекой 


.






Этот макрос похож на 


: первый аргумент является строкой, выбранной с помощью опции 


, а второй — код для исполнения:











Это значение типа 


 для использования с процедурами 


. Оно позволяет осуществлять собственный вывод в поток файла отладки.






Этот макрос заключает в оболочку вызов 


, принимая те же самые аргументы, так что библиотека 


 будет знать, когда вы сделали нелокальный переход.






Этот макрос выталкивает из стека один уровень сохраненного состояния отладки, созданный макросом 


. Он довольно эзотерический; вы скорее всего не будете его использовать.






Этот макрос заключает в оболочку вызов 


, принимая те же самые аргументы. Он позволяет библиотеке 


 обрабатывать нелокальные переходы.

В другом воплощении, в первой начинающей компании, для которой мы работали[177 - Хотя нам следовало бы усвоить свой урок после первой компании, мы перешли ко второй. С тех пор, как мы это выяснили, мы обычно избегаем начинающие компании. Ваша выгода, конечно, может меняться — Примеч. автора.], мы использовали в своем продукте библиотеку 


. Она была неоценимой при разработке, а опустив 


 в конечной сборке, мы смогли построить готовую версию без других изменений исходного кода.

Чтобы извлечь максимальную выгоду от библиотеки 


, нужно использовать ее последовательно, по всей программе. Это проще, если вы используете ее с начала проекта, но в качестве эксперимента мы обнаружили, что с помощью простого сценария 


 мы смогли включить библиотеку в программу с 30 000 строк кода за несколько часов работы. Если вы можете позволить себе накладные расходы, лучше всего оставить ее в конечной сборке вашей программы, чтобы можно было ее отлаживать без необходимости предварительной перекомпиляции.

Мы нашли, что библиотека 


 является удачным дополнением к внешним отладчикам, таким, как GDB; она обеспечивает организованный и последовательный способ применения поддержки к коду С. Она также довольно элегантно сочетает многие из методик, которые мы ранее в данной главе очертили отдельно. Особенно полезна особенность динамической трассировки вызовов функций, и она доказывает свою бесценность в качестве помощи в изучении поведения программы, если вы незнакомы с ней.




15.5.2. Отладчики выделения памяти



Игнорируя такие проблемы, как плохой дизайн программы, для любого крупномасштабного практического приложения единственной сложной задачей программиста на С является управление динамической памятью (посредством 


, 


 и 


).

Этот факт подкреплен большим количеством инструментов, доступных для отладки динамической памяти. Имеется значительное перекрывание того, что предлагают данные утилиты. Например:

• Обнаружение утечек памяти: память, которая выделяется, а затем становится недоступной.

• Обнаружение не освобождаемой памяти: память, которая выделяется, но никогда не освобождается. Не освобождаемая память не всегда является ошибкой, но определение таких случаев дает вам возможность проверить, что с ними все в порядке.

• Обнаружение неправильных освобождений: память, которая освобождается дважды, или функции 


 передаются указатели, которые не были получены с помощью 


.

• Обнаружение использования уже освобожденной памяти: память, которая освобождена, используется через висячий указатель.

• Обнаружение выхода за границы выделенной памяти: получение доступа или сохранение в память за пределами выделенной границы.

• Предупреждение об использовании неинициализированной памяти. (Многие компиляторы могут выдавать такие предупреждения.)

• Динамическая трассировка функций: когда появляется ошибочный доступ к памяти, вы получаете трассировку от того места, где память используется, до того места, где она была выделена.

• Управление инструментами посредством использования переменных окружения.

• Файлы журналов для необработанной отладочной информации, которая может быть обработана позже для создания полезных отчетов.

Некоторые утилиты просто записывают эти события. Другие организуют жуткое завершение программы приложения (посредством 


), чтобы на код-нарушитель можно было точно указать из отладчика. Вдобавок, большинство спроектированы для работы вместе с GDB.

Некоторые инструменты требуют изменения исходного кода, такого, как вызов специальных функций или использование особого заголовочного файла, дополнительных 


 и статической библиотеки. Другие работают посредством использования специального механизма библиотек общего пользования Linux/Unix для прозрачной установки себя в качестве заместителя стандартных библиотечных версий 


 и 


.

В данном разделе мы рассмотрим три отладчика динамической памяти, а затем предоставим ссылки на несколько других.




15.5.2.1. GNU/Linux 





Системы GNU/Linux, использующие GLIBC, предоставляют две функции для включения и отключения трассировки памяти во время исполнения.


















Когда вызывается 


, библиотека проверяет переменную окружения 


. Ожидается, что она указывает на записываемый файл (существующий или нет). Библиотека открывает файл и начинает записывать сведения о выделениях и освобождениях памяти (Если файл не может быть открыт, запись не производится. Файл урезается каждый раз при запуске программы.) Когда вызывается 


, библиотека закрывает файл и больше не регистрирует выделения и освобождения.

Использование отдельных функций дает возможность проводить трассировку памяти для определенных частей программы; необязательно отслеживать все. (Мы нашли наиболее полезным включить журналирование в начале программы и все, но эта схема предоставляет гибкость, которую хорошо иметь.)

Когда приложение завершается, вы используете программу 


 для анализа файла журнала. (Файл журнала в формате ASCII, но информацию нельзя использовать непосредственно.) Например, 


 включает трассировку, если определена 


:



























































































Вывод представляет собой список мест, в которых 


 выделяет память, которая в дальнейшем не освобождается. Обратите внимание, что постоянное подвешивание к динамической памяти является замечательным, если это сделано намеренно. Все показанные здесь случаи являются выделениями такого рода.




15.5.2.2. Electric Fence


В разделе 3.1 «Адресное пространство Linux/Unix» мы описали, как динамическая память выделяется из кучи, которая может расти и сокращаться (с помощью вызовов 


 или 


, описанных в разделе 3.2.3 «Системные вызовы: 


 и 


»).

Ну, картина, которую мы там представили, является упрощением действительности. Более развитые системные вызовы (не рассматриваемые в данной книге) позволяют добавлять в адресное пространство процесса дополнительные, необязательно смежные сегменты памяти. Многие отладчики 


 работают с использованием этих системных вызовов для добавления новых областей адресного пространства при каждом выделении. Преимуществом этой схемы является то, что операционная система и аппаратное обеспечение защиты памяти компьютера взаимодействуют для обеспечения недействительности доступа к памяти за пределами этих изолированных сегментов, генерируя сигнал 


. Эта схема изображена на рис. 15.1.




Рис. 15.1. Адресное пространство Linux/Unix, включая специальные области

Первым пакетом отладки, реализовавшим эту схему, был Electric Fence. Electric Fence является вставляемым заместителем для 


 и др. Он работает на многих системах Unix и GNU/Linux; он доступен с FTP архива его авторов.[178 - 


 — Примеч. автора.] Он поставляется также со многими дистрибутивами GNU/Linux, хотя, возможно, вам придется выбрать ею явным образом при установке системы.

После компоновки программы с Electric Fence любой доступ за пределами выделенной памяти генерирует 


. Electric Fence также перехватывает попытки использования уже освобожденной памяти. Вот простая программа, которая иллюстрирует обе проблемы.













































































































































Эта программа осуществляет простую проверку опций командной строки, чтобы решить, как вести себя плохо: 


 вызывает доступ к памяти за ее выделенными страницами, а 


 пытается использовать освобожденную память. (Строки 18 и 21 являются соответственно опасными.) Обратите внимание, что без опций указатель никогда не освобождается (строка 25), Electric Fence не перехватывает этот случай.

Одним из способов использования Electric Fence, способом, который гарантированно работает на различных системах Unix и GNU/Linux, является статическая компоновка с ним вашей программы. Затем программа должна быть запущена из отладчика. (Документация Electric Fence явно указывает, что Electric Fence не следует компоновать с двоичным файлом готового изделия.) Следующий сеанс демонстрирует эту процедуру и показывает, что происходит для обеих опций командной строки:






























































































































На системах, которые поддерживают разделяемые библиотеки и переменную окружения 


 (в том числе и на GNU/Linux), вам не нужно явным образом компоновать библиотеку 


. Вместо этого сценарий оболочки 


 организует запуск программы с соответствующей настройкой.

Хотя мы не описали механизмы подробно, GNU/Linux (и другие системы Unix) поддерживают разделяемые (shared) библиотеки, особые версии библиотечных процедур, которые хранятся в одном файле на диске, вместо того, чтобы копироваться в каждый отдельный двоичный исполняемый файл программы. Разделяемые библиотеки экономят дисковое пространство и могут сохранить системную память, поскольку все программы, использующие разделяемые библиотеки, используют одну и ту же копию библиотеки в памяти. Платой за это является замедление загрузки программы, поскольку программу и разделяемую библиотеку нужно подключить друг к другу прежде, чем программа сможет начать выполнение. (Обычно это прозрачно для вас, пользователя.)

Переменная окружения 


 заставляет системный загрузчик программ (который загружает исполняемые файлы в память) связаться со специальной библиотекой до стандартных библиотек. Сценарий 


 использует эту особенность для связывания набора функций 


 в Electric Fence.[179 - GDB также позволяет определить переменную окружения 


: 


 — Примеч. науч. ред.] Таким образом, повторная компоновка даже не нужна. Этот пример демонстрирует 


:









































































GNU/Linux создает файлы 


, которые включают в свое имя ID процесса. В данном случае такое поведение полезно, поскольку мы можем отдельно отлаживать каждый файл 


:
























































































Справочная страница efence(3) описывает несколько переменных окружения, которые должны быть установлены, чтобы настроить поведение Electric Fence. Следующие три наиболее примечательны.






Установка этой переменной в 1 заставляет Electric Fence проверять «недоборы» (underruns) вместо «переборов» (overruns) при выходе за пределы отведенной памяти. «Перебор», т.е. доступ к памяти в области за выделенной, был продемонстрирован ранее. «Недобор» является доступом к памяти, расположенной перед выделенной областью памяти.






Установка этой переменной в 1 предотвращает повторное использование Electric Fence памяти, которая была корректно освобождена. Это полезно, когда вы думаете, что программа может получать доступ к освобожденной памяти; если освобожденная память впоследствии была выделена заново, доступ к ней через предыдущий висячий указатель остался бы в противном случае незамеченным.






При наличии ненулевого значения Electric Fence допускает вызовы '


'. Такие вызовы в стандартном С технически действительны, но могут представлять программную ошибку. Соответственно Electric Fence по умолчанию их запрещает.

Вдобавок к переменным окружения Electric Fence предоставляет глобальные переменные с такими же названиями. Вы можете изменить их значения из отладчика, так что можно динамически изменять поведение программы, которая уже начала выполнение. Подробности см. в efence(3).




15.5.2.3. Отладка Malloc: 





Библиотека 


 предоставляет большое число опций отладки. Ее автором является Грей Ватсон (Gray Watson), есть также и свой веб-сайт.[180 - 


 — Примеч. автора.] Как и в случае с Electric Fence, она может быть уже установленной на вашей системе, или же вы можете ее извлечь и построить самостоятельно.

Библиотека 


 проверяет наличие в переменной окружения 


 управляющей информации. Например, она может выглядеть следующим образом:











Компонент '


' этой переменной содержит набор битовых флагов, которыми для большинства людей почти невозможно непосредственно управлять. Поэтому документация описывает двухэтапный процесс для облегчения их использования.

Первый шаг заключается в определении функции оболочки с названием 


, которая вызывает программу драйвера 


:
















После того, как это сделано, вы можете передать функции опции для установки файла журнала (-1), указать число итераций, после которых 


 должна проверить свои внутренние структуры данных (-1), и указать уровень отладки или другой тэг ('


').






Как и Electric Fence, библиотека 


 может быть скомпонована с приложением статически или связана динамически при помощи 


. Последнее демонстрирует следующий пример:













ЗАМЕЧАНИЕ. Не используйте '


'! Если вы это сделаете, каждая программа, которую вы запустите, такая как 


, будет выполняться со включенной проверкой 


. Ваша система быстро станет непригодной. Если вы сделали это случайно, можете использовать '


', чтобы восстановить обычное поведение.


Результаты записываются в файл 


 следующим образом:























































































































































Вывод содержит много статистических данных, которые нам пока не интересны. Интересна строка, в которой указывается не освобожденная память, с адресом возврата, указывающим на выделившую память функцию ('


'). Документация 


 объясняет, как получить расположение в исходном коде этого адреса с использованием GDB.









































Это трудно, но выполнимо, если нет другого выбора. Однако, если вы включите в свою программу заголовочный файл "


" (после всех остальных операторов 


), вы можете получить сведения из исходного кода непосредственно в отчете.
























































(Файл 


 является аналогичным 


, за исключением того, что он включает 


, поэтому мы не стали беспокоиться с его отображением).

Отдельные возможности отладки включаются или выключаются посредством использования лексем (tokens) — специально распознаваемых идентификаторов — и опций 


 для добавления лексем (свойств) или 


 для их удаления. Имеются предопределенные комбинации, '


', '


' и '


'. Чем являются эти комбинации, вы можете увидеть с помощью '


'.





























































Полный список лексем вместе с кратким объяснением и соответствующим каждой лексеме числовым значением можно получить с помощью '


':























































































































































К этому времени у вас должно быть ощущение того, как использовать 


, и его гибкости, 


 является избыточным для нашей простой демонстрационной программы, но он неоценим для более крупномасштабного, реального приложения.




15.5.2.4. Valgrind: многосторонний инструмент


Инструменты, описанные в предыдущем разделе, все фокусируются на отладке динамической памяти, и это в самом деле является значительной проблемной областью для многих программ. Однако, проблемы динамической памяти не являются единственной разновидностью. Программа Valgrind под лицензией GPL охватывает большое разнообразие проблем, включая те, которые происходят от динамической памяти.

Руководство по Valgrind описывает программу также или лучше, чем можем мы, поэтому мы будем цитировать (и сокращать) его по мере продвижения вперед.



Valgrind является гибким инструментом для отладки и профилирования исполняемых файлов Linux-x86. Инструмент состоит из ядра, которое программно обеспечивает искусственный процессор x86, и ряда «оболочек», каждая из которых является отладочным или профилирующим инструментом. Архитектура модульная, так что можно легко создавать новые «оболочки», не нарушая существующую структуру.

Наиболее полезной «оболочкой» является 


.

«Оболочка» 


 обнаруживает в ваших программах проблемы с управлением памятью. Проверяются все чтения и записи памяти, а вызовы 


 перехватываются. В результате 


 может обнаружить следующие проблемы

• Использование неинициализированной памяти.

• Чтение/запись в память после ее освобождения.

• Чтение/запись за границей выделенного 


 блока.

• Чтение/запись в ненадлежащие области стека.

• Утечки памяти, когда указатели на выделенные 


 теряются навсегда.

• Несоответствующее использование 


 против 


.

• Некоторые неправильные употребления 


 API POSIX.

Проблемы, подобные этим, могут быть трудно обнаруживаемыми другими средствами, часто остающимися необнаруженными в течение длительного времени и вызывающими редкие, трудные для обнаружения отказы.

Другие «оболочки» более специализированы:

• 


 осуществляет обстоятельную имитацию кэшей I1, D1 и L2 процессора, поэтому может точно указать источники осечек кэшей в вашем коде.

• 


 идентична 


 за исключением одной детали — она не проверяет неинициализированные данные. Все остальные проверки — главным образом, точная проверка адресов — по-прежнему проводится. Обратной стороной этого является то, что вы не перехватываете ошибки неинициализированных данных, которые может найти 


.

Но положительная сторона значительна: программы работают почти в два раза быстрее, чем с 


, используя значительно меньше памяти. Утилита по-прежнему находит чтения/записи освобожденной памяти, памяти за пределами выделенных блоков и в других недействительных местах, ошибки, которые вы действительно хотите обнаружить до выпуска программы в свет!

• 


 является отладочной оболочкой, предназначенной для обнаружения состязания данных в многопоточных программах.


Наконец, руководство отмечает:



Valgrind тесно связан с особенностями процессора, операционной системы и, в меньшей степени, компилятора и основных библиотек С. Это затрудняет его переносимость, поэтому мы с самого начала сконцентрировались на том, что мы считаем широко использующейся платформой: Linux на x86. Valgrind использует стандартный механизм Unix '


', '


', '


', и мы попытались обеспечить его работу на машинах с ядром 2.2 или 2.4 и glibc 2.1.X, 2.2.X или 2.3.1. Это должно охватить значительное большинство современных установок Linux. Обратите внимание, что glibc-2.3.2+ с пакетом NPTL (Native POSIX Thread Library — собственная библиотека потоков POSIX) не будет работать. Мы надеемся исправить это, но это будет нелегко.


Если вы используете GNU/Linux на другой платформе или используете коммерческую систему Unix, Valgrind не окажет вам большой помощи. Однако, поскольку системы GNU/Linux на x86 довольно обычны (и вполне доступны), вполне вероятно, что вы сможете приобрести ее с умеренным бюджетом, или по крайней мере, занять на время! Что еще, когда Valgrind нашел для вас проблему, она исправляется для любой платформы, для которой компилируется ваша программа. Таким образом, разумно использовать систему x86 GNU/Linux для разработки, а какую-нибудь другую коммерческую систему Unix для развертывания высококачественного продукта.[181 - Все в большей степени для разработки высококачественных продуктов используется также GNU/Linux! — Примеч. автора.]

Хотя из руководства Valgrind у вас могло сложиться впечатление, что существуют отдельные команды 


, 


 и т.д., это не так. Вместо этого программа оболочки драйвера с именем 


 запускает отладочное ядро с соответствующей «оболочкой», указанной в опции 


. Оболочкой по умолчанию является 


; таким образом, запуск просто 


 равносильно '


' (Это обеспечивает совместимость с более ранними версиями Valgrind, которые осуществляли лишь проверку памяти, это имеет также больший смысл, поскольку оболочка 


 предоставляет большую часть сведений.)

Valgrind предусматривает ряд опций. За всеми подробностями мы отсылаем вас к его документации. Опции поделены на две группы; из тех, которые используются с ядром (т. е. работают для всех оболочек), наиболее полезными могут быть следующие:






Запускается с подключенным к процессу GDB для интерактивной отладки. По умолчанию используется 


.






Перечисляет опции.






Записывает сообщения в 


.






Выводит число вызывающих в трассировке стека. По умолчанию 4.






Использует соответствующую оболочку. По умолчанию 


.






Запускает трассировку также в порожденных процессах. По умолчанию используется 


.




, 




Использует более полный вывод. Это включает перечисление загруженных библиотек, а также подсчеты всех различных видов ошибок.

Из опций для оболочки 


 мы полагаем, что эти являются наиболее полезными.






Искать утечки памяти после завершения программы. По умолчанию используется 


.






Показать доступные блоки после завершения программы. Если используется 


, Valgrind ищет динамически выделенную память, на которую все еще есть указывающий на нее указатель. Такая память не является утечкой, но о ней все равно следует знать. По умолчанию используется 


.

Давайте посмотрим на Valgrind в действии. Помните 


? (См. раздел 15.5.2.2 «Electric Fence».) Опция 


 записывает в память, находящуюся вне выделенного 


 блока. Вот что сообщает Valgrind:

























































































































(Были добавлены номера строк в выводе, чтобы облегчить обсуждение.) Строка 8 является выводом программы; остальные от Valgrind в стандартную ошибку. Сообщение об ошибке находится в строках 9–17. Она указывает, сколько байтов было записано неверно (строка 9), где это случилось (строка 10), и показывает трассировку стека. Строки 13–17 описывают, откуда была выделена память. Строки 19–23 подводят итоги.

Опция 


 программы 


 освобождает выделенную память, а затем записывает в нее через висячий указатель. Вот что сообщает Valgrind в этом случае:







































































На этот раз в отчете указано, что запись была осуществлена в освобожденную память и что вызов 


 находится в строке 20 


.

При вызове без опций 


 выделяет и использует память, но не освобождает ее. О таком случае сообщает опция —


:




















































































































Строки 17–29 предоставляют отчет об утечке; эта память была выделена в строке 11 


.

Помимо отчетов о неправильном использовании динамической памяти, Valgrind может диагностировать использование неинициализированной памяти. Рассмотрим следующую программу, 


:



























































































При запуске Valgrind выдает этот (сокращенный) отчет:










































































































В документации Valgrind объясняется, что копирование неинициализированных данных не выдает сообщений об ошибках. Оболочка memcheck отмечает состояние данных (неинициализированные) и отслеживает его при перемещениях данных. Таким образом, 


 считается неинициализированной, поскольку это значение было получено от 


, которая была неинициализированной.




 сообщает о проблеме лишь тогда, когда неинициализированное значение используется. Здесь это происходит в библиотеке С (


), которая должна преобразовать значение в строку, для этого, она проводит с этим значением вычисления.

К сожалению, хотя Valgrind может обнаружить использование неинициализированной памяти вплоть до уровня битов, он не может осуществлять проверки границ массивов для локальных и глобальных переменных. (Valgrind может осуществлять проверку границ для динамической памяти, поскольку он сам обрабатывает такую память, поэтому знает о начале и конце каждой области.)

В заключение, Valgrind является мощным инструментом отладки памяти. Он использовался в таких крупномасштабных, многопоточных производственных программах, как KDE 3, OpenOffice и веб-браузер Konqueror. Он конкурирует с несколькими коммерческими предложениями, а другая его версия была даже использована (совместно с эмулятором WINE[182 - 


 — Примеч. автора.]) для отладки программ, написанных для Microsoft Windows с использованием Visual С++! Вы можете получить Valgrind с его веб-сайта[183 - 


 — Примеч. автора.].




15.5.2.5. Другие отладчики malloc


Две статьи Cal Ericson в Linux Journal описывают 


 и 


, а также большинство других перечисленных ниже инструментов. Эти статьи Memory Leak Detection in Embedded Systems, выпуск 101[184 - 


 — Примеч. автора.], сентябрь 2002 г., и Memory Leak Detection in C++, выпуск 110[185 - 


 — Примеч. автора.], июнь 2003 г. Обе статьи доступны на веб-сайте Linux Journal.

Другие инструменты сходны по природе с описанными ранее.






Замещающая 


 библиотека, которая не нуждается в особой компиляции и может использоваться с С++. См. 


. 




 Марка Мораеса (Mark Moraes)

Старинная, но полнофункциональная библиотека замещения 


, предоставляющая возможности профилирования, трассировки и отладки. Вы можете получить ее с 


.






Пакет с большими возможностями настройки для отладки памяти и тестирования. См 


.






Пакет, требующий использования специального заголовочного файла и опций времени компилирования. См. 


.






«Не просто еще один отладчик malloc» (Not Just Another Malloc Debugger). Эта библиотека не требует специальной компоновки с приложением; вместо этого она использует 


 для замены стандартных процедур. См. 


.






Похож на Electric Fence, но со многими дополнительными опциями. См. 


.

Почти все из этих пакетов используют для точной настройки своего поведения переменные окружения. В таблице 15.1 на основе статей из Linux Journal сделана сводка различных пакетов.



Таблица 15.1. Сводка особенностей инструментов памяти




Как видно, для отладки проблем динамической памяти доступен ряд выборов. На системах GNU/Linux и BSD один или более из этих инструментов, возможно, уже установлены, что избавляет вас от хлопот по их загрузке и построению.

Полезно также использовать для своей программы несколько инструментов подряд. Например, 


 для обнаружения не освобождаемой памяти, a Electric Fence для перехвата доступа к недействительной памяти.




15.5.3. Современная 





В оригинальном С компилятор не мог проверить, соответствуют ли параметры, переданные в вызове функции, списку параметров в определении функции; прототипов не было. Это часто вело к неуловимым ошибкам, поскольку ошибочный вызов функции мог вызывать лишь частично ошибочные результаты, которые проходили незамеченными во время тестирования, или мог даже вообще не появиться во время тестирования. Например:
















Если программа, содержащая этот фрагмент, никогда не вызывается с ошибочным числом аргументов, 


, в которой отсутствует первый аргумент 


, также никогда не вызывается.

Программа V7 


 была предназначена для решения таких проблем. Она делала два прохода через все файлы программы, сначала собирая сведения об аргументах функций, а затем сравнивая вызовы функций с собранной информацией. Особые файлы «библиотеки 


» предоставляли сведения о функциях стандартных библиотек, так что их также можно было проверить, lint проверяла также другие сомнительные конструкции.

С появлением в стандартном С прототипов необходимость в 


 уменьшилась, но не исчезла совсем, поскольку C89 все еще допускает объявления функций в старом стиле.






Вдобавок, многие другие аспекты программы можно проверять статически, т.е. путем анализа исходных текстов.

Программа 


 (Secure Programming Lint — Lint для безопасного программирования)[186 - 


 — Примеч. автора.] является современным обновлением 


. Она предусматривает слишком много опций и возможностей, чтобы перечислять их здесь, но ее стоит исследовать.

Следует знать об одной особенности подобных 


 программ, которая заключается в том, что они выводят целый поток предупреждающих сообщений. Многие из сообщаемых предупреждений в действительности безвредны. В таких случаях инструменты допускают использование специальных комментариев, сообщающих. «Да, я знаю об этом, это не проблема», 


 лучше всего работает, когда вы предоставляете в своем коде большое количество подобных примечаний.




 является мощным, но сложным инструментом; выделение некоторого времени на изучение его использования, а затем частое его использование поможет сохранить ваш код ясным.




15.6. Тестирование программ


Разработка программного обеспечения содержит элементы и искусства, и науки, это одна сторона того, что делает ее такой восхищающей и стимулирующей профессией. Данный раздел вводит в тему тестирования программного обеспечения, которая также включает в себя и искусство, и науку; таким образом, это несколько более общий и высокий уровень (читай: «на который можно махнуть рукой»), чем остальная часть данной главы.

Тестирование программ является неотъемлемой частью процесса разработки программного обеспечения. Весьма маловероятно, что программа заработает правильно на 100 процентов при первой компиляции. Программа не несет ответственности за свою правильность; за это отвечает автор программы. Одним из самых важных способов проверки того, что программа работает так, как предполагалось, является ее тестирование.

Один из способов классификации различных видов тестов следующий:

Тесты модулей (Unit tests)

Это тесты, которые вы пишете для каждого модуля или функционального компонента своей программы. В качестве части работы может потребоваться также создать окружение (scaffolding) — код, предназначенный для предоставления поддерживающего каркаса, чтобы запустить модуль в виде отдельной программы.

Важно спроектировать тесты для каждого функционального компонента во время его разработки. Это помогает прояснить проектирование особенностей; знание того, как это тестировать, помогает определить, что следует и что не следует делать в первую очередь.

Комплексные тесты (Integration tests)

Это тесты, которые применяются, когда все функциональные компоненты были написаны, протестированы и отлажены по отдельности. Идея в том, что все затем помешается на свое место в каркасе и тестируется все в целом, чтобы убедиться, что взаимодействия между компонентами работают.

Возвратные тесты (Regression tests)

Неизбежно вы (или ваши пользователи!) обнаружат проблемы. Это могут быть действительные ошибки, или ограничения дизайна, или неизбежные отказы в «пограничных случаях». Когда вы смогли воспроизвести и исправить проблему, сохраните первоначальные условия отказа в качестве возвратного теста.

Возвратный тест позволяет вам убедиться, что при проведении изменений не была повторена старая проблема. (Это случается довольно легко.) Пропустив программу после проделанных изменений через набор тестов, вы можете быть (более) уверены, что все работает таким образом, как предполагалось.

Тестирование следует по возможности автоматизировать. Это особенно легко сделать для программ, не содержащих графического пользовательского интерфейса (GUI), написанных в стиле инструментов Linux/Unix: читающих стандартный ввод или указанные файлы и записывающих в стандартный вывод и стандартную ошибку. По меньшей мере, тестирование можно осуществить с помощью простых сценариев оболочки. Более сложное тестирование осуществляется обычно с помощью отдельного подкаталога 


 и программы 


.

Тестирование программного обеспечения само по себе является отдельной областью, и мы не предполагаем отдавать ей здесь должное; скорее, наше намерение дать вам знание, что тестирование является неотъемлемой частью разработки и часто движущей силой для использования ваших навыков в отладке! Вот очень короткий резюмирующий список.

• Проектируйте тест вместе с функциональностью

• Тестируйте пограничные условия: убедитесь, что функция работает внутри и на действительных границах и что она корректно выдает ошибку за их пределами. (Например, функция 


 должна потерпеть неудачу с отрицательным аргументом). 

• Используйте в своем коде операторы проверки (см. раздел 12.1 «Операторы проверки 


») и проведите свои тесты с разрешенными операторами проверки.

• Создайте и используйте повторно тестовое окружение.

• Сохраняйте условия сбоев для возвратного тестирования

• Как можно больше автоматизируйте тестирование.

• Печатайте число потерпевших неудачу тестов, чтобы легко можно было определить успех или неудачу, а также степень неудачи.

• Используйте инструменты обзора кода, такие, как 


, чтобы удостовериться, что ваш набор тестов охватывает весь ваш код.

• Тестируйте с самого начала и тестируйте часто.

• Изучите литературу по тестированию программного обеспечения, чтобы совершенствовать свою способность разрабатывать и тестировать программное обеспечение.




15.7. Правила отладки


Отладка не является «черной магией». Ее принципы и методики могут быть изучены и последовательно применены каждым. С этой целью мы рекомендуем книгу Debugging Дэвида Эганса (David J. Agans; ISBN: 0-8144-7168-4). У книги есть веб-сайт[187 - 


 — Примеч. автора.], на котором обобщены правила и представлен плакат для загрузки, чтобы вы могли его распечатать и повесить на стену в своем офисе.

Чтобы завершить наше обсуждение, мы представляем следующий материал. Он был адаптирован Дэвидом Эгансом по разрешению из Debugging, Copyright © 2002 David J. Agans, опубликованной AMACOM[188 - 


 — Примеч. автора.], отделением American Management Association, New York. Мы благодарим его.

1. Поймите систему. Когда ничто не помогает, прочтите руководство. Вам необходимо узнать, что должна делать проблемная система и все ее части, если хотите выяснить, почему она не работает. Поэтому прочтите всю документацию, которую можете получить в свои руки (и в свой браузер).

Знание того, где находятся функциональные блоки и размещаются данные, и как они взаимодействуют, дает вам схему для изоляции ошибки. Конечно, вам нужно знать также соответствующую область (язык, операционную систему, приложение) и свои инструменты (компилятор, отладчик исходного кода).

2. Вызовите сбой. Для того, чтобы увидеть ошибку, вы должны быть способны постоянно воспроизводить сбой. Задокументируйте свои процедуры и начните с известного состояния, чтобы вы всегда могли снова вызвать сбой. Ищите ошибку в системе, которая дает сбой, не старайтесь имитировать проблему на другой системе. Не доверяйте статистике непостоянных проблем; они скорее скроют ошибку, чем проявят ее. Вместо этого постарайтесь сделать ее устойчивой, изменяя вводимые данные, начальные условия и координацию действий.

Если ошибка все еще непостоянна, вам придется сделать так, чтобы она выглядела постоянной. При каждом запуске фиксируйте в журнале каждый бит информации, какой только сможете; затем, когда есть успешные запуски и сбои, сравните их друг с другом. Если вы собрали достаточно данных, вы сможете нацелиться на проблему, как если бы смогли вызывать ошибку все время. Способность вызывать каждый раз ошибку означает также, что вы сможете сказать, когда вы ее исправили.

3. Прекратите думать и смотрите. Имеется больше способов появления ошибок, чем вы можете себе представить. Поэтому не представляйте, что могло бы случиться, смотрите на это — оснастите систему инструментарием, чтобы вы действительно смогли увидеть механизм ошибки. Используйте любой инструментарий, который можете — отладчики, 


, 


, анализаторы логики и даже светодиоды и звуковые сигнализаторы. Проверяйте достаточно глубоко, пока ошибка не станет очевидной для глаз, а не только для мозга.

Если вы все же догадались, используйте догадку, чтобы сфокусировать поиск — не старайтесь исправить, пока вы ее не увидите. Если вам приходится добавлять код инструментария, сделайте это, но убедитесь, что начинаете с той же самой базы кода, как на проблемной системе, и убедитесь, что ошибка все еще возникает при работе вашего добавленного кода. Часто добавление отладчика вызывает исчезновение ошибки (вот почему его называют отладчиком).

4. Разделяй и властвуй. Каждый это знает. Вы делаете последовательное приближение — начинаете с одного конца, перескакиваете полпути, смотрите, с какой стороны ошибка, затем перескакиваете оставшиеся полпути в направлении ошибки. Бинарный поиск, вы оказываетесь так за несколько прыжков. Трудной частью является определение того, прошли вы ошибку или нет. Одной из полезных уловок является помещение в систему известных, простых данных, так чтобы можно было легче узнать мусор. Начните также с плохого конца и работайте по направлению к хорошему: если вы начнете с хорошего конца, имеется слишком много хороших путей для исследования. Известные ошибки исправляйте сразу, поскольку иногда две ошибки взаимодействуют (хотя вы могли бы поклясться, что они не должны этого делать), и последовательное приближение не работает с двумя целевыми значениями.

5. Каждый раз изменяйте лишь что-то одно. Если вы стараетесь усовершенствовать модуль обработки потоков и одновременно переходите на следующую версию операционной системы, не имеет значения, видите ли вы улучшение, ухудшение или отсутствие изменений — у вас не будет мыслей по поводу того, каким был результат ваших отдельных изменений. Взаимодействие нескольких изменений может быть непредсказуемым и сбивающим с толку. Не делайте этого. Изменяйте за один раз только что-то одно, чтобы вы могли поручиться, что любое отличие, которые вы видите, возникло из-за этого изменения.

Если вы делаете изменение, а результата не видно, немедленно вернитесь обратно. Возможно, оно имело результат, который вы не увидели, и он может проявиться в сочетании с другими изменениями. Это относится к изменениям как в тестировании, так и в кодировании.

6. Сохраняйте контрольные журналы. Многое в эффективности приведенных выше правил зависит от сохранения хороших записей. Во всех отношениях тестирования и отладки записывайте, что вы делали, когда вы это делали, как вы это делали и что случилось в результате. По возможности делайте это в электронном виде, чтобы записи можно было послать по электронной почте и прикрепить к базе данных ошибок. Многие ключи можно найти в паттернах событий, которые были бы не замечены, если бы все они не записывались для просмотра и сравнения. Ключ может находиться также в деталях, о которых вы думали, что они неважны, поэтому запишите их все.

7. Проверьте подключение. У каждого есть история о какой-нибудь проблеме, оказавшейся в том, что «это не было подключено». Иногда что-то оказывается буквально не подключенным, но для программного обеспечения «не подключено» может означать отсутствующий драйвер или старую версию кода, о которой вы думали, что заменили ее. Или плохое оборудование, когда вы клянетесь, что это проблема программного обеспечения. В одной истории инженеры-программисты и электронщики показывали пальцами друг на друга, и никто не был прав: тестирующее устройство, которое они использовали, не соответствовало спецификации. Основной момент в том, что иногда вы ищете проблему внутри системы, тогда как на самом деле она вне системы, или лежит в основе системы, или в инициализации системы, или вы смотрите не на ту систему.

Не следует также непременно доверять своим инструментам. Производители инструментов также являются инженерами; у них есть ошибки, и вы можете оказаться тем, кто их обнаружит.

8. Оцените свежим взглядом. Есть три причины попросить помощи при отладке.

Первая причина в получении свежего взгляда — другие люди часто видят что-то лишь потому, что они не вовлечены в это так, как вы. Вторая причина заключается в получении экспертной оценки — они знают о системе больше, чем вы. Третья причина заключается в получении опыта — они видели это раньше.

Когда вы описываете ситуацию кому-либо, сообщите о симптомах, которые вы видели, а не о своих предположениях, почему это происходит так. Вы пришли к ним, потому что ваши предположения не ведут вас никуда — не тяните их в ту же колею, в которую попали сами.

9. Если вы не исправили это, это не исправлено. Так вы думаете, это исправлено? Испытайте. Раз вы могли заставить ошибку повторяться постоянно, создайте ту же самую ситуацию и убедитесь, что ошибки нет. Не думайте, что все исправлено лишь потому, что проблема была очевидной. Может, она не была такой очевидной. Может, ваше исправление не было сделано правильно. Может, ваше исправление даже не находится в новом выпуске! Проверьте! Заставьте ошибку исчезнуть.

Вы уверены, что именно ваш код исправил проблему? Или это произошло из-за изменения теста, или туда был внесен какой-то другой код? Когда вы видите, что ваше исправление работает, уберите его и заставьте ошибку появиться снова. Затем верните исправление на место и убедитесь, что ошибки нет. Этот шаг гарантирует, что именно ваше исправление решило проблему.

Дополнительные сведения о книге Debugging и плакат с правилами отладки можно найти для свободной загрузки по адресу 


.




15.8. Рекомендуемая литература


Следующие книги отличные, с множеством сведений как в отношении тестирования, так и отладки. Все, кроме первой, относятся к программированию вообще. Их все стоит прочесть.

1. Debugging, David J. Agans. AMACOM, New York, New York. USA 2003. ISBN: 0-8144-7168-4.

Настоятельно рекомендуем эту книгу. У нее легкий стиль, удивительное звучание, чтение — одно удовольствие!

2. Programming Pearls, 2nd edition, by Jon Louis Bentley. Addison-Wesley, Reading, Massachusetts, USA, 2000, ISBN: 0-201-63788-0. См. также веб-сайт этой книги.[189 - 


 — Примеч. автора.]

В главе 5 этой книги приведено хорошее обсуждение тестирования элементов и построения тестовой среды.

3. Literate Programming, by Donald E. Knuth. Center for the Study of Language and Information (CSLI), Stanford University, USA, 1992. ISBN: 0-9370-7380-6.

Эта восхитительная книга содержит ряд статей Дональда Кнута по грамотному программированию (literate programming) — методике программирования, которую он изобрел и использовал для создания ТеХ и Metafont. Особый интерес представляет статья, озаглавленная «Ошибки ТеХ», которая описывает, как он разрабатывал и отлаживал ТеХ, включая его журнал всех найденных и исправленных ошибок.

4. Writing Solid Code, by Steve Maguire. Microsoft Press, Redmond, Washington, USA, 1993. ISBN 1-55615-551-4.

5. Code Complete: A Practical Handbook of Software Construction, by Steve McConnell Microsoft Press, Redmond, Washington, USA, 1994. ISBN: 1-55615-484-4.

6. The Practice of Programming, by Brian W. Kernighan and Rob Pike. Addison-Wesley, Reading. Massachusetts, USA, 1999. ISBN: 0-201-61585-X.




15.9. Резюме


• Отладка является важной частью разработки программного обеспечения. Для минимизации ошибок должны использоваться хорошие проектирование и практика разработки, но отладка всегда будет с нами.

• Программы должны компилироваться без оптимизации и с включенными идентификаторами отладки, чтобы упростить отладку под отладчиком. На многих системах компиляция с оптимизацией и компиляция с идентификаторами отладки несовместимы. Это не относится к GCC, вот почему разработчикам GNU/Linux нужно знать об этой проблеме.

• Отладчик GNU GDB является стандартом на системах GNU/Linux и может использоваться также почти на любой коммерческой системе Unix. (Также доступны и легко переносимы графические отладчики на основе GDB.) Контрольные точки, отслеживаемые точки и пошаговое исполнение с посредством 


, 


 и 


 предоставляют базовый контроль над программой при ее работе. GDB позволяет также проверять данные и вызывать функции внутри отлаживаемой программы.

 • Имеется множество вещей, которые вы можете сделать при написании программы для ее упрощения, когда неизбежно придется ее отлаживать. Мы рассмотрели следующие темы:

 • Отладочные макросы для вывода состояния.

 • Избегание макросов с выражениями.

 • Перестановку кода для облегчения пошагового выполнения.

 • Написание вспомогательных функций для использования их из отладчика.

 • Избегание объединений.

 • Помещение отладочного кода времени исполнения в готовую версию программы и обеспечение различных способов включения вывода этого кода.

 • Добавление фиктивных функций для упрощения установки контрольных точек.

• Для помощи при отладке помимо простых отладчиков общего назначения существует ряд инструментов и библиотек. Библиотека 


 предоставляет элегантный внутренний отладчик, который использует многие из описанных нами методик последовательным, связанным образом.

• Существует множество отладочных библиотек для динамической памяти, имеющие сходные свойства. Мы рассмотрели три из них (


, Electric Fence и 


) и предоставили ссылки на несколько других. Программа Valgrind идет еще дальше, обнаруживая проблемы, относящиеся к неинициализированной памяти, а не только к динамической памяти.

• 


 является современной альтернативой многоуважаемой программе V7 


. Она доступна по крайней мере на системе одного из поставщиков GNU/Linux и легко может быть загружена и построена из исходных кодов.

• Помимо инструментов отладки, неотъемлемой частью процесса разработки программного обеспечения является также тестирование программ. Ее следует понять, запланировать и управлять ею с самого начала любого проекта разработки программного обеспечения, даже индивидуального.

• Отладка является умением, которому можно научиться. Мы рекомендуем прочесть книгу Debugging Дэвида Дж. Эганса и научиться применять его правила.




Упражнения


1. Откомпилируйте одну из ваших программ с помощью GCC, используя как 


, так и 


. Запустите ее под GDB, установив контрольную точку в 


. Выполните программу пошагово и посмотрите, насколько близко соответствует (или не соответствует) исполнение оригинальному исходному коду. Это особенно хорошо делать с кодом, использующим циклы 


 или 


.

2. Прочитайте об особенности GDB условной контрольной точки. Насколько это упрощает работу с проблемами, которые появляются лишь после того, как будет сделано определенное число операций?

3. Перепишите функцию 


 из раздела 15.4.2.1 «Добавляйте отладочные опции и переменные», чтобы использовать таблицу строк опций отладки, значений флагов и длин строк

4. (Трудное.) Изучите исходный код 


; в частности, структуру 


 в 


. Напишите вспомогательную отладочную функцию, которая выводит содержимое 


, основываясь на значении в поле 


.

5. Возьмите одну из своих программ и измените ее так, чтобы использовать библиотеку 


. Откомпилируйте ее сначала без 


, чтобы убедиться, что она компилируется и работает нормально. (Есть ли у вас для нее набор возвратных тестов? Прошла ли ваша программа все тесты?)

Убедившись, что добавление библиотеки 


 не нарушает работу вашей программы, перекомпилируйте ее с 


. По-прежнему ли проходит ваша программа все свои тесты? Какова разница в производительности при включенной и отключенной библиотеке? Запустите ваш тестовый набор с опцией 


, чтобы увидеть трассировку вызовов функций. Как вы думаете, это поможет вам в будущем, когда придется иметь дело с отладкой? Почему да или почему нет?

6. Запустите одну из своих программ, использующих динамическую память, с Electric Fence или одним из других тестеров динамической памяти. Опишите проблемы, которые вы обнаружили, если они есть.

7. Перезапустите ту же самую программу, используя Valgrind с включенным режимом проверки утечек. Опишите найденные вами проблемы, если они есть.

8. Разработайте набор тестов для программы 


. (Прочтите mv(1): убедитесь, что охватили все ее опции.)

9. Поищите в Интернете ресурсы по тестированию программного обеспечения. Какие интересные вещи вы нашли?




Глава 16

Проект, связывающий все воедино



В первой половине этой книги мы довольно аккуратно связали все, что было представлено, рассмотрев V7 


. Однако, нет достаточно небольшой программы, насколько бы это нам хотелось, чтобы связать воедино все концепции и API, представленные начиная с главы 8 «Файловые системы и обходы каталогов».




16.1. Описание проекта


В повседневном использовании единственной программой, которая действительно использует почти все в этой книге, является оболочка. И на самом деле есть книги по программированию на Unix, в которых пишется небольшая, но работающая оболочка для иллюстрации использованных принципов.

Настоящие оболочки являются большими и беспорядочными творениями. Они должны иметь дело со многими проблемами переносимости, такими, которые мы обрисовывали по всей книге, а помимо этого, они часто должны обходить различные ошибки в различных версиях Unix Более того, чтобы быть полезными, оболочки делают множество вещей, которые не затрагивают API системных вызовов, такие, как хранение переменных оболочки, историю сохраненных команд и т.д. Предоставление завершенного обзора полноценной оболочки, такой как Bash, 


 или 


, потребовало бы отдельной книги.

Вместо этого мы рекомендуем следующий список шагов по написанию своей собственной оболочки либо в качестве (большого) упражнения для закрепления вашего понимания, либо, возможно, в качестве совместного проекта, если вы обучаетесь в учебном заведении.

1. Спроектируйте свой командный «язык», чтобы его было легко интерпретировать с помощью простого кода. Хотя технология компиляторов и интерпретаторов полезна при написании оболочки как изделия, для вас на данный момент это, вероятно, излишне.

Рассмотрите следующие моменты:

 • Собираетесь ли вы использовать возможности интернационализации?

 • Какие команды должны быть встроены в оболочку?

 • Чтобы быть полезной, в вашей оболочке должен быть механизм пути поиска команд, аналогичный 


 в обычной оболочке. Как вы его установите?

 • Какие перенаправления ввода/вывода вы хотите поддержать? Только файлы? Также и каналы? Хотите ли вы иметь возможность перенаправлять нет только дескрипторы файлов 0, 1 и 2?

 • Решите, как будут работать кавычки: одинарные и двойные? Или лишь одна разновидность? Как вы поместите в кавычки сами кавычки? Как кавычки будут взаимодействовать с перенаправлениями ввода/вывода?

 • Как вы обработаете вызов команд в фоновом режиме? Что насчет ожидания завершения работы команды в фоновом режиме?

 • Решите, будут ли у вас переменные оболочки.

 • Какую разновидность символов подстановки или других расширений будете вы поддерживать? Как это взаимодействует с кавычками? С переменными оболочки?

 • Вы должны запланировать по крайней мере операторы 


 и 


. Спроектируйте синтаксис. Мы будем называть их блочными операторами.

 • Решите, хотите ли вы разрешить перенаправления ввода/вывода для блочных операторов. Если да, как будет выглядеть синтаксис?

 • Решите, как язык вашей оболочки должен обрабатывать сигналы, если он вообще это делает.

 • Разработайте шаблон тестирования и отладки до того, как вы начнете программировать.

2. Если вы собираетесь использовать возможности интернационализации, делайте это с самого начала. Последующая ее вставка тяжела.

3. Для настоящей работы начните просто. Начальная версия должна читать одну строку за раз и разделять ее на слова для использования в качестве отдельных аргументов. Не используйте кавычек, перенаправления ввода-вывода или что-нибудь еще. Не старайтесь даже создать новый процесс для запуска введенной программы. Как вы собираетесь тестировать то, что у вас пока есть?

4. Добавьте кавычки так, чтобы отдельные «слова» могли содержать разделители. Реализует ли код для кавычек ваш проект?

5. Заставьте работать ваши встроенные команды. (По крайней мере две нужные встроенные команды см. в разделах 4.6 «Создание файлов» и 8.4.1 «Смена каталога: 


 и 


».) Как вы собираетесь их тестировать?

6. Первоначально используйте фиксированный путь поиска, такой как "


". Добавьте создание процесса при помощи 


 и его исполнение при помощи 


. (См. главу 9 «Управление процессами и каналы».) Запустив новую программу, оболочка должна ждать ее завершения.

7. Добавьте фоновое исполнение и, в качестве отдельной команды, ожидание завершения выполнения процесса (см. главу 9 «Управление процессами и каналы»).

8. Добавьте устанавливаемый пользователем путь поиска (см. раздел 2.4 «Переменные окружения»).

9. Добавьте перенаправление ввода/вывода для файлов (см. раздел 9.4 «Управление дескрипторами файлов»).

10. Добавьте переменные оболочки. Протестируйте их взаимодействие с кавычками.

11. Добавьте символы подстановки и другие расширения (см. раздел 12.7 «Расширения метасимволов»). Протестируйте их взаимодействие с переменными оболочки. Протестируйте их взаимодействие с кавычками.

12. Добавьте конвейеры (см. раздел 9.3 «Базовое межпроцессное взаимодействие: каналы и очереди FIFO»). С этого момента начинаются настоящие сложности. Вам может потребоваться тщательно рассмотреть то, как вы управляете данными, представляющими запускаемые команды.

Здесь можно было бы остановиться с законным чувством достижения, если вы получили работающую оболочку, которая может делать все, упомянутое до сих пор.

13. Если вы принимаете дальнейший вызов, добавьте операторы 


 и/или 


.

14. Добавьте обработку сигналов (см. главу 10 «Сигналы»).

15. Если вы хотели бы использовать свою оболочку для настоящей работы, изучите библиотеку GNU Readline (наберите в системе GNU/Linux '


' или посмотрите исходный код для оболочки Bash). Эта библиотека дает вам возможность добавлять к интерактивным программам возможность редактирования командной строки в стиле Emacs или 


.

Постоянно держите в уме две вещи- всегда имейте возможность протестировать то, что вы делаете; и «никаких произвольных ограничений»!

Когда все это сделано, проделайте анализ сделанного проекта. Как вы сделали бы его по-другому во второй раз? Удачи!




16.2. Рекомендуемая литература


1. The UNIX Programming Environment, by Brian W. Kernighan and Rob Pike. Prentice-Hall, Englewood Cliffs, New Jersey, USA, 1984. ISBN: 0-13-937699-2.[190 - Русский перевод Брайан Керниган, Роб Пайк. UNIX: Программное окружение. Санкт-Петербург. Символ-Плюс, 2003 — Примеч. науч. ред.]

Эта классическая книга по программированию на Unix, описывающая целостную структуру окружения Unix, от интерактивного использования до программирования оболочки, программирования с помощью функций 


 и низкоуровневых системных вызовов, разработки программ с помощью 


, 


 и 


, и документирования с помощью 


 и 


.

Хотя возраст книги приличный, ее в высшей степени стоит прочесть, и мы ее чрезвычайно рекомендуем.

2. The Art of UNIX Programming, by Eric S. Raymond. Addison-Wesley, Reading, Massachusetts, USA, 2004. ISBN: 0-13-142901-9.

Это книга на более высоком уровне фокусируется на проблемах проектирования при программировании в Unix: как работают программы Unix и как разрабатывать свои собственные программы, чтобы уютно вписаться в окружение Linux/Unix. Хотя мы не всегда согласны со многим из того, что хочет сказать автор, книга действительно содержит значительное количество важного материала, и ее стоит прочесть.




Часть 4

Приложения





Приложение А

Научитесь программированию за десять лет


«Опыт, сущ.: Нечто, что вы не получаете до тех пор, пока это вам не понадобится».

    - Оливер -


Данная глава написана Петером Норвигом (Peter Norvig, © 2001 г.). Воспроизводится по разрешению. Оригинальную статью, включая гиперссылки, можно найти по адресу 


. Мы включили ее, поскольку полагаем, что она содержит важную идею. Приведенная цитата является одной из наших давних любимых, и поскольку она применима к сути нашего приложения, мы ее также включили.




Почему каждый в такой спешке?


Зайдите в любой книжный магазин, и вы увидите «Научитесь Java за 7 дней» наряду с бесконечными вариациями, предлагающими научиться Visual Basic, Windows, Internet и т.д. за несколько дней или часов. Я произвел следующий расширенный поиск на 


:











и получил 248 попаданий. Первые 78 были компьютерными книгами (номер 79 был «Изучите Бенгали за 30 дней»). Я заменил «дни» ('days') на «часы» ('hours') и получил замечательным образом сходные результаты: еще 253 книг, из них 77 компьютерных, за которыми следовала под номером 78 «Научитесь грамматике и стилистике за 24 часа». Всего из верхних 200 книг 96% были компьютерные.

Вывод таков, что либо люди очень торопятся изучить компьютеры, либо эти компьютеры каким-то образом фантастически легче изучить, чем что-то еще. Книг о том, как изучить Бетховена, или квантовую физику, или даже научиться ухаживать за собакой за несколько дней, нет.

Давайте проанализируем, что может означать название наподобие «Изучите Паскаль за три дня»:

• Изучите: за 3 дня у вас не будет времени написать несколько значительных программ и научиться из них на своих успехах и неудачах. У вас не будет времени поработать с опытным программистом и понять, на что похожа жизнь в этом окружении. Короче, у вас не будет времени научиться многому. Поэтому можно говорить лишь о поверхностном знакомстве, а не глубоком понимании. Как сказал римский папа Александр, неглубокое знание является опасной вещью.

• Паскаль: за 3 дня вы смогли бы изучить синтаксис Паскаля (если вы уже знаете сходный язык), но не смогли бы много узнать о том, как использовать этот синтаксис. Короче, если бы вы были программистом на Бейсике, вы смогли бы писать программы в стиле Бейсика на Паскале, но не смогли бы изучить, для чего Паскаль в действительности подходит (или не подходит). В чем же суть? Алан Перлис (Alan Perlis) сказал однажды: «Язык, который не влияет на способ вашего мышления о программировании, не стоит того, чтобы его знали». Другими словами, вам приходится изучить крошечный кусок Паскаля (или, более вероятно, чего-то наподобие Visual Basic или JavaScript), поскольку вам нужно взаимодействовать с существующим инструментом для выполнения определенной задачи. Но тогда вы не обучаетесь программированию; вы учитесь выполнять эту задачу.

• За три дня: к сожалению, этого недостаточно, как показывает следующий раздел.




Научитесь программированию за десять лет


Ученые (Hayes, Bloom) показали, что развитие высокой квалификации в любой из широкого разнообразия областей, включая шахматы, сочинение музыки, рисование, игра на фортепьяно, плавание, теннис, исследования в нейропсихологии и топологии, занимают около десяти лет. По-видимому, в действительности не может быть сокращения: даже Моцарту, который был музыкально одаренным уже в 4 года, потребовалось еще 13 лет, прежде чем он начал создавать мировую классическую музыку. В другом жанре Битлз, казалось, вырвались на сцену, появившись в шоу Эда Салливана в 1964 г. Но они играли с 1957 года, и хотя они рано завоевали широкую популярность, их первый переломный успех, Сержант Пепперс, был выпущен в 1967 г. Сэмюэл Джонсон (Samuel Johnson) считал, что требуется более десяти лет: «Мастерство в любой отрасли достигается лишь работой в течение жизни; его нельзя купить по меньшей цене». А Чосер (Chaucer) жаловался: «Жизнь так коротка, а ремеслу так долго учиться».

Вот мой рецепт для успеха в программировании:

• Заинтересуйтесь программированием и сделайте что-нибудь, потому что это забавно. Убедитесь, что оно продолжает оставаться достаточно интересным, чтобы вы хотели прилагать усилия в течение десяти лет.

• Говорите с другими программистами; читайте другие программы. Это важнее, чем любая книга или учебный курс.

• Программируйте. Лучшей разновидностью обучения является обучение деланием. Говоря более технически, «максимальный уровень производительности индивидуума в данной области не достигается автоматически как функция расширения опыта, но его могут повысить даже очень опытные индивидуумы в результате обдуманных усилий по совершенствованию» и «наиболее эффективное обучение требует хорошо определенной задачи с соответствующим уровнем трудности для данного конкретного индивидуума, информационной обратной связи и возможностей повторения и исправления ошибок». Книга Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life (Практическое познание мышление, математика и совершенствование способностей в повседневной жизни) является интересным справочным пособием для этой точки зрения.

• Если хотите, проведите четыре года в колледже (или еще больше в аспирантуре). Это даст вам доступ к некоторым видам работ, требующим диплома, и это даст более глубокое понимание области, но если вам не нравится школа, вы можете (с некоторым упорством) получить аналогичный опыт на работе В любом случае, одного лишь изучения книг недостаточно. «Образование в компьютерных науках может сделать кого-нибудь искусным программистом не в большей степени, чем изучение кистей и красок может сделать кого-то искусным художником», — говорит Эрик Реймонд (Eric Raymond), автор The New Hacker's Dictionary (Словаря новых хакеров). Один из лучших программистов, которых я когда-либо принимал на работу, имел лишь среднее образование, он создал массу превосходных программ, у него есть своя группа новостей и через фондовые опционы, без сомнения, намного богаче, чем буду я когда-либо.

• Работайте над проектами с другими программистами. Будьте лучшим программистом в некоторых проектах; будьте худшим в некоторых других. Когда вы лучший, вы принимаетесь проверять свои способности возглавлять проект и вдохновлять других своим видением. Когда вы худший, вы изучаете то, что делают мастера, и вы изучаете, что они не любят делать (поскольку они заставляют делать это за себя вас).

• Работайте над проектами после других программистов. Погрузитесь в понимание программы, написанной кем-то еще. Посмотрите, чего стоит понять и исправить ее, когда рядом нет авторов программы. Подумайте над тем, как спроектировать свои программы, чтобы сделать их проще для тех, кто будет их сопровождать после вас.

• Изучите по крайней мере полдюжины языков программирования. Включите один язык, поддерживающий абстракции классов (подобно Java или С++), один, поддерживающий функциональные абстракции (подобно Lisp или ML), один, поддерживающий синтаксические абстракции (подобно Lisp), один, поддерживающий декларативные спецификации (подобно Prolog или шаблонам C++), один, поддерживающий сопрограммы (подобно Icon или Scheme), и одни, поддерживающий параллелизм (подобно Sisal).

• Помните, что в «компьютерных науках» есть «компьютер». Знайте, сколько времени ваш компьютер тратит на исполнение инструкции, получение слова из памяти (с попаданием в кэш и без попадания), чтение последовательных слов с диска и поиск нового положения на диске (Ответы ниже.)

• Погрузитесь в работу по стандартизации языка. Это может быть комитет ANSI С++, или это может быть принятием решения, должен ли ваш местный стиль программирования использовать 2 или 4 пробела в отступах. В любом случае, вы узнаете, что любят в языке другие люди, насколько глубоко они это чувствуют и, возможно, даже немного о том, почему они это чувствуют.

• Имейте здравый смысл, чтобы отделаться от работы по стандартизации языка как можно скорее.

Держа все это в уме, сомнительно, насколько далеко вы сможете уйти, обучаясь лишь по книгам. До рождения моего первого ребенка я прочел все книги How To (Как…), и до сих пор чувствую себя необразованным новичком. 30 месяцев спустя, когда ожидался мой второй ребенок, вернулся ли я к книгам, чтобы освежить их в памяти? Нет. Вместо этого я полагался на свой собственный опыт, который оказался для меня намного более полезным и обнадеживающим, чем тысячи страниц, написанных экспертами.

Фред Брукс (Fred Brooks) в своем эссе Никаких серебряных пуль (No Silver Bullets) определил план из трех частей для обнаружения великих проектировщиков программного обеспечения:

1. Систематически как можно раньше распознавать ведущих проектировщиков.

2. Назначить наставников по достижениям, ответственных за разработку перспективы и тщательно хранить архивы достижений.

3. Предоставлять растущим проектировщикам возможности для взаимодействия и стимулирования ими друг друга.

Это предполагает, что у некоторых людей уже есть качества, необходимые, чтобы стать великими проектировщиками; задача заключается в том, чтобы соответствующим образом их выманить. Алан Перлис (Alan Perlis) выразился более лаконично- «Каждого можно научить ваять: Микеланджело пришлось бы учить, как не делать это. Так же и с великими программистами».

Поэтому вперед, купите эту книгу по Java; возможно, вы получите от нее какую- нибудь пользу. Но вы не измените свою жизнь или свою действительную общую квалификацию как программиста за 24 часа, дня или даже месяцев.




Ссылки


Bloom, Benjamin (ed.) Developing Talent in Young People, Ballantine, 1985.

Brooks, Fred, No Silver Bullets, IEEE Computer, vol. 20, no 4, 1987, p. 10-19.

Hayes, John R., Complete Problem Solver, Lawrence Erlbaum, 1989.

Lave, Jean, Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life, Cambridge University Press, 1988.




Ответы


Время выполнения различных операций на типичном ПК 1 ГГц летом 2001 г.:

исполнение одной инструкции  1 нс = (1/1000 000 000) сек

выборка слова из кэша L1  2 нс

выборка слова из основной памяти  10 нс

выборка смежного слова с диска  200 нс

выборка слова из нового места на диске (поиск) 8 000 000 нс = 8 мс




Сноски


Эта страница[191 - Это приложение приведено в буквальном виде с веб-страницы, указанной вначале — Примеч. автора.] доступна также в переводе на японский язык[192 - 


 — Примеч. автора.] благодаря Yasushi Murakawa и в переводе на испанский язык[193 - 


 — Примеч. автора.] благодаря Carlos Rueda.

T. Capey указывает, что страница Complete Problem Solver на Amazon теперь содержит книги Teach Yourself Bengali in 21 days и Teach Yourself Grammar and Style под рубрикой «Клиенты, которые купили эту книгу, купили также и эти книги». Я догадываюсь, что большая часть людей, посмотревших на ту книгу, пришли с этой страницы.




Приложение В

Лицензия Caldera для старой Unix[194 - Это — неофициальный перевод Лицензии Caldera для старой Unix на русский язык. Он не был опубликован Caldera International, Inc и не может легально определять условия распространения программных продуктов, использующих Лицензию Caldera — только оригинальный английский текст Лицензии Caldera для старой Unix имеет законную силу.]


CALDERA

240 West Center Street

Orem, Utah 84057

801-765-4999 Fax 801-765-4481

23 января 2002 г.

Дорогие энтузиасты UNIX®,

Caldera International, Inc. настоящим предоставляет безвозмездную лицензию, которая включает права на использование, модификацию и распространение этого названного исходного кода, включая создание производных двоичных изделий из исходного кода. Исходный код, для которого Caldera International, Inc. передает права, ограничены следующими операционными системами UNIX, которые работают на 16-разрядном процессоре PDP-11 и ранних версиях 32-разрядной операционной системы UNIX, со специальным исключением UNIX System III и UNIX System V и операционных систем-наследников:

32-разрядной 32V UNIX,

16-разрядной UNIX версий 1, 2, 3, 4, 5, 6, 7.

Caldera International, Inc. не дает никаких гарантий или поручительств, что какой-нибудь исходный код доступен от Caldera International, Inc.

Следующее уведомление об авторских правах применяется к файлам исходного кода, для которых предоставляется данная лицензия.

Copyright © Caldera International Inc. 2001–2002. Все права сохранены. Разрешается распространение и использование в исходной и двоичной форме, с модификациями или без них, при соблюдении следующих условий:

При распространении исходного кода и документации должно быть сохранено вышеприведенное уведомление об авторских правах, данный список условий и следующий отказ от ответственности. При распространении в двоичном виде вышеприведенное уведомление об авторских правах, данный список условий и следующий отказ от ответственности должны быть воспроизведены в документации и/или в других материалах, предоставляемых при распространении.

Все рекламные материалы, упоминающие особенности или использование данного программного обеспечения, должны отображать следующее признание:

Этот продукт включает программное обеспечение, разработанное или принадлежащее Caldera International, Inc.

Ни название Caldera International, Inc., ни названия других внесших вклад участников не могут использоваться для поддержки или продвижения продуктов, производных отданного программного обеспечения, без особого предварительного письменного разрешения.

ИСПОЛЬЗОВАНИЕ ЭТОГО ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ ПРЕДУСМОТРЕНО ПО ЛИЦЕНЗИИ CALDERA INTERNATIONAL, INC. И ДРУГИХ ВНЕСШИХ ВКЛАД УЧАСТНИКОВ «КАК ЕСТЬ» И БЕЗ ВСЯКИХ ЯВНЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ ГАРАНТИЙ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ НЕЯВНЫМИ ГАРАНТИЯМИ ПРИГОДНОСТИ ДЛЯ ПРОДАЖИ ИЛИ ПРИМЕНИМОСТИ ДЛЯ ОПРЕДЕЛЕННЫХ ЦЕЛЕЙ. НИ В КОЕМ СЛУЧАЕ CALDERA INTERNATIONAL, INC. НЕ НЕСЕТ ОТВЕТСТВЕННОСТИ ЗА ЛЮБОЙ ПРЯМОЙ, КОСВЕННЫЙ, СЛУЧАЙНЫЙ, СПЕЦИАЛЬНЫЙ, ШТРАФНОЙ ИЛИ ЯВЛЯЮЩИЙСЯ СЛЕДСТВИЕМ УЩЕРБ (ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ ПРИОБРЕТЕНИЕМ ИЛИ ЗАМЕНОЙ ТОВАРОВ; ПОТЕРЮ ЦЕННОСТИ, ДАННЫХ, УПУЩЕННУЮ ВЫГОДУ ИЛИ ПРИОСТАНОВКУ БИЗНЕСА), КАК БЫ ОН НИ БЫЛ ВЫЗВАН И В СООТВЕТСТВИИ С КАКИМИ БЫ ТО НИ БЫЛО ПРЕДПОЛОЖЕНИЯМИ, БУДЬ ТО В КОНТРАКТЕ, НЕПОСРЕДСТВЕННОЙ ОТВЕТСТВЕННОСТИ ИЛИ ГРАЖДАНСКОМ ПРАВОНАРУШЕНИИ (ВКЛЮЧАЯ НЕБРЕЖНОСТЬ ИЛИ ДРУГОЕ), ВОЗНИКШИЕ ЛЮБЫМ СПОСОБОМ ВСЛЕДСТВИЕ ИСПОЛЬЗОВАНИЯ ДАННОГО ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ, ДАЖЕ В СЛУЧАЕ ПРЕДУПРЕЖДЕНИЯ О ВОЗМОЖНОСТИ ТАКОГО УЩЕРБА.



    Искренне ваш,
    (подпись) Bill Broderick
    Bill Broderick
    Директор, Служба лицензирования
    UNIX является зарегистрированной торговой маркой Open Group в США и других странах.




Приложение С

Общедоступная лицензия GNU[195 - Это — неофициальный перевал Общедоступной лицензии GNU на русский язык. Он не был опубликован Фондом Свободного Программного Обеспечения и не может легально определять условия распространения программных продуктов, использующих Общедоступную лицензию GNU — только оригинальный английский текст Общедоступной лицензии GNU имеет законную силу.]



Версия 2, июнь 1991 г.

Copyright © 1989, 1991 Free Software Foundation, Inc.

59 Temple Place, Suite 330, Boston, MA 02111, USA

Разрешается копировать и распространять дословные копии данного лицензионного документа, но не разрешается его изменять.


Преамбула

Лицензии большинства программных продуктов составлены так, чтобы отобрать у вас право совместно использовать и изменять продукт. По контрасту, Общедоступная лицензия GNU (GNU General Public License), напротив, подразумевает вашу свободу в совместном использовании и изменении свободного программного обеспечения — чтобы гарантировать, что программное обеспечение является свободным для всех своих пользователей. Данная Общедоступная лицензия применяется к большей части программного обеспечения Фонда независимых программ (Free Software Foundation) и к любой другой программе, авторы которой передают ее на использование с данной лицензией. (Некоторое другое программное обеспечение Фонду независимых программ защищается вместо этого Общедоступной библиотечной лицензией GNU (GNU Library General Public License).) Вы также можете использовать ее для своих программ.

Когда мы говорим о независимом программном обеспечении, мы имеем в виду свободу, а не цену. Наши Общедоступные лицензии разработаны так, чтобы гарантировать вам свободу распространять копии независимого программного обеспечения (и назначать за это цену, если хотите), получать исходный код, если хотите, изменять программное обеспечение или его части в новых независимых программах; а также гарантировать, что вы будете знать обо всех этих вещах.

Чтобы защитить ваши права, нам необходимо предусмотреть ограничения, которые запрещают кому бы то ни было отказывать вам в этих правах или просить вас от них отказаться. Эти ограничения преобразуются а определенные ваши обязанности, если вы распространяете копии программного обеспечения или модифицируете его.

Например, если вы распространяете копии таких программ, вне зависимости от того, бесплатно или за плату, вы обязаны дать получателям все права, которые есть у вас. Вы должны также обеспечить для них получение или возможность получения исходного кода. И вы должны довести до их сведения эти положения, чтобы они знали о своих правах.

Мы защищаем ваши права а два этапа: (1) обеспечивая авторское право на программное обеспечение и (2) предоставляя вам эту лицензию, которая дает вам законное разрешение копировать, распространять и/или модифицировать программное обеспечение.

Также, для защиты каждого автора и нашей собственной, мы хотим удостовериться в том, что каждый понимает, что на это независимое программное обеспечение нет гарантий. Если программное обеспечение модифицируется кем-либо еще и распространяется дальше, мы хотим, чтобы его получатели знали, что то, что они получают, не является оригиналом, поэтому любые проблемы, привнесенные другими, не должны отражаться на репутации автора оригинального продукта.

Наконец, любая независимая программа постоянно подвергается угрозе со стороны патентов на программное обеспечение. Мы хотим избежать опасности, когда распространители независимой программы получают отдельные патентные права, фактически превращая программу в патентованную. Чтобы предотвратить это, мы ясно дали понять, что любой патент должен предусматривать свободное его использование всеми или не регистрироваться вообще.

Далее следуют точные праве и обязанности при копировании, распространении и модификации.


Права и обязанности при копировании, распространении и модификации

0. Данная лицензия распространяется на любую программу или другой продукт, который содержит размещенное владельцем авторских прав уведомление, заявляющее, что этот продукт может распространяться в соответствии с условиями данной Общедоступной лицензии. Используемый далее термин «Программа» относится к любым таким программе или продукту, а «продукт, основанный на Программе» означает либо саму Программу, либо любой производный продукт, защищаемый законом об авторском праве: то есть продукт, содержащий Программу или часть ее, воспроизведенный точно или с модификациями и/или переведенный на другой язык. (В дальнейшем перевод без ограничений включается в термин «модификация».) К каждому обладателю лицензии обращение следует как «вы».

Другая деятельность, отличная от копирования, распространения и модификации, не охватывается данной Лицензией; она выходит за рамки ее действия. Акт запуска Программы на выполнение не ограничивается, а результаты работы Программы попадают под действие Лицензии лишь в том случае, если их содержание составляет продукт на основе Программы (независимо от того, было ли это сделано путем запуска Программы). Правомочность этого положения зависит от того, что делает Программа.

1. Вы можете копировать и распространять дословные копии исходного кода Программы в том виде, как вы его получили, с помощью любого средства при условии, что вы открыто и соответствующим образом опубликуете в каждой копни соответствующее заявление об авторских правах и отказе от гарантий; сохраните без изменений все заявления, ссылающиеся на данную Лицензию и на отсутствие каких-либо гарантий, и предоставите всем остальным получателям Программы вместе с самой Программой копию данной Лицензии.

Вы можете назначить плату за акт физического копирования, вы можете также по своему усмотрению предоставить гарантию на платной основе.

2. Вы вправе модифицировать свою копию или копии Программы или любую их часть, создавая тем самым продукт, основанный на Программе, и копировать и распространять такие модификации или продукты на условиях Параграфа 1, приведенного выше, при условии, что вы будете также следовать всем нижеприведенным требованиям:

 a. Модифицированные файлы должны иметь заметные предупреждения о том, что вы изменили файлы, с указанием даты изменений.

 b. Любой продукт, который вы распространяете или публикуете, который целиком или частично является производным от Программы или любой ее части, должен быть целиком бесплатно лицензирован для всех третьих сторон в соответствии с условиями данной Лицензии.

 c. Если модифицированная программа обычно интерактивно принимает команды при работе, вы должны обеспечить при ее запуске стандартным способом для такого интерактивного использования выведение на печать или отображение на экране сообщения, включающего соответствующее заявление об авторских правах и заявление об отсутствии гарантий (либо, в противном случае, заявляющее о предоставлении гарантии вами) и о том, что пользователи могут далее распространять программу на данных условиях, и сообщающее пользователю, как можно просмотреть копню данной Лицензии. (Исключение: если сама Программа интерактивная, но обычно не выводит подобного сообщения, от вашего продукта, основанного на Программе, не требуется выводить это сообщение).

Эти требования применяются к модифицированному продукту в целом. Если идентифицируемые разделы этого продукта не являются производными от Программы и могут с основанием рассматриваться независимыми и отдельными продуктами сами по себе, тогда данная лицензия и ее условия неприменимы к этим разделам при распространении их в качестве отдельных продуктов. Но когда вы распространяете те же разделы в виде целого, являющегося продуктом, основанным на Программе, распространение этого целого должно соответствовать положениям данной Лицензии, положения которой для обладателей лицензии распространяется на все целое и, таким образом, на каждую отдельную часть независимо от того, кто ее написал.

Таким образом, цель данного раздела состоит не в том, чтобы заявить свои права или оспорить ваши права на продукт, написанный исключительно вами; целью скорее является использование права контролировать распространение производных или совместных продуктов, основанных на Программе.

В дополнение, простое объединение другого продукта, не основанного на Программе, с Программой (или продуктом, основанным на Программе) на одном носителе информации или среде передачи данных не включает другой продукт в сферу применения данной Лицензии.

3. Вы вправе копировать и распространять Программу (или продукт, основанный на ней, в соответствии с Параграфом 2) в виде объектного кода или исполняемой программы, при выполнении условий, оговоренных в Параграфах 1 и 2, обеспечив также соблюдение одного из следующих требований:

 a. Сопроводив ее соответствующим полным исходным кодом в электронной форме, который должен распространяться в соответствии с вышеприведенными условиями Параграфов 1 и 2, на носителях, обычно используемых для обмена программами; или

 b. Сопроводив ее письменным предложением, действительным по крайней мере в течение трех лет, на предоставление любой третьей стороне по цене, не превышающей стоимость затрат на физическое распространение исходного кода, полной копии соответствующего исходного кода в электронном виде для распространения в соответствии с вышеприведенными условиями Параграфов 1 и 2, на носителях, обычно используемых для обмена программами; или

 c. Сопроводив ее сведениями, которые вы получили в качестве предложения распространения соответствующего исходного кода. (Данный вариант допустим лишь для некоммерческого распространения и лишь в том случае, если вы получили программу в виде объектного кода или исполняемого модуля с данным предложением, в соответствии с вышеприведенным Подпунктом b.)

Исходный код для продукта означает предпочтительную форму продукта для внесения изменений. Для продукта исполняемого модуля полный исходный код означает весь исходный код для всех модулей, который в нем содержится, плюс любые связанные с ним файлы определения интерфейсов, плюс сценарии, используемые для управления компиляцией и установки исполняемого файла. Однако, в виде особого исключения, распространяемый исходный код не нуждается во включении чего-либо, что обычно распространяется (либо в виде исходного кода, либо в бинарной форме) с главными компонентами (компилятором, ядром и т.д.) операционной системы, на которой исполняемый модуль запускается, если только этот компонент сам не сопровождает исполняемый модуль.

Если распространение исполняемого или объектного кода осуществляется путем предложения доступа к копированию из определенного места, в таком случае предложение эквивалентного доступа для копирования исходного кода из того же источника рассматривается как распространение исходного кода, даже если третья сторона не принуждается к копированию исходного кода вместе с объектным кодом.

4. Вы не вправе копировать, изменять, выдавать сублицензии или распространять Программу на иных условиях, чем предусмотрено настоящей Лицензией. Любая попытка копировать, изменять, выдавать сублицензии или распространять Программу иным способом является не имеющей юридической силы и ведет к автоматическому прекращению ваших прав, предусмотренных данной Лицензией. Однако стороны, получившие от вас копии или права на условиях данной Лицензии, сохранят свои лицензии до тех пор, пока эти стороны будут полностью соблюдать условия данной Лицензии.

5. От вас не требуется признавать данную Лицензию, поскольку вы не подписывали ее. Однако, ничто иное не дает вам прав на изменение или распространение Программы или производных от нее продуктов. Подобные действия запрещены законом, если вы не признаете данную Лицензию. Следовательно, фактом изменения или распространения Программы (или любого продукта на основе Программы) вы заявляете о своем признании данной Лицензии и всех содержащихся в ней требований и условий по копированию, распространению или изменению Программы или продуктов, основанных на ней.

6. Каждый раз при распространении Программы (или любого продукта, основанного на Программе), получатель автоматически становится обладателем лицензии от оригинального владельца авторских прав на копирование, распространение или изменение Программы в соответствии с данными требованиями и условиями. Вы не вправе налагать дополнительные ограничения на реализации предоставляемых здесь прав получателя. Вы не несете ответственности за обеспечение соблюдения третьей стороной данной Лицензии.

7. Если в результате судебного разбирательства или заявления о нарушении патентных прав, или по любой иной причине (не ограничиваясь вопросами патентов) на вас наложены ограничения (по предписанию суда, по соглашению или иные), которые противоречат условиям настоящей Лицензии, они не освобождают вас от условий данной Лицензии. Если вы не можете распространять Программу таким образом, чтобы одновременно выполнять свои обязательства в соответствии с настоящей Лицензией и с любыми другими относящимися к делу обязательствами, вы, как следствие, вовсе лишаетесь права распространять Программу. Например, если патентная лицензия не допускает безвозмездное распространение Программы всеми теми, кто прямо или косвенно получит от вас копии, единственным способом, с помощью которого вы можете удовлетворить и патентную лицензию, и данную Лицензию, будет полное воздержание от распространения Программы.

Если любая часть данного параграфа считается недействительной или не могущей быть выполненной в каких-либо конкретных обстоятельствах, должна применяться оставшаяся часть параграфа, а параграф в целом должен применяться в других условиях.

Целью данного параграфа не является склонить вас к нарушению каких-либо заявлений о патентных или иных правах собственности или оспорить любые такие заявления; единственная цель данного параграфа заключается в защите целостности системы распространения свободного программного обеспечения, которая реализуется практикой общедоступной лицензии. Многие люди сделали щедрый вклад в широкий спектр программного обеспечения, распространяемого посредством этой системы, в надежде на последовательное применение этой системы; делом автора/дарителя является решение, нужно ли распространять программу через любую другую систему, а обладатель лицензии не может повлиять на этот выбор.

Этот параграф нацелен на прояснение того, что подразумевается выводом оставшейся части настоящей Лицензии.

8. Если распространение и/или использование Программы в определенных странах ограничено либо патентами, либо охраняемыми авторским правом интерфейсами, ординальный владелец авторских прав, помещающий Программу под сферу влияния данной Лицензии, может добавить явные географические ограничения на распространение, исключающие эти страны, таким образом, чтобы распространение было разрешено лишь в не исключенных странах. В таком случае, данная Лицензия включает в себя это ограничение, как если бы оно было написано в тексте самой данной Лицензии.

9. Фонд свободного программного обеспечения время от времени может публиковать пересмотренные и/или новые версии Общедоступной Лицензии. Такие новые версии будут сходны по духу с настоящей версией, но могут отличаться в деталях для учета новых проблем или интересов.

Каждая версия получает отличительный номер версии. Если в Программе указан номер версии данной Лицензии, которая применяется к ней, и «любая последующая версия», вы имеете возможность соблюдать условия либо данной версии, либо любой последующей версии, опубликованной Фондом свободного программного обеспечения. Если в Программе не указан номер версии данной Лицензии, вы вправе выбрать любую версию, когда-либо публиковавшуюся Фондом свободного программного обеспечения.

10. Если вы хотите включить части Программы в другие свободные программы с иными условиями их распространения, напишите автору с просьбой о разрешении. Для программного обеспечения, авторским правом на которое обладает Фонд свободного программного обеспечения, напишите в Фонд свободного программного обеспечения, для этого мы иногда делаем исключения. Наше решение будет определяться двумя целями, сохранение свободного статуса всех производных от нашего свободного программного обеспечения и продвижение совместного и повторного использования программного обеспечения вообще.


Отказ от гарантий

11. ПОСКОЛЬКУ ДАННАЯ ПРОГРАММА ЛИЦЕНЗИРУЕТСЯ БЕСПЛАТНО, ДЛЯ НЕЕ НЕ ПРЕДОСТАВЛЯЕТСЯ НИКАКИХ ГАРАНТИЙ, В ТОЙ СТЕПЕНИ, НАСКОЛЬКО ЭТО ПРИМЕНИМО ПО ЗАКОНУ. ЕСЛИ ПИСЬМЕННО НЕ УКАЗАНО ИНОЕ, ВЛАДЕЛЬЦЫ АВТОРСКОГО ПРАВА И/ИЛИ ДРУГИЕ СТОРОНЫ ПРЕДОСТАВЛЯЮТ ПРОГРАММУ «КАК ЕСТЬ», БЕЗ ГАРАНТИЙ КАКОГО-ЛИБО РОДА, ВЫРАЖЕННЫХ ЯВНО ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЛ, НО НЕ ОГРАНИЧИВАЯСЬ ТОЛЬКО ЭТИМ, ПОДРАЗУМЕВАЕМЫМИ ГАРАНТИЯМИ ПОЛЕЗНОСТИ И ПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННЫХ ЦЕЛЕЙ. ВЕСЬ РИСК, КАСАЮЩИЙСЯ КАЧЕСТВА И ПРОИЗВОДИТЕЛЬНОСТИ ПРОГРАММЫ, ЛОЖИТСЯ НА ВАС. ЕСЛИ ПРОГРАММА ОКАЖЕТСЯ С НЕДОСТАТКАМИ, ВЫ БЕРЕТЕ НА СЕБЯ РАСХОДЫ ПО ВСЕМУ НЕОБХОДИМОМУ ОБСЛУЖИВАНИЮ, ВОССТАНОВЛЕНИЮ ИЛИ ИСПРАВЛЕНИЮ.

12. НИ ПРИ КАКИХ ОБСТОЯТЕЛЬСТВАХ, ЕСЛИ ТОЛЬКО ЭТО НЕ ТРЕБУЕТСЯ ПО СООТВЕТСТВУЮЩЕМУ ЗАКОНУ ИЛИ НЕ ОГОВОРЕНО ПО ПИСЬМЕННОМУ СОГЛАШЕНИЮ, НИ ОДИН ИЗ ВЛАДЕЛЬЦЕВ АВТОРСКИХ ПРАВ ИЛИ ЛЮБАЯ ДРУГАЯ СТОРОНА, КОТОРАЯ МОЖЕТ МОДИФИЦИРОВАТЬ И/ИЛИ РАСПРОСТРАНИТЬ ПРОГРАММУ НА ОГОВОРЕННЫХ ВЫШЕ УСЛОВИЯХ, НЕ БУДЕТ ОТВЕЧАТЬ ЗА ПРИЧИНЕННЫЙ ВАМ УЩЕРБ, ВКЛЮЧАЯ ЛЮБОЙ ОБЩИЙ, ОСОБЫЙ, СЛУЧАЙНЫЙ ИЛИ КОСВЕННЫЙ УЩЕРБ, ПОНЕСЕННЫЙ ОТ ИСПОЛЬЗОВАНИЯ ИЛИ НЕВОЗМОЖНОСТИ ИСПОЛЬЗОВАНИЯ ПРОГРАММЫ (ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ ТОЛЬКО ЭТИМ, ПОТЕРИ ДАННЫХ ИЛИ НЕТОЧНЫЕ ОБРАБОТКИ ДАННЫХ ИЛИ ПОТЕРИ, КОТОРЫЕ ПОНЕСЛИ ВЫ ИЛИ ТРЕТЬИ ЛИЦА; ИЛИ НЕСПОСОБНОСТЬ ПРОГРАММЫ РАБОТАТЬ С ЛЮБЫМИ ДРУГИМИ ПРОГРАММАМИ), ДАЖЕ ЕСЛИ ВЛАДЕЛЕЦ АВТОРСКИХ ПРАВ ИЛИ ИНАЯ СТОРОНА БЫЛИ ПРЕДУПРЕЖДЕНЫ О ВОЗМОЖНОСТИ ТАКОГО УЩЕРБА.


КОНЕЦ ОПИСАНИЯ ПРАВ И ОБЯЗАННОСТЕЙ




Как применить эти условия договора к своим новым программам


Если вы разрабатываете новую программу и хотите, чтобы она принесла максимально большую пользу широкому кругу людей, лучшим способом достижения этого является включение ее в состав свободного программного обеспечения, которое каждый может распространять и изменять в соответствии с данными условиями.

Чтобы это сделать, добавьте к программе следующие уведомления. Надежнее всего добавить их в начало каждого исходного файла, чтобы наиболее эффективно сообщить об отказе от гарантий; и в каждом файле должна быть по крайней мере строка с «авторскими правами» и указанием на то, где можно найти полное уведомление.

















































































Добавьте также сведения о том, как связаться с вами по электронной или обычной почте.

Если программа интерактивная, вставьте в ее вывод при запуске краткое уведомление, подобное данному:


























Гипотетические команды '


' и '


' должны отображать соответствующие части Общедоступной лицензии. Конечно, используемые вами команды могут называться как-нибудь иначе, а не '


' и '


'; они могут быть даже щелчками мышью или пунктами меню — всем, что лучше подходит вашей программе.

Вам следует также получить от вашего нанимателя (если вы работаете программистом) или учебного заведения, если оно имеется, заявление об «отказе от авторских прав» для программы, если это необходимо. Вот образец; измените имена:


























Данная Общедоступная лицензия не разрешает включать вашу программу в частные программы. Если ваша программа представляет собой библиотеку процедур, вы можете счесть более полезным разрешить компоновку частных приложений с данной библиотекой. Если это то, что вам нужно, используйте вместо данной Лицензии Малую общедоступную библиотечную лицензию GNU.




Пример использования


Данный раздел не является частью GPL. Здесь мы показываем комментарий с заявлением об авторских правах из программы GNU 


:


































































Это обычное использование. Оно содержит следующие, в сущности, стереотипные элементы:

• Одну строку комментария с названием и описанием программы. В более крупных программах здесь может быть название и описание файла внутри программы.

• Заявление об авторских правах.

• Два параграфа с объяснением и отказом от гарантий.

• Где получить копию GPL.



notes


Примечания





1


Это знаменитое высказывание было сделано на Международном симпозиуме по эффективному производству больших программ в Jablonna, Польша, 10-14 августа 1970 г. — Примеч. автора.




2





 — Примеч. автора.




3





 — Примеч. автора.




4





 — Примеч. автора.




5





 — Примеч. автора.




6


Игра слов: free — свободный, бесплатный — Примеч. перев.




7


В оригинале: «Rome wasn't built in a day» — Примеч. перев.




8


См. справочные страницы csh(1) и tcsh(1) и книгу Using csh & tcsh, by Paul DuBois, O'Reilly & Associates. Sebastopol, CA. USA, 1995. ISBN 1-56592-132-1 — Примеч. автора.




9


Соответствующие справочные страницы можно посмотреть с помощью man 1 awk и man 3 printf — Примеч. науч. ред.




10





 — Примеч. автора.




11


Некоторые системы позволяют рядовым пользователям назначать владельцем их файла кого-нибудь еще, таким образом «отдавая его». Детали определяются стандартом POSIX, но они несколько запутаны. Обычная конфигурация GNU/Linux не допускает этого — Примеч. автора.




12


Конечно, владелец всегда может изменить права доступа. Большинство пользователей не отменяют для себя нрава на запись — Примеч. автора.




13


Для этого правила есть несколько редких исключений, но все они выходят за рамки данной книги — Примеч. автора.




14


Эта особенность впервые появилась в Multics, но Multics никогда широко не использовался — Примеч. автора.




15


Процесс может быть приостановлен, в этом случае он не «работающий»; но он и не завершён. В любом случае, на ранних этапах восхождения по кривой обучения не стоит быть слишком педантичным — Примеч. автора.




16


Так называемые переменные окружения — Примеч. науч. ред.




17


Между народный стандарт ISO/IEC 9899-1990 описывает разновидность языка С известную также как C89 или C90 — Примеч. науч. ред.




18


Стандарт C99 (ISO/IЕС 9899-1999) — Примеч. науч. ред.




19


Этот раздел адаптирован из статьи автора, который издавался в выпуске 16 Linux Journal (См. 


) Перепечатано и адаптировано по разрешению — Примеч. автора.




20


Это утверждение относится к ядру HURD, которое все еще находится в стадии разработки (в начале 2004 г.) Разработка на основе GCC и библиотеки GNU С (GLIBC) сегодня имеет место большей частью на Linux-системах — Примеч. автора.




21


Стиль расположения кода, рекомендуемый фондом свободного программного обеспечения (Free Software Foundation) — Примеч. науч. ред.




22


Эта ситуация имела место примерно в 1993 г; трюизм даже более очевиден сегодня, когда пользователи обрабатывают с помощью 


 гигабайты протокольных файлов — Примеч. автора.




23


Раздел 13.4, «Не могли бы вы произнести это для меня по буквам?», с. 521, дает обзор многобайтных символов и кодировок — Примеч. автора.




24


Механика проверки ошибок и сообщений о них обсуждаются в разделе 4.3, «Обнаружение неправильной работы» — Примеч. автора.




25


Русский перевод Брайан Керниган, Денис Ритчи. Язык программирования Си (изд. 3-е, исправленное) Санкт- Петербург. Невский диалект, 2001 — Примеч. науч. ред.




26





 — Примеч. автора.




27


Имя команды — 


 в данном примере, так же доступно программе в качестве аргумента — Примеч. науч. ред.




28


См. 


 в дистрибутиве V7 — Примеч. автора.




29


Когда мы спросили Джима Мейеринга (Jim Meyering), сопроводителя Coreulils, о наличии 


 в GNU Coreutils, он дал нам интересный ответ. Он удаляет эти слова при изменении кода, но в остальных случаях оставляет их на месте, чтобы облегчить интеграцию сделанных изменений с существующими версиями — Примеч. автора.




30


См. 


 — Примеч. автора.




31





 — Примеч. автора.




32





 — Примеч. автора.




33





 — Примеч. автора.




34





 — Примеч. автора.




35





 — Примеч. автора.




36





 — Примеч. автора.




37





 — Примеч. автора.




38


Существует также другое название для этой области данных — Неинициализированные данные — Примеч. науч. ред.




39


BSS означает 'Block Started by Symbol', мнемоника из ассемблера IBM 7094 — Примеч. автора.




40


Дамп ядра (core dump) является образом запущенного процесса в памяти, который создаётся при неожиданном завершении процесса. Позже этот дамп может быть использован для отладки Unix-системы, называют это файл 


, а системы GNU/Linux — 


, где 


 — ID потерпевшего крушения процесса — Примеч. автора.




41


Описание здесь намеренно упрощено. Запущенные программы занимают значительно больше места, чем указывает программа 


, поскольку разделяемые библиотеки включены в адресное пространство. Также сегмент данных будет расти по мере выделения программной памяти — Примеч. автора.




42


Он получен от реальной практики работы с 


 — Примеч. автора.




43


Этот код несет с собой аромат практического опыта, не удивительно было узнать, что более ранние версии просто проверяли наличие обратного слеша перед символом конца строки, пока кто-то не пожаловался, что он не работает, когда в конце строки есть несколько обратных слешей — Примеч. автора.




44


Эта функция завершает выполнение программы — Примеч. науч. ред.




45


alloca(3) — Примеч. науч. ред.




46





 является одним из немногих варьирующих (variadic) системных вызовов — Примеч. автора.




47


См. 


 в дистрибутиве V7. Программа без изменений компилируется для GNU/Linux. — Примеч. автора.




48


По крайней мере, три из этих блоков содержат данные, которые мы записали, другие для использования операционной системой при отслеживании размещения этих данных — Примеч. автора.




49


Да, это пишется так. Кена Томпсона (Ken Thompson), одного из двух «отцов» Unix, однажды спросили, что бы он сделал по-другому, если бы ему пришлось переделать Unix. Он ответил, что написал бы 


 с «e» на конце. И в самом деле, именно это он сделал для операционной системы Plan 9 From Bell Labs — Примеч. автора.




50


Если у вас нет UPS и вы используете систему для критической работы, мы настоятельно рекомендуем вам обзавестись им. Следует также регулярно делать резервные копии. — Примеч. автора.




51


Состояние .гонки (race condition) является ситуацией, при которой детали временных соотношений могут вызывать непреднамеренные побочные эффекты или ошибки. В данном случае, каталог в течение короткого периода времени находится в противоречивом состоянии, и именно эта противоречивость и создаёт уязвимость — Примеч. автора.




52


Конечно, меняются служебные данные файла (число ссылок), но это не влияет ни на какой другой атрибут файла, также, как не влияет на содержимое файла. Обновление счетчика ссылок на файл является единственной операцией над файлом, при которой не проверяются права доступа к файлу — Примеч. автора.




53


См 


 с в дистрибутиве V7 — Примеч. автора.




54


То есть прочитаны все элементы каталога — Примеч. науч. ред.




55


В системах GNU/Linux могут монтироваться файловые системы многих операционных систем, не относящихся к Unix. Во многих коммерческих системах Unix также можно смонтировать файловые системы MS-DOS. В таких случаях предположения относительно файловых систем Unix неприменимы — Примеч. автора.




56


Стоит внимательно подумать прежде чем использовать эти функции — Примеч. науч. ред.




57


Linux использует блочные устройства исключительно для дисков. Другие системы используют оба типа — Примеч. автора.




58


Именованные каналы и сокеты были разработаны независимо группами Unix System V и BSD соответственно. Когда системы Unix вновь сошлись, обе разновидности файлов стали доступными универсально —- Примеч. автора.




59


Технический термин warm fuzzy — Примеч. автора.




60


Это утверждение было верно для V7, на современных системах больше нет таких гарантий — Примеч. автора.




61


Спасибо Джиму Мейерингу (Jim Meyering) за объяснение проблем — Примеч. автора.




62


UTC представляет собой независимое от языка сокращение для Coordinated Universal Time (универсальное скоординированное время). Старый код (а иногда и люди постарше) называют это Гринвичским временем (Greenwich Mean Time, GMT), которое является временем в Гринвиче, Великобритания. Когда стали широко использоваться часовые пояса, в качестве точки отсчета, относительно которого все остальные часовые пояса отсчитывались либо вперед, либо назад, был выбран Гринвич — Примеч. автора.




63





 и 


 были введены в 4 2 BSD, но не включались в System V до выпуска 4 — Примеч. автора.




64


a.m. — от ante meridiem (до полудня), p.m. — от post meridiem (пополудни), американская система обозначения 12-часового цикла времени суток. — Примеч. перев.




65


Хотя POSIX стандартизует формат TZ, он не представляет интереса, поэтому мы не стали возиться здесь с его документированием. В конце концов, именно 


 должна понимать формат, а не код пользователя. Реализации могут использовать и используют форматы, которые расширяют POSIX — Примеч. автора.




66


Вывод, показанный здесь, относится к US Eastern Standard Time. Вы получите различные результаты для одних и тех же программ и данных, если используете другой часовой пояс — Примеч. автора.




67


STL (Standard Template Library, стандартная библиотека шаблонов). — Примеч. науч. ред.




68


Заметным исключением является лишь Sun Solaris, где эти две функции существуют лишь в трудной для использования библиотеке совместимости с BSD — Примеч. автора.




69


Типичные сетевые базы данных включают Network Information Service (NIS) и NIS+ от Sun Microsystems, Kerberos (Hesiod), MacOS X NetInfo (версии вплоть до и включая 10.2) и LDAP, Lightweight Directory Access Protocol. Системы BSD хранят сведения в базах данных на диске и автоматически создают файлы 


 и 


 — Примеч. автора.




70


К сожалению, если производительность является проблемой, нет стандартных способов узнать, как ваша библиотека осуществляет работу, а на самом деле способ ее работы может варьировать во время исполнения! (См. справочную страницу nsswitchconf(5) в системе GNU/Linux.) С другой стороны, назначением API помимо всего прочего является сокрытие деталей — Примеч. автора.




71


Русский перевод Дональд E. Кнут. Искусство программирования Том 3. Сортировка и поиск (2-е издание). Москва • Санкт-Петербург • Киев, Вильямс, 2000 — Примеч. науч. ред.




72





 — Примеч. автора.




73





 — Примеч. автора.




74





 — Примеч. автора.




75


В C++ это по-другому: там символьные константы действительно имеют тип char. Это различие не влияет на данный конкретный код — Примеч. автора.




76


GNU/Linux и Solaris дают возможность монтировать один файл поверх другого; это продвинутое использование, которое мы не будем обсуждать — Примеч. автора.




77


Например, при обновлении VAX 11/780 с 4.1 BSD до 4.2 BSD — Примеч. автора.




78


System V Release 3 поддерживала два различных размера блоков: 512 байтов и 1024 байта, но в остальном организация диска была той же самой — Примеч. автора.




79


Университет Карнеги-Меллона — Примеч. перев.




80


Источник: 


 — Примеч. автора.




81


Ha GNU/Linux и большинстве систем Solaris и некоторые системы на основе System V Release 4 используют 


, возможно, с другим форматом — Примеч. автора.




82


См. 


 на системе GNU/Linux — Примеч. автора.




83


На системах GNU/Linux и BSD для получения нижележащего дескриптора файла можно применить функцию 


 к указателю 


, см. справочную страницу GNU/Linux dirfd(3) — Примеч. автора.




84


POSIX стандартизировал 


 для поддержки существующего кода, а GNU/Linux b коммерческие системы Unix продолжают её поддерживать. Однако, поскольку она недостаточно функциональна, мы не будем больше ее обсуждать. Если интересуетесь, см. ftw(3). — Примеч. автора.




85


У некоторых старых версий GLIBC были проблемы с FTW_CHDIR. Это не относится к GLIBC 2.3.2 и более поздним, и маловероятно, что вы столкнетесь с проблемами — Примеч. автора.




86


Мы не знаем, почему кому-нибудь может понадобиться делать такое изменение, но философия «что вы просили, то и получили» применяется и здесь! — Примеч. автора.




87


Хэш-таблица является структурой данных, позволяющей быстрое получение сохраненной информации, подробности выходят за рамки данной книги — Примеч. автора.




88


Fork (англ.) — «n вилка, развилка, v разветвлять, ответвлять» — Примеч. перев.




89


Такие процессы часто демонстрируют детское поведение. — Примеч. автора.




90


См. 9.1.4.3 Имена программ и 


 — Примеч. науч. ред.




91


Мы это не придумываем. Терминология, конечно, не совсем правильна, но таким было чувство юмора разработчиков оригинальной Unix — Примеч. автора.




92


Дважды проверьте справочную страницу getrusage(2), если у вас более новое ядро, поскольку это поведение, возможно, изменилось — Примеч. автора.




93





 и 


 также могут быть включены в эту категорию, но мы предпочитаем оболочки в стиле оболочки Борна — Примеч. автора.




94


Такая операция часто обозначается no-op — «no operation» (нет операции) — Примеч. автора.




95


Мы уверены, что вы не волновались. В конце концов, вы, возможно, используете конвейеры из оболочки десятки раз в день — Примеч. автора.




96


Что они ели на обед, остается не указанным. — Примеч. автора.




97


FIFO означает «first in, first out» — «первым вошел, первым вышел». Так работают каналы. — Примеч. автора.




98


На системах GNU/Linux 


 является символической ссылкой на 


, но поскольку 


 является общеизвестным, в своем коде следует использовать именно его — Примеч. автора.




99


Хотя мы показали простые команды, допустимы произвольные конвейеры — Примеч. автора.




100


Стандарт POSIX умышленно не приписывает ей значение. Однако, чтобы старый код продолжал работать, единственным значением, которое могла бы разумно использовать любая реализация, является 1 — Примеч. автора.




101


Ну, мы игнорируем мысль, что два супруга могли бы хотеть поговорить друг с другом и насладиться компанией — Примеч. автора.




102


В одно и то же время есть только один сопроцесс по умолчанию (доступный посредством '


' и '


'). Сценарии оболочки могут использовать команду 


 со специальной записью перенаправления для назначения дескрипторов файла сопроцесса определенным номерам. После этого можно запустить другой сопроцесс — Примеч. автора.




103


Очевидно, вы можете их закрыть. Но если вы не знаете, что они открыты, они теряются с таким же успехом, как и память через утечку памяти — Примеч. автора.




104


Игра слов kill-overkill (избыточно — overkill) — Примеч. перев.




105


По крайней мере один поставщик дистрибутивов GNU/Linux отменяет сознание файлов 


 «с иголочки». Для повторного подключения этой возможности поместите в свой файл 


 строку '


' — Примеч. автора.




106


Handler (англ.) — обработчик — Примеч. перев.




107


Изменение поведения было плохой мыслью, сильно критиковавшейся в свое время, но было слишком поздно. Изменение семантики определенного интерфейса всегда ведет к проблеме, как было в этом случае. Хотя это особенно относится к проектировщикам операционных систем, любой, кто разрабатывает библиотеки общего назначения, также должен помнить этот урок. — Примеч. автора.




108


Хотя мы описываем 


, эти правила применяются ко всем системным вызовам, которые могут завершиться с ошибкой 


, как, например, семейство функций 


 — Примеч. автора.




109


Для использования API требуется компоновка с отдельной библиотекой, — 


 — Примеч. автора.




110


Насколько мы смогли определить, имена 


 и 


 являются специфическими для GNU/Linux. Если кому-нибудь известно иное, пожалуйста, сообщите нам!




111


Наша благодарность Ульриху Дрепперу (Ulrich Drepper) за помощь в разъяснении, связанных с этим проблем — Примеч. автора.




112


Исторически системы BSD использовали имя 


, которое используется и POSIX. В System V есть сходный сигнал с именем 


. GNU/Linux определяет последний через 


 как первый — см. табл. 10.1 — Примеч. автора.




113


Возможно, лучшим именем для функции было бы 


 [ребенок_в_школе] — Примеч. автора.




114


MacOS X и Windows XP обе являются многопользовательскими системами, но это довольно недавние разработки — Примеч. автора.




115


Хотя в Соединенных Штатах нет официальных удостоверений личности, во многих странах они имеются — Примеч. автора.




116


Денис Ричи (Dennis Ritchie), создатель С и соавтор Unix, получил патент для бита setuid: Protection of Data File Contents (Защита содержимого файла данных), номер патента США 4135240. См. 


, а также 


. AT&T передала патент общественности, разрешив всем использовать свою технологию — Примеч. автора.




117


Безопасность для систем GNU/Linux и Unix является глубокой темой сама по себе. Это просто пример. см. раздел 11.9 «Рекомендуемая литература» — Примеч. автора.




118


Одной из программ, разработанных с этой целью, является GNU userv (


) — Примеч. автора.




119


На ум приходят образы счастливых юных программ их лица и руки, запачканные шоколадом — Примеч. автора.




120


E (Effective) эффективный ID, R (Real) действительный ID и S (Saved) сохраненный ID — Примеч. науч. ред.




121


Однако, в своей лекции в честь присуждения премии Тьюринга Ассоциации по вычислительной технике в 1981 г. д-р Хоар утверждает, что эту идею выдвинул сам Алан Тьюринг — Примеч. автора.




122


Как упоминалось в разделе 10.2 «Действия сигналов», некоторые дистрибутивы GNU/Linux запрещают создание файлов 


. Чтобы снова разрешить их, поместите в свой файл 


 строку '


' — Примеч. автора.




123


Hints On Programming Language Design, C.A.R. Hoare Stanford University Computer Science Technical Report CS-73-403 (


). December, 1973 — Примеч. автора.




124


См. wс(1). 


 подсчитывает строки, слова и символы — Примеч. автора.




125


Такое использование 


 на самом деле является злоупотреблением,, он предназначен для использования в реализации разделяемой памяти, а не в качестве электронного диска. Тем не менее, это полезно для иллюстрации нашей мысли — Примеч. автора.




126


На нашей системе 512 мегабайтов оперативной памяти, что для старых чудаков вроде автора кажется порядочным. Однако цены на память упали, и вполне обычны системы с одним или более гигабайтами оперативной памяти, по крайней мере, для разработчиков программного обеспечения — Примеч. автора.




127


Пространство для подкачки состоит из одного или более выделенных участков диска, используемых для хранения частей исполняющегося процесса, который не находится в настоящее время в памяти — Примеч. автора.




128


Такая утечка была у нас в 


 К счастью, она исправлена — Примеч. автора.




129


Numerical Recipes in С. The Art of Scientific Computing,, 2nd edition, by William H. Press, Brian P. Plannery, Saul A. Teukolsky, and William T. Vetterling. Cambridge University Press, USA, 1993, ISBN 0-521-43108-5 — Примеч. автора.




130


См 


 в дистрибутиве V6




131





 — Примеч. автора.




132


Русский перевод: Дональд E. Кнут. Искусство программирования. Том 2. Получисленные алгоритмы (3-е издание). Москва - Санкт-Петербург - Киев. Вильямс. 2000 — Примеч. науч. ред.




133





 — Примеч. автора.




134


Русский перевод — Дж. Фридл. Регулярные выражения (2-е издание). C.-Петербург, Питер, 2003 — Прим. науч. ред.




135





 — Примеч. автора.




136


От английских слов i(nternationalizatio)n и l(ocalizatio)n —Примеч. перев.




137


NLS — native language support — Примеч. перев.




138


Существует более ранний дизайн, известный как 


. Хотя он стандартизован POSIX, его гораздо сложнее использовать, и мы его не рекомендуем — Примеч. автора.




139


Программисты, долгое время работавшие на С и Unix, могут предпочесть использовать локаль '


', даже если их родной язык английский, английские локали дают другой результат по сравнению с тем, что ожидают эти седые, понюхавшие пороху ветераны Unix — Примеч. автора.




140


Мы так же счастливы, как и вы, поскольку нам не нужно представлять код, использующий эту полнофункциональную структуру — Примеч. автора.




141


В стандарте используется технический термин radix point (позиционный разделитель), поскольку числа с другим основанием счисления также могут иметь дробные части. Однако, для денежных значений можно довольно безопасно использовать термин 'decimal point' (десятичный разделитель) — Примеч. автора.




142


Нам, вероятно, следовало выбрать более осмысленные имена вместо простых 


 и 


, поскольку использующий их код короткий, отсутствие у нас воображения не представляет значительной проблемы — Примеч. автора.




143


Это устанавливается механизмом Autoconf и Automake. Autoconf и Automake являются мощными программными наборами, дающими возможность поддержки широкого круга Unix-систем систематическим образом — Примеч. автора.




144


Хотя американцы часто ссылаются на эры определенных президентов, они не являются частью национального календаря в том же смысле, как в Японии до Второй мировой войны или в докоммунистическом Китае — Примеч. автора.




145


Подробности приведены в документации GNU 


. Здесь мы концентрируемся на потребностях разработчика, а не переводчика — Примеч. автора.




146


Этот макрос обычно определяется автоматически программой 


, либо в специальном заголовке, либо в командной строке компилятора 


 создается с помощью Autoconf и Automake — Примеч. автора.




147


Pig — свинья, поросенок (англ.) — Примеч. перев.




148


Мы тщетно потратили 30 или 45 минут, пытаясь использовать каталог 


 и установку 


' без всякого успеха, пока не выяснили это — Примеч. автора.




149





 — Примеч. автора.




150





 — Примеч. автора.




151


GNU/Linux ее поддерживает, но лишь для совместимости — Примеч. автора.




152


Справочная страница GNU/Linux fcntl(3) указывает, что этих сведений может быть недостаточно, процесс может находиться на другой машине! При блокировках по сети есть и другие проблемы, в общем, использование блокировки в файловых системах, смонтированных для удаленных компьютеров, не является удачной мыслью — Примеч. автора.




153


В системе GNU/Linux 


 реализована в виде «оболочки» вокруг 


 — Примеч. автора.




154


Тупик (deadlock) является ситуацией, при которой оба процесса блокируются, причем каждый из них ждёт, пока другой освободит определенный ресурс — Примеч. автора.




155


Удачно, что название 


 отличается от 


, поскольку их семантика различна. Это также страшно сбивает с толку. Держите свое руководство под рукой. — Примеч. автора.




156


В справочной странице gettimeofday(2) документирована соответствующая функция 


 для использования суперпользователем (


) для установки времени дня всей системы — Примеч. автора.




157


К сожалению, по-видимому, в настоящее время нет стандарта для названий членов 


, что делает такую операцию непереносимой — Примеч. автора.




158


Корректное выполнение профилировки нетривиальная задача, если вы думаете о написании интерпретатора, стоит сначала провести свои исследования — Примеч. автора.




159


В голову приходят образы, как маленькие двоичные структуры данных сидят друг рядом с другом за чаем и пирожными. По крайней мере, такое бывает, если вы проводите слишком много времени перед своим компьютером. — Примеч. автора.




160


Этот вывод для часового пояса U.S. Eastern Time zone — Примеч. автора.




161


Оптимизации компилятора являются общеизвестным козлом отпущения для логических ошибок. В прошлом обвинения компиляторов были более оправданы. Судя по нашему опыту, используя современные системы и компиляторы, очень редко можно обнаружить случаи, в которых оптимизации компилятора привносят ошибки в работающий код — Примеч. автора.




162


Мы говорим об оригинальном BSD 


. В течение десяти лет мы использовали исключительно GDB — Примеч. автора.




163





 поставляется со многими системами GNU/Linux. Исходный код доступен на FTP-сайте проекта GNU 


 (


) — Примеч. автора.




164





— Примеч. автора.




165





 — Примеч. автора.




166





 — Примеч. автора.




167


Если вы хотите изменить такое поведение, см. sysctl(8) — Примеч. автора.




168


Примерно 213&#215;275 мм — Примеч. перев.




169


Bjarne Stroustrup, создатель С++, настойчиво работал над тем, чтобы сделать использование препроцессора С совершенно ненужным в С++. По нашему мнению, он не вполне добился успеха: 


 нужен до сих пор, но не обычные макросы. Для С препроцессор остается ценным и инструментом, но он должен использоваться благоразумно — Примеч. автора.




170


Серьезно! Часто люди пропускают через 


 мегабайты данных. Помните, никаких произвольных ограничений! — Примеч. автора.




171


Мы унаследовали эту схему. В общем, она работает, но все же есть проблемы. Целью данного раздела является передача накопленного нами в ходе работы с объединениями опыта — Примеч. автора.




172


Опять-таки, GCC 3.1 или более новый и GDB 5 дают возможность непосредственного использования макросов, но только лишь если вы используете их совместно, с определенными опциями. Это было описано ранее в разделе 15.4.1.2 «По возможности избегайте макросов с выражениями». — Примеч. автора.




173


Эта часть кода была с тех пор пересмотрена, поэтому там больше нет этих строк из примера. — Примеч. автора.




174


Переписав код управления буфером! — Примеч. автора.




175





 — Примеч. автора.




176


В C99, который допускает смешивание объявлений переменных с исполняемым кодом, это составляет меньшую проблему, но помните, что этот пакет был разработан для K&R С — Примеч. автора.




177


Хотя нам следовало бы усвоить свой урок после первой компании, мы перешли ко второй. С тех пор, как мы это выяснили, мы обычно избегаем начинающие компании. Ваша выгода, конечно, может меняться — Примеч. автора.




178





 — Примеч. автора.




179


GDB также позволяет определить переменную окружения 


: 


 — Примеч. науч. ред.




180





 — Примеч. автора.




181


Все в большей степени для разработки высококачественных продуктов используется также GNU/Linux! — Примеч. автора.




182





 — Примеч. автора.




183





 — Примеч. автора.




184





 — Примеч. автора.




185





 — Примеч. автора.




186





 — Примеч. автора.




187





 — Примеч. автора.




188





 — Примеч. автора.




189





 — Примеч. автора.




190


Русский перевод Брайан Керниган, Роб Пайк. UNIX: Программное окружение. Санкт-Петербург. Символ-Плюс, 2003 — Примеч. науч. ред.




191


Это приложение приведено в буквальном виде с веб-страницы, указанной вначале — Примеч. автора.




192





 — Примеч. автора.




193





 — Примеч. автора.




194


Это — неофициальный перевод Лицензии Caldera для старой Unix на русский язык. Он не был опубликован Caldera International, Inc и не может легально определять условия распространения программных продуктов, использующих Лицензию Caldera — только оригинальный английский текст Лицензии Caldera для старой Unix имеет законную силу.




195


Это — неофициальный перевал Общедоступной лицензии GNU на русский язык. Он не был опубликован Фондом Свободного Программного Обеспечения и не может легально определять условия распространения программных продуктов, использующих Общедоступную лицензию GNU — только оригинальный английский текст Общедоступной лицензии GNU имеет законную силу.


